var __DEV__=true,__BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),process=this.process||{};process.env=process.env||{};process.env.NODE_ENV='development';
(function (global) {
  'use strict';

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  global.require = _require;
  global.__d = define;
  var modules = Object.create(null);

  if (__DEV__) {
    var verboseNamesToModuleIds = Object.create(null);
  }

  function define(factory, moduleId, dependencyMap) {
    if (moduleId in modules) {
      if (__DEV__) {
        var inverseDependencies = arguments[4];

        if (inverseDependencies) {
          global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
        } else {
          console.warn("Trying to define twice module ID " + moduleId + " in the same bundle");
        }
      }

      return;
    }

    modules[moduleId] = {
      dependencyMap: dependencyMap,
      exports: undefined,
      factory: factory,
      hasError: false,
      isInitialized: false
    };

    if (__DEV__) {
      modules[moduleId].hot = createHotReloadingObject();
      var verboseName = arguments[3];

      if (verboseName) {
        modules[moduleId].verboseName = verboseName;
        verboseNamesToModuleIds[verboseName] = moduleId;
      }
    }
  }

  function _require(moduleId) {
    if (__DEV__ && typeof moduleId === 'string') {
      var verboseName = moduleId;
      moduleId = verboseNamesToModuleIds[verboseName];

      if (moduleId == null) {
        throw new Error("Unknown named module: '" + verboseName + "'");
      } else {
        console.warn("Requiring module '" + verboseName + "' by name is only supported for " + 'debugging purposes and will BREAK IN PRODUCTION!');
      }
    }

    var moduleIdReallyIsNumber = moduleId;
    var module = modules[moduleIdReallyIsNumber];
    return module && module.isInitialized ? module.exports : guardedLoadModule(moduleIdReallyIsNumber, module);
  }

  var inGuard = false;

  function guardedLoadModule(moduleId, module) {
    if (!inGuard && global.ErrorUtils) {
      inGuard = true;
      var returnValue = void 0;

      try {
        returnValue = loadModuleImplementation(moduleId, module);
      } catch (e) {
        global.ErrorUtils.reportFatalError(e);
      }

      inGuard = false;
      return returnValue;
    } else {
      return loadModuleImplementation(moduleId, module);
    }
  }

  var ID_MASK_SHIFT = 16;
  var LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;

  function unpackModuleId(moduleId) {
    var segmentId = moduleId >>> ID_MASK_SHIFT;
    var localId = moduleId & LOCAL_ID_MASK;
    return {
      segmentId: segmentId,
      localId: localId
    };
  }

  _require.unpackModuleId = unpackModuleId;

  function packModuleId(value) {
    return value.segmentId << ID_MASK_SHIFT + value.localId;
  }

  _require.packModuleId = packModuleId;

  function loadModuleImplementation(moduleId, module) {
    var nativeRequire = global.nativeRequire;

    if (!module && nativeRequire) {
      var _unpackModuleId = unpackModuleId(moduleId);

      var segmentId = _unpackModuleId.segmentId,
          localId = _unpackModuleId.localId;
      nativeRequire(localId, segmentId);
      module = modules[moduleId];
    }

    if (!module) {
      throw unknownModuleError(moduleId);
    }

    if (module.hasError) {
      throw moduleThrewError(moduleId, module.error);
    }

    if (__DEV__) {
      var Systrace = _require.Systrace;
    }

    module.isInitialized = true;
    var exports = module.exports = {};
    var _module = module;
    var factory = _module.factory,
        dependencyMap = _module.dependencyMap;

    try {
      if (__DEV__) {
        Systrace.beginEvent('JS_require_' + (module.verboseName || moduleId));
      }

      var moduleObject = {
        exports: exports
      };

      if (__DEV__ && module.hot) {
        moduleObject.hot = module.hot;
      }

      factory(global, _require, moduleObject, exports, dependencyMap);

      if (!__DEV__) {
        module.factory = undefined;
        module.dependencyMap = undefined;
      }

      if (__DEV__) {
        Systrace.endEvent();
      }

      return module.exports = moduleObject.exports;
    } catch (e) {
      module.hasError = true;
      module.error = e;
      module.isInitialized = false;
      module.exports = undefined;
      throw e;
    }
  }

  function unknownModuleError(id) {
    var message = 'Requiring unknown module "' + id + '".';

    if (__DEV__) {
      message += 'If you are sure the module is there, try restarting Metro Bundler. ' + 'You may also want to run `yarn`, or `npm install` (depending on your environment).';
    }

    return Error(message);
  }

  function moduleThrewError(id, error) {
    var displayName = __DEV__ && modules[id] && modules[id].verboseName || id;
    return Error('Requiring module "' + displayName + '", which threw an exception: ' + error);
  }

  if (__DEV__) {
    _require.Systrace = {
      beginEvent: function beginEvent() {},
      endEvent: function endEvent() {}
    };

    _require.getModules = function () {
      return modules;
    };

    var createHotReloadingObject = function createHotReloadingObject() {
      var hot = {
        acceptCallback: null,
        accept: function accept(callback) {
          hot.acceptCallback = callback;
        }
      };
      return hot;
    };

    var acceptAll = function acceptAll(dependentModules, inverseDependencies) {
      if (!dependentModules || dependentModules.length === 0) {
        return true;
      }

      var notAccepted = dependentModules.filter(function (module) {
        return !accept(module, undefined, undefined, inverseDependencies);
      });
      var parents = [];

      for (var i = 0; i < notAccepted.length; i++) {
        if (inverseDependencies[notAccepted[i]].length === 0) {
          return false;
        }

        parents.push.apply(parents, _toConsumableArray(inverseDependencies[notAccepted[i]]));
      }

      return acceptAll(parents, inverseDependencies);
    };

    var accept = function accept(id, factory, dependencyMap, inverseDependencies) {
      var mod = modules[id];

      if (!mod && factory) {
        return true;
      }

      var hot = mod.hot;

      if (!hot) {
        console.warn('Cannot accept module because Hot Module Replacement ' + 'API was not installed.');
        return false;
      }

      if (factory) {
        mod.factory = factory;
      }

      if (dependencyMap) {
        mod.dependencyMap = dependencyMap;
      }

      mod.hasError = false;
      mod.isInitialized = false;

      _require(id);

      if (hot.acceptCallback) {
        hot.acceptCallback();
        return true;
      } else {
        if (!inverseDependencies) {
          throw new Error('Undefined `inverseDependencies`');
        }

        return acceptAll(inverseDependencies[id], inverseDependencies);
      }
    };

    global.__accept = accept;
  }
})(this);
(function (global) {
  Object.assign = function (target, sources) {
    if (__DEV__) {
      if (target == null) {
        throw new TypeError('Object.assign target cannot be null or undefined');
      }

      if (typeof target !== 'object' && typeof target !== 'function') {
        throw new TypeError('In this environment the target of assign MUST be an object. ' + 'This error is a performance optimization and not spec compliant.');
      }
    }

    for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
      var nextSource = arguments[nextIndex];

      if (nextSource == null) {
        continue;
      }

      if (__DEV__) {
        if (typeof nextSource !== 'object' && typeof nextSource !== 'function') {
          throw new TypeError('In this environment the sources for assign MUST be an object. ' + 'This error is a performance optimization and not spec compliant.');
        }
      }

      for (var key in nextSource) {
        if (__DEV__) {
          var hasOwnProperty = Object.prototype.hasOwnProperty;

          if (!hasOwnProperty.call(nextSource, key)) {
            throw new TypeError('One of the sources for assign has an enumerable key on the ' + 'prototype chain. Are you trying to assign a prototype property? ' + 'We don\'t allow it, as this is an edge case that we do not support. ' + 'This error is a performance optimization and not spec compliant.');
          }
        }

        target[key] = nextSource[key];
      }
    }

    return target;
  };
})(this);
(function (global) {
  var inspect = function () {
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      return formatValue(ctx, obj, opts.depth);
    }

    function stylizeNoColor(str, styleType) {
      return str;
    }

    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }

    function formatValue(ctx, value, recurseTimes) {
      var primitive = formatPrimitive(ctx, value);

      if (primitive) {
        return primitive;
      }

      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }

        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }

        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }

        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '',
          array = false,
          braces = ['{', '}'];

      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);
      var output;

      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      }

      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      if (isNull(value)) return ctx.stylize('null', 'null');
    }

    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];

      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };

      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }

      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }

      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }

          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }

      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }

        name = JSON.stringify('' + key);

        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }

    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    function isArray(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }

    function isUndefined(arg) {
      return arg === void 0;
    }

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    return inspect;
  }();

  var OBJECT_COLUMN_NAME = '(index)';
  var LOG_LEVELS = {
    trace: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  var INSPECTOR_LEVELS = [];
  INSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';
  INSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';
  INSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';
  INSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';
  var INSPECTOR_FRAMES_TO_SKIP = __DEV__ ? 2 : 1;

  if (global.nativeLoggingHook) {
    function getNativeLogFunction(level) {
      return function () {
        var str = void 0;

        if (arguments.length === 1 && typeof arguments[0] === 'string') {
          str = arguments[0];
        } else {
          str = Array.prototype.map.call(arguments, function (arg) {
            return inspect(arg, {
              depth: 10
            });
          }).join(', ');
        }

        var logLevel = level;

        if (str.slice(0, 9) === 'Warning: ' && logLevel >= LOG_LEVELS.error) {
          logLevel = LOG_LEVELS.warn;
        }

        if (global.__inspectorLog) {
          global.__inspectorLog(INSPECTOR_LEVELS[logLevel], str, [].slice.call(arguments), INSPECTOR_FRAMES_TO_SKIP);
        }

        global.nativeLoggingHook(str, logLevel);
      };
    }

    function repeat(element, n) {
      return Array.apply(null, Array(n)).map(function () {
        return element;
      });
    }

    function consoleTablePolyfill(rows) {
      if (!Array.isArray(rows)) {
        var data = rows;
        rows = [];

        for (var key in data) {
          if (data.hasOwnProperty(key)) {
            var row = data[key];
            row[OBJECT_COLUMN_NAME] = key;
            rows.push(row);
          }
        }
      }

      if (rows.length === 0) {
        global.nativeLoggingHook('', LOG_LEVELS.info);
        return;
      }

      var columns = Object.keys(rows[0]).sort();
      var stringRows = [];
      var columnWidths = [];
      columns.forEach(function (k, i) {
        columnWidths[i] = k.length;

        for (var j = 0; j < rows.length; j++) {
          var cellStr = (rows[j][k] || '?').toString();
          stringRows[j] = stringRows[j] || [];
          stringRows[j][i] = cellStr;
          columnWidths[i] = Math.max(columnWidths[i], cellStr.length);
        }
      });

      function joinRow(row, space) {
        var cells = row.map(function (cell, i) {
          var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');
          return cell + extraSpaces;
        });
        space = space || ' ';
        return cells.join(space + '|' + space);
      }

      var separators = columnWidths.map(function (columnWidth) {
        return repeat('-', columnWidth).join('');
      });
      var separatorRow = joinRow(separators, '-');
      var header = joinRow(columns);
      var table = [header, separatorRow];

      for (var i = 0; i < rows.length; i++) {
        table.push(joinRow(stringRows[i]));
      }

      global.nativeLoggingHook('\n' + table.join('\n'), LOG_LEVELS.info);
    }

    var originalConsole = global.console;
    global.console = {
      error: getNativeLogFunction(LOG_LEVELS.error),
      info: getNativeLogFunction(LOG_LEVELS.info),
      log: getNativeLogFunction(LOG_LEVELS.info),
      warn: getNativeLogFunction(LOG_LEVELS.warn),
      trace: getNativeLogFunction(LOG_LEVELS.trace),
      debug: getNativeLogFunction(LOG_LEVELS.trace),
      table: consoleTablePolyfill
    };

    if (__DEV__ && originalConsole) {
      var descriptor = Object.getOwnPropertyDescriptor(global, 'console');

      if (descriptor) {
        Object.defineProperty(global, 'originalConsole', descriptor);
      }

      Object.keys(console).forEach(function (methodName) {
        var reactNativeMethod = console[methodName];

        if (originalConsole[methodName]) {
          console[methodName] = function () {
            originalConsole[methodName].apply(originalConsole, arguments);
            reactNativeMethod.apply(console, arguments);
          };
        }
      });
    }
  } else if (!global.console) {
    var log = global.print || function consoleLoggingStub() {};

    global.console = {
      error: log,
      info: log,
      log: log,
      warn: log,
      trace: log,
      debug: log,
      table: log
    };
  }
})(this);
(function (global) {
  var _inGuard = 0;

  var _globalHandler = function onError(e) {
    throw e;
  };

  var ErrorUtils = {
    setGlobalHandler: function setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler: function getGlobalHandler() {
      return _globalHandler;
    },
    reportError: function reportError(error) {
      _globalHandler && _globalHandler(error);
    },
    reportFatalError: function reportFatalError(error) {
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard: function applyWithGuard(fun, context, args) {
      try {
        _inGuard++;
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }

      return null;
    },
    applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }

      return null;
    },
    inGuard: function inGuard() {
      return _inGuard;
    },
    guard: function guard(fun, name, context) {
      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }

      name = name || fun.name || '<generated guard>';

      function guarded() {
        return ErrorUtils.applyWithGuard(fun, context || this, arguments, null, name);
      }

      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(this);
(function (global) {
  if (Number.EPSILON === undefined) {
    Object.defineProperty(Number, 'EPSILON', {
      value: Math.pow(2, -52)
    });
  }

  if (Number.MAX_SAFE_INTEGER === undefined) {
    Object.defineProperty(Number, 'MAX_SAFE_INTEGER', {
      value: Math.pow(2, 53) - 1
    });
  }

  if (Number.MIN_SAFE_INTEGER === undefined) {
    Object.defineProperty(Number, 'MIN_SAFE_INTEGER', {
      value: -(Math.pow(2, 53) - 1)
    });
  }

  if (!Number.isNaN) {
    var globalIsNaN = global.isNaN;
    Object.defineProperty(Number, 'isNaN', {
      configurable: true,
      enumerable: false,
      value: function isNaN(value) {
        return typeof value === 'number' && globalIsNaN(value);
      },
      writable: true
    });
  }
})(this);
(function (global) {
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (search) {
      'use strict';

      if (this == null) {
        throw TypeError();
      }

      var string = String(this);
      var pos = arguments.length > 1 ? Number(arguments[1]) || 0 : 0;
      var start = Math.min(Math.max(pos, 0), string.length);
      return string.indexOf(String(search), pos) === start;
    };
  }

  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (search) {
      'use strict';

      if (this == null) {
        throw TypeError();
      }

      var string = String(this);
      var stringLength = string.length;
      var searchString = String(search);
      var pos = arguments.length > 1 ? Number(arguments[1]) || 0 : stringLength;
      var end = Math.min(Math.max(pos, 0), stringLength);
      var start = end - searchString.length;

      if (start < 0) {
        return false;
      }

      return string.lastIndexOf(searchString, start) === start;
    };
  }

  if (!String.prototype.repeat) {
    String.prototype.repeat = function (count) {
      'use strict';

      if (this == null) {
        throw TypeError();
      }

      var string = String(this);
      count = Number(count) || 0;

      if (count < 0 || count === Infinity) {
        throw RangeError();
      }

      if (count === 1) {
        return string;
      }

      var result = '';

      while (count) {
        if (count & 1) {
          result += string;
        }

        if (count >>= 1) {
          string += string;
        }
      }

      return result;
    };
  }

  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
      'use strict';

      if (typeof start !== 'number') {
        start = 0;
      }

      if (start + search.length > this.length) {
        return false;
      } else {
        return this.indexOf(search, start) !== -1;
      }
    };
  }

  if (!String.prototype.codePointAt) {
    String.prototype.codePointAt = function (position) {
      if (this == null) {
        throw TypeError();
      }

      var string = String(this);
      var size = string.length;
      var index = position ? Number(position) : 0;

      if (Number.isNaN(index)) {
        index = 0;
      }

      if (index < 0 || index >= size) {
        return undefined;
      }

      var first = string.charCodeAt(index);
      var second;

      if (first >= 0xd800 && first <= 0xdbff && size > index + 1) {
          second = string.charCodeAt(index + 1);

          if (second >= 0xdc00 && second <= 0xdfff) {
            return (first - 0xd800) * 0x400 + second - 0xdc00 + 0x10000;
          }
        }

      return first;
    };
  }
})(this);
(function (global) {
  function findIndex(predicate, context) {
    if (this == null) {
      throw new TypeError('Array.prototype.findIndex called on null or undefined');
    }

    if (typeof predicate !== 'function') {
      throw new TypeError('predicate must be a function');
    }

    var list = Object(this);
    var length = list.length >>> 0;

    for (var i = 0; i < length; i++) {
      if (predicate.call(context, list[i], i, list)) {
        return i;
      }
    }

    return -1;
  }

  if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: findIndex
    });
  }

  if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function value(predicate, context) {
        if (this == null) {
          throw new TypeError('Array.prototype.find called on null or undefined');
        }

        var index = findIndex.call(this, predicate, context);
        return index === -1 ? undefined : this[index];
      }
    });
  }

  if (!Array.prototype.includes) {
    Object.defineProperty(Array.prototype, 'includes', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function value(searchElement) {
        var O = Object(this);
        var len = parseInt(O.length) || 0;

        if (len === 0) {
          return false;
        }

        var n = parseInt(arguments[1]) || 0;
        var k;

        if (n >= 0) {
          k = n;
        } else {
          k = len + n;

          if (k < 0) {
            k = 0;
          }
        }

        var currentElement;

        while (k < len) {
          currentElement = O[k];

          if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
            return true;
          }

          k++;
        }

        return false;
      }
    });
  }
})(this);
(function (global) {
  if (!Array.from) {
    Array.from = function (arrayLike) {
      if (arrayLike == null) {
        throw new TypeError('Object is null or undefined');
      }

      var mapFn = arguments[1];
      var thisArg = arguments[2];
      var C = this;
      var items = Object(arrayLike);
      var symbolIterator = typeof Symbol === 'function' ? typeof Symbol === "function" ? Symbol.iterator : "@@iterator" : '@@iterator';
      var mapping = typeof mapFn === 'function';
      var usingIterator = typeof items[symbolIterator] === 'function';
      var key = 0;
      var ret;
      var value;

      if (usingIterator) {
        ret = typeof C === 'function' ? new C() : [];
        var it = items[symbolIterator]();
        var next;

        while (!(next = it.next()).done) {
          value = next.value;

          if (mapping) {
            value = mapFn.call(thisArg, value, key);
          }

          ret[key] = value;
          key += 1;
        }

        ret.length = key;
        return ret;
      }

      var len = items.length;

      if (isNaN(len) || len < 0) {
        len = 0;
      }

      ret = typeof C === 'function' ? new C(len) : new Array(len);

      while (key < len) {
        value = items[key];

        if (mapping) {
          value = mapFn.call(thisArg, value, key);
        }

        ret[key] = value;
        key += 1;
      }

      ret.length = key;
      return ret;
    };
  }
})(this);
(function (global) {
  (function () {
    'use strict';

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    if (typeof Object.entries !== 'function') {
      Object.entries = function (object) {
        if (object == null) {
          throw new TypeError('Object.entries called on non-object');
        }

        var entries = [];

        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            entries.push([key, object[key]]);
          }
        }

        return entries;
      };
    }

    if (typeof Object.values !== 'function') {
      Object.values = function (object) {
        if (object == null) {
          throw new TypeError('Object.values called on non-object');
        }

        var values = [];

        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            values.push(object[key]);
          }
        }

        return values;
      };
    }
  })();
})(this);
(function (global) {
  var babelHelpers = global.babelHelpers = {};
  babelHelpers.typeof = typeof Symbol === "function" && typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
  };

  babelHelpers.createRawReactElement = function () {
    var REACT_ELEMENT_TYPE = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.for : "@@for") && (typeof Symbol === "function" ? Symbol.for : "@@for")("react.element") || 0xeac7;
    return function createRawReactElement(type, key, props) {
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        ref: null,
        props: props,
        _owner: null
      };
    };
  }();

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  babelHelpers.defineEnumerableProperties = function (obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ('value' in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    return obj;
  };

  babelHelpers.defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  babelHelpers._extends = babelHelpers.extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  babelHelpers.get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  babelHelpers.inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  babelHelpers.interopRequireDefault = function (obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  };

  babelHelpers.interopRequireWildcard = function (obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  };

  babelHelpers.objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  babelHelpers.possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  babelHelpers.slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if ((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  babelHelpers.taggedTemplateLiteral = function (strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  };

  babelHelpers.toArray = function (arr) {
    return Array.isArray(arr) ? arr : Array.from(arr);
  };

  babelHelpers.toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  };
})(this);
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/index.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactRedux = require(_dependencyMap[1], "react-redux");

  var _discover = require(_dependencyMap[2], "./page/discover");

  var _discover2 = babelHelpers.interopRequireDefault(_discover);

  var _reactNative = require(_dependencyMap[3], "react-native");

  var _redux = require(_dependencyMap[4], "redux");

  var _reactNavigation = require(_dependencyMap[5], "react-navigation");

  var _AppNavigator = require(_dependencyMap[6], "./component/AppNavigator");

  var _AppNavigator2 = babelHelpers.interopRequireDefault(_AppNavigator);

  var _reduxPersist = require(_dependencyMap[7], "redux-persist");

  var _reduxPersistTransformCompress = require(_dependencyMap[8], "redux-persist-transform-compress");

  var _reduxPersistTransformCompress2 = babelHelpers.interopRequireDefault(_reduxPersistTransformCompress);

  var _reduxPersistTransformFilter = require(_dependencyMap[9], "redux-persist-transform-filter");

  var _reduxPersistTransformFilter2 = babelHelpers.interopRequireDefault(_reduxPersistTransformFilter);

  var _reduxThunk = require(_dependencyMap[10], "redux-thunk");

  var _reduxThunk2 = babelHelpers.interopRequireDefault(_reduxThunk);

  var _lbryRedux = require(_dependencyMap[11], "lbry-redux");

  var _redux2 = require(_dependencyMap[12], "./utils/redux");

  function isFunction(object) {
    return typeof object === 'function';
  }

  function isNotFunction(object) {
    return !isFunction(object);
  }

  function createBulkThunkMiddleware() {
    return function (_ref) {
      var dispatch = _ref.dispatch,
          getState = _ref.getState;
      return function (next) {
        return function (action) {
          if (action.type === 'BATCH_ACTIONS') {
            action.actions.filter(isFunction).map(function (actionFn) {
              return actionFn(dispatch, getState);
            });
          }

          return next(action);
        };
      };
    };
  }

  function enableBatching(reducer) {
    return function batchingReducer(state, action) {
      switch (action.type) {
        case 'BATCH_ACTIONS':
          return action.actions.filter(isNotFunction).reduce(batchingReducer, state);

        default:
          return reducer(state, action);
      }
    };
  }

  var router = _AppNavigator.AppNavigator.router;
  var navAction = router.getActionForPathAndParams('Splash');
  var initialNavState = router.getStateForAction(navAction);

  var navigatorReducer = function navigatorReducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialNavState;
    var action = arguments[1];

    var nextState = _AppNavigator.AppNavigator.router.getStateForAction(action, state);

    return nextState || state;
  };

  var reducers = (0, _redux.combineReducers)({
    claims: _lbryRedux.claimsReducer,
    costInfo: _lbryRedux.costInfoReducer,
    fileInfo: _lbryRedux.fileInfoReducer,
    search: _lbryRedux.searchReducer,
    wallet: _lbryRedux.walletReducer,
    nav: navigatorReducer
  });
  var bulkThunk = createBulkThunkMiddleware();
  var middleware = [_reduxThunk2.default, bulkThunk, _redux2.reactNavigationMiddleware];
  var composeEnhancers = _redux.compose;
  var store = (0, _redux.createStore)(enableBatching(reducers), {}, composeEnhancers((0, _reduxPersist.autoRehydrate)(), _redux.applyMiddleware.apply(undefined, middleware)));
  var compressor = (0, _reduxPersistTransformCompress2.default)();
  var saveClaimsFilter = (0, _reduxPersistTransformFilter2.default)('claims', ['byId', 'claimsByUri']);
  var subscriptionsFilter = (0, _reduxPersistTransformFilter2.default)('subscriptions', ['subscriptions']);
  var persistOptions = {
    whitelist: ['claims', 'subscriptions'],
    transforms: [saveClaimsFilter, subscriptionsFilter, compressor],
    debounce: 10000,
    storage: _reactNative.AsyncStorage
  };
  (0, _reduxPersist.persistStore)(store, persistOptions, function (err) {
    if (err) {
      console.log('Unable to load saved SETTINGS');
    }
  });

  var LBRYApp = function (_React$Component) {
    babelHelpers.inherits(LBRYApp, _React$Component);

    function LBRYApp() {
      babelHelpers.classCallCheck(this, LBRYApp);
      return babelHelpers.possibleConstructorReturn(this, (LBRYApp.__proto__ || Object.getPrototypeOf(LBRYApp)).apply(this, arguments));
    }

    babelHelpers.createClass(LBRYApp, [{
      key: "render",
      value: function render() {
        return _react2.default.createElement(
          _reactRedux.Provider,
          {
            store: store,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 107
            }
          },
          _react2.default.createElement(_AppNavigator2.default, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 108
            }
          })
        );
      }
    }]);
    return LBRYApp;
  }(_react2.default.Component);

  _reactNative.AppRegistry.registerComponent('LBRYApp', function () {
    return LBRYApp;
  });

  exports.default = LBRYApp;
},11,[12,22,61,66,36,376,609,633,645,647,654,62,628],"LBRYApp/src/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], './cjs/react.production.min.js');
  } else {
    module.exports = require(_dependencyMap[1], './cjs/react.development.js');
  }
},12,[13,17],"react/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  /** @license React v16.2.0
   * react.production.min.js
   *
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */'use strict';

  var m = require(_dependencyMap[0], "object-assign"),
      n = require(_dependencyMap[1], "fbjs/lib/emptyObject"),
      p = require(_dependencyMap[2], "fbjs/lib/emptyFunction"),
      q = "function" === typeof Symbol && Symbol["for"],
      r = q ? Symbol["for"]("react.element") : 60103,
      t = q ? Symbol["for"]("react.call") : 60104,
      u = q ? Symbol["for"]("react.return") : 60105,
      v = q ? Symbol["for"]("react.portal") : 60106,
      w = q ? Symbol["for"]("react.fragment") : 60107,
      x = "function" === typeof Symbol && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");

  function y(a) {
    for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, c = 0; c < b; c++) {
      e += "\x26args[]\x3d" + encodeURIComponent(arguments[c + 1]);
    }

    b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
    b.name = "Invariant Violation";
    b.framesToPop = 1;
    throw b;
  }

  var z = {
    isMounted: function isMounted() {
      return !1;
    },
    enqueueForceUpdate: function enqueueForceUpdate() {},
    enqueueReplaceState: function enqueueReplaceState() {},
    enqueueSetState: function enqueueSetState() {}
  };

  function A(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = n;
    this.updater = e || z;
  }

  A.prototype.isReactComponent = {};

  A.prototype.setState = function (a, b) {
    "object" !== typeof a && "function" !== typeof a && null != a ? y("85") : void 0;
    this.updater.enqueueSetState(this, a, b, "setState");
  };

  A.prototype.forceUpdate = function (a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };

  function B(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = n;
    this.updater = e || z;
  }

  function C() {}

  C.prototype = A.prototype;
  var D = B.prototype = new C();
  D.constructor = B;
  m(D, A.prototype);
  D.isPureReactComponent = !0;

  function E(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = n;
    this.updater = e || z;
  }

  var F = E.prototype = new C();
  F.constructor = E;
  m(F, A.prototype);
  F.unstable_isAsyncReactComponent = !0;

  F.render = function () {
    return this.props.children;
  };

  var G = {
    current: null
  },
      H = Object.prototype.hasOwnProperty,
      I = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

  function J(a, b, e) {
    var c,
        d = {},
        g = null,
        k = null;
    if (null != b) for (c in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), b) {
      H.call(b, c) && !I.hasOwnProperty(c) && (d[c] = b[c]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e;else if (1 < f) {
      for (var h = Array(f), l = 0; l < f; l++) {
        h[l] = arguments[l + 2];
      }

      d.children = h;
    }
    if (a && a.defaultProps) for (c in f = a.defaultProps, f) {
      void 0 === d[c] && (d[c] = f[c]);
    }
    return {
      $$typeof: r,
      type: a,
      key: g,
      ref: k,
      props: d,
      _owner: G.current
    };
  }

  function K(a) {
    return "object" === typeof a && null !== a && a.$$typeof === r;
  }

  function escape(a) {
    var b = {
      "\x3d": "\x3d0",
      ":": "\x3d2"
    };
    return "$" + ("" + a).replace(/[=:]/g, function (a) {
      return b[a];
    });
  }

  var L = /\/+/g,
      M = [];

  function N(a, b, e, c) {
    if (M.length) {
      var d = M.pop();
      d.result = a;
      d.keyPrefix = b;
      d.func = e;
      d.context = c;
      d.count = 0;
      return d;
    }

    return {
      result: a,
      keyPrefix: b,
      func: e,
      context: c,
      count: 0
    };
  }

  function O(a) {
    a.result = null;
    a.keyPrefix = null;
    a.func = null;
    a.context = null;
    a.count = 0;
    10 > M.length && M.push(a);
  }

  function P(a, b, e, c) {
    var d = typeof a;
    if ("undefined" === d || "boolean" === d) a = null;
    var g = !1;
    if (null === a) g = !0;else switch (d) {
      case "string":
      case "number":
        g = !0;
        break;

      case "object":
        switch (a.$$typeof) {
          case r:
          case t:
          case u:
          case v:
            g = !0;
        }

    }
    if (g) return e(c, a, "" === b ? "." + Q(a, 0) : b), 1;
    g = 0;
    b = "" === b ? "." : b + ":";
    if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
      d = a[k];
      var f = b + Q(d, k);
      g += P(d, f, e, c);
    } else if (null === a || "undefined" === typeof a ? f = null : (f = x && a[x] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), k = 0; !(d = a.next()).done;) {
      d = d.value, f = b + Q(d, k++), g += P(d, f, e, c);
    } else "object" === d && (e = "" + a, y("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));
    return g;
  }

  function Q(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);
  }

  function R(a, b) {
    a.func.call(a.context, b, a.count++);
  }

  function S(a, b, e) {
    var c = a.result,
        d = a.keyPrefix;
    a = a.func.call(a.context, b, a.count++);
    Array.isArray(a) ? T(a, c, e, p.thatReturnsArgument) : null != a && (K(a) && (b = d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(L, "$\x26/") + "/") + e, a = {
      $$typeof: r,
      type: a.type,
      key: b,
      ref: a.ref,
      props: a.props,
      _owner: a._owner
    }), c.push(a));
  }

  function T(a, b, e, c, d) {
    var g = "";
    null != e && (g = ("" + e).replace(L, "$\x26/") + "/");
    b = N(b, g, c, d);
    null == a || P(a, "", S, b);
    O(b);
  }

  var U = {
    Children: {
      map: function map(a, b, e) {
        if (null == a) return a;
        var c = [];
        T(a, c, null, b, e);
        return c;
      },
      forEach: function forEach(a, b, e) {
        if (null == a) return a;
        b = N(null, null, b, e);
        null == a || P(a, "", R, b);
        O(b);
      },
      count: function count(a) {
        return null == a ? 0 : P(a, "", p.thatReturnsNull, null);
      },
      toArray: function toArray(a) {
        var b = [];
        T(a, b, null, p.thatReturnsArgument);
        return b;
      },
      only: function only(a) {
        K(a) ? void 0 : y("143");
        return a;
      }
    },
    Component: A,
    PureComponent: B,
    unstable_AsyncComponent: E,
    Fragment: w,
    createElement: J,
    cloneElement: function cloneElement(a, b, e) {
      var c = m({}, a.props),
          d = a.key,
          g = a.ref,
          k = a._owner;

      if (null != b) {
        void 0 !== b.ref && (g = b.ref, k = G.current);
        void 0 !== b.key && (d = "" + b.key);
        if (a.type && a.type.defaultProps) var f = a.type.defaultProps;

        for (h in b) {
          H.call(b, h) && !I.hasOwnProperty(h) && (c[h] = void 0 === b[h] && void 0 !== f ? f[h] : b[h]);
        }
      }

      var h = arguments.length - 2;
      if (1 === h) c.children = e;else if (1 < h) {
        f = Array(h);

        for (var l = 0; l < h; l++) {
          f[l] = arguments[l + 2];
        }

        c.children = f;
      }
      return {
        $$typeof: r,
        type: a.type,
        key: d,
        ref: g,
        props: c,
        _owner: k
      };
    },
    createFactory: function createFactory(a) {
      var b = J.bind(null, a);
      b.type = a;
      return b;
    },
    isValidElement: K,
    version: "16.2.0",
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      ReactCurrentOwner: G,
      assign: m
    }
  },
      V = Object.freeze({
    default: U
  }),
      W = V && U || V;
  module.exports = W["default"] ? W["default"] : W;
},13,[14,15,16],"react/cjs/react.production.min.js");
__d(function (global, require, module, exports, _dependencyMap) {
	/*
 object-assign
 (c) Sindre Sorhus
 @license MIT
 */'use strict';

	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			var test1 = new String('abc');
			test1[5] = 'de';

			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			var test2 = {};

			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}

			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});

			if (order2.join('') !== '0123456789') {
				return false;
			}

			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});

			if (Object.keys(babelHelpers.extends({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);

				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
},14,[],"object-assign/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var emptyObject = {};

  if (process.env.NODE_ENV !== 'production') {
    Object.freeze(emptyObject);
  }

  module.exports = emptyObject;
},15,[],"fbjs/lib/emptyObject.js");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }

  var emptyFunction = function emptyFunction() {};

  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);

  emptyFunction.thatReturnsThis = function () {
    return this;
  };

  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };

  module.exports = emptyFunction;
},16,[],"fbjs/lib/emptyFunction.js");
__d(function (global, require, module, exports, _dependencyMap) {
  /** @license React v16.2.0
   * react.development.js
   *
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      var _assign = require(_dependencyMap[0], 'object-assign');

      var emptyObject = require(_dependencyMap[1], 'fbjs/lib/emptyObject');

      var invariant = require(_dependencyMap[2], 'fbjs/lib/invariant');

      var warning = require(_dependencyMap[3], 'fbjs/lib/warning');

      var emptyFunction = require(_dependencyMap[4], 'fbjs/lib/emptyFunction');

      var checkPropTypes = require(_dependencyMap[5], 'prop-types/checkPropTypes');

      var ReactVersion = '16.2.0';
      var hasSymbol = typeof Symbol === 'function' && Symbol['for'];
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
      var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
      var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");
      var FAUX_ITERATOR_SYMBOL = '@@iterator';

      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable === 'undefined') {
          return null;
        }

        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

        if (typeof maybeIterator === 'function') {
          return maybeIterator;
        }

        return null;
      }

      var lowPriorityWarning = function lowPriorityWarning() {};

      {
        var printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var argIndex = 0;
          var message = 'Warning: ' + format.replace(/%s/g, function () {
            return args[argIndex++];
          });

          if (typeof console !== 'undefined') {
            console.warn(message);
          }

          try {
            throw new Error(message);
          } catch (x) {}
        };

        lowPriorityWarning = function lowPriorityWarning(condition, format) {
          if (format === undefined) {
            throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
          }

          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }

            printWarning.apply(undefined, [format].concat(args));
          }
        };
      }
      var lowPriorityWarning$1 = lowPriorityWarning;
      var didWarnStateUpdateForUnmountedComponent = {};

      function warnNoop(publicInstance, callerName) {
        {
          var constructor = publicInstance.constructor;
          var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
          var warningKey = componentName + '.' + callerName;

          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
            return;
          }

          warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
          didWarnStateUpdateForUnmountedComponent[warningKey] = true;
        }
      }

      var ReactNoopUpdateQueue = {
        isMounted: function isMounted(publicInstance) {
          return false;
        },
        enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
          warnNoop(publicInstance, 'forceUpdate');
        },
        enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, 'replaceState');
        },
        enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, 'setState');
        }
      };

      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }

      Component.prototype.isReactComponent = {};

      Component.prototype.setState = function (partialState, callback) {
        !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
        this.updater.enqueueSetState(this, partialState, callback, 'setState');
      };

      Component.prototype.forceUpdate = function (callback) {
        this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
      };

      {
        var deprecatedAPIs = {
          isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
          replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
        };

        var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function get() {
              lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
              return undefined;
            }
          });
        };

        for (var fnName in deprecatedAPIs) {
          if (deprecatedAPIs.hasOwnProperty(fnName)) {
            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          }
        }
      }

      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }

      function ComponentDummy() {}

      ComponentDummy.prototype = Component.prototype;
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;

      _assign(pureComponentPrototype, Component.prototype);

      pureComponentPrototype.isPureReactComponent = true;

      function AsyncComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }

      var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
      asyncComponentPrototype.constructor = AsyncComponent;

      _assign(asyncComponentPrototype, Component.prototype);

      asyncComponentPrototype.unstable_isAsyncReactComponent = true;

      asyncComponentPrototype.render = function () {
        return this.props.children;
      };

      var ReactCurrentOwner = {
        current: null
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;

      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }

      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }

      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function warnAboutAccessingKey() {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;
            warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
          }
        };

        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }

      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function warnAboutAccessingRef() {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;
            warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
          }
        };

        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }

      var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type,
          key: key,
          ref: ref,
          props: props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });

          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };

      function createElement(type, config, children) {
        var propName;
        var props = {};
        var key = null;
        var ref = null;
        var self = null;
        var source = null;

        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
          }

          if (hasValidKey(config)) {
            key = '' + config.key;
          }

          self = config.__self === undefined ? null : config.__self;
          source = config.__source === undefined ? null : config.__source;

          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
        }

        var childrenLength = arguments.length - 2;

        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);

          for (var i = 0; i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }

          {
            if (Object.freeze) {
              Object.freeze(childArray);
            }
          }
          props.children = childArray;
        }

        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;

          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }

        {
          if (key || ref) {
            if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
              var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }

              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }

      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }

      function cloneElement(element, config, children) {
        var propName;

        var props = _assign({}, element.props);

        var key = element.key;
        var ref = element.ref;
        var self = element._self;
        var source = element._source;
        var owner = element._owner;

        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            owner = ReactCurrentOwner.current;
          }

          if (hasValidKey(config)) {
            key = '' + config.key;
          }

          var defaultProps;

          if (element.type && element.type.defaultProps) {
            defaultProps = element.type.defaultProps;
          }

          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              if (config[propName] === undefined && defaultProps !== undefined) {
                props[propName] = defaultProps[propName];
              } else {
                props[propName] = config[propName];
              }
            }
          }
        }

        var childrenLength = arguments.length - 2;

        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);

          for (var i = 0; i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }

          props.children = childArray;
        }

        return ReactElement(element.type, key, ref, self, source, owner, props);
      }

      function isValidElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }

      var ReactDebugCurrentFrame = {};
      {
        ReactDebugCurrentFrame.getCurrentStack = null;

        ReactDebugCurrentFrame.getStackAddendum = function () {
          var impl = ReactDebugCurrentFrame.getCurrentStack;

          if (impl) {
            return impl();
          }

          return null;
        };
      }
      var SEPARATOR = '.';
      var SUBSEPARATOR = ':';

      function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
          '=': '=0',
          ':': '=2'
        };
        var escapedString = ('' + key).replace(escapeRegex, function (match) {
          return escaperLookup[match];
        });
        return '$' + escapedString;
      }

      var didWarnAboutMaps = false;
      var userProvidedKeyEscapeRegex = /\/+/g;

      function escapeUserProvidedKey(text) {
        return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
      }

      var POOL_SIZE = 10;
      var traverseContextPool = [];

      function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
        if (traverseContextPool.length) {
          var traverseContext = traverseContextPool.pop();
          traverseContext.result = mapResult;
          traverseContext.keyPrefix = keyPrefix;
          traverseContext.func = mapFunction;
          traverseContext.context = mapContext;
          traverseContext.count = 0;
          return traverseContext;
        } else {
          return {
            result: mapResult,
            keyPrefix: keyPrefix,
            func: mapFunction,
            context: mapContext,
            count: 0
          };
        }
      }

      function releaseTraverseContext(traverseContext) {
        traverseContext.result = null;
        traverseContext.keyPrefix = null;
        traverseContext.func = null;
        traverseContext.context = null;
        traverseContext.count = 0;

        if (traverseContextPool.length < POOL_SIZE) {
          traverseContextPool.push(traverseContext);
        }
      }

      function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
        var type = typeof children;

        if (type === 'undefined' || type === 'boolean') {
          children = null;
        }

        var invokeCallback = false;

        if (children === null) {
          invokeCallback = true;
        } else {
          switch (type) {
            case 'string':
            case 'number':
              invokeCallback = true;
              break;

            case 'object':
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_CALL_TYPE:
                case REACT_RETURN_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
              }

          }
        }

        if (invokeCallback) {
          callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
          return 1;
        }

        var child;
        var nextName;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

        if (Array.isArray(children)) {
          for (var i = 0; i < children.length; i++) {
            child = children[i];
            nextName = nextNamePrefix + getComponentKey(child, i);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else {
          var iteratorFn = getIteratorFn(children);

          if (typeof iteratorFn === 'function') {
            {
              if (iteratorFn === children.entries) {
                warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
                didWarnAboutMaps = true;
              }
            }
            var iterator = iteratorFn.call(children);
            var step;
            var ii = 0;

            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else if (type === 'object') {
            var addendum = '';
            {
              addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
            }
            var childrenString = '' + children;
            invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
          }
        }

        return subtreeCount;
      }

      function traverseAllChildren(children, callback, traverseContext) {
        if (children == null) {
          return 0;
        }

        return traverseAllChildrenImpl(children, '', callback, traverseContext);
      }

      function getComponentKey(component, index) {
        if (typeof component === 'object' && component !== null && component.key != null) {
          return escape(component.key);
        }

        return index.toString(36);
      }

      function forEachSingleChild(bookKeeping, child, name) {
        var func = bookKeeping.func,
            context = bookKeeping.context;
        func.call(context, child, bookKeeping.count++);
      }

      function forEachChildren(children, forEachFunc, forEachContext) {
        if (children == null) {
          return children;
        }

        var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
        traverseAllChildren(children, forEachSingleChild, traverseContext);
        releaseTraverseContext(traverseContext);
      }

      function mapSingleChildIntoContext(bookKeeping, child, childKey) {
        var result = bookKeeping.result,
            keyPrefix = bookKeeping.keyPrefix,
            func = bookKeeping.func,
            context = bookKeeping.context;
        var mappedChild = func.call(context, child, bookKeeping.count++);

        if (Array.isArray(mappedChild)) {
          mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
        } else if (mappedChild != null) {
          if (isValidElement(mappedChild)) {
            mappedChild = cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
          }

          result.push(mappedChild);
        }
      }

      function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
        var escapedPrefix = '';

        if (prefix != null) {
          escapedPrefix = escapeUserProvidedKey(prefix) + '/';
        }

        var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
        releaseTraverseContext(traverseContext);
      }

      function mapChildren(children, func, context) {
        if (children == null) {
          return children;
        }

        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, func, context);
        return result;
      }

      function countChildren(children, context) {
        return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
      }

      function toArray(children) {
        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
        return result;
      }

      function onlyChild(children) {
        !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
        return children;
      }

      var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
        return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
      };

      function getComponentName(fiber) {
        var type = fiber.type;

        if (typeof type === 'string') {
          return type;
        }

        if (typeof type === 'function') {
          return type.displayName || type.name;
        }

        return null;
      }

      {
        var currentlyValidatingElement = null;
        var propTypesMisspellWarningShown = false;

        var getDisplayName = function getDisplayName(element) {
          if (element == null) {
            return '#empty';
          } else if (typeof element === 'string' || typeof element === 'number') {
            return '#text';
          } else if (typeof element.type === 'string') {
            return element.type;
          } else if (element.type === REACT_FRAGMENT_TYPE) {
            return 'React.Fragment';
          } else {
            return element.type.displayName || element.type.name || 'Unknown';
          }
        };

        var getStackAddendum = function getStackAddendum() {
          var stack = '';

          if (currentlyValidatingElement) {
            var name = getDisplayName(currentlyValidatingElement);
            var owner = currentlyValidatingElement._owner;
            stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
          }

          stack += ReactDebugCurrentFrame.getStackAddendum() || '';
          return stack;
        };

        var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
      }

      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentName(ReactCurrentOwner.current);

          if (name) {
            return '\n\nCheck the render method of `' + name + '`.';
          }
        }

        return '';
      }

      function getSourceInfoErrorAddendum(elementProps) {
        if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
          var source = elementProps.__source;
          var fileName = source.fileName.replace(/^.*[\\\/]/, '');
          var lineNumber = source.lineNumber;
          return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }

        return '';
      }

      var ownerHasKeyUseWarning = {};

      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();

        if (!info) {
          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

          if (parentName) {
            info = '\n\nCheck the top-level render call using <' + parentName + '>.';
          }
        }

        return info;
      }

      function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }

        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        var childOwner = '';

        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
          childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
        }

        currentlyValidatingElement = element;
        {
          warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
        }
        currentlyValidatingElement = null;
      }

      function validateChildKeys(node, parentType) {
        if (typeof node !== 'object') {
          return;
        }

        if (Array.isArray(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];

            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);

          if (typeof iteratorFn === 'function') {
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;

              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }

      function validatePropTypes(element) {
        var componentClass = element.type;

        if (typeof componentClass !== 'function') {
          return;
        }

        var name = componentClass.displayName || componentClass.name;
        var propTypes = componentClass.propTypes;

        if (propTypes) {
          currentlyValidatingElement = element;
          checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
          currentlyValidatingElement = null;
        } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true;
          warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
        }

        if (typeof componentClass.getDefaultProps === 'function') {
          warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
        }
      }

      function validateFragmentProps(fragment) {
        currentlyValidatingElement = fragment;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = Object.keys(fragment.props)[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            if (!VALID_FRAGMENT_PROPS.has(key)) {
              warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (fragment.ref !== null) {
          warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
        }

        currentlyValidatingElement = null;
      }

      function createElementWithValidation(type, props, children) {
        var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';

        if (!validType) {
          var info = '';

          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
          }

          var sourceInfo = getSourceInfoErrorAddendum(props);

          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }

          info += getStackAddendum() || '';
          warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
        }

        var element = createElement.apply(this, arguments);

        if (element == null) {
          return element;
        }

        if (validType) {
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }

        if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }

        return element;
      }

      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        {
          Object.defineProperty(validatedFactory, 'type', {
            enumerable: false,
            get: function get() {
              lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
              Object.defineProperty(this, 'type', {
                value: type
              });
              return type;
            }
          });
        }
        return validatedFactory;
      }

      function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);

        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }

        validatePropTypes(newElement);
        return newElement;
      }

      var React = {
        Children: {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray: toArray,
          only: onlyChild
        },
        Component: Component,
        PureComponent: PureComponent,
        unstable_AsyncComponent: AsyncComponent,
        Fragment: REACT_FRAGMENT_TYPE,
        createElement: createElementWithValidation,
        cloneElement: cloneElementWithValidation,
        createFactory: createFactoryWithValidation,
        isValidElement: isValidElement,
        version: ReactVersion,
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
          ReactCurrentOwner: ReactCurrentOwner,
          assign: _assign
        }
      };
      {
        _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
          ReactDebugCurrentFrame: ReactDebugCurrentFrame,
          ReactComponentTreeHook: {}
        });
      }
      var React$2 = Object.freeze({
        default: React
      });
      var React$3 = React$2 && React || React$2;
      var react = React$3['default'] ? React$3['default'] : React$3;
      module.exports = react;
    })();
  }
},17,[14,15,18,19,16,20],"react/cjs/react.development.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var validateFormat = function validateFormat(format) {};

  if (process.env.NODE_ENV !== 'production') {
    validateFormat = function validateFormat(format) {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    };
  }

  function invariant(condition, format, a, b, c, d, e, f) {
    validateFormat(format);

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1;
      throw error;
    }
  }

  module.exports = invariant;
},18,[],"fbjs/lib/invariant.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var emptyFunction = require(_dependencyMap[0], './emptyFunction');

  var warning = emptyFunction;

  if (process.env.NODE_ENV !== 'production') {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return;
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  }

  module.exports = warning;
},19,[16],"fbjs/lib/warning.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV !== 'production') {
    var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

    var warning = require(_dependencyMap[1], 'fbjs/lib/warning');

    var ReactPropTypesSecret = require(_dependencyMap[2], './lib/ReactPropTypesSecret');

    var loggedTypeFailures = {};
  }

  function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if (process.env.NODE_ENV !== 'production') {
      for (var typeSpecName in typeSpecs) {
        if (typeSpecs.hasOwnProperty(typeSpecName)) {
          var error;

          try {
            invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }

          warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);

          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : '';
            warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
          }
        }
      }
    }
  }

  module.exports = checkPropTypes;
},20,[18,19,21],"prop-types/checkPropTypes.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  module.exports = ReactPropTypesSecret;
},21,[],"prop-types/lib/ReactPropTypesSecret.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.connect = exports.connectAdvanced = exports.createProvider = exports.Provider = undefined;

  var _Provider = require(_dependencyMap[0], './components/Provider');

  var _Provider2 = _interopRequireDefault(_Provider);

  var _connectAdvanced = require(_dependencyMap[1], './components/connectAdvanced');

  var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

  var _connect = require(_dependencyMap[2], './connect/connect');

  var _connect2 = _interopRequireDefault(_connect);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  exports.Provider = _Provider2.default;
  exports.createProvider = _Provider.createProvider;
  exports.connectAdvanced = _connectAdvanced2.default;
  exports.connect = _connect2.default;
},22,[23,29,33],"react-redux/lib/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.createProvider = createProvider;

  var _react = require(_dependencyMap[0], 'react');

  var _propTypes = require(_dependencyMap[1], 'prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _PropTypes = require(_dependencyMap[2], '../utils/PropTypes');

  var _warning = require(_dependencyMap[3], '../utils/warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var didWarnAboutReceivingStore = false;

  function warnAboutReceivingStore() {
    if (didWarnAboutReceivingStore) {
      return;
    }

    didWarnAboutReceivingStore = true;
    (0, _warning2.default)('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
  }

  function createProvider() {
    var _Provider$childContex;

    var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
    var subKey = arguments[1];
    var subscriptionKey = subKey || storeKey + 'Subscription';

    var Provider = function (_Component) {
      _inherits(Provider, _Component);

      Provider.prototype.getChildContext = function getChildContext() {
        var _ref;

        return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
      };

      function Provider(props, context) {
        _classCallCheck(this, Provider);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this[storeKey] = props.store;
        return _this;
      }

      Provider.prototype.render = function render() {
        return _react.Children.only(this.props.children);
      };

      return Provider;
    }(_react.Component);

    if (process.env.NODE_ENV !== 'production') {
      Provider.prototype.componentWillReceiveProps = function (nextProps) {
        if (this[storeKey] !== nextProps.store) {
          warnAboutReceivingStore();
        }
      };
    }

    Provider.propTypes = {
      store: _PropTypes.storeShape.isRequired,
      children: _propTypes2.default.element.isRequired
    };
    Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = _PropTypes.storeShape.isRequired, _Provider$childContex[subscriptionKey] = _PropTypes.subscriptionShape, _Provider$childContex);
    return Provider;
  }

  exports.default = createProvider();
},23,[12,24,27,28],"react-redux/lib/components/Provider.js");
__d(function (global, require, module, exports, _dependencyMap) {
  if (process.env.NODE_ENV !== 'production') {
    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && (typeof Symbol === "function" ? Symbol.for : "@@for") && (typeof Symbol === "function" ? Symbol.for : "@@for")('react.element') || 0xeac7;

    var isValidElement = function isValidElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    };

    var throwOnDirectAccess = true;
    module.exports = require(_dependencyMap[0], './factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
  } else {
    module.exports = require(_dependencyMap[1], './factoryWithThrowingShims')();
  }
},24,[25,26],"prop-types/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var emptyFunction = require(_dependencyMap[0], 'fbjs/lib/emptyFunction');

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  var warning = require(_dependencyMap[2], 'fbjs/lib/warning');

  var assign = require(_dependencyMap[3], 'object-assign');

  var ReactPropTypesSecret = require(_dependencyMap[4], './lib/ReactPropTypesSecret');

  var checkPropTypes = require(_dependencyMap[5], './checkPropTypes');

  module.exports = function (isValidElement, throwOnDirectAccess) {
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    var ANONYMOUS = '<<anonymous>>';
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };

    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }

    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    }

    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      if (process.env.NODE_ENV !== 'production') {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }

      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
          } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
            var cacheKey = componentName + ':' + propName;

            if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
              warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }

        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }

            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }

          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== expectedType) {
          var preciseType = getPreciseType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunction.thatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }

        var propValue = props[propName];

        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }

        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);

          if (error instanceof Error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
        return emptyFunction.thatReturnsNull;
      }

      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }

        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }

        for (var key in propValue) {
          if (propValue.hasOwnProperty(key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

            if (error instanceof Error) {
              return error;
            }
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
        return emptyFunction.thatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];

        if (typeof checker !== 'function') {
          warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
          return emptyFunction.thatReturnsNull;
        }
      }

      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];

          if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
            return null;
          }
        }

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }

        for (var key in shapeTypes) {
          var checker = shapeTypes[key];

          if (!checker) {
            continue;
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }

        var allKeys = assign({}, props[propName], shapeTypes);

        for (var key in allKeys) {
          var checker = shapeTypes[key];

          if (!checker) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;

        case 'boolean':
          return !propValue;

        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }

          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);

          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;

            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator.next()).done) {
                var entry = step.value;

                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;

        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      if (propType === 'symbol') {
        return true;
      }

      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }

      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    }

    function getPropType(propValue) {
      var propType = typeof propValue;

      if (Array.isArray(propValue)) {
        return 'array';
      }

      if (propValue instanceof RegExp) {
        return 'object';
      }

      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }

      return propType;
    }

    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }

      var propType = getPropType(propValue);

      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }

      return propType;
    }

    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);

      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;

        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;

        default:
          return type;
      }
    }

    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }

      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
},25,[16,18,19,14,21,20],"prop-types/factoryWithTypeCheckers.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var emptyFunction = require(_dependencyMap[0], 'fbjs/lib/emptyFunction');

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  var ReactPropTypesSecret = require(_dependencyMap[2], './lib/ReactPropTypesSecret');

  module.exports = function () {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }

      invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    }

    ;
    shim.isRequired = shim;

    function getShim() {
      return shim;
    }

    ;
    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim
    };
    ReactPropTypes.checkPropTypes = emptyFunction;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
},26,[16,18,21],"prop-types/factoryWithThrowingShims.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.storeShape = exports.subscriptionShape = undefined;

  var _propTypes = require(_dependencyMap[0], 'prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var subscriptionShape = exports.subscriptionShape = _propTypes2.default.shape({
    trySubscribe: _propTypes2.default.func.isRequired,
    tryUnsubscribe: _propTypes2.default.func.isRequired,
    notifyNestedSubs: _propTypes2.default.func.isRequired,
    isSubscribed: _propTypes2.default.func.isRequired
  });

  var storeShape = exports.storeShape = _propTypes2.default.shape({
    subscribe: _propTypes2.default.func.isRequired,
    dispatch: _propTypes2.default.func.isRequired,
    getState: _propTypes2.default.func.isRequired
  });
},27,[24],"react-redux/lib/utils/PropTypes.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.default = warning;

  function warning(message) {
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }

    try {
      throw new Error(message);
    } catch (e) {}
  }
},28,[],"react-redux/lib/utils/warning.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  exports.default = connectAdvanced;

  var _hoistNonReactStatics = require(_dependencyMap[0], 'hoist-non-react-statics');

  var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

  var _invariant = require(_dependencyMap[1], 'invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _react = require(_dependencyMap[2], 'react');

  var _Subscription = require(_dependencyMap[3], '../utils/Subscription');

  var _Subscription2 = _interopRequireDefault(_Subscription);

  var _PropTypes = require(_dependencyMap[4], '../utils/PropTypes');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _objectWithoutProperties(obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  }

  var hotReloadingVersion = 0;
  var dummyState = {};

  function noop() {}

  function makeSelectorStateful(sourceSelector, store) {
    var selector = {
      run: function runComponentSelector(props) {
        try {
          var nextProps = sourceSelector(store.getState(), props);

          if (nextProps !== selector.props || selector.error) {
            selector.shouldComponentUpdate = true;
            selector.props = nextProps;
            selector.error = null;
          }
        } catch (error) {
          selector.shouldComponentUpdate = true;
          selector.error = error;
        }
      }
    };
    return selector;
  }

  function connectAdvanced(selectorFactory) {
    var _contextTypes, _childContextTypes;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$getDisplayName = _ref.getDisplayName,
        getDisplayName = _ref$getDisplayName === undefined ? function (name) {
      return 'ConnectAdvanced(' + name + ')';
    } : _ref$getDisplayName,
        _ref$methodName = _ref.methodName,
        methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
        _ref$renderCountProp = _ref.renderCountProp,
        renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
        _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
        shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
        _ref$storeKey = _ref.storeKey,
        storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
        _ref$withRef = _ref.withRef,
        withRef = _ref$withRef === undefined ? false : _ref$withRef,
        connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

    var subscriptionKey = storeKey + 'Subscription';
    var version = hotReloadingVersion++;
    var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = _PropTypes.storeShape, _contextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _contextTypes);
    var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _childContextTypes);
    return function wrapWithConnect(WrappedComponent) {
      (0, _invariant2.default)(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + (methodName + '. Instead received ' + JSON.stringify(WrappedComponent)));
      var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
      var displayName = getDisplayName(wrappedComponentName);

      var selectorFactoryOptions = _extends({}, connectOptions, {
        getDisplayName: getDisplayName,
        methodName: methodName,
        renderCountProp: renderCountProp,
        shouldHandleStateChanges: shouldHandleStateChanges,
        storeKey: storeKey,
        withRef: withRef,
        displayName: displayName,
        wrappedComponentName: wrappedComponentName,
        WrappedComponent: WrappedComponent
      });

      var Connect = function (_Component) {
        _inherits(Connect, _Component);

        function Connect(props, context) {
          _classCallCheck(this, Connect);

          var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

          _this.version = version;
          _this.state = {};
          _this.renderCount = 0;
          _this.store = props[storeKey] || context[storeKey];
          _this.propsMode = Boolean(props[storeKey]);
          _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);
          (0, _invariant2.default)(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

          _this.initSelector();

          _this.initSubscription();

          return _this;
        }

        Connect.prototype.getChildContext = function getChildContext() {
          var _ref2;

          var subscription = this.propsMode ? null : this.subscription;
          return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
        };

        Connect.prototype.componentDidMount = function componentDidMount() {
          if (!shouldHandleStateChanges) return;
          this.subscription.trySubscribe();
          this.selector.run(this.props);
          if (this.selector.shouldComponentUpdate) this.forceUpdate();
        };

        Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
          this.selector.run(nextProps);
        };

        Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
          return this.selector.shouldComponentUpdate;
        };

        Connect.prototype.componentWillUnmount = function componentWillUnmount() {
          if (this.subscription) this.subscription.tryUnsubscribe();
          this.subscription = null;
          this.notifyNestedSubs = noop;
          this.store = null;
          this.selector.run = noop;
          this.selector.shouldComponentUpdate = false;
        };

        Connect.prototype.getWrappedInstance = function getWrappedInstance() {
          (0, _invariant2.default)(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
          return this.wrappedInstance;
        };

        Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
          this.wrappedInstance = ref;
        };

        Connect.prototype.initSelector = function initSelector() {
          var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
          this.selector = makeSelectorStateful(sourceSelector, this.store);
          this.selector.run(this.props);
        };

        Connect.prototype.initSubscription = function initSubscription() {
          if (!shouldHandleStateChanges) return;
          var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
          this.subscription = new _Subscription2.default(this.store, parentSub, this.onStateChange.bind(this));
          this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
        };

        Connect.prototype.onStateChange = function onStateChange() {
          this.selector.run(this.props);

          if (!this.selector.shouldComponentUpdate) {
            this.notifyNestedSubs();
          } else {
            this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
            this.setState(dummyState);
          }
        };

        Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
          this.componentDidUpdate = undefined;
          this.notifyNestedSubs();
        };

        Connect.prototype.isSubscribed = function isSubscribed() {
          return Boolean(this.subscription) && this.subscription.isSubscribed();
        };

        Connect.prototype.addExtraProps = function addExtraProps(props) {
          if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;

          var withExtras = _extends({}, props);

          if (withRef) withExtras.ref = this.setWrappedInstance;
          if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
          if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
          return withExtras;
        };

        Connect.prototype.render = function render() {
          var selector = this.selector;
          selector.shouldComponentUpdate = false;

          if (selector.error) {
            throw selector.error;
          } else {
            return (0, _react.createElement)(WrappedComponent, this.addExtraProps(selector.props));
          }
        };

        return Connect;
      }(_react.Component);

      Connect.WrappedComponent = WrappedComponent;
      Connect.displayName = displayName;
      Connect.childContextTypes = childContextTypes;
      Connect.contextTypes = contextTypes;
      Connect.propTypes = contextTypes;

      if (process.env.NODE_ENV !== 'production') {
        Connect.prototype.componentWillUpdate = function componentWillUpdate() {
          var _this2 = this;

          if (this.version !== version) {
            this.version = version;
            this.initSelector();
            var oldListeners = [];

            if (this.subscription) {
              oldListeners = this.subscription.listeners.get();
              this.subscription.tryUnsubscribe();
            }

            this.initSubscription();

            if (shouldHandleStateChanges) {
              this.subscription.trySubscribe();
              oldListeners.forEach(function (listener) {
                return _this2.subscription.listeners.subscribe(listener);
              });
            }
          }
        };
      }

      return (0, _hoistNonReactStatics2.default)(Connect, WrappedComponent);
    };
  }
},29,[30,31,12,32,27],"react-redux/lib/components/connectAdvanced.js");
__d(function (global, require, module, exports, _dependencyMap) {
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.hoistNonReactStatics = factory();
    })(this, function () {
        'use strict';

        var REACT_STATICS = {
            childContextTypes: true,
            contextTypes: true,
            defaultProps: true,
            displayName: true,
            getDefaultProps: true,
            getDerivedStateFromProps: true,
            mixins: true,
            propTypes: true,
            type: true
        };
        var KNOWN_STATICS = {
            name: true,
            length: true,
            prototype: true,
            caller: true,
            callee: true,
            arguments: true,
            arity: true
        };
        var defineProperty = Object.defineProperty;
        var getOwnPropertyNames = Object.getOwnPropertyNames;
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var getPrototypeOf = Object.getPrototypeOf;
        var objectPrototype = getPrototypeOf && getPrototypeOf(Object);
        return function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
            if (typeof sourceComponent !== 'string') {
                if (objectPrototype) {
                    var inheritedComponent = getPrototypeOf(sourceComponent);

                    if (inheritedComponent && inheritedComponent !== objectPrototype) {
                        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                    }
                }

                var keys = getOwnPropertyNames(sourceComponent);

                if (getOwnPropertySymbols) {
                    keys = keys.concat(getOwnPropertySymbols(sourceComponent));
                }

                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];

                    if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

                        try {
                            defineProperty(targetComponent, key, descriptor);
                        } catch (e) {}
                    }
                }

                return targetComponent;
            }

            return targetComponent;
        };
    });
},30,[],"hoist-non-react-statics/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = function invariant(condition, format, a, b, c, d, e, f) {
    if (process.env.NODE_ENV !== 'production') {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1;
      throw error;
    }
  };

  module.exports = invariant;
},31,[],"invariant/browser.js");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  exports.__esModule = true;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var CLEARED = null;
  var nullListeners = {
    notify: function notify() {}
  };

  function createListenerCollection() {
    var current = [];
    var next = [];
    return {
      clear: function clear() {
        next = CLEARED;
        current = CLEARED;
      },
      notify: function notify() {
        var listeners = current = next;

        for (var i = 0; i < listeners.length; i++) {
          listeners[i]();
        }
      },
      get: function get() {
        return next;
      },
      subscribe: function subscribe(listener) {
        var isSubscribed = true;
        if (next === current) next = current.slice();
        next.push(listener);
        return function unsubscribe() {
          if (!isSubscribed || current === CLEARED) return;
          isSubscribed = false;
          if (next === current) next = current.slice();
          next.splice(next.indexOf(listener), 1);
        };
      }
    };
  }

  var Subscription = function () {
    function Subscription(store, parentSub, onStateChange) {
      _classCallCheck(this, Subscription);

      this.store = store;
      this.parentSub = parentSub;
      this.onStateChange = onStateChange;
      this.unsubscribe = null;
      this.listeners = nullListeners;
    }

    Subscription.prototype.addNestedSub = function addNestedSub(listener) {
      this.trySubscribe();
      return this.listeners.subscribe(listener);
    };

    Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
      this.listeners.notify();
    };

    Subscription.prototype.isSubscribed = function isSubscribed() {
      return Boolean(this.unsubscribe);
    };

    Subscription.prototype.trySubscribe = function trySubscribe() {
      if (!this.unsubscribe) {
        this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);
        this.listeners = createListenerCollection();
      }
    };

    Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
      if (this.unsubscribe) {
        this.unsubscribe();
        this.unsubscribe = null;
        this.listeners.clear();
        this.listeners = nullListeners;
      }
    };

    return Subscription;
  }();

  exports.default = Subscription;
},32,[],"react-redux/lib/utils/Subscription.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  exports.createConnect = createConnect;

  var _connectAdvanced = require(_dependencyMap[0], '../components/connectAdvanced');

  var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

  var _shallowEqual = require(_dependencyMap[1], '../utils/shallowEqual');

  var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

  var _mapDispatchToProps = require(_dependencyMap[2], './mapDispatchToProps');

  var _mapDispatchToProps2 = _interopRequireDefault(_mapDispatchToProps);

  var _mapStateToProps = require(_dependencyMap[3], './mapStateToProps');

  var _mapStateToProps2 = _interopRequireDefault(_mapStateToProps);

  var _mergeProps = require(_dependencyMap[4], './mergeProps');

  var _mergeProps2 = _interopRequireDefault(_mergeProps);

  var _selectorFactory = require(_dependencyMap[5], './selectorFactory');

  var _selectorFactory2 = _interopRequireDefault(_selectorFactory);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _objectWithoutProperties(obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  }

  function match(arg, factories, name) {
    for (var i = factories.length - 1; i >= 0; i--) {
      var result = factories[i](arg);
      if (result) return result;
    }

    return function (dispatch, options) {
      throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
    };
  }

  function strictEqual(a, b) {
    return a === b;
  }

  function createConnect() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$connectHOC = _ref.connectHOC,
        connectHOC = _ref$connectHOC === undefined ? _connectAdvanced2.default : _ref$connectHOC,
        _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
        mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? _mapStateToProps2.default : _ref$mapStateToPropsF,
        _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
        mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? _mapDispatchToProps2.default : _ref$mapDispatchToPro,
        _ref$mergePropsFactor = _ref.mergePropsFactories,
        mergePropsFactories = _ref$mergePropsFactor === undefined ? _mergeProps2.default : _ref$mergePropsFactor,
        _ref$selectorFactory = _ref.selectorFactory,
        selectorFactory = _ref$selectorFactory === undefined ? _selectorFactory2.default : _ref$selectorFactory;

    return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
      var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
          _ref2$pure = _ref2.pure,
          pure = _ref2$pure === undefined ? true : _ref2$pure,
          _ref2$areStatesEqual = _ref2.areStatesEqual,
          areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
          _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
          areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? _shallowEqual2.default : _ref2$areOwnPropsEqua,
          _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
          areStatePropsEqual = _ref2$areStatePropsEq === undefined ? _shallowEqual2.default : _ref2$areStatePropsEq,
          _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
          areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? _shallowEqual2.default : _ref2$areMergedPropsE,
          extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

      var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
      var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
      var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');
      return connectHOC(selectorFactory, _extends({
        methodName: 'connect',
        getDisplayName: function getDisplayName(name) {
          return 'Connect(' + name + ')';
        },
        shouldHandleStateChanges: Boolean(mapStateToProps),
        initMapStateToProps: initMapStateToProps,
        initMapDispatchToProps: initMapDispatchToProps,
        initMergeProps: initMergeProps,
        pure: pure,
        areStatesEqual: areStatesEqual,
        areOwnPropsEqual: areOwnPropsEqual,
        areStatePropsEqual: areStatePropsEqual,
        areMergedPropsEqual: areMergedPropsEqual
      }, extraOptions));
    };
  }

  exports.default = createConnect();
},33,[29,34,35,57,58,59],"react-redux/lib/connect/connect.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.default = shallowEqual;
  var hasOwn = Object.prototype.hasOwnProperty;

  function is(x, y) {
    if (x === y) {
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }

  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;

    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  }
},34,[],"react-redux/lib/utils/shallowEqual.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.whenMapDispatchToPropsIsFunction = whenMapDispatchToPropsIsFunction;
  exports.whenMapDispatchToPropsIsMissing = whenMapDispatchToPropsIsMissing;
  exports.whenMapDispatchToPropsIsObject = whenMapDispatchToPropsIsObject;

  var _redux = require(_dependencyMap[0], 'redux');

  var _wrapMapToProps = require(_dependencyMap[1], './wrapMapToProps');

  function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
    return typeof mapDispatchToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapDispatchToProps, 'mapDispatchToProps') : undefined;
  }

  function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
    return !mapDispatchToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
      return {
        dispatch: dispatch
      };
    }) : undefined;
  }

  function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
    return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
      return (0, _redux.bindActionCreators)(mapDispatchToProps, dispatch);
    }) : undefined;
  }

  exports.default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
},35,[36,55],"react-redux/lib/connect/mapDispatchToProps.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

  var _createStore = require(_dependencyMap[0], './createStore');

  var _createStore2 = _interopRequireDefault(_createStore);

  var _combineReducers = require(_dependencyMap[1], './combineReducers');

  var _combineReducers2 = _interopRequireDefault(_combineReducers);

  var _bindActionCreators = require(_dependencyMap[2], './bindActionCreators');

  var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

  var _applyMiddleware = require(_dependencyMap[3], './applyMiddleware');

  var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

  var _compose = require(_dependencyMap[4], './compose');

  var _compose2 = _interopRequireDefault(_compose);

  var _warning = require(_dependencyMap[5], './utils/warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  function isCrushed() {}

  if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
    (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
  }

  exports.createStore = _createStore2['default'];
  exports.combineReducers = _combineReducers2['default'];
  exports.bindActionCreators = _bindActionCreators2['default'];
  exports.applyMiddleware = _applyMiddleware2['default'];
  exports.compose = _compose2['default'];
},36,[37,50,52,53,54,51],"redux/lib/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.ActionTypes = undefined;
  exports['default'] = createStore;

  var _isPlainObject = require(_dependencyMap[0], 'lodash/isPlainObject');

  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

  var _symbolObservable = require(_dependencyMap[1], 'symbol-observable');

  var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var ActionTypes = exports.ActionTypes = {
    INIT: '@@redux/INIT'
  };

  function createStore(reducer, preloadedState, enhancer) {
    var _ref2;

    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
      enhancer = preloadedState;
      preloadedState = undefined;
    }

    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error('Expected the enhancer to be a function.');
      }

      return enhancer(createStore)(reducer, preloadedState);
    }

    if (typeof reducer !== 'function') {
      throw new Error('Expected the reducer to be a function.');
    }

    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;

    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }

    function getState() {
      return currentState;
    }

    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error('Expected listener to be a function.');
      }

      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }

        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
      };
    }

    function dispatch(action) {
      if (!(0, _isPlainObject2['default'])(action)) {
        throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
      }

      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
      }

      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }

      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }

      var listeners = currentListeners = nextListeners;

      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }

      return action;
    }

    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error('Expected the nextReducer to be a function.');
      }

      currentReducer = nextReducer;
      dispatch({
        type: ActionTypes.INIT
      });
    }

    function observable() {
      var _ref;

      var outerSubscribe = subscribe;
      return _ref = {
        subscribe: function subscribe(observer) {
          if (typeof observer !== 'object') {
            throw new TypeError('Expected the observer to be an object.');
          }

          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }

          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe: unsubscribe
          };
        }
      }, _ref[_symbolObservable2['default']] = function () {
        return this;
      }, _ref;
    }

    dispatch({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    }, _ref2[_symbolObservable2['default']] = observable, _ref2;
  }
},37,[38,48],"redux/lib/createStore.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseGetTag = require(_dependencyMap[0], './_baseGetTag'),
      getPrototype = require(_dependencyMap[1], './_getPrototype'),
      isObjectLike = require(_dependencyMap[2], './isObjectLike');

  var objectTag = '[object Object]';
  var funcProto = Function.prototype,
      objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);

  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }

    var proto = getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }

  module.exports = isPlainObject;
},38,[39,45,47],"lodash/isPlainObject.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var Symbol = require(_dependencyMap[0], './_Symbol'),
        getRawTag = require(_dependencyMap[1], './_getRawTag'),
        objectToString = require(_dependencyMap[2], './_objectToString');

    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
    var symToStringTag = Symbol ? typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag" : undefined;

    function baseGetTag(value) {
        if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
        }

        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }

    module.exports = baseGetTag;
},39,[40,43,44],"lodash/_baseGetTag.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var root = require(_dependencyMap[0], './_root');

  var Symbol = root.Symbol;
  module.exports = Symbol;
},40,[41],"lodash/_Symbol.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var freeGlobal = require(_dependencyMap[0], './_freeGlobal');

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  module.exports = root;
},41,[42],"lodash/_root.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  module.exports = freeGlobal;
},42,[],"lodash/_freeGlobal.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var Symbol = require(_dependencyMap[0], './_Symbol');

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol ? typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag" : undefined;

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  module.exports = getRawTag;
},43,[40],"lodash/_getRawTag.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;

  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  module.exports = objectToString;
},44,[],"lodash/_objectToString.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var overArg = require(_dependencyMap[0], './_overArg');

  var getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = getPrototype;
},45,[46],"lodash/_getPrototype.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  module.exports = overArg;
},46,[],"lodash/_overArg.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  module.exports = isObjectLike;
},47,[],"lodash/isObjectLike.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _ponyfill = require(_dependencyMap[0], './ponyfill.js');

  var _ponyfill2 = _interopRequireDefault(_ponyfill);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var root;

  if (typeof self !== 'undefined') {
    root = self;
  } else if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof global !== 'undefined') {
    root = global;
  } else if (typeof module !== 'undefined') {
    root = module;
  } else {
    root = Function('return this')();
  }

  var result = (0, _ponyfill2['default'])(root);
  exports['default'] = result;
},48,[49],"symbol-observable/lib/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;

	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;

		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}

		return result;
	}

	;
},49,[],"symbol-observable/lib/ponyfill.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports['default'] = combineReducers;

  var _createStore = require(_dependencyMap[0], './createStore');

  var _isPlainObject = require(_dependencyMap[1], 'lodash/isPlainObject');

  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

  var _warning = require(_dependencyMap[2], './utils/warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  function getUndefinedStateErrorMessage(key, action) {
    var actionType = action && action.type;
    var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
    return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
  }

  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    var reducerKeys = Object.keys(reducers);
    var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

    if (reducerKeys.length === 0) {
      return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
    }

    if (!(0, _isPlainObject2['default'])(inputState)) {
      return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
    }

    var unexpectedKeys = Object.keys(inputState).filter(function (key) {
      return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
    });
    unexpectedKeys.forEach(function (key) {
      unexpectedKeyCache[key] = true;
    });

    if (unexpectedKeys.length > 0) {
      return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
    }
  }

  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach(function (key) {
      var reducer = reducers[key];
      var initialState = reducer(undefined, {
        type: _createStore.ActionTypes.INIT
      });

      if (typeof initialState === 'undefined') {
        throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
      }

      var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');

      if (typeof reducer(undefined, {
        type: type
      }) === 'undefined') {
        throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
      }
    });
  }

  function combineReducers(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};

    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];

      if (process.env.NODE_ENV !== 'production') {
        if (typeof reducers[key] === 'undefined') {
          (0, _warning2['default'])('No reducer provided for key "' + key + '"');
        }
      }

      if (typeof reducers[key] === 'function') {
        finalReducers[key] = reducers[key];
      }
    }

    var finalReducerKeys = Object.keys(finalReducers);
    var unexpectedKeyCache = void 0;

    if (process.env.NODE_ENV !== 'production') {
      unexpectedKeyCache = {};
    }

    var shapeAssertionError = void 0;

    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }

    return function combination() {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var action = arguments[1];

      if (shapeAssertionError) {
        throw shapeAssertionError;
      }

      if (process.env.NODE_ENV !== 'production') {
        var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

        if (warningMessage) {
          (0, _warning2['default'])(warningMessage);
        }
      }

      var hasChanged = false;
      var nextState = {};

      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer(previousStateForKey, action);

        if (typeof nextStateForKey === 'undefined') {
          var errorMessage = getUndefinedStateErrorMessage(_key, action);
          throw new Error(errorMessage);
        }

        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }

      return hasChanged ? nextState : state;
    };
  }
},50,[37,38,51],"redux/lib/combineReducers.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports['default'] = warning;

  function warning(message) {
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }

    try {
      throw new Error(message);
    } catch (e) {}
  }
},51,[],"redux/lib/utils/warning.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports['default'] = bindActionCreators;

  function bindActionCreator(actionCreator, dispatch) {
    return function () {
      return dispatch(actionCreator.apply(undefined, arguments));
    };
  }

  function bindActionCreators(actionCreators, dispatch) {
    if (typeof actionCreators === 'function') {
      return bindActionCreator(actionCreators, dispatch);
    }

    if (typeof actionCreators !== 'object' || actionCreators === null) {
      throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
    }

    var keys = Object.keys(actionCreators);
    var boundActionCreators = {};

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var actionCreator = actionCreators[key];

      if (typeof actionCreator === 'function') {
        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
      }
    }

    return boundActionCreators;
  }
},52,[],"redux/lib/bindActionCreators.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  exports['default'] = applyMiddleware;

  var _compose = require(_dependencyMap[0], './compose');

  var _compose2 = _interopRequireDefault(_compose);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  function applyMiddleware() {
    for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }

    return function (createStore) {
      return function (reducer, preloadedState, enhancer) {
        var store = createStore(reducer, preloadedState, enhancer);
        var _dispatch = store.dispatch;
        var chain = [];
        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch(action) {
            return _dispatch(action);
          }
        };
        chain = middlewares.map(function (middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);
        return _extends({}, store, {
          dispatch: _dispatch
        });
      };
    };
  }
},53,[54],"redux/lib/applyMiddleware.js");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  exports.__esModule = true;
  exports["default"] = compose;

  function compose() {
    for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    if (funcs.length === 0) {
      return function (arg) {
        return arg;
      };
    }

    if (funcs.length === 1) {
      return funcs[0];
    }

    return funcs.reduce(function (a, b) {
      return function () {
        return a(b.apply(undefined, arguments));
      };
    });
  }
},54,[],"redux/lib/compose.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.wrapMapToPropsConstant = wrapMapToPropsConstant;
  exports.getDependsOnOwnProps = getDependsOnOwnProps;
  exports.wrapMapToPropsFunc = wrapMapToPropsFunc;

  var _verifyPlainObject = require(_dependencyMap[0], '../utils/verifyPlainObject');

  var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function wrapMapToPropsConstant(getConstant) {
    return function initConstantSelector(dispatch, options) {
      var constant = getConstant(dispatch, options);

      function constantSelector() {
        return constant;
      }

      constantSelector.dependsOnOwnProps = false;
      return constantSelector;
    };
  }

  function getDependsOnOwnProps(mapToProps) {
    return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
  }

  function wrapMapToPropsFunc(mapToProps, methodName) {
    return function initProxySelector(dispatch, _ref) {
      var displayName = _ref.displayName;

      var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
        return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
      };

      proxy.dependsOnOwnProps = true;

      proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
        proxy.mapToProps = mapToProps;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
        var props = proxy(stateOrDispatch, ownProps);

        if (typeof props === 'function') {
          proxy.mapToProps = props;
          proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
          props = proxy(stateOrDispatch, ownProps);
        }

        if (process.env.NODE_ENV !== 'production') (0, _verifyPlainObject2.default)(props, displayName, methodName);
        return props;
      };

      return proxy;
    };
  }
},55,[56],"react-redux/lib/connect/wrapMapToProps.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.default = verifyPlainObject;

  var _isPlainObject = require(_dependencyMap[0], 'lodash/isPlainObject');

  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

  var _warning = require(_dependencyMap[1], './warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function verifyPlainObject(value, displayName, methodName) {
    if (!(0, _isPlainObject2.default)(value)) {
      (0, _warning2.default)(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
    }
  }
},56,[38,28],"react-redux/lib/utils/verifyPlainObject.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.whenMapStateToPropsIsFunction = whenMapStateToPropsIsFunction;
  exports.whenMapStateToPropsIsMissing = whenMapStateToPropsIsMissing;

  var _wrapMapToProps = require(_dependencyMap[0], './wrapMapToProps');

  function whenMapStateToPropsIsFunction(mapStateToProps) {
    return typeof mapStateToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapStateToProps, 'mapStateToProps') : undefined;
  }

  function whenMapStateToPropsIsMissing(mapStateToProps) {
    return !mapStateToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function () {
      return {};
    }) : undefined;
  }

  exports.default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
},57,[55],"react-redux/lib/connect/mapStateToProps.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  exports.defaultMergeProps = defaultMergeProps;
  exports.wrapMergePropsFunc = wrapMergePropsFunc;
  exports.whenMergePropsIsFunction = whenMergePropsIsFunction;
  exports.whenMergePropsIsOmitted = whenMergePropsIsOmitted;

  var _verifyPlainObject = require(_dependencyMap[0], '../utils/verifyPlainObject');

  var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function defaultMergeProps(stateProps, dispatchProps, ownProps) {
    return _extends({}, ownProps, stateProps, dispatchProps);
  }

  function wrapMergePropsFunc(mergeProps) {
    return function initMergePropsProxy(dispatch, _ref) {
      var displayName = _ref.displayName,
          pure = _ref.pure,
          areMergedPropsEqual = _ref.areMergedPropsEqual;
      var hasRunOnce = false;
      var mergedProps = void 0;
      return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
        var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

        if (hasRunOnce) {
          if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
        } else {
          hasRunOnce = true;
          mergedProps = nextMergedProps;
          if (process.env.NODE_ENV !== 'production') (0, _verifyPlainObject2.default)(mergedProps, displayName, 'mergeProps');
        }

        return mergedProps;
      };
    };
  }

  function whenMergePropsIsFunction(mergeProps) {
    return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
  }

  function whenMergePropsIsOmitted(mergeProps) {
    return !mergeProps ? function () {
      return defaultMergeProps;
    } : undefined;
  }

  exports.default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
},58,[56],"react-redux/lib/connect/mergeProps.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.impureFinalPropsSelectorFactory = impureFinalPropsSelectorFactory;
  exports.pureFinalPropsSelectorFactory = pureFinalPropsSelectorFactory;
  exports.default = finalPropsSelectorFactory;

  var _verifySubselectors = require(_dependencyMap[0], './verifySubselectors');

  var _verifySubselectors2 = _interopRequireDefault(_verifySubselectors);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _objectWithoutProperties(obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  }

  function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
    return function impureFinalPropsSelector(state, ownProps) {
      return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
    };
  }

  function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
    var areStatesEqual = _ref.areStatesEqual,
        areOwnPropsEqual = _ref.areOwnPropsEqual,
        areStatePropsEqual = _ref.areStatePropsEqual;
    var hasRunAtLeastOnce = false;
    var state = void 0;
    var ownProps = void 0;
    var stateProps = void 0;
    var dispatchProps = void 0;
    var mergedProps = void 0;

    function handleFirstCall(firstState, firstOwnProps) {
      state = firstState;
      ownProps = firstOwnProps;
      stateProps = mapStateToProps(state, ownProps);
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      hasRunAtLeastOnce = true;
      return mergedProps;
    }

    function handleNewPropsAndNewState() {
      stateProps = mapStateToProps(state, ownProps);
      if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }

    function handleNewProps() {
      if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
      if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }

    function handleNewState() {
      var nextStateProps = mapStateToProps(state, ownProps);
      var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
      stateProps = nextStateProps;
      if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }

    function handleSubsequentCalls(nextState, nextOwnProps) {
      var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
      var stateChanged = !areStatesEqual(nextState, state);
      state = nextState;
      ownProps = nextOwnProps;
      if (propsChanged && stateChanged) return handleNewPropsAndNewState();
      if (propsChanged) return handleNewProps();
      if (stateChanged) return handleNewState();
      return mergedProps;
    }

    return function pureFinalPropsSelector(nextState, nextOwnProps) {
      return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
    };
  }

  function finalPropsSelectorFactory(dispatch, _ref2) {
    var initMapStateToProps = _ref2.initMapStateToProps,
        initMapDispatchToProps = _ref2.initMapDispatchToProps,
        initMergeProps = _ref2.initMergeProps,
        options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

    var mapStateToProps = initMapStateToProps(dispatch, options);
    var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
    var mergeProps = initMergeProps(dispatch, options);

    if (process.env.NODE_ENV !== 'production') {
      (0, _verifySubselectors2.default)(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
    }

    var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
    return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
  }
},59,[60],"react-redux/lib/connect/selectorFactory.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.default = verifySubselectors;

  var _warning = require(_dependencyMap[0], '../utils/warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function verify(selector, methodName, displayName) {
    if (!selector) {
      throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
    } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
      if (!selector.hasOwnProperty('dependsOnOwnProps')) {
        (0, _warning2.default)('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
      }
    }
  }

  function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
    verify(mapStateToProps, 'mapStateToProps', displayName);
    verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
    verify(mergeProps, 'mergeProps', displayName);
  }
},60,[28],"react-redux/lib/connect/verifySubselectors.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactRedux = require(_dependencyMap[0], "react-redux");

  var _lbryRedux = require(_dependencyMap[1], "lbry-redux");

  var _view = require(_dependencyMap[2], "./view");

  var _view2 = babelHelpers.interopRequireDefault(_view);

  var select = function select(state) {
    return {
      featuredUris: (0, _lbryRedux.selectFeaturedUris)(state),
      fetchingFeaturedUris: (0, _lbryRedux.selectFetchingFeaturedUris)(state)
    };
  };

  var perform = function perform(dispatch) {
    return {
      fetchFeaturedUris: function fetchFeaturedUris() {
        return dispatch((0, _lbryRedux.doFetchFeaturedUris)());
      }
    };
  };

  exports.default = (0, _reactRedux.connect)(select, perform)(_view2.default);
},61,[22,62,63],"LBRYApp/src/page/discover/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else {
      var a = factory();

      for (var i in a) {
        (typeof exports === 'object' ? exports : root)[i] = a[i];
      }
    }
  })(typeof self !== 'undefined' ? self : this, function () {
    return function (modules) {
      var installedModules = {};

      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }

        var module = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.l = true;
        return module.exports;
      }

      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;

      __webpack_require__.d = function (exports, name, getter) {
        if (!__webpack_require__.o(exports, name)) {
          Object.defineProperty(exports, name, {
            configurable: false,
            enumerable: true,
            get: getter
          });
        }
      };

      __webpack_require__.n = function (module) {
        var getter = module && module.__esModule ? function getDefault() {
          return module['default'];
        } : function getModuleExports() {
          return module;
        };

        __webpack_require__.d(getter, 'a', getter);

        return getter;
      };

      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };

      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = 14);
    }([function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var OPEN_MODAL = exports.OPEN_MODAL = 'OPEN_MODAL';
      var CLOSE_MODAL = exports.CLOSE_MODAL = 'CLOSE_MODAL';
      var SHOW_SNACKBAR = exports.SHOW_SNACKBAR = 'SHOW_SNACKBAR';
      var REMOVE_SNACKBAR_SNACK = exports.REMOVE_SNACKBAR_SNACK = 'REMOVE_SNACKBAR_SNACK';
      var WINDOW_FOCUSED = exports.WINDOW_FOCUSED = 'WINDOW_FOCUSED';
      var DAEMON_READY = exports.DAEMON_READY = 'DAEMON_READY';
      var DAEMON_VERSION_MATCH = exports.DAEMON_VERSION_MATCH = 'DAEMON_VERSION_MATCH';
      var DAEMON_VERSION_MISMATCH = exports.DAEMON_VERSION_MISMATCH = 'DAEMON_VERSION_MISMATCH';
      var VOLUME_CHANGED = exports.VOLUME_CHANGED = 'VOLUME_CHANGED';
      var CHANGE_AFTER_AUTH_PATH = exports.CHANGE_AFTER_AUTH_PATH = 'CHANGE_AFTER_AUTH_PATH';
      var WINDOW_SCROLLED = exports.WINDOW_SCROLLED = 'WINDOW_SCROLLED';
      var HISTORY_NAVIGATE = exports.HISTORY_NAVIGATE = 'HISTORY_NAVIGATE';
      var UPGRADE_CANCELLED = exports.UPGRADE_CANCELLED = 'UPGRADE_CANCELLED';
      var DOWNLOAD_UPGRADE = exports.DOWNLOAD_UPGRADE = 'DOWNLOAD_UPGRADE';
      var UPGRADE_DOWNLOAD_STARTED = exports.UPGRADE_DOWNLOAD_STARTED = 'UPGRADE_DOWNLOAD_STARTED';
      var UPGRADE_DOWNLOAD_COMPLETED = exports.UPGRADE_DOWNLOAD_COMPLETED = 'UPGRADE_DOWNLOAD_COMPLETED';
      var UPGRADE_DOWNLOAD_PROGRESSED = exports.UPGRADE_DOWNLOAD_PROGRESSED = 'UPGRADE_DOWNLOAD_PROGRESSED';
      var CHECK_UPGRADE_AVAILABLE = exports.CHECK_UPGRADE_AVAILABLE = 'CHECK_UPGRADE_AVAILABLE';
      var CHECK_UPGRADE_START = exports.CHECK_UPGRADE_START = 'CHECK_UPGRADE_START';
      var CHECK_UPGRADE_SUCCESS = exports.CHECK_UPGRADE_SUCCESS = 'CHECK_UPGRADE_SUCCESS';
      var CHECK_UPGRADE_FAIL = exports.CHECK_UPGRADE_FAIL = 'CHECK_UPGRADE_FAIL';
      var CHECK_UPGRADE_SUBSCRIBE = exports.CHECK_UPGRADE_SUBSCRIBE = 'CHECK_UPGRADE_SUBSCRIBE';
      var UPDATE_VERSION = exports.UPDATE_VERSION = 'UPDATE_VERSION';
      var UPDATE_REMOTE_VERSION = exports.UPDATE_REMOTE_VERSION = 'UPDATE_REMOTE_VERSION';
      var SKIP_UPGRADE = exports.SKIP_UPGRADE = 'SKIP_UPGRADE';
      var START_UPGRADE = exports.START_UPGRADE = 'START_UPGRADE';
      var GET_NEW_ADDRESS_STARTED = exports.GET_NEW_ADDRESS_STARTED = 'GET_NEW_ADDRESS_STARTED';
      var GET_NEW_ADDRESS_COMPLETED = exports.GET_NEW_ADDRESS_COMPLETED = 'GET_NEW_ADDRESS_COMPLETED';
      var FETCH_TRANSACTIONS_STARTED = exports.FETCH_TRANSACTIONS_STARTED = 'FETCH_TRANSACTIONS_STARTED';
      var FETCH_TRANSACTIONS_COMPLETED = exports.FETCH_TRANSACTIONS_COMPLETED = 'FETCH_TRANSACTIONS_COMPLETED';
      var UPDATE_BALANCE = exports.UPDATE_BALANCE = 'UPDATE_BALANCE';
      var CHECK_ADDRESS_IS_MINE_STARTED = exports.CHECK_ADDRESS_IS_MINE_STARTED = 'CHECK_ADDRESS_IS_MINE_STARTED';
      var CHECK_ADDRESS_IS_MINE_COMPLETED = exports.CHECK_ADDRESS_IS_MINE_COMPLETED = 'CHECK_ADDRESS_IS_MINE_COMPLETED';
      var SET_DRAFT_TRANSACTION_AMOUNT = exports.SET_DRAFT_TRANSACTION_AMOUNT = 'SET_DRAFT_TRANSACTION_AMOUNT';
      var SET_DRAFT_TRANSACTION_ADDRESS = exports.SET_DRAFT_TRANSACTION_ADDRESS = 'SET_DRAFT_TRANSACTION_ADDRESS';
      var SEND_TRANSACTION_STARTED = exports.SEND_TRANSACTION_STARTED = 'SEND_TRANSACTION_STARTED';
      var SEND_TRANSACTION_COMPLETED = exports.SEND_TRANSACTION_COMPLETED = 'SEND_TRANSACTION_COMPLETED';
      var SEND_TRANSACTION_FAILED = exports.SEND_TRANSACTION_FAILED = 'SEND_TRANSACTION_FAILED';
      var FETCH_BLOCK_SUCCESS = exports.FETCH_BLOCK_SUCCESS = 'FETCH_BLOCK_SUCCESS';
      var SUPPORT_TRANSACTION_STARTED = exports.SUPPORT_TRANSACTION_STARTED = 'SUPPORT_TRANSACTION_STARTED';
      var SUPPORT_TRANSACTION_COMPLETED = exports.SUPPORT_TRANSACTION_COMPLETED = 'SUPPORT_TRANSACTION_COMPLETED';
      var SUPPORT_TRANSACTION_FAILED = exports.SUPPORT_TRANSACTION_FAILED = 'SUPPORT_TRANSACTION_FAILED';
      var FETCH_FEATURED_CONTENT_STARTED = exports.FETCH_FEATURED_CONTENT_STARTED = 'FETCH_FEATURED_CONTENT_STARTED';
      var FETCH_FEATURED_CONTENT_COMPLETED = exports.FETCH_FEATURED_CONTENT_COMPLETED = 'FETCH_FEATURED_CONTENT_COMPLETED';
      var RESOLVE_URIS_STARTED = exports.RESOLVE_URIS_STARTED = 'RESOLVE_URIS_STARTED';
      var RESOLVE_URIS_COMPLETED = exports.RESOLVE_URIS_COMPLETED = 'RESOLVE_URIS_COMPLETED';
      var FETCH_CHANNEL_CLAIMS_STARTED = exports.FETCH_CHANNEL_CLAIMS_STARTED = 'FETCH_CHANNEL_CLAIMS_STARTED';
      var FETCH_CHANNEL_CLAIMS_COMPLETED = exports.FETCH_CHANNEL_CLAIMS_COMPLETED = 'FETCH_CHANNEL_CLAIMS_COMPLETED';
      var FETCH_CHANNEL_CLAIM_COUNT_STARTED = exports.FETCH_CHANNEL_CLAIM_COUNT_STARTED = 'FETCH_CHANNEL_CLAIM_COUNT_STARTED';
      var FETCH_CHANNEL_CLAIM_COUNT_COMPLETED = exports.FETCH_CHANNEL_CLAIM_COUNT_COMPLETED = 'FETCH_CHANNEL_CLAIM_COUNT_COMPLETED';
      var FETCH_CLAIM_LIST_MINE_STARTED = exports.FETCH_CLAIM_LIST_MINE_STARTED = 'FETCH_CLAIM_LIST_MINE_STARTED';
      var FETCH_CLAIM_LIST_MINE_COMPLETED = exports.FETCH_CLAIM_LIST_MINE_COMPLETED = 'FETCH_CLAIM_LIST_MINE_COMPLETED';
      var ABANDON_CLAIM_STARTED = exports.ABANDON_CLAIM_STARTED = 'ABANDON_CLAIM_STARTED';
      var ABANDON_CLAIM_SUCCEEDED = exports.ABANDON_CLAIM_SUCCEEDED = 'ABANDON_CLAIM_SUCCEEDED';
      var FETCH_CHANNEL_LIST_MINE_STARTED = exports.FETCH_CHANNEL_LIST_MINE_STARTED = 'FETCH_CHANNEL_LIST_MINE_STARTED';
      var FETCH_CHANNEL_LIST_MINE_COMPLETED = exports.FETCH_CHANNEL_LIST_MINE_COMPLETED = 'FETCH_CHANNEL_LIST_MINE_COMPLETED';
      var CREATE_CHANNEL_STARTED = exports.CREATE_CHANNEL_STARTED = 'CREATE_CHANNEL_STARTED';
      var CREATE_CHANNEL_COMPLETED = exports.CREATE_CHANNEL_COMPLETED = 'CREATE_CHANNEL_COMPLETED';
      var PUBLISH_STARTED = exports.PUBLISH_STARTED = 'PUBLISH_STARTED';
      var PUBLISH_COMPLETED = exports.PUBLISH_COMPLETED = 'PUBLISH_COMPLETED';
      var PUBLISH_FAILED = exports.PUBLISH_FAILED = 'PUBLISH_FAILED';
      var SET_PLAYING_URI = exports.SET_PLAYING_URI = 'PLAY_URI';
      var FILE_LIST_STARTED = exports.FILE_LIST_STARTED = 'FILE_LIST_STARTED';
      var FILE_LIST_SUCCEEDED = exports.FILE_LIST_SUCCEEDED = 'FILE_LIST_SUCCEEDED';
      var FETCH_FILE_INFO_STARTED = exports.FETCH_FILE_INFO_STARTED = 'FETCH_FILE_INFO_STARTED';
      var FETCH_FILE_INFO_COMPLETED = exports.FETCH_FILE_INFO_COMPLETED = 'FETCH_FILE_INFO_COMPLETED';
      var FETCH_COST_INFO_STARTED = exports.FETCH_COST_INFO_STARTED = 'FETCH_COST_INFO_STARTED';
      var FETCH_COST_INFO_COMPLETED = exports.FETCH_COST_INFO_COMPLETED = 'FETCH_COST_INFO_COMPLETED';
      var LOADING_VIDEO_STARTED = exports.LOADING_VIDEO_STARTED = 'LOADING_VIDEO_STARTED';
      var LOADING_VIDEO_COMPLETED = exports.LOADING_VIDEO_COMPLETED = 'LOADING_VIDEO_COMPLETED';
      var LOADING_VIDEO_FAILED = exports.LOADING_VIDEO_FAILED = 'LOADING_VIDEO_FAILED';
      var DOWNLOADING_STARTED = exports.DOWNLOADING_STARTED = 'DOWNLOADING_STARTED';
      var DOWNLOADING_PROGRESSED = exports.DOWNLOADING_PROGRESSED = 'DOWNLOADING_PROGRESSED';
      var DOWNLOADING_COMPLETED = exports.DOWNLOADING_COMPLETED = 'DOWNLOADING_COMPLETED';
      var PLAY_VIDEO_STARTED = exports.PLAY_VIDEO_STARTED = 'PLAY_VIDEO_STARTED';
      var FETCH_AVAILABILITY_STARTED = exports.FETCH_AVAILABILITY_STARTED = 'FETCH_AVAILABILITY_STARTED';
      var FETCH_AVAILABILITY_COMPLETED = exports.FETCH_AVAILABILITY_COMPLETED = 'FETCH_AVAILABILITY_COMPLETED';
      var FILE_DELETE = exports.FILE_DELETE = 'FILE_DELETE';
      var SEARCH_STARTED = exports.SEARCH_STARTED = 'SEARCH_STARTED';
      var SEARCH_COMPLETED = exports.SEARCH_COMPLETED = 'SEARCH_COMPLETED';
      var SEARCH_CANCELLED = exports.SEARCH_CANCELLED = 'SEARCH_CANCELLED';
      var DAEMON_SETTINGS_RECEIVED = exports.DAEMON_SETTINGS_RECEIVED = 'DAEMON_SETTINGS_RECEIVED';
      var CLIENT_SETTING_CHANGED = exports.CLIENT_SETTING_CHANGED = 'CLIENT_SETTING_CHANGED';
      var AUTHENTICATION_STARTED = exports.AUTHENTICATION_STARTED = 'AUTHENTICATION_STARTED';
      var AUTHENTICATION_SUCCESS = exports.AUTHENTICATION_SUCCESS = 'AUTHENTICATION_SUCCESS';
      var AUTHENTICATION_FAILURE = exports.AUTHENTICATION_FAILURE = 'AUTHENTICATION_FAILURE';
      var USER_EMAIL_DECLINE = exports.USER_EMAIL_DECLINE = 'USER_EMAIL_DECLINE';
      var USER_EMAIL_NEW_STARTED = exports.USER_EMAIL_NEW_STARTED = 'USER_EMAIL_NEW_STARTED';
      var USER_EMAIL_NEW_SUCCESS = exports.USER_EMAIL_NEW_SUCCESS = 'USER_EMAIL_NEW_SUCCESS';
      var USER_EMAIL_NEW_EXISTS = exports.USER_EMAIL_NEW_EXISTS = 'USER_EMAIL_NEW_EXISTS';
      var USER_EMAIL_NEW_FAILURE = exports.USER_EMAIL_NEW_FAILURE = 'USER_EMAIL_NEW_FAILURE';
      var USER_EMAIL_VERIFY_STARTED = exports.USER_EMAIL_VERIFY_STARTED = 'USER_EMAIL_VERIFY_STARTED';
      var USER_EMAIL_VERIFY_SUCCESS = exports.USER_EMAIL_VERIFY_SUCCESS = 'USER_EMAIL_VERIFY_SUCCESS';
      var USER_EMAIL_VERIFY_FAILURE = exports.USER_EMAIL_VERIFY_FAILURE = 'USER_EMAIL_VERIFY_FAILURE';
      var USER_IDENTITY_VERIFY_STARTED = exports.USER_IDENTITY_VERIFY_STARTED = 'USER_IDENTITY_VERIFY_STARTED';
      var USER_IDENTITY_VERIFY_SUCCESS = exports.USER_IDENTITY_VERIFY_SUCCESS = 'USER_IDENTITY_VERIFY_SUCCESS';
      var USER_IDENTITY_VERIFY_FAILURE = exports.USER_IDENTITY_VERIFY_FAILURE = 'USER_IDENTITY_VERIFY_FAILURE';
      var USER_FETCH_STARTED = exports.USER_FETCH_STARTED = 'USER_FETCH_STARTED';
      var USER_FETCH_SUCCESS = exports.USER_FETCH_SUCCESS = 'USER_FETCH_SUCCESS';
      var USER_FETCH_FAILURE = exports.USER_FETCH_FAILURE = 'USER_FETCH_FAILURE';
      var USER_INVITE_STATUS_FETCH_STARTED = exports.USER_INVITE_STATUS_FETCH_STARTED = 'USER_INVITE_STATUS_FETCH_STARTED';
      var USER_INVITE_STATUS_FETCH_SUCCESS = exports.USER_INVITE_STATUS_FETCH_SUCCESS = 'USER_INVITE_STATUS_FETCH_SUCCESS';
      var USER_INVITE_STATUS_FETCH_FAILURE = exports.USER_INVITE_STATUS_FETCH_FAILURE = 'USER_INVITE_STATUS_FETCH_FAILURE';
      var USER_INVITE_NEW_STARTED = exports.USER_INVITE_NEW_STARTED = 'USER_INVITE_NEW_STARTED';
      var USER_INVITE_NEW_SUCCESS = exports.USER_INVITE_NEW_SUCCESS = 'USER_INVITE_NEW_SUCCESS';
      var USER_INVITE_NEW_FAILURE = exports.USER_INVITE_NEW_FAILURE = 'USER_INVITE_NEW_FAILURE';
      var FETCH_ACCESS_TOKEN_SUCCESS = exports.FETCH_ACCESS_TOKEN_SUCCESS = 'FETCH_ACCESS_TOKEN_SUCCESS';
      var FETCH_REWARDS_STARTED = exports.FETCH_REWARDS_STARTED = 'FETCH_REWARDS_STARTED';
      var FETCH_REWARDS_COMPLETED = exports.FETCH_REWARDS_COMPLETED = 'FETCH_REWARDS_COMPLETED';
      var CLAIM_REWARD_STARTED = exports.CLAIM_REWARD_STARTED = 'CLAIM_REWARD_STARTED';
      var CLAIM_REWARD_SUCCESS = exports.CLAIM_REWARD_SUCCESS = 'CLAIM_REWARD_SUCCESS';
      var CLAIM_REWARD_FAILURE = exports.CLAIM_REWARD_FAILURE = 'CLAIM_REWARD_FAILURE';
      var CLAIM_REWARD_CLEAR_ERROR = exports.CLAIM_REWARD_CLEAR_ERROR = 'CLAIM_REWARD_CLEAR_ERROR';
      var FETCH_REWARD_CONTENT_COMPLETED = exports.FETCH_REWARD_CONTENT_COMPLETED = 'FETCH_REWARD_CONTENT_COMPLETED';
      var DOWNLOAD_LANGUAGE_SUCCEEDED = exports.DOWNLOAD_LANGUAGE_SUCCEEDED = 'DOWNLOAD_LANGUAGE_SUCCEEDED';
      var DOWNLOAD_LANGUAGE_FAILED = exports.DOWNLOAD_LANGUAGE_FAILED = 'DOWNLOAD_LANGUAGE_FAILED';
      var GET_SUPPORTED_COINS_START = exports.GET_SUPPORTED_COINS_START = 'GET_SUPPORTED_COINS_START';
      var GET_SUPPORTED_COINS_SUCCESS = exports.GET_SUPPORTED_COINS_SUCCESS = 'GET_SUPPORTED_COINS_SUCCESS';
      var GET_SUPPORTED_COINS_FAIL = exports.GET_SUPPORTED_COINS_FAIL = 'GET_SUPPORTED_COINS_FAIL';
      var GET_COIN_STATS_START = exports.GET_COIN_STATS_START = 'GET_COIN_STATS_START';
      var GET_COIN_STATS_SUCCESS = exports.GET_COIN_STATS_SUCCESS = 'GET_COIN_STATS_SUCCESS';
      var GET_COIN_STATS_FAIL = exports.GET_COIN_STATS_FAIL = 'GET_COIN_STATS_FAIL';
      var PREPARE_SHAPE_SHIFT_START = exports.PREPARE_SHAPE_SHIFT_START = 'PREPARE_SHAPE_SHIFT_START';
      var PREPARE_SHAPE_SHIFT_SUCCESS = exports.PREPARE_SHAPE_SHIFT_SUCCESS = 'PREPARE_SHAPE_SHIFT_SUCCESS';
      var PREPARE_SHAPE_SHIFT_FAIL = exports.PREPARE_SHAPE_SHIFT_FAIL = 'PREPARE_SHAPE_SHIFT_FAIL';
      var GET_ACTIVE_SHIFT_START = exports.GET_ACTIVE_SHIFT_START = 'GET_ACTIVE_SHIFT_START';
      var GET_ACTIVE_SHIFT_SUCCESS = exports.GET_ACTIVE_SHIFT_SUCCESS = 'GET_ACTIVE_SHIFT_SUCCESS';
      var GET_ACTIVE_SHIFT_FAIL = exports.GET_ACTIVE_SHIFT_FAIL = 'GET_ACTIVE_SHIFT_FAIL';
      var CLEAR_SHAPE_SHIFT = exports.CLEAR_SHAPE_SHIFT = 'CLEAR_SHAPE_SHIFT';
      var CHANNEL_SUBSCRIBE = exports.CHANNEL_SUBSCRIBE = 'CHANNEL_SUBSCRIBE';
      var CHANNEL_UNSUBSCRIBE = exports.CHANNEL_UNSUBSCRIBE = 'CHANNEL_UNSUBSCRIBE';
      var HAS_FETCHED_SUBSCRIPTIONS = exports.HAS_FETCHED_SUBSCRIPTIONS = 'HAS_FETCHED_SUBSCRIPTIONS';
      var SET_VIDEO_PAUSE = exports.SET_VIDEO_PAUSE = 'SET_VIDEO_PAUSE';
      var MEDIA_PLAY = exports.MEDIA_PLAY = 'MEDIA_PLAY';
      var MEDIA_PAUSE = exports.MEDIA_PAUSE = 'MEDIA_PAUSE';
      var MEDIA_POSITION = exports.MEDIA_POSITION = 'MEDIA_POSITION';
      var NOTIFICATION_CREATED = exports.NOTIFICATION_CREATED = 'NOTIFICATION_CREATED';
      var NOTIFICATION_DISPLAYED = exports.NOTIFICATION_DISPLAYED = 'NOTIFICATION_DISPLAYED';
    }, function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.defaultMemoize = defaultMemoize;
      exports.createSelectorCreator = createSelectorCreator;
      exports.createStructuredSelector = createStructuredSelector;

      function defaultEqualityCheck(a, b) {
        return a === b;
      }

      function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
        if (prev === null || next === null || prev.length !== next.length) {
          return false;
        }

        var length = prev.length;

        for (var i = 0; i < length; i++) {
          if (!equalityCheck(prev[i], next[i])) {
            return false;
          }
        }

        return true;
      }

      function defaultMemoize(func) {
        var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;
        var lastArgs = null;
        var lastResult = null;
        return function () {
          if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
            lastResult = func.apply(null, arguments);
          }

          lastArgs = arguments;
          return lastResult;
        };
      }

      function getDependencies(funcs) {
        var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

        if (!dependencies.every(function (dep) {
          return typeof dep === 'function';
        })) {
          var dependencyTypes = dependencies.map(function (dep) {
            return typeof dep;
          }).join(', ');
          throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
        }

        return dependencies;
      }

      function createSelectorCreator(memoize) {
        for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          memoizeOptions[_key - 1] = arguments[_key];
        }

        return function () {
          for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            funcs[_key2] = arguments[_key2];
          }

          var recomputations = 0;
          var resultFunc = funcs.pop();
          var dependencies = getDependencies(funcs);
          var memoizedResultFunc = memoize.apply(undefined, [function () {
            recomputations++;
            return resultFunc.apply(null, arguments);
          }].concat(memoizeOptions));
          var selector = defaultMemoize(function () {
            var params = [];
            var length = dependencies.length;

            for (var i = 0; i < length; i++) {
              params.push(dependencies[i].apply(null, arguments));
            }

            return memoizedResultFunc.apply(null, params);
          });
          selector.resultFunc = resultFunc;

          selector.recomputations = function () {
            return recomputations;
          };

          selector.resetRecomputations = function () {
            return recomputations = 0;
          };

          return selector;
        };
      }

      var createSelector = exports.createSelector = createSelectorCreator(defaultMemoize);

      function createStructuredSelector(selectors) {
        var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;

        if (typeof selectors !== 'object') {
          throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));
        }

        var objectKeys = Object.keys(selectors);
        return selectorCreator(objectKeys.map(function (key) {
          return selectors[key];
        }), function () {
          for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            values[_key3] = arguments[_key3];
          }

          return values.reduce(function (composition, value, index) {
            composition[objectKeys[index]] = value;
            return composition;
          }, {});
        });
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if ((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      exports.parseURI = parseURI;
      exports.buildURI = buildURI;
      exports.normalizeURI = normalizeURI;
      exports.isURIValid = isURIValid;
      exports.isNameValid = isNameValid;
      exports.isURIClaimable = isURIClaimable;
      var channelNameMinLength = 1;
      var claimIdMaxLength = 40;
      var regexInvalidURI = exports.regexInvalidURI = /[^A-Za-z0-9-]/g;
      var regexAddress = exports.regexAddress = /^b(?=[^0OIl]{32,33})[0-9A-Za-z]{32,33}$/;

      function parseURI(URI) {
        var requireProto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var componentsRegex = new RegExp('^((?:lbry://)?)' + '([^:$#/]*)' + '([:$#]?)([^/]*)' + '(/?)(.*)');

        var _componentsRegex$exec = componentsRegex.exec(URI).slice(1).map(function (match) {
          return match || null;
        }),
            _componentsRegex$exec2 = _slicedToArray(_componentsRegex$exec, 6),
            proto = _componentsRegex$exec2[0],
            name = _componentsRegex$exec2[1],
            modSep = _componentsRegex$exec2[2],
            modVal = _componentsRegex$exec2[3],
            pathSep = _componentsRegex$exec2[4],
            path = _componentsRegex$exec2[5];

        var contentName = void 0;

        if (requireProto && !proto) {
          throw new Error(__('LBRY URIs must include a protocol prefix (lbry://).'));
        }

        if (!name) {
          throw new Error(__('URI does not include name.'));
        }

        var isChannel = name.startsWith('@');
        var channelName = isChannel ? name.slice(1) : name;

        if (isChannel) {
          if (!channelName) {
            throw new Error(__('No channel name after @.'));
          }

          if (channelName.length < channelNameMinLength) {
            throw new Error(__('Channel names must be at least %s characters.', channelNameMinLength));
          }

          contentName = path;
        }

        var nameBadChars = (channelName || name).match(regexInvalidURI);

        if (nameBadChars) {
          throw new Error(__('Invalid character %s in name: %s.', nameBadChars.length === 1 ? '' : 's', nameBadChars.join(', ')));
        }

        var claimId = void 0;
        var claimSequence = void 0;
        var bidPosition = void 0;

        if (modSep) {
          if (!modVal) {
            throw new Error(__('No modifier provided after separator %s.', modSep));
          }

          if (modSep === '#') {
            claimId = modVal;
          } else if (modSep === ':') {
            claimSequence = modVal;
          } else if (modSep === '$') {
            bidPosition = modVal;
          }
        }

        if (claimId && (claimId.length > claimIdMaxLength || !claimId.match(/^[0-9a-f]+$/)) && !claimId.match(/^pending/)) {
            throw new Error(__('Invalid claim ID %s.', claimId));
          }

        if (claimSequence && !claimSequence.match(/^-?[1-9][0-9]*$/)) {
          throw new Error(__('Claim sequence must be a number.'));
        }

        if (bidPosition && !bidPosition.match(/^-?[1-9][0-9]*$/)) {
          throw new Error(__('Bid position must be a number.'));
        }

        if (path) {
          if (!isChannel) {
            throw new Error(__('Only channel URIs may have a path.'));
          }

          var pathBadChars = path.match(regexInvalidURI);

          if (pathBadChars) {
            throw new Error(__('Invalid character in path: %s', pathBadChars.join(', ')));
          }

          contentName = path;
        } else if (pathSep) {
          throw new Error(__('No path provided after /'));
        }

        return _extends({
          name: name,
          path: path,
          isChannel: isChannel
        }, contentName ? {
          contentName: contentName
        } : {}, channelName ? {
          channelName: channelName
        } : {}, claimSequence ? {
          claimSequence: parseInt(claimSequence, 10)
        } : {}, bidPosition ? {
          bidPosition: parseInt(bidPosition, 10)
        } : {}, claimId ? {
          claimId: claimId
        } : {}, path ? {
          path: path
        } : {});
      }

      function buildURI(URIObj) {
        var includeProto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var claimId = URIObj.claimId,
            claimSequence = URIObj.claimSequence,
            bidPosition = URIObj.bidPosition,
            contentName = URIObj.contentName,
            channelName = URIObj.channelName;
        var name = URIObj.name,
            path = URIObj.path;

        if (channelName) {
          var channelNameFormatted = channelName.startsWith('@') ? channelName : '@' + channelName;

          if (!name) {
            name = channelNameFormatted;
          } else if (name !== channelNameFormatted) {
            throw new Error(__('Received a channel content URI, but name and channelName do not match. "name" represents the value in the name position of the URI (lbry://name...), which for channel content will be the channel name. In most cases, to construct a channel URI you should just pass channelName and contentName.'));
          }
        }

        if (contentName) {
          if (!name) {
            name = contentName;
          } else if (!path) {
            path = contentName;
          }

          if (path && path !== contentName) {
            throw new Error(__('Path and contentName do not match. Only one is required; most likely you wanted contentName.'));
          }
        }

        return (includeProto ? 'lbry://' : '') + name + (claimId ? '#' + claimId : '') + (claimSequence ? ':' + claimSequence : '') + (bidPosition ? '' + bidPosition : '') + (path ? '/' + path : '');
      }

      function normalizeURI(URI) {
        if (URI.match(/pending_claim/)) return URI;

        var _parseURI = parseURI(URI),
            name = _parseURI.name,
            path = _parseURI.path,
            bidPosition = _parseURI.bidPosition,
            claimSequence = _parseURI.claimSequence,
            claimId = _parseURI.claimId;

        return buildURI({
          name: name,
          path: path,
          claimSequence: claimSequence,
          bidPosition: bidPosition,
          claimId: claimId
        });
      }

      function isURIValid(URI) {
        var parts = void 0;

        try {
          parts = parseURI(normalizeURI(URI));
        } catch (error) {
          return false;
        }

        return parts && parts.name;
      }

      function isNameValid(name) {
        var checkCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var regexp = new RegExp('^[a-z0-9-]+$', checkCase ? '' : 'i');
        return regexp.test(name);
      }

      function isURIClaimable(URI) {
        var parts = void 0;

        try {
          parts = parseURI(normalizeURI(URI));
        } catch (error) {
          return false;
        }

        return parts && parts.name && !parts.claimId && !parts.bidPosition && !parts.claimSequence && !parts.isChannel && !parts.path;
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.selectRewardContentClaimIds = exports.makeSelectTotalPagesForChannel = exports.makeSelectTotalItemsForChannel = exports.selectChannelClaimCounts = exports.selectPlayingUri = exports.selectFetchingFeaturedUris = exports.selectFeaturedUris = exports.makeSelectIsUriResolving = exports.selectResolvingUris = exports.selectMyChannelClaims = exports.selectFetchingMyChannels = exports.selectMyClaimsOutpoints = exports.selectAllMyClaimsByOutpoint = exports.selectMyClaimsWithoutChannels = exports.selectMyClaims = exports.selectPendingClaims = exports.selectIsFetchingClaimListMine = exports.makeSelectContentTypeForUri = exports.makeSelectTitleForUri = exports.makeSelectMetadataForUri = exports.makeSelectClaimsInChannelForCurrentPage = exports.makeSelectFetchingChannelClaims = exports.selectAllFetchingChannelClaims = exports.makeSelectClaimIsMine = exports.selectMyActiveClaims = exports.selectAbandoningIds = exports.selectMyClaimsRaw = exports.makeSelectClaimForUri = exports.selectAllClaimsByChannel = exports.selectClaimsByUri = exports.selectClaimsById = undefined;

      var _lbryURI = __webpack_require__(2);

      var _navigation = __webpack_require__(4);

      var _reselect = __webpack_require__(1);

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } else {
          return Array.from(arr);
        }
      }

      var selectState = function selectState(state) {
        return state.claims || {};
      };

      var selectClaimsById = exports.selectClaimsById = (0, _reselect.createSelector)(selectState, function (state) {
        return state.byId || {};
      });
      var selectClaimsByUri = exports.selectClaimsByUri = (0, _reselect.createSelector)(selectState, selectClaimsById, function (state, byId) {
        var byUri = state.claimsByUri || {};
        var claims = {};
        Object.keys(byUri).forEach(function (uri) {
          var claimId = byUri[uri];

          if (claimId === null) {
            claims[uri] = null;
          } else {
            claims[uri] = byId[claimId];
          }
        });
        return claims;
      });
      var selectAllClaimsByChannel = exports.selectAllClaimsByChannel = (0, _reselect.createSelector)(selectState, function (state) {
        return state.claimsByChannel || {};
      });

      var makeSelectClaimForUri = exports.makeSelectClaimForUri = function makeSelectClaimForUri(uri) {
        return (0, _reselect.createSelector)(selectClaimsByUri, function (claims) {
          return claims && claims[(0, _lbryURI.normalizeURI)(uri)];
        });
      };

      var selectMyClaimsRaw = exports.selectMyClaimsRaw = (0, _reselect.createSelector)(selectState, function (state) {
        return state.myClaims;
      });
      var selectAbandoningIds = exports.selectAbandoningIds = (0, _reselect.createSelector)(selectState, function (state) {
        return Object.keys(state.abandoningById || {});
      });
      var selectMyActiveClaims = exports.selectMyActiveClaims = (0, _reselect.createSelector)(selectMyClaimsRaw, selectAbandoningIds, function (claims, abandoningIds) {
        return new Set(claims && claims.map(function (claim) {
          return claim.claim_id;
        }).filter(function (claimId) {
          return Object.keys(abandoningIds).indexOf(claimId) === -1;
        }));
      });

      var makeSelectClaimIsMine = exports.makeSelectClaimIsMine = function makeSelectClaimIsMine(rawUri) {
        var uri = (0, _lbryURI.normalizeURI)(rawUri);
        return (0, _reselect.createSelector)(selectClaimsByUri, selectMyActiveClaims, function (claims, myClaims) {
          return claims && claims[uri] && claims[uri].claim_id && myClaims.has(claims[uri].claim_id);
        });
      };

      var selectAllFetchingChannelClaims = exports.selectAllFetchingChannelClaims = (0, _reselect.createSelector)(selectState, function (state) {
        return state.fetchingChannelClaims || {};
      });

      var makeSelectFetchingChannelClaims = exports.makeSelectFetchingChannelClaims = function makeSelectFetchingChannelClaims(uri) {
        return (0, _reselect.createSelector)(selectAllFetchingChannelClaims, function (fetching) {
          return fetching && fetching[uri];
        });
      };

      var makeSelectClaimsInChannelForCurrentPage = exports.makeSelectClaimsInChannelForCurrentPage = function makeSelectClaimsInChannelForCurrentPage(uri) {
        var pageSelector = (0, _navigation.makeSelectCurrentParam)('page');
        return (0, _reselect.createSelector)(selectClaimsById, selectAllClaimsByChannel, pageSelector, function (byId, allClaims, page) {
          var byChannel = allClaims[uri] || {};
          var claimIds = byChannel[page || 1];
          if (!claimIds) return claimIds;
          return claimIds.map(function (claimId) {
            return byId[claimId];
          });
        });
      };

      var makeSelectMetadataForUri = exports.makeSelectMetadataForUri = function makeSelectMetadataForUri(uri) {
        return (0, _reselect.createSelector)(makeSelectClaimForUri(uri), function (claim) {
          var metadata = claim && claim.value && claim.value.stream && claim.value.stream.metadata;
          return metadata || (claim === undefined ? undefined : null);
        });
      };

      var makeSelectTitleForUri = exports.makeSelectTitleForUri = function makeSelectTitleForUri(uri) {
        return (0, _reselect.createSelector)(makeSelectMetadataForUri(uri), function (metadata) {
          return metadata && metadata.title;
        });
      };

      var makeSelectContentTypeForUri = exports.makeSelectContentTypeForUri = function makeSelectContentTypeForUri(uri) {
        return (0, _reselect.createSelector)(makeSelectClaimForUri(uri), function (claim) {
          var source = claim && claim.value && claim.value.stream && claim.value.stream.source;
          return source ? source.contentType : undefined;
        });
      };

      var selectIsFetchingClaimListMine = exports.selectIsFetchingClaimListMine = (0, _reselect.createSelector)(selectState, function (state) {
        return state.isFetchingClaimListMine;
      });
      var selectPendingClaims = exports.selectPendingClaims = (0, _reselect.createSelector)(selectState, function (state) {
        return Object.values(state.pendingById || {});
      });
      var selectMyClaims = exports.selectMyClaims = (0, _reselect.createSelector)(selectMyActiveClaims, selectClaimsById, selectAbandoningIds, selectPendingClaims, function (myClaimIds, byId, abandoningIds, pendingClaims) {
        var claims = [];
        myClaimIds.forEach(function (id) {
          var claim = byId[id];
          if (claim && abandoningIds.indexOf(id) === -1) claims.push(claim);
        });
        return [].concat(claims, _toConsumableArray(pendingClaims));
      });
      var selectMyClaimsWithoutChannels = exports.selectMyClaimsWithoutChannels = (0, _reselect.createSelector)(selectMyClaims, function (myClaims) {
        return myClaims.filter(function (claim) {
          return !claim.name.match(/^@/);
        });
      });
      var selectAllMyClaimsByOutpoint = exports.selectAllMyClaimsByOutpoint = (0, _reselect.createSelector)(selectMyClaimsRaw, function (claims) {
        return new Set(claims && claims.length ? claims.map(function (claim) {
          return claim.txid + ':' + claim.nout;
        }) : null);
      });
      var selectMyClaimsOutpoints = exports.selectMyClaimsOutpoints = (0, _reselect.createSelector)(selectMyClaims, function (myClaims) {
        var outpoints = [];
        myClaims.forEach(function (claim) {
          return outpoints.push(claim.txid + ':' + claim.nout);
        });
        return outpoints;
      });
      var selectFetchingMyChannels = exports.selectFetchingMyChannels = (0, _reselect.createSelector)(selectState, function (state) {
        return state.fetchingMyChannels;
      });
      var selectMyChannelClaims = exports.selectMyChannelClaims = (0, _reselect.createSelector)(selectState, selectClaimsById, function (state, byId) {
        var ids = state.myChannelClaims || [];
        var claims = [];
        ids.forEach(function (id) {
          if (byId[id]) {
            claims.push(byId[id]);
          }
        });
        return claims;
      });
      var selectResolvingUris = exports.selectResolvingUris = (0, _reselect.createSelector)(selectState, function (state) {
        return state.resolvingUris || [];
      });

      var makeSelectIsUriResolving = exports.makeSelectIsUriResolving = function makeSelectIsUriResolving(uri) {
        return (0, _reselect.createSelector)(selectResolvingUris, function (resolvingUris) {
          return resolvingUris && resolvingUris.indexOf(uri) !== -1;
        });
      };

      var selectFeaturedUris = exports.selectFeaturedUris = (0, _reselect.createSelector)(selectState, function (state) {
        return state.featuredUris;
      });
      var selectFetchingFeaturedUris = exports.selectFetchingFeaturedUris = (0, _reselect.createSelector)(selectState, function (state) {
        return state.fetchingFeaturedContent;
      });
      var selectPlayingUri = exports.selectPlayingUri = (0, _reselect.createSelector)(selectState, function (state) {
        return state.playingUri;
      });
      var selectChannelClaimCounts = exports.selectChannelClaimCounts = (0, _reselect.createSelector)(selectState, function (state) {
        return state.channelClaimCounts || {};
      });

      var makeSelectTotalItemsForChannel = exports.makeSelectTotalItemsForChannel = function makeSelectTotalItemsForChannel(uri) {
        return (0, _reselect.createSelector)(selectChannelClaimCounts, function (byUri) {
          return byUri && byUri[uri];
        });
      };

      var makeSelectTotalPagesForChannel = exports.makeSelectTotalPagesForChannel = function makeSelectTotalPagesForChannel(uri) {
        return (0, _reselect.createSelector)(selectChannelClaimCounts, function (byUri) {
          return byUri && byUri[uri] && Math.ceil(byUri[uri] / 10);
        });
      };

      var selectRewardContentClaimIds = exports.selectRewardContentClaimIds = (0, _reselect.createSelector)(selectState, function (state) {
        return state.rewardedContentClaimIds;
      });
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.selectActiveHistoryEntry = exports.selectHistoryStack = exports.selectHistoryIndex = exports.selectIsForwardDisabled = exports.selectIsBackDisabled = exports.selectPathAfterAuth = exports.selectPageTitle = exports.selectHeaderLinks = exports.makeSelectCurrentParam = exports.selectCurrentParams = exports.selectCurrentPage = exports.computePageFromPath = exports.selectCurrentPath = exports.selectState = undefined;

      var _reselect = __webpack_require__(1);

      var _lbryURI = __webpack_require__(2);

      var _query_params = __webpack_require__(11);

      var selectState = exports.selectState = function selectState(state) {
        return state.navigation || {};
      };

      var selectCurrentPath = exports.selectCurrentPath = (0, _reselect.createSelector)(selectState, function (state) {
        return state.currentPath;
      });

      var computePageFromPath = exports.computePageFromPath = function computePageFromPath(path) {
        return path.replace(/^\//, '').split('?')[0];
      };

      var selectCurrentPage = exports.selectCurrentPage = (0, _reselect.createSelector)(selectCurrentPath, function (path) {
        return computePageFromPath(path);
      });
      var selectCurrentParams = exports.selectCurrentParams = (0, _reselect.createSelector)(selectCurrentPath, function (path) {
        if (path === undefined) return {};
        if (!path.match(/\?/)) return {};
        return (0, _query_params.parseQueryParams)(path.split('?')[1]);
      });

      var makeSelectCurrentParam = exports.makeSelectCurrentParam = function makeSelectCurrentParam(param) {
        return (0, _reselect.createSelector)(selectCurrentParams, function (params) {
          return params ? params[param] : undefined;
        });
      };

      var selectHeaderLinks = exports.selectHeaderLinks = (0, _reselect.createSelector)(selectCurrentPage, function (page) {
        switch (page) {
          case 'wallet':
          case 'history':
          case 'send':
          case 'getcredits':
          case 'invite':
          case 'rewards':
          case 'backup':
            return {
              wallet: __('Overview'),
              getcredits: __('Get Credits'),
              send: __('Send / Receive'),
              rewards: __('Rewards'),
              invite: __('Invites'),
              history: __('History')
            };

          case 'downloaded':
          case 'published':
            return {
              downloaded: __('Downloaded'),
              published: __('Published')
            };

          case 'settings':
          case 'help':
            return {
              settings: __('Settings'),
              help: __('Help')
            };

          case 'discover':
          case 'subscriptions':
            return {
              discover: __('Discover'),
              subscriptions: __('Subscriptions')
            };

          default:
            return null;
        }
      });
      var selectPageTitle = exports.selectPageTitle = (0, _reselect.createSelector)(selectCurrentPage, selectCurrentParams, function (page, params) {
        switch (page) {
          case 'settings':
            return __('Settings');

          case 'report':
            return __('Report');

          case 'wallet':
            return __('Wallet');

          case 'send':
            return __('Send or Receive LBRY Credits');

          case 'getcredits':
            return __('Get LBRY Credits');

          case 'backup':
            return __('Backup Your Wallet');

          case 'rewards':
            return __('Rewards');

          case 'invite':
            return __('Invites');

          case 'start':
            return __('Start');

          case 'publish':
            return params.id ? __('Edit') : __('Publish');

          case 'help':
            return __('Help');

          case 'developer':
            return __('Developer');

          case 'show':
            {
              var parts = [(0, _lbryURI.normalizeURI)(params.uri)];

              if (Object.keys(params).length > 1) {
                parts.push((0, _query_params.toQueryString)(babelHelpers.extends({}, params, {
                  uri: null
                })));
              }

              return parts.join('?');
            }

          case 'downloaded':
            return __('Downloads & Purchases');

          case 'published':
            return __('Publications');

          case 'search':
            return params.query ? __('Search results for %s', params.query) : __('Search');

          case 'subscriptions':
            return __('Your Subscriptions');

          case 'discover':
          case false:
          case null:
          case '':
            return '';

          default:
            return page[0].toUpperCase() + (page.length > 0 ? page.substr(1) : '');
        }
      });
      var selectPathAfterAuth = exports.selectPathAfterAuth = (0, _reselect.createSelector)(selectState, function (state) {
        return state.pathAfterAuth;
      });
      var selectIsBackDisabled = exports.selectIsBackDisabled = (0, _reselect.createSelector)(selectState, function (state) {
        return state.index === 0;
      });
      var selectIsForwardDisabled = exports.selectIsForwardDisabled = (0, _reselect.createSelector)(selectState, function (state) {
        return state.index === state.stack.length - 1;
      });
      var selectHistoryIndex = exports.selectHistoryIndex = (0, _reselect.createSelector)(selectState, function (state) {
        return state.index;
      });
      var selectHistoryStack = exports.selectHistoryStack = (0, _reselect.createSelector)(selectState, function (state) {
        return state.stack;
      });
      var selectActiveHistoryEntry = exports.selectActiveHistoryEntry = (0, _reselect.createSelector)(selectState, function (state) {
        return state.stack[state.index];
      });
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      __webpack_require__(16);

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } else {
          return Array.from(arr);
        }
      }

      var CHECK_DAEMON_STARTED_TRY_NUMBER = 200;
      var Lbry = {
        isConnected: false,
        daemonConnectionString: 'http://localhost:5279',
        pendingPublishTimeout: 20 * 60 * 1000
      };

      function checkAndParse(response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        }

        return response.json().then(function (json) {
          var error = void 0;

          if (json.error) {
            error = new Error(json.error);
          } else {
            error = new Error('Protocol error with unknown response signature');
          }

          return Promise.reject(error);
        });
      }

      function apiCall(method, params, resolve, reject) {
        var counter = new Date().getTime();
        var options = {
          method: 'POST',
          body: JSON.stringify({
            jsonrpc: '2.0',
            method: method,
            params: params,
            id: counter
          })
        };
        return fetch(Lbry.daemonConnectionString, options).then(checkAndParse).then(function (response) {
          var error = response.error || response.result && response.result.error;

          if (error) {
            return reject(error);
          }

          return resolve(response.result);
        }).catch(reject);
      }

      function getLocal(key) {
        var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        var itemRaw = null;
        return itemRaw === null ? fallback : JSON.parse(itemRaw);
      }

      function setLocal(key, value) {}

      var pendingId = 0;

      function savePendingPublish(_ref) {
        var name = _ref.name,
            channelName = _ref.channelName;
        pendingId += 1;
        var pendingPublishes = getLocal('pendingPublishes') || [];
        var newPendingPublish = {
          name: name,
          channelName: channelName,
          claim_id: 'pending-' + pendingId,
          txid: 'pending-' + pendingId,
          nout: 0,
          outpoint: 'pending-' + pendingId + ':0',
          time: Date.now()
        };
        setLocal('pendingPublishes', [].concat(_toConsumableArray(pendingPublishes), [newPendingPublish]));
        return newPendingPublish;
      }

      function removePendingPublishIfNeeded(_ref2) {
        var name = _ref2.name,
            channelName = _ref2.channelName,
            outpoint = _ref2.outpoint;

        function pubMatches(pub) {
          return pub.outpoint === outpoint || pub.name === name && (!channelName || pub.channel_name === channelName);
        }

        setLocal('pendingPublishes', Lbry.getPendingPublishes().filter(function (pub) {
          return !pubMatches(pub);
        }));
      }

      Lbry.getPendingPublishes = function () {
        var pendingPublishes = getLocal('pendingPublishes') || [];
        var newPendingPublishes = pendingPublishes.filter(function (pub) {
          return Date.now() - pub.time <= Lbry.pendingPublishTimeout;
        });
        setLocal('pendingPublishes', newPendingPublishes);
        return newPendingPublishes;
      };

      function getPendingPublish(_ref3) {
        var name = _ref3.name,
            channelName = _ref3.channelName,
            outpoint = _ref3.outpoint;
        var pendingPublishes = Lbry.getPendingPublishes();
        return pendingPublishes.find(function (pub) {
          return pub.outpoint === outpoint || pub.name === name && (!channelName || pub.channel_name === channelName);
        }) || null;
      }

      function pendingPublishToDummyClaim(_ref4) {
        var channelName = _ref4.channelName,
            name = _ref4.name,
            outpoint = _ref4.outpoint,
            claimId = _ref4.claimId,
            txid = _ref4.txid,
            nout = _ref4.nout;
        return {
          name: name,
          outpoint: outpoint,
          claimId: claimId,
          txid: txid,
          nout: nout,
          channelName: channelName
        };
      }

      function pendingPublishToDummyFileInfo(_ref5) {
        var name = _ref5.name,
            outpoint = _ref5.outpoint,
            claimId = _ref5.claimId;
        return {
          name: name,
          outpoint: outpoint,
          claimId: claimId,
          metadata: null
        };
      }

      Lbry.status = function () {
        return new Promise(function (resolve, reject) {
          apiCall('status', {}, function (status) {
            resolve(status);
          }, reject);
        });
      };

      Lbry.connectPromise = null;

      Lbry.connect = function () {
        if (Lbry.connectPromise === null) {
          Lbry.connectPromise = new Promise(function (resolve, reject) {
            var tryNum = 0;

            function checkDaemonStarted() {
              tryNum += 1;
              Lbry.status().then(resolve).catch(function () {
                if (tryNum <= CHECK_DAEMON_STARTED_TRY_NUMBER) {
                  setTimeout(checkDaemonStarted, tryNum < 50 ? 400 : 1000);
                } else {
                  reject(new Error('Unable to connect to LBRY'));
                }
              });
            }

            checkDaemonStarted();
          });
        }

        return Lbry.connectPromise;
      };

      Lbry.publishDeprecated = function (params, fileListedCallback, publishedCallback, errorCallback) {
        var returnPendingTimeout = setTimeout(function () {
          var name = params.name,
              channelName = params.channel_name;

          if (publishedCallback || fileListedCallback) {
            savePendingPublish({
              name: name,
              channelName: channelName
            });
            publishedCallback(true);
          }
        }, 2000, {
          once: true
        });
        lbryProxy.publish(params).then(function (result) {
          if (returnPendingTimeout) clearTimeout(returnPendingTimeout);
          publishedCallback(result);
        }, function (err) {
          if (returnPendingTimeout) clearTimeout(returnPendingTimeout);
          errorCallback(err);
        });
      };

      Lbry.getMediaType = function (contentType, fileName) {
        if (contentType) {
          return (/^[^/]+/.exec(contentType)[0]
          );
        } else if (fileName) {
          var dotIndex = fileName.lastIndexOf('.');

          if (dotIndex === -1) {
            return 'unknown';
          }

          var ext = fileName.substr(dotIndex + 1);

          if (/^mp4|m4v|webm|flv|f4v|ogv$/i.test(ext)) {
            return 'video';
          } else if (/^mp3|m4a|aac|wav|flac|ogg|opus$/i.test(ext)) {
            return 'audio';
          } else if (/^html|htm|xml|pdf|odf|doc|docx|md|markdown|txt|epub|org$/i.test(ext)) {
            return 'document';
          }

          return 'unknown';
        }

        return 'unknown';
      };

      Lbry.file_list = function () {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return new Promise(function (resolve, reject) {
          var name = params.name,
              channelName = params.channel_name,
              outpoint = params.outpoint;

          if (outpoint) {
            var pendingPublish = getPendingPublish({
              outpoint: outpoint
            });

            if (pendingPublish) {
              resolve([pendingPublishToDummyFileInfo(pendingPublish)]);
              return;
            }
          }

          apiCall('file_list', params, function (fileInfos) {
            removePendingPublishIfNeeded({
              name: name,
              channelName: channelName,
              outpoint: outpoint
            });

            if (!name && !channelName && !outpoint) {
              var dummyFileInfos = Lbry.getPendingPublishes().map(pendingPublishToDummyFileInfo);
              resolve([].concat(_toConsumableArray(fileInfos), _toConsumableArray(dummyFileInfos)));
            } else {
              resolve(fileInfos);
            }
          }, reject);
        });
      };

      Lbry.claim_list_mine = function () {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return new Promise(function (resolve, reject) {
          apiCall('claim_list_mine', params, function (claims) {
            claims.forEach(function (_ref6) {
              var name = _ref6.name,
                  channelName = _ref6.channel_name,
                  txid = _ref6.txid,
                  nout = _ref6.nout;
              removePendingPublishIfNeeded({
                name: name,
                channelName: channelName,
                outpoint: txid + ':' + nout
              });
            });
            var dummyClaims = Lbry.getPendingPublishes().map(pendingPublishToDummyClaim);
            resolve([].concat(_toConsumableArray(claims), _toConsumableArray(dummyClaims)));
          }, reject);
        });
      };

      Lbry.get = function () {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return new Promise(function (resolve, reject) {
          apiCall('get', params, function (streamInfo) {
            resolve(streamInfo);
          }, reject);
        });
      };

      Lbry.resolve = function () {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return new Promise(function (resolve, reject) {
          apiCall('resolve', params, function (data) {
            if ('uri' in params) {
              resolve(data && data[params.uri] ? data[params.uri] : {});
            } else {
              resolve(data || {});
            }
          }, reject);
        });
      };

      var lbryProxy = new Proxy(Lbry, {
        get: function get(target, name) {
          if (name in target) {
            return target[name];
          }

          return function () {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return new Promise(function (resolve, reject) {
              apiCall(name, params, resolve, reject);
            });
          };
        }
      });
      exports.default = lbryProxy;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if ((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      exports.doResolveUris = doResolveUris;
      exports.doResolveUri = doResolveUri;
      exports.doFetchClaimListMine = doFetchClaimListMine;
      exports.doAbandonClaim = doAbandonClaim;
      exports.doFetchFeaturedUris = doFetchFeaturedUris;
      exports.doFetchRewardedContent = doFetchRewardedContent;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      var _lbry = __webpack_require__(5);

      var _lbry2 = _interopRequireDefault(_lbry);

      var _lbryapi = __webpack_require__(7);

      var _lbryapi2 = _interopRequireDefault(_lbryapi);

      var _lbryURI = __webpack_require__(2);

      var _claims = __webpack_require__(3);

      var _batchActions = __webpack_require__(8);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } else {
          return Array.from(arr);
        }
      }

      function doResolveUris(uris) {
        return function (dispatch, getState) {
          var normalizedUris = uris.map(_lbryURI.normalizeURI);
          var state = getState();
          var resolvingUris = (0, _claims.selectResolvingUris)(state);
          var urisToResolve = normalizedUris.filter(function (uri) {
            return !resolvingUris.includes(uri);
          });

          if (urisToResolve.length === 0) {
            return;
          }

          dispatch({
            type: ACTIONS.RESOLVE_URIS_STARTED,
            data: {
              uris: normalizedUris
            }
          });
          var resolveInfo = {};

          _lbry2.default.resolve({
            uris: urisToResolve
          }).then(function (result) {
            Object.entries(result).forEach(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  uri = _ref2[0],
                  uriResolveInfo = _ref2[1];

              var fallbackResolveInfo = {
                claim: null,
                claimsInChannel: null,
                certificate: null
              };

              var _ref3 = uriResolveInfo && !uriResolveInfo.error ? uriResolveInfo : fallbackResolveInfo,
                  claim = _ref3.claim,
                  certificate = _ref3.certificate,
                  claimsInChannel = _ref3.claims_in_channel;

              resolveInfo[uri] = {
                claim: claim,
                certificate: certificate,
                claimsInChannel: claimsInChannel
              };
            });
            dispatch({
              type: ACTIONS.RESOLVE_URIS_COMPLETED,
              data: {
                resolveInfo: resolveInfo
              }
            });
          });
        };
      }

      function doResolveUri(uri) {
        return doResolveUris([uri]);
      }

      function doFetchClaimListMine() {
        return function (dispatch) {
          dispatch({
            type: ACTIONS.FETCH_CLAIM_LIST_MINE_STARTED
          });

          _lbry2.default.claim_list_mine().then(function (claims) {
            dispatch({
              type: ACTIONS.FETCH_CLAIM_LIST_MINE_COMPLETED,
              data: {
                claims: claims
              }
            });
          });
        };
      }

      function doAbandonClaim(txid, nout) {
        return function (dispatch, getState) {
          var state = getState();
          var myClaims = (0, _claims.selectMyClaimsRaw)(state);

          var _myClaims$find = myClaims.find(function (claim) {
            return claim.txid === txid && claim.nout === nout;
          }),
              claimId = _myClaims$find.claim_id,
              name = _myClaims$find.name;

          dispatch({
            type: ACTIONS.ABANDON_CLAIM_STARTED,
            data: {
              claimId: claimId
            }
          });

          var errorCallback = function errorCallback() {};

          var successCallback = function successCallback(results) {
            if (results.txid) {
              dispatch({
                type: ACTIONS.ABANDON_CLAIM_SUCCEEDED,
                data: {
                  claimId: claimId
                }
              });
              dispatch(doResolveUri((0, _lbryURI.buildURI)({
                name: name,
                claimId: claimId
              })));
              dispatch(doFetchClaimListMine());
            } else {}
          };

          _lbry2.default.claim_abandon({
            txid: txid,
            nout: nout
          }).then(successCallback, errorCallback);
        };
      }

      function doFetchFeaturedUris() {
        return function (dispatch) {
          dispatch({
            type: ACTIONS.FETCH_FEATURED_CONTENT_STARTED
          });

          var success = function success(_ref4) {
            var Uris = _ref4.Uris;
            var urisToResolve = [];
            Object.keys(Uris).forEach(function (category) {
              urisToResolve = [].concat(_toConsumableArray(urisToResolve), _toConsumableArray(Uris[category]));
            });
            var actions = [doResolveUris(urisToResolve), {
              type: ACTIONS.FETCH_FEATURED_CONTENT_COMPLETED,
              data: {
                uris: Uris,
                success: true
              }
            }];
            dispatch(_batchActions.batchActions.apply(undefined, actions));
          };

          var failure = function failure() {
            dispatch({
              type: ACTIONS.FETCH_FEATURED_CONTENT_COMPLETED,
              data: {
                uris: {}
              }
            });
          };

          _lbryapi2.default.call('file', 'list_homepage').then(success, failure);
        };
      }

      function doFetchRewardedContent() {
        return function (dispatch) {
          var success = function success(nameToClaimId) {
            dispatch({
              type: ACTIONS.FETCH_REWARD_CONTENT_COMPLETED,
              data: {
                claimIds: Object.values(nameToClaimId),
                success: true
              }
            });
          };

          var failure = function failure() {
            dispatch({
              type: ACTIONS.FETCH_REWARD_CONTENT_COMPLETED,
              data: {
                claimIds: [],
                success: false
              }
            });
          };

          _lbryapi2.default.call('reward', 'list_featured').then(success, failure);
        };
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      (function (process) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        var _querystring = __webpack_require__(19);

        var _querystring2 = _interopRequireDefault(_querystring);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        var Lbryapi = {
          enabled: true,
          exchangePromise: null,
          exchangeLastFetched: null
        };
        var CONNECTION_STRING = process.env.LBRY_APP_API_URL ? process.env.LBRY_APP_API_URL.replace(/\/*$/, '/') : 'https://api.lbry.io/';
        var EXCHANGE_RATE_TIMEOUT = 20 * 60 * 1000;

        Lbryapi.getExchangeRates = function () {
          if (!Lbryapi.exchangeLastFetched || Date.now() - Lbryapi.exchangeLastFetched > EXCHANGE_RATE_TIMEOUT) {
            Lbryapi.exchangePromise = new Promise(function (resolve, reject) {
              Lbryapi.call('lbc', 'exchange_rate', {}, 'get', true).then(function (_ref) {
                var LBC_USD = _ref.lbc_usd,
                    LBC_BTC = _ref.lbc_btc,
                    BTC_USD = _ref.btc_usd;
                var rates = {
                  LBC_USD: LBC_USD,
                  LBC_BTC: LBC_BTC,
                  BTC_USD: BTC_USD
                };
                resolve(rates);
              }).catch(reject);
            });
            Lbryapi.exchangeLastFetched = Date.now();
          }

          return Lbryapi.exchangePromise;
        };

        Lbryapi.call = function (resource, action) {
          var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'get';

          if (!Lbryapi.enabled) {
            return Promise.reject(new Error(__('LBRY internal API is disabled')));
          }

          if (!(method === 'get' || method === 'post')) {
            return Promise.reject(new Error(__('Invalid method')));
          }

          function checkAndParse(response) {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            }

            return response.json().then(function (json) {
              var error = void 0;

              if (json.error) {
                error = new Error(json.error);
              } else {
                error = new Error('Unknown API error signature');
              }

              error.response = response;
              return Promise.reject(error);
            });
          }

          function makeRequest(url, options) {
            return fetch(url, options).then(checkAndParse);
          }

          var fullParams = _extends({}, params);

          var qs = _querystring2.default.stringify(fullParams);

          var url = '' + CONNECTION_STRING + resource + '/' + action + '?' + qs;
          var options = {
            method: 'GET'
          };

          if (method === 'post') {
            options = {
              method: 'POST',
              headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
              },
              body: qs
            };
            url = '' + CONNECTION_STRING + resource + '/' + action;
          }

          return makeRequest(url, options).then(function (response) {
            return response.data;
          });
        };

        exports.default = Lbryapi;
      }).call(exports, __webpack_require__(18));
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.batchActions = batchActions;

      function batchActions() {
        for (var _len = arguments.length, actions = Array(_len), _key = 0; _key < _len; _key++) {
          actions[_key] = arguments[_key];
        }

        return {
          type: 'BATCH_ACTIONS',
          actions: actions
        };
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doOpenModal = doOpenModal;
      exports.doCloseModal = doCloseModal;
      exports.doShowSnackBar = doShowSnackBar;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      function doOpenModal(modal) {
        var modalProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return {
          type: ACTIONS.OPEN_MODAL,
          data: {
            modal: modal,
            modalProps: modalProps
          }
        };
      }

      function doCloseModal() {
        return {
          type: ACTIONS.CLOSE_MODAL
        };
      }

      function doShowSnackBar(data) {
        return {
          type: ACTIONS.SHOW_SNACKBAR,
          data: data
        };
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if ((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      exports.parseQueryParams = parseQueryParams;
      exports.toQueryString = toQueryString;

      function parseQueryParams(queryString) {
        if (queryString === '') return {};
        var parts = queryString.split('?').pop().split('&').map(function (p) {
          return p.split('=');
        });
        var params = {};
        parts.forEach(function (array) {
          var _array = _slicedToArray(array, 2),
              first = _array[0],
              second = _array[1];

          params[first] = second;
        });
        return params;
      }

      function toQueryString(params) {
        if (!params) return '';
        var parts = [];
        Object.keys(params).forEach(function (key) {
          if (Object.prototype.hasOwnProperty.call(params, key) && params[key]) {
            parts.push(key + '=' + params[key]);
          }
        });
        return parts.join('&');
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.selectTotalDownloadProgress = exports.selectDownloadingFileInfos = exports.selectFileInfosDownloaded = exports.makeSelectLoadingForUri = exports.selectUrisLoading = exports.makeSelectDownloadingForUri = exports.selectDownloadingByOutpoint = exports.makeSelectFileInfoForUri = exports.selectIsFetchingFileListDownloadedOrPublished = exports.selectIsFetchingFileList = exports.selectFileInfosByOutpoint = exports.selectState = undefined;

      var _claims = __webpack_require__(3);

      var _reselect = __webpack_require__(1);

      var selectState = exports.selectState = function selectState(state) {
        return state.fileInfo || {};
      };

      var selectFileInfosByOutpoint = exports.selectFileInfosByOutpoint = (0, _reselect.createSelector)(selectState, function (state) {
        return state.byOutpoint || {};
      });
      var selectIsFetchingFileList = exports.selectIsFetchingFileList = (0, _reselect.createSelector)(selectState, function (state) {
        return state.isFetchingFileList;
      });
      var selectIsFetchingFileListDownloadedOrPublished = exports.selectIsFetchingFileListDownloadedOrPublished = (0, _reselect.createSelector)(selectIsFetchingFileList, _claims.selectIsFetchingClaimListMine, function (isFetchingFileList, isFetchingClaimListMine) {
        return isFetchingFileList || isFetchingClaimListMine;
      });

      var makeSelectFileInfoForUri = exports.makeSelectFileInfoForUri = function makeSelectFileInfoForUri(uri) {
        return (0, _reselect.createSelector)(_claims.selectClaimsByUri, selectFileInfosByOutpoint, function (claims, byOutpoint) {
          var claim = claims[uri];
          var outpoint = claim ? claim.txid + ':' + claim.nout : undefined;
          return outpoint ? byOutpoint[outpoint] : undefined;
        });
      };

      var selectDownloadingByOutpoint = exports.selectDownloadingByOutpoint = (0, _reselect.createSelector)(selectState, function (state) {
        return state.downloadingByOutpoint || {};
      });

      var makeSelectDownloadingForUri = exports.makeSelectDownloadingForUri = function makeSelectDownloadingForUri(uri) {
        return (0, _reselect.createSelector)(selectDownloadingByOutpoint, makeSelectFileInfoForUri(uri), function (byOutpoint, fileInfo) {
          if (!fileInfo) return false;
          return byOutpoint[fileInfo.outpoint];
        });
      };

      var selectUrisLoading = exports.selectUrisLoading = (0, _reselect.createSelector)(selectState, function (state) {
        return state.urisLoading || {};
      });

      var makeSelectLoadingForUri = exports.makeSelectLoadingForUri = function makeSelectLoadingForUri(uri) {
        return (0, _reselect.createSelector)(selectUrisLoading, function (byUri) {
          return byUri && byUri[uri];
        });
      };

      var selectFileInfosDownloaded = exports.selectFileInfosDownloaded = (0, _reselect.createSelector)(selectFileInfosByOutpoint, _claims.selectMyClaims, function (byOutpoint, myClaims) {
        return Object.values(byOutpoint).filter(function (fileInfo) {
          var myClaimIds = myClaims.map(function (claim) {
            return claim.claim_id;
          });
          return fileInfo && myClaimIds.indexOf(fileInfo.claim_id) === -1 && (fileInfo.completed || fileInfo.written_bytes);
        });
      });
      var selectDownloadingFileInfos = exports.selectDownloadingFileInfos = (0, _reselect.createSelector)(selectDownloadingByOutpoint, selectFileInfosByOutpoint, function (downloadingByOutpoint, fileInfosByOutpoint) {
        var outpoints = Object.keys(downloadingByOutpoint);
        var fileInfos = [];
        outpoints.forEach(function (outpoint) {
          var fileInfo = fileInfosByOutpoint[outpoint];
          if (fileInfo) fileInfos.push(fileInfo);
        });
        return fileInfos;
      });
      var selectTotalDownloadProgress = exports.selectTotalDownloadProgress = (0, _reselect.createSelector)(selectDownloadingFileInfos, function (fileInfos) {
        var progress = [];
        fileInfos.forEach(function (fileInfo) {
          progress.push(fileInfo.written_bytes / fileInfo.total_bytes * 100);
        });
        var totalProgress = progress.reduce(function (a, b) {
          return a + b;
        }, 0);
        if (fileInfos.length > 0) return totalProgress / fileInfos.length / 100.0;
        return -1;
      });
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.makeSelectBlockDate = exports.selectBlocks = exports.selectDraftTransactionError = exports.selectDraftTransactionAddress = exports.selectDraftTransactionAmount = exports.selectDraftTransaction = exports.selectGettingNewAddress = exports.selectReceiveAddress = exports.selectIsSendingSupport = exports.selectIsFetchingTransactions = exports.selectHasTransactions = exports.selectRecentTransactions = exports.selectTransactionItems = exports.selectTransactionsById = exports.selectBalance = exports.selectState = undefined;

      var _reselect = __webpack_require__(1);

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } else {
          return Array.from(arr);
        }
      }

      var selectState = exports.selectState = function selectState(state) {
        return state.wallet || {};
      };

      var selectBalance = exports.selectBalance = (0, _reselect.createSelector)(selectState, function (state) {
        return state.balance;
      });
      var selectTransactionsById = exports.selectTransactionsById = (0, _reselect.createSelector)(selectState, function (state) {
        return state.transactions;
      });
      var selectTransactionItems = exports.selectTransactionItems = (0, _reselect.createSelector)(selectTransactionsById, function (byId) {
        var items = [];
        Object.keys(byId).forEach(function (txid) {
          var tx = byId[txid];

          if (Math.abs(tx.value) === Math.abs(tx.fee) && tx.claim_info.length === 0 && tx.support_info.length === 0 && tx.update_info.length === 0) {
            return;
          }

          var append = [];
          append.push.apply(append, _toConsumableArray(tx.claim_info.map(function (item) {
            return babelHelpers.extends({}, tx, item, {
              type: item.claim_name[0] === '@' ? 'channel' : 'publish'
            });
          })));
          append.push.apply(append, _toConsumableArray(tx.support_info.map(function (item) {
            return babelHelpers.extends({}, tx, item, {
              type: !item.is_tip ? 'support' : 'tip'
            });
          })));
          append.push.apply(append, _toConsumableArray(tx.update_info.map(function (item) {
            return babelHelpers.extends({}, tx, item, {
              type: 'update'
            });
          })));

          if (!append.length) {
            append.push(babelHelpers.extends({}, tx, {
              type: tx.value < 0 ? 'spend' : 'receive'
            }));
          }

          items.push.apply(items, _toConsumableArray(append.map(function (item) {
            var amount = parseFloat(item.balance_delta ? item.balance_delta : item.value);
            return {
              txid: txid,
              date: tx.timestamp ? new Date(Number(tx.timestamp) * 1000) : null,
              amount: amount,
              fee: amount < 0 ? -1 * tx.fee / append.length : 0,
              claim_id: item.claim_id,
              claim_name: item.claim_name,
              type: item.type || 'send',
              nout: item.nout
            };
          })));
        });
        return items.reverse();
      });
      var selectRecentTransactions = exports.selectRecentTransactions = (0, _reselect.createSelector)(selectTransactionItems, function (transactions) {
        var threshold = new Date();
        threshold.setDate(threshold.getDate() - 7);
        return transactions.filter(function (transaction) {
          return transaction.date > threshold;
        });
      });
      var selectHasTransactions = exports.selectHasTransactions = (0, _reselect.createSelector)(selectTransactionItems, function (transactions) {
        return transactions && transactions.length > 0;
      });
      var selectIsFetchingTransactions = exports.selectIsFetchingTransactions = (0, _reselect.createSelector)(selectState, function (state) {
        return state.fetchingTransactions;
      });
      var selectIsSendingSupport = exports.selectIsSendingSupport = (0, _reselect.createSelector)(selectState, function (state) {
        return state.sendingSupport;
      });
      var selectReceiveAddress = exports.selectReceiveAddress = (0, _reselect.createSelector)(selectState, function (state) {
        return state.receiveAddress;
      });
      var selectGettingNewAddress = exports.selectGettingNewAddress = (0, _reselect.createSelector)(selectState, function (state) {
        return state.gettingNewAddress;
      });
      var selectDraftTransaction = exports.selectDraftTransaction = (0, _reselect.createSelector)(selectState, function (state) {
        return state.draftTransaction || {};
      });
      var selectDraftTransactionAmount = exports.selectDraftTransactionAmount = (0, _reselect.createSelector)(selectDraftTransaction, function (draft) {
        return draft.amount;
      });
      var selectDraftTransactionAddress = exports.selectDraftTransactionAddress = (0, _reselect.createSelector)(selectDraftTransaction, function (draft) {
        return draft.address;
      });
      var selectDraftTransactionError = exports.selectDraftTransactionError = (0, _reselect.createSelector)(selectDraftTransaction, function (draft) {
        return draft.error;
      });
      var selectBlocks = exports.selectBlocks = (0, _reselect.createSelector)(selectState, function (state) {
        return state.blocks;
      });

      var makeSelectBlockDate = exports.makeSelectBlockDate = function makeSelectBlockDate(block) {
        return (0, _reselect.createSelector)(selectBlocks, function (blocks) {
          return blocks && blocks[block] ? new Date(blocks[block].time * 1000) : undefined;
        });
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.selectBlocks = exports.selectDraftTransactionError = exports.selectDraftTransactionAddress = exports.selectDraftTransactionAmount = exports.selectDraftTransaction = exports.selectGettingNewAddress = exports.selectReceiveAddress = exports.selectIsSendingSupport = exports.selectIsFetchingTransactions = exports.selectHasTransactions = exports.selectRecentTransactions = exports.selectTransactionItems = exports.selectTransactionsById = exports.selectBalance = exports.makeSelectBlockDate = exports.selectWunderBarIcon = exports.selectWunderBarAddress = exports.selectSearchUrisByQuery = exports.selectIsSearching = exports.selectSearchQuery = exports.makeSelectSearchUris = exports.selectActiveHistoryEntry = exports.selectHistoryStack = exports.selectHistoryIndex = exports.selectIsForwardDisabled = exports.selectIsBackDisabled = exports.selectPathAfterAuth = exports.selectPageTitle = exports.selectHeaderLinks = undefined;
      exports.selectCurrentParams = exports.selectCurrentPage = exports.selectCurrentPath = exports.makeSelectCurrentParam = exports.computePageFromPath = exports.selectTotalDownloadProgress = exports.selectDownloadingFileInfos = exports.selectFileInfosDownloaded = exports.selectUrisLoading = exports.selectDownloadingByOutpoint = exports.selectIsFetchingFileListDownloadedOrPublished = exports.selectIsFetchingFileList = exports.selectFileInfosByOutpoint = exports.makeSelectLoadingForUri = exports.makeSelectDownloadingForUri = exports.makeSelectFileInfoForUri = exports.selectFetchingCostInfo = exports.selectCostForCurrentPageUri = exports.selectAllCostInfoByUri = exports.makeSelectCostInfoForUri = exports.makeSelectFetchingCostInfoForUri = exports.selectRewardContentClaimIds = exports.selectChannelClaimCounts = exports.selectPlayingUri = exports.selectFetchingFeaturedUris = exports.selectFeaturedUris = exports.selectResolvingUris = exports.selectMyChannelClaims = exports.selectFetchingMyChannels = exports.selectMyClaimsOutpoints = exports.selectAllMyClaimsByOutpoint = exports.selectMyClaimsWithoutChannels = exports.selectMyClaims = exports.selectPendingClaims = exports.selectIsFetchingClaimListMine = exports.selectAllFetchingChannelClaims = exports.selectMyActiveClaims = exports.selectAbandoningIds = exports.selectMyClaimsRaw = exports.selectAllClaimsByChannel = exports.selectClaimsByUri = exports.selectClaimsById = exports.makeSelectTotalPagesForChannel = exports.makeSelectTotalItemsForChannel = exports.makeSelectIsUriResolving = exports.makeSelectContentTypeForUri = exports.makeSelectTitleForUri = exports.makeSelectMetadataForUri = exports.makeSelectClaimsInChannelForCurrentPage = exports.makeSelectFetchingChannelClaims = exports.makeSelectClaimIsMine = exports.makeSelectClaimForUri = exports.selectNotification = exports.walletReducer = exports.searchReducer = exports.notificationsReducer = exports.fileInfoReducer = exports.costInfoReducer = exports.claimsReducer = exports.formatFullPrice = exports.formatCredits = exports.toQueryString = exports.parseQueryParams = exports.batchActions = exports.doSendSupport = exports.doSetDraftTransactionAddress = exports.doSetDraftTransactionAmount = exports.doSendDraftTransaction = exports.doCheckAddressIsMine = exports.doGetNewAddress = exports.doFetchBlock = exports.doFetchTransactions = exports.doBalanceSubscribe = exports.doUpdateBalance = exports.doSearch = exports.doFetchFileInfosAndPublishedClaims = exports.doFileList = exports.doFetchFileInfo = exports.doFetchCostInfoForUri = exports.doFetchRewardedContent = exports.doFetchFeaturedUris = exports.doResolveUri = exports.doResolveUris = exports.doAbandonClaim = exports.doFetchClaimListMine = exports.doShowSnackBar = exports.doCloseModal = exports.doOpenModal = exports.doNotify = exports.isURIClaimable = exports.isURIValid = exports.normalizeURI = exports.buildURI = exports.parseURI = exports.regexAddress = exports.regexInvalidURI = exports.Lbryapi = exports.Lbry = exports.ACTIONS = exports.Notification = undefined;

      var _Notification = __webpack_require__(9);

      Object.defineProperty(exports, 'Notification', {
        enumerable: true,
        get: function get() {
          return _Notification.Notification;
        }
      });

      var _lbryURI = __webpack_require__(2);

      Object.defineProperty(exports, 'regexInvalidURI', {
        enumerable: true,
        get: function get() {
          return _lbryURI.regexInvalidURI;
        }
      });
      Object.defineProperty(exports, 'regexAddress', {
        enumerable: true,
        get: function get() {
          return _lbryURI.regexAddress;
        }
      });
      Object.defineProperty(exports, 'parseURI', {
        enumerable: true,
        get: function get() {
          return _lbryURI.parseURI;
        }
      });
      Object.defineProperty(exports, 'buildURI', {
        enumerable: true,
        get: function get() {
          return _lbryURI.buildURI;
        }
      });
      Object.defineProperty(exports, 'normalizeURI', {
        enumerable: true,
        get: function get() {
          return _lbryURI.normalizeURI;
        }
      });
      Object.defineProperty(exports, 'isURIValid', {
        enumerable: true,
        get: function get() {
          return _lbryURI.isURIValid;
        }
      });
      Object.defineProperty(exports, 'isURIClaimable', {
        enumerable: true,
        get: function get() {
          return _lbryURI.isURIClaimable;
        }
      });

      var _notifications = __webpack_require__(15);

      Object.defineProperty(exports, 'doNotify', {
        enumerable: true,
        get: function get() {
          return _notifications.doNotify;
        }
      });

      var _app = __webpack_require__(10);

      Object.defineProperty(exports, 'doOpenModal', {
        enumerable: true,
        get: function get() {
          return _app.doOpenModal;
        }
      });
      Object.defineProperty(exports, 'doCloseModal', {
        enumerable: true,
        get: function get() {
          return _app.doCloseModal;
        }
      });
      Object.defineProperty(exports, 'doShowSnackBar', {
        enumerable: true,
        get: function get() {
          return _app.doShowSnackBar;
        }
      });

      var _claims = __webpack_require__(6);

      Object.defineProperty(exports, 'doFetchClaimListMine', {
        enumerable: true,
        get: function get() {
          return _claims.doFetchClaimListMine;
        }
      });
      Object.defineProperty(exports, 'doAbandonClaim', {
        enumerable: true,
        get: function get() {
          return _claims.doAbandonClaim;
        }
      });
      Object.defineProperty(exports, 'doResolveUris', {
        enumerable: true,
        get: function get() {
          return _claims.doResolveUris;
        }
      });
      Object.defineProperty(exports, 'doResolveUri', {
        enumerable: true,
        get: function get() {
          return _claims.doResolveUri;
        }
      });
      Object.defineProperty(exports, 'doFetchFeaturedUris', {
        enumerable: true,
        get: function get() {
          return _claims.doFetchFeaturedUris;
        }
      });
      Object.defineProperty(exports, 'doFetchRewardedContent', {
        enumerable: true,
        get: function get() {
          return _claims.doFetchRewardedContent;
        }
      });

      var _cost_info = __webpack_require__(22);

      Object.defineProperty(exports, 'doFetchCostInfoForUri', {
        enumerable: true,
        get: function get() {
          return _cost_info.doFetchCostInfoForUri;
        }
      });

      var _file_info = __webpack_require__(23);

      Object.defineProperty(exports, 'doFetchFileInfo', {
        enumerable: true,
        get: function get() {
          return _file_info.doFetchFileInfo;
        }
      });
      Object.defineProperty(exports, 'doFileList', {
        enumerable: true,
        get: function get() {
          return _file_info.doFileList;
        }
      });
      Object.defineProperty(exports, 'doFetchFileInfosAndPublishedClaims', {
        enumerable: true,
        get: function get() {
          return _file_info.doFetchFileInfosAndPublishedClaims;
        }
      });

      var _search = __webpack_require__(24);

      Object.defineProperty(exports, 'doSearch', {
        enumerable: true,
        get: function get() {
          return _search.doSearch;
        }
      });

      var _wallet = __webpack_require__(25);

      Object.defineProperty(exports, 'doUpdateBalance', {
        enumerable: true,
        get: function get() {
          return _wallet.doUpdateBalance;
        }
      });
      Object.defineProperty(exports, 'doBalanceSubscribe', {
        enumerable: true,
        get: function get() {
          return _wallet.doBalanceSubscribe;
        }
      });
      Object.defineProperty(exports, 'doFetchTransactions', {
        enumerable: true,
        get: function get() {
          return _wallet.doFetchTransactions;
        }
      });
      Object.defineProperty(exports, 'doFetchBlock', {
        enumerable: true,
        get: function get() {
          return _wallet.doFetchBlock;
        }
      });
      Object.defineProperty(exports, 'doGetNewAddress', {
        enumerable: true,
        get: function get() {
          return _wallet.doGetNewAddress;
        }
      });
      Object.defineProperty(exports, 'doCheckAddressIsMine', {
        enumerable: true,
        get: function get() {
          return _wallet.doCheckAddressIsMine;
        }
      });
      Object.defineProperty(exports, 'doSendDraftTransaction', {
        enumerable: true,
        get: function get() {
          return _wallet.doSendDraftTransaction;
        }
      });
      Object.defineProperty(exports, 'doSetDraftTransactionAmount', {
        enumerable: true,
        get: function get() {
          return _wallet.doSetDraftTransactionAmount;
        }
      });
      Object.defineProperty(exports, 'doSetDraftTransactionAddress', {
        enumerable: true,
        get: function get() {
          return _wallet.doSetDraftTransactionAddress;
        }
      });
      Object.defineProperty(exports, 'doSendSupport', {
        enumerable: true,
        get: function get() {
          return _wallet.doSendSupport;
        }
      });

      var _batchActions = __webpack_require__(8);

      Object.defineProperty(exports, 'batchActions', {
        enumerable: true,
        get: function get() {
          return _batchActions.batchActions;
        }
      });

      var _query_params = __webpack_require__(11);

      Object.defineProperty(exports, 'parseQueryParams', {
        enumerable: true,
        get: function get() {
          return _query_params.parseQueryParams;
        }
      });
      Object.defineProperty(exports, 'toQueryString', {
        enumerable: true,
        get: function get() {
          return _query_params.toQueryString;
        }
      });

      var _formatCredits = __webpack_require__(27);

      Object.defineProperty(exports, 'formatCredits', {
        enumerable: true,
        get: function get() {
          return _formatCredits.formatCredits;
        }
      });
      Object.defineProperty(exports, 'formatFullPrice', {
        enumerable: true,
        get: function get() {
          return _formatCredits.formatFullPrice;
        }
      });

      var _claims2 = __webpack_require__(28);

      Object.defineProperty(exports, 'claimsReducer', {
        enumerable: true,
        get: function get() {
          return _claims2.claimsReducer;
        }
      });

      var _cost_info2 = __webpack_require__(29);

      Object.defineProperty(exports, 'costInfoReducer', {
        enumerable: true,
        get: function get() {
          return _cost_info2.costInfoReducer;
        }
      });

      var _file_info2 = __webpack_require__(30);

      Object.defineProperty(exports, 'fileInfoReducer', {
        enumerable: true,
        get: function get() {
          return _file_info2.fileInfoReducer;
        }
      });

      var _notifications2 = __webpack_require__(31);

      Object.defineProperty(exports, 'notificationsReducer', {
        enumerable: true,
        get: function get() {
          return _notifications2.notificationsReducer;
        }
      });

      var _search2 = __webpack_require__(32);

      Object.defineProperty(exports, 'searchReducer', {
        enumerable: true,
        get: function get() {
          return _search2.searchReducer;
        }
      });

      var _wallet2 = __webpack_require__(33);

      Object.defineProperty(exports, 'walletReducer', {
        enumerable: true,
        get: function get() {
          return _wallet2.walletReducer;
        }
      });

      var _notifications3 = __webpack_require__(34);

      Object.defineProperty(exports, 'selectNotification', {
        enumerable: true,
        get: function get() {
          return _notifications3.selectNotification;
        }
      });

      var _claims3 = __webpack_require__(3);

      Object.defineProperty(exports, 'makeSelectClaimForUri', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectClaimForUri;
        }
      });
      Object.defineProperty(exports, 'makeSelectClaimIsMine', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectClaimIsMine;
        }
      });
      Object.defineProperty(exports, 'makeSelectFetchingChannelClaims', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectFetchingChannelClaims;
        }
      });
      Object.defineProperty(exports, 'makeSelectClaimsInChannelForCurrentPage', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectClaimsInChannelForCurrentPage;
        }
      });
      Object.defineProperty(exports, 'makeSelectMetadataForUri', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectMetadataForUri;
        }
      });
      Object.defineProperty(exports, 'makeSelectTitleForUri', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectTitleForUri;
        }
      });
      Object.defineProperty(exports, 'makeSelectContentTypeForUri', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectContentTypeForUri;
        }
      });
      Object.defineProperty(exports, 'makeSelectIsUriResolving', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectIsUriResolving;
        }
      });
      Object.defineProperty(exports, 'makeSelectTotalItemsForChannel', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectTotalItemsForChannel;
        }
      });
      Object.defineProperty(exports, 'makeSelectTotalPagesForChannel', {
        enumerable: true,
        get: function get() {
          return _claims3.makeSelectTotalPagesForChannel;
        }
      });
      Object.defineProperty(exports, 'selectClaimsById', {
        enumerable: true,
        get: function get() {
          return _claims3.selectClaimsById;
        }
      });
      Object.defineProperty(exports, 'selectClaimsByUri', {
        enumerable: true,
        get: function get() {
          return _claims3.selectClaimsByUri;
        }
      });
      Object.defineProperty(exports, 'selectAllClaimsByChannel', {
        enumerable: true,
        get: function get() {
          return _claims3.selectAllClaimsByChannel;
        }
      });
      Object.defineProperty(exports, 'selectMyClaimsRaw', {
        enumerable: true,
        get: function get() {
          return _claims3.selectMyClaimsRaw;
        }
      });
      Object.defineProperty(exports, 'selectAbandoningIds', {
        enumerable: true,
        get: function get() {
          return _claims3.selectAbandoningIds;
        }
      });
      Object.defineProperty(exports, 'selectMyActiveClaims', {
        enumerable: true,
        get: function get() {
          return _claims3.selectMyActiveClaims;
        }
      });
      Object.defineProperty(exports, 'selectAllFetchingChannelClaims', {
        enumerable: true,
        get: function get() {
          return _claims3.selectAllFetchingChannelClaims;
        }
      });
      Object.defineProperty(exports, 'selectIsFetchingClaimListMine', {
        enumerable: true,
        get: function get() {
          return _claims3.selectIsFetchingClaimListMine;
        }
      });
      Object.defineProperty(exports, 'selectPendingClaims', {
        enumerable: true,
        get: function get() {
          return _claims3.selectPendingClaims;
        }
      });
      Object.defineProperty(exports, 'selectMyClaims', {
        enumerable: true,
        get: function get() {
          return _claims3.selectMyClaims;
        }
      });
      Object.defineProperty(exports, 'selectMyClaimsWithoutChannels', {
        enumerable: true,
        get: function get() {
          return _claims3.selectMyClaimsWithoutChannels;
        }
      });
      Object.defineProperty(exports, 'selectAllMyClaimsByOutpoint', {
        enumerable: true,
        get: function get() {
          return _claims3.selectAllMyClaimsByOutpoint;
        }
      });
      Object.defineProperty(exports, 'selectMyClaimsOutpoints', {
        enumerable: true,
        get: function get() {
          return _claims3.selectMyClaimsOutpoints;
        }
      });
      Object.defineProperty(exports, 'selectFetchingMyChannels', {
        enumerable: true,
        get: function get() {
          return _claims3.selectFetchingMyChannels;
        }
      });
      Object.defineProperty(exports, 'selectMyChannelClaims', {
        enumerable: true,
        get: function get() {
          return _claims3.selectMyChannelClaims;
        }
      });
      Object.defineProperty(exports, 'selectResolvingUris', {
        enumerable: true,
        get: function get() {
          return _claims3.selectResolvingUris;
        }
      });
      Object.defineProperty(exports, 'selectFeaturedUris', {
        enumerable: true,
        get: function get() {
          return _claims3.selectFeaturedUris;
        }
      });
      Object.defineProperty(exports, 'selectFetchingFeaturedUris', {
        enumerable: true,
        get: function get() {
          return _claims3.selectFetchingFeaturedUris;
        }
      });
      Object.defineProperty(exports, 'selectPlayingUri', {
        enumerable: true,
        get: function get() {
          return _claims3.selectPlayingUri;
        }
      });
      Object.defineProperty(exports, 'selectChannelClaimCounts', {
        enumerable: true,
        get: function get() {
          return _claims3.selectChannelClaimCounts;
        }
      });
      Object.defineProperty(exports, 'selectRewardContentClaimIds', {
        enumerable: true,
        get: function get() {
          return _claims3.selectRewardContentClaimIds;
        }
      });

      var _cost_info3 = __webpack_require__(35);

      Object.defineProperty(exports, 'makeSelectFetchingCostInfoForUri', {
        enumerable: true,
        get: function get() {
          return _cost_info3.makeSelectFetchingCostInfoForUri;
        }
      });
      Object.defineProperty(exports, 'makeSelectCostInfoForUri', {
        enumerable: true,
        get: function get() {
          return _cost_info3.makeSelectCostInfoForUri;
        }
      });
      Object.defineProperty(exports, 'selectAllCostInfoByUri', {
        enumerable: true,
        get: function get() {
          return _cost_info3.selectAllCostInfoByUri;
        }
      });
      Object.defineProperty(exports, 'selectCostForCurrentPageUri', {
        enumerable: true,
        get: function get() {
          return _cost_info3.selectCostForCurrentPageUri;
        }
      });
      Object.defineProperty(exports, 'selectFetchingCostInfo', {
        enumerable: true,
        get: function get() {
          return _cost_info3.selectFetchingCostInfo;
        }
      });

      var _file_info3 = __webpack_require__(12);

      Object.defineProperty(exports, 'makeSelectFileInfoForUri', {
        enumerable: true,
        get: function get() {
          return _file_info3.makeSelectFileInfoForUri;
        }
      });
      Object.defineProperty(exports, 'makeSelectDownloadingForUri', {
        enumerable: true,
        get: function get() {
          return _file_info3.makeSelectDownloadingForUri;
        }
      });
      Object.defineProperty(exports, 'makeSelectLoadingForUri', {
        enumerable: true,
        get: function get() {
          return _file_info3.makeSelectLoadingForUri;
        }
      });
      Object.defineProperty(exports, 'selectFileInfosByOutpoint', {
        enumerable: true,
        get: function get() {
          return _file_info3.selectFileInfosByOutpoint;
        }
      });
      Object.defineProperty(exports, 'selectIsFetchingFileList', {
        enumerable: true,
        get: function get() {
          return _file_info3.selectIsFetchingFileList;
        }
      });
      Object.defineProperty(exports, 'selectIsFetchingFileListDownloadedOrPublished', {
        enumerable: true,
        get: function get() {
          return _file_info3.selectIsFetchingFileListDownloadedOrPublished;
        }
      });
      Object.defineProperty(exports, 'selectDownloadingByOutpoint', {
        enumerable: true,
        get: function get() {
          return _file_info3.selectDownloadingByOutpoint;
        }
      });
      Object.defineProperty(exports, 'selectUrisLoading', {
        enumerable: true,
        get: function get() {
          return _file_info3.selectUrisLoading;
        }
      });
      Object.defineProperty(exports, 'selectFileInfosDownloaded', {
        enumerable: true,
        get: function get() {
          return _file_info3.selectFileInfosDownloaded;
        }
      });
      Object.defineProperty(exports, 'selectDownloadingFileInfos', {
        enumerable: true,
        get: function get() {
          return _file_info3.selectDownloadingFileInfos;
        }
      });
      Object.defineProperty(exports, 'selectTotalDownloadProgress', {
        enumerable: true,
        get: function get() {
          return _file_info3.selectTotalDownloadProgress;
        }
      });

      var _navigation = __webpack_require__(4);

      Object.defineProperty(exports, 'computePageFromPath', {
        enumerable: true,
        get: function get() {
          return _navigation.computePageFromPath;
        }
      });
      Object.defineProperty(exports, 'makeSelectCurrentParam', {
        enumerable: true,
        get: function get() {
          return _navigation.makeSelectCurrentParam;
        }
      });
      Object.defineProperty(exports, 'selectCurrentPath', {
        enumerable: true,
        get: function get() {
          return _navigation.selectCurrentPath;
        }
      });
      Object.defineProperty(exports, 'selectCurrentPage', {
        enumerable: true,
        get: function get() {
          return _navigation.selectCurrentPage;
        }
      });
      Object.defineProperty(exports, 'selectCurrentParams', {
        enumerable: true,
        get: function get() {
          return _navigation.selectCurrentParams;
        }
      });
      Object.defineProperty(exports, 'selectHeaderLinks', {
        enumerable: true,
        get: function get() {
          return _navigation.selectHeaderLinks;
        }
      });
      Object.defineProperty(exports, 'selectPageTitle', {
        enumerable: true,
        get: function get() {
          return _navigation.selectPageTitle;
        }
      });
      Object.defineProperty(exports, 'selectPathAfterAuth', {
        enumerable: true,
        get: function get() {
          return _navigation.selectPathAfterAuth;
        }
      });
      Object.defineProperty(exports, 'selectIsBackDisabled', {
        enumerable: true,
        get: function get() {
          return _navigation.selectIsBackDisabled;
        }
      });
      Object.defineProperty(exports, 'selectIsForwardDisabled', {
        enumerable: true,
        get: function get() {
          return _navigation.selectIsForwardDisabled;
        }
      });
      Object.defineProperty(exports, 'selectHistoryIndex', {
        enumerable: true,
        get: function get() {
          return _navigation.selectHistoryIndex;
        }
      });
      Object.defineProperty(exports, 'selectHistoryStack', {
        enumerable: true,
        get: function get() {
          return _navigation.selectHistoryStack;
        }
      });
      Object.defineProperty(exports, 'selectActiveHistoryEntry', {
        enumerable: true,
        get: function get() {
          return _navigation.selectActiveHistoryEntry;
        }
      });

      var _search3 = __webpack_require__(36);

      Object.defineProperty(exports, 'makeSelectSearchUris', {
        enumerable: true,
        get: function get() {
          return _search3.makeSelectSearchUris;
        }
      });
      Object.defineProperty(exports, 'selectSearchQuery', {
        enumerable: true,
        get: function get() {
          return _search3.selectSearchQuery;
        }
      });
      Object.defineProperty(exports, 'selectIsSearching', {
        enumerable: true,
        get: function get() {
          return _search3.selectIsSearching;
        }
      });
      Object.defineProperty(exports, 'selectSearchUrisByQuery', {
        enumerable: true,
        get: function get() {
          return _search3.selectSearchUrisByQuery;
        }
      });
      Object.defineProperty(exports, 'selectWunderBarAddress', {
        enumerable: true,
        get: function get() {
          return _search3.selectWunderBarAddress;
        }
      });
      Object.defineProperty(exports, 'selectWunderBarIcon', {
        enumerable: true,
        get: function get() {
          return _search3.selectWunderBarIcon;
        }
      });

      var _wallet3 = __webpack_require__(13);

      Object.defineProperty(exports, 'makeSelectBlockDate', {
        enumerable: true,
        get: function get() {
          return _wallet3.makeSelectBlockDate;
        }
      });
      Object.defineProperty(exports, 'selectBalance', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectBalance;
        }
      });
      Object.defineProperty(exports, 'selectTransactionsById', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectTransactionsById;
        }
      });
      Object.defineProperty(exports, 'selectTransactionItems', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectTransactionItems;
        }
      });
      Object.defineProperty(exports, 'selectRecentTransactions', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectRecentTransactions;
        }
      });
      Object.defineProperty(exports, 'selectHasTransactions', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectHasTransactions;
        }
      });
      Object.defineProperty(exports, 'selectIsFetchingTransactions', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectIsFetchingTransactions;
        }
      });
      Object.defineProperty(exports, 'selectIsSendingSupport', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectIsSendingSupport;
        }
      });
      Object.defineProperty(exports, 'selectReceiveAddress', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectReceiveAddress;
        }
      });
      Object.defineProperty(exports, 'selectGettingNewAddress', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectGettingNewAddress;
        }
      });
      Object.defineProperty(exports, 'selectDraftTransaction', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectDraftTransaction;
        }
      });
      Object.defineProperty(exports, 'selectDraftTransactionAmount', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectDraftTransactionAmount;
        }
      });
      Object.defineProperty(exports, 'selectDraftTransactionAddress', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectDraftTransactionAddress;
        }
      });
      Object.defineProperty(exports, 'selectDraftTransactionError', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectDraftTransactionError;
        }
      });
      Object.defineProperty(exports, 'selectBlocks', {
        enumerable: true,
        get: function get() {
          return _wallet3.selectBlocks;
        }
      });

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      var _lbry = __webpack_require__(5);

      var _lbry2 = _interopRequireDefault(_lbry);

      var _lbryapi = __webpack_require__(7);

      var _lbryapi2 = _interopRequireDefault(_lbryapi);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      exports.ACTIONS = ACTIONS;
      exports.Lbry = _lbry2.default;
      exports.Lbryapi = _lbryapi2.default;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doNotify = doNotify;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      var _Notification = __webpack_require__(9);

      var _Notification2 = _interopRequireDefault(_Notification);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      function doNotify(data) {
        return {
          type: ACTIONS.CREATE_NOTIFICATION,
          data: data
        };
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      (function (global) {
        (function (scope) {
          if (scope['Proxy']) {
            return;
          }

          var lastRevokeFn = null;

          function isObject(o) {
            return o ? typeof o == 'object' || typeof o == 'function' : false;
          }

          scope.Proxy = function (target, handler) {
            if (!isObject(target) || !isObject(handler)) {
              throw new TypeError('Cannot create proxy with a non-object as target or handler');
            }

            var throwRevoked = function throwRevoked() {};

            lastRevokeFn = function lastRevokeFn() {
              throwRevoked = function throwRevoked(trap) {
                throw new TypeError("Cannot perform '" + trap + "' on a proxy that has been revoked");
              };
            };

            var unsafeHandler = handler;
            handler = {
              'get': null,
              'set': null,
              'apply': null,
              'construct': null
            };

            for (var k in unsafeHandler) {
              if (!(k in handler)) {
                throw new TypeError("Proxy polyfill does not support trap '" + k + "'");
              }

              handler[k] = unsafeHandler[k];
            }

            if (typeof unsafeHandler == 'function') {
              handler.apply = unsafeHandler.apply.bind(unsafeHandler);
            }

            var proxy = this;
            var isMethod = false;
            var targetIsFunction = typeof target == 'function';

            if (handler.apply || handler['construct'] || targetIsFunction) {
              proxy = function Proxy() {
                var usingNew = this && this.constructor === proxy;
                throwRevoked(usingNew ? 'construct' : 'apply');

                if (usingNew && handler['construct']) {
                  return handler['construct'].call(this, target, arguments);
                } else if (!usingNew && handler.apply) {
                  return handler.apply(target, this, arguments);
                } else if (targetIsFunction) {
                  if (usingNew) {
                    var all = Array.prototype.slice.call(arguments);
                    all.unshift(target);
                    var f = target.bind.apply(target, all);
                    return new f();
                  }

                  return target.apply(this, arguments);
                }

                throw new TypeError(usingNew ? 'not a constructor' : 'not a function');
              };

              isMethod = true;
            }

            var getter = handler.get ? function (prop) {
              throwRevoked('get');
              return handler.get(this, prop, proxy);
            } : function (prop) {
              throwRevoked('get');
              return this[prop];
            };
            var setter = handler.set ? function (prop, value) {
              throwRevoked('set');
              var status = handler.set(this, prop, value, proxy);

              if (!status) {}
            } : function (prop, value) {
              throwRevoked('set');
              this[prop] = value;
            };
            var propertyNames = Object.getOwnPropertyNames(target);
            var propertyMap = {};
            propertyNames.forEach(function (prop) {
              if (isMethod && prop in proxy) {
                return;
              }

              var real = Object.getOwnPropertyDescriptor(target, prop);
              var desc = {
                enumerable: !!real.enumerable,
                get: getter.bind(target, prop),
                set: setter.bind(target, prop)
              };
              Object.defineProperty(proxy, prop, desc);
              propertyMap[prop] = true;
            });
            var prototypeOk = true;

            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(proxy, Object.getPrototypeOf(target));
            } else if (proxy.__proto__) {
              proxy.__proto__ = target.__proto__;
            } else {
              prototypeOk = false;
            }

            if (handler.get || !prototypeOk) {
              for (var _k in target) {
                if (propertyMap[_k]) {
                  continue;
                }

                Object.defineProperty(proxy, _k, {
                  get: getter.bind(target, _k)
                });
              }
            }

            Object.seal(target);
            Object.seal(proxy);
            return proxy;
          };

          scope.Proxy.revocable = function (target, handler) {
            var p = new scope.Proxy(target, handler);
            return {
              'proxy': p,
              'revoke': lastRevokeFn
            };
          };

          scope.Proxy['revocable'] = scope.Proxy.revocable;
          scope['Proxy'] = scope.Proxy;
        })(typeof module !== 'undefined' && module['exports'] ? global : window);
      }).call(exports, __webpack_require__(17));
    }, function (module, exports) {
      var g;

      g = function () {
        return this;
      }();

      try {
        g = g || Function("return this")() || (1, eval)("this");
      } catch (e) {
        if (typeof window === "object") g = window;
      }

      module.exports = g;
    }, function (module, exports) {
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }

      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }

      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }

        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();

      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }

        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }

        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }

      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }

        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }

        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }

      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }

        draining = false;

        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }

        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }

        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;

        while (len) {
          currentQueue = queue;
          queue = [];

          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }

          queueIndex = -1;
          len = queue.length;
        }

        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);

        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }

        queue.push(new Item(fun, args));

        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }

      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };

      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = '';
      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {
        return [];
      };

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {
        return '/';
      };

      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };

      process.umask = function () {
        return 0;
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      exports.decode = exports.parse = __webpack_require__(20);
      exports.encode = exports.stringify = __webpack_require__(21);
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }

      module.exports = function (qs, sep, eq, options) {
        sep = sep || '&';
        eq = eq || '=';
        var obj = {};

        if (typeof qs !== 'string' || qs.length === 0) {
          return obj;
        }

        var regexp = /\+/g;
        qs = qs.split(sep);
        var maxKeys = 1000;

        if (options && typeof options.maxKeys === 'number') {
          maxKeys = options.maxKeys;
        }

        var len = qs.length;

        if (maxKeys > 0 && len > maxKeys) {
          len = maxKeys;
        }

        for (var i = 0; i < len; ++i) {
          var x = qs[i].replace(regexp, '%20'),
              idx = x.indexOf(eq),
              kstr,
              vstr,
              k,
              v;

          if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
          } else {
            kstr = x;
            vstr = '';
          }

          k = decodeURIComponent(kstr);
          v = decodeURIComponent(vstr);

          if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
          } else if (isArray(obj[k])) {
            obj[k].push(v);
          } else {
            obj[k] = [obj[k], v];
          }
        }

        return obj;
      };

      var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var stringifyPrimitive = function stringifyPrimitive(v) {
        switch (typeof v) {
          case 'string':
            return v;

          case 'boolean':
            return v ? 'true' : 'false';

          case 'number':
            return isFinite(v) ? v : '';

          default:
            return '';
        }
      };

      module.exports = function (obj, sep, eq, name) {
        sep = sep || '&';
        eq = eq || '=';

        if (obj === null) {
          obj = undefined;
        }

        if (typeof obj === 'object') {
          return map(objectKeys(obj), function (k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

            if (isArray(obj[k])) {
              return map(obj[k], function (v) {
                return ks + encodeURIComponent(stringifyPrimitive(v));
              }).join(sep);
            } else {
              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
          }).join(sep);
        }

        if (!name) return '';
        return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
      };

      var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };

      function map(xs, f) {
        if (xs.map) return xs.map(f);
        var res = [];

        for (var i = 0; i < xs.length; i++) {
          res.push(f(xs[i], i));
        }

        return res;
      }

      var objectKeys = Object.keys || function (obj) {
        var res = [];

        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
        }

        return res;
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doFetchCostInfoForUri = doFetchCostInfoForUri;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      var _lbryapi = __webpack_require__(7);

      var _lbryapi2 = _interopRequireDefault(_lbryapi);

      var _claims = __webpack_require__(3);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      function doFetchCostInfoForUri(uri) {
        return function (dispatch, getState) {
          var state = getState();
          var claim = (0, _claims.selectClaimsByUri)(state)[uri];
          if (!claim) return;

          function resolve(costInfo) {
            dispatch({
              type: ACTIONS.FETCH_COST_INFO_COMPLETED,
              data: {
                uri: uri,
                costInfo: costInfo
              }
            });
          }

          var fee = claim.value && claim.value.stream && claim.value.stream.metadata ? claim.value.stream.metadata.fee : undefined;

          if (fee === undefined) {
            resolve({
              cost: 0,
              includesData: true
            });
          } else if (fee.currency === 'LBC') {
            resolve({
              cost: fee.amount,
              includesData: true
            });
          } else {
            _lbryapi2.default.getExchangeRates().then(function (_ref) {
              var LBC_USD = _ref.LBC_USD;
              resolve({
                cost: fee.amount / LBC_USD,
                includesData: true
              });
            });
          }
        };
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doFetchFileInfo = doFetchFileInfo;
      exports.doFileList = doFileList;
      exports.doFetchFileInfosAndPublishedClaims = doFetchFileInfosAndPublishedClaims;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      var _lbry = __webpack_require__(5);

      var _lbry2 = _interopRequireDefault(_lbry);

      var _claims = __webpack_require__(6);

      var _claims2 = __webpack_require__(3);

      var _file_info = __webpack_require__(12);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      function doFetchFileInfo(uri) {
        return function (dispatch, getState) {
          var state = getState();
          var claim = (0, _claims2.selectClaimsByUri)(state)[uri];
          var outpoint = claim ? claim.txid + ':' + claim.nout : null;
          var alreadyFetching = !!(0, _file_info.selectUrisLoading)(state)[uri];

          if (!alreadyFetching) {
            dispatch({
              type: ACTIONS.FETCH_FILE_INFO_STARTED,
              data: {
                outpoint: outpoint
              }
            });

            _lbry2.default.file_list({
              outpoint: outpoint,
              full_status: true
            }).then(function (fileInfos) {
              dispatch({
                type: ACTIONS.FETCH_FILE_INFO_COMPLETED,
                data: {
                  outpoint: outpoint,
                  fileInfo: fileInfos && fileInfos.length ? fileInfos[0] : null
                }
              });
            });
          }
        };
      }

      function doFileList() {
        return function (dispatch, getState) {
          var state = getState();
          var isFetching = (0, _file_info.selectIsFetchingFileList)(state);

          if (!isFetching) {
            dispatch({
              type: ACTIONS.FILE_LIST_STARTED
            });

            _lbry2.default.file_list().then(function (fileInfos) {
              dispatch({
                type: ACTIONS.FILE_LIST_SUCCEEDED,
                data: {
                  fileInfos: fileInfos
                }
              });
            });
          }
        };
      }

      function doFetchFileInfosAndPublishedClaims() {
        return function (dispatch, getState) {
          var state = getState();
          var isFetchingClaimListMine = (0, _claims2.selectIsFetchingClaimListMine)(state);
          var isFetchingFileInfo = (0, _file_info.selectIsFetchingFileList)(state);
          if (!isFetchingClaimListMine) dispatch((0, _claims.doFetchClaimListMine)());
          if (!isFetchingFileInfo) dispatch(doFileList());
        };
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doSearch = doSearch;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      var _lbryURI = __webpack_require__(2);

      var _claims = __webpack_require__(6);

      var _navigation = __webpack_require__(4);

      var _batchActions = __webpack_require__(8);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      function doSearch(rawQuery, currentPageNotSearchHandler) {
        return function (dispatch, getState) {
          var state = getState();
          var page = (0, _navigation.selectCurrentPage)(state);
          var query = rawQuery.replace(/^lbry:\/\//i, '');

          if (!query) {
            dispatch({
              type: ACTIONS.SEARCH_CANCELLED
            });
            return;
          }

          dispatch({
            type: ACTIONS.SEARCH_STARTED,
            data: {
              query: query
            }
          });

          if (page !== 'search') {
            if (currentPageNotSearchHandler) {
              currentPageNotSearchHandler();
            }
          } else {
            fetch('https://lighthouse.lbry.io/search?s=' + query).then(function (response) {
              return response.status === 200 ? Promise.resolve(response.json()) : Promise.reject(new Error(response.statusText));
            }).then(function (data) {
              var uris = [];
              var actions = [];
              data.forEach(function (result) {
                var uri = (0, _lbryURI.buildURI)({
                  name: result.name,
                  claimId: result.claimId
                });
                actions.push((0, _claims.doResolveUri)(uri));
                uris.push(uri);
              });
              actions.push({
                type: ACTIONS.SEARCH_COMPLETED,
                data: {
                  query: query,
                  uris: uris
                }
              });
              dispatch(_batchActions.batchActions.apply(undefined, actions));
            }).catch(function () {
              dispatch({
                type: ACTIONS.SEARCH_CANCELLED
              });
            });
          }
        };
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doUpdateBalance = doUpdateBalance;
      exports.doBalanceSubscribe = doBalanceSubscribe;
      exports.doFetchTransactions = doFetchTransactions;
      exports.doFetchBlock = doFetchBlock;
      exports.doGetNewAddress = doGetNewAddress;
      exports.doCheckAddressIsMine = doCheckAddressIsMine;
      exports.doSendDraftTransaction = doSendDraftTransaction;
      exports.doSetDraftTransactionAmount = doSetDraftTransactionAmount;
      exports.doSetDraftTransactionAddress = doSetDraftTransactionAddress;
      exports.doSendSupport = doSendSupport;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      var _modal_types = __webpack_require__(26);

      var MODALS = _interopRequireWildcard(_modal_types);

      var _lbry = __webpack_require__(5);

      var _lbry2 = _interopRequireDefault(_lbry);

      var _app = __webpack_require__(10);

      var _wallet = __webpack_require__(13);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      function doUpdateBalance() {
        return function (dispatch) {
          _lbry2.default.wallet_balance().then(function (balance) {
            return dispatch({
              type: ACTIONS.UPDATE_BALANCE,
              data: {
                balance: balance
              }
            });
          });
        };
      }

      function doBalanceSubscribe() {
        return function (dispatch) {
          dispatch(doUpdateBalance());
          setInterval(function () {
            return dispatch(doUpdateBalance());
          }, 5000);
        };
      }

      function doFetchTransactions() {
        return function (dispatch) {
          dispatch({
            type: ACTIONS.FETCH_TRANSACTIONS_STARTED
          });

          _lbry2.default.transaction_list({
            include_tip_info: true
          }).then(function (results) {
            dispatch({
              type: ACTIONS.FETCH_TRANSACTIONS_COMPLETED,
              data: {
                transactions: results
              }
            });
          });
        };
      }

      function doFetchBlock(height) {
        return function (dispatch) {
          _lbry2.default.block_show({
            height: height
          }).then(function (block) {
            dispatch({
              type: ACTIONS.FETCH_BLOCK_SUCCESS,
              data: {
                block: block
              }
            });
          });
        };
      }

      function doGetNewAddress() {
        return function (dispatch) {
          dispatch({
            type: ACTIONS.GET_NEW_ADDRESS_STARTED
          });

          _lbry2.default.wallet_new_address().then(function (address) {
            dispatch({
              type: ACTIONS.GET_NEW_ADDRESS_COMPLETED,
              data: {
                address: address
              }
            });
          });
        };
      }

      function doCheckAddressIsMine(address) {
        return function (dispatch) {
          dispatch({
            type: ACTIONS.CHECK_ADDRESS_IS_MINE_STARTED
          });

          _lbry2.default.wallet_is_address_mine({
            address: address
          }).then(function (isMine) {
            if (!isMine) dispatch(doGetNewAddress());
            dispatch({
              type: ACTIONS.CHECK_ADDRESS_IS_MINE_COMPLETED
            });
          });
        };
      }

      function doSendDraftTransaction() {
        return function (dispatch, getState) {
          var state = getState();
          var draftTx = (0, _wallet.selectDraftTransaction)(state);
          var balance = (0, _wallet.selectBalance)(state);
          var amount = (0, _wallet.selectDraftTransactionAmount)(state);

          if (balance - amount <= 0) {
            dispatch((0, _app.doOpenModal)(MODALS.INSUFFICIENT_CREDITS));
            return;
          }

          dispatch({
            type: ACTIONS.SEND_TRANSACTION_STARTED
          });

          var successCallback = function successCallback(results) {
            if (results === true) {
              dispatch({
                type: ACTIONS.SEND_TRANSACTION_COMPLETED
              });
              dispatch((0, _app.doShowSnackBar)({
                message: __('You sent ' + amount + ' LBC'),
                linkText: __('History'),
                linkTarget: __('/wallet')
              }));
            } else {
              dispatch({
                type: ACTIONS.SEND_TRANSACTION_FAILED,
                data: {
                  error: results
                }
              });
              dispatch((0, _app.doOpenModal)(MODALS.TRANSACTION_FAILED));
            }
          };

          var errorCallback = function errorCallback(error) {
            dispatch({
              type: ACTIONS.SEND_TRANSACTION_FAILED,
              data: {
                error: error.message
              }
            });
            dispatch((0, _app.doOpenModal)(MODALS.TRANSACTION_FAILED));
          };

          _lbry2.default.wallet_send({
            amount: draftTx.amount,
            address: draftTx.address
          }).then(successCallback, errorCallback);
        };
      }

      function doSetDraftTransactionAmount(amount) {
        return {
          type: ACTIONS.SET_DRAFT_TRANSACTION_AMOUNT,
          data: {
            amount: amount
          }
        };
      }

      function doSetDraftTransactionAddress(address) {
        return {
          type: ACTIONS.SET_DRAFT_TRANSACTION_ADDRESS,
          data: {
            address: address
          }
        };
      }

      function doSendSupport(amount, claimId, uri, successCallback, errorCallback) {
        return function (dispatch, getState) {
          var state = getState();
          var balance = (0, _wallet.selectBalance)(state);

          if (balance - amount <= 0) {
            dispatch((0, _app.doOpenModal)(MODALS.INSUFFICIENT_CREDITS));
            return;
          }

          dispatch({
            type: ACTIONS.SUPPORT_TRANSACTION_STARTED
          });

          _lbry2.default.wallet_send({
            claim_id: claimId,
            amount: amount
          }).then(successCallback, errorCallback);
        };
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var CONFIRM_FILE_REMOVE = exports.CONFIRM_FILE_REMOVE = 'confirmFileRemove';
      var INCOMPATIBLE_DAEMON = exports.INCOMPATIBLE_DAEMON = 'incompatibleDaemon';
      var FILE_TIMEOUT = exports.FILE_TIMEOUT = 'file_timeout';
      var DOWNLOADING = exports.DOWNLOADING = 'downloading';
      var ERROR = exports.ERROR = 'error';
      var INSUFFICIENT_CREDITS = exports.INSUFFICIENT_CREDITS = 'insufficient_credits';
      var UPGRADE = exports.UPGRADE = 'upgrade';
      var WELCOME = exports.WELCOME = 'welcome';
      var EMAIL_COLLECTION = exports.EMAIL_COLLECTION = 'email_collection';
      var FIRST_REWARD = exports.FIRST_REWARD = 'first_reward';
      var AUTHENTICATION_FAILURE = exports.AUTHENTICATION_FAILURE = 'auth_failure';
      var TRANSACTION_FAILED = exports.TRANSACTION_FAILED = 'transaction_failed';
      var REWARD_APPROVAL_REQUIRED = exports.REWARD_APPROVAL_REQUIRED = 'reward_approval_required';
      var AFFIRM_PURCHASE = exports.AFFIRM_PURCHASE = 'affirm_purchase';
      var CONFIRM_CLAIM_REVOKE = exports.CONFIRM_CLAIM_REVOKE = 'confirmClaimRevoke';
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.formatCredits = formatCredits;
      exports.formatFullPrice = formatFullPrice;

      function formatCredits(amount, precision) {
        return amount.toFixed(precision || 1).replace(/\.?0+$/, '');
      }

      function formatFullPrice(amount) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var formated = '';
        var quantity = amount.toString().split('.');
        var fraction = quantity[1];

        if (fraction) {
          var decimals = fraction.split('');
          var first = decimals.filter(function (number) {
            return number !== '0';
          })[0];
          var index = decimals.indexOf(first);
          formated = '.' + fraction.substring(0, index + precision);
        }

        return parseFloat(quantity[0] + formated);
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if ((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      exports.claimsReducer = claimsReducer;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      var reducers = {};
      var defaultState = {
        rewardedContentClaimIds: [],
        channelClaimCounts: {}
      };

      reducers[ACTIONS.RESOLVE_URIS_COMPLETED] = function (state, action) {
        var resolveInfo = action.data.resolveInfo;
        var byUri = babelHelpers.extends({}, state.claimsByUri);
        var byId = babelHelpers.extends({}, state.byId);
        var channelClaimCounts = babelHelpers.extends({}, state.channelClaimCounts);
        Object.entries(resolveInfo).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              uri = _ref2[0],
              _ref2$ = _ref2[1],
              certificate = _ref2$.certificate,
              claimsInChannel = _ref2$.claimsInChannel;

          if (certificate && !Number.isNaN(claimsInChannel)) {
            channelClaimCounts[uri] = claimsInChannel;
          }
        });
        Object.entries(resolveInfo).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              uri = _ref4[0],
              _ref4$ = _ref4[1],
              certificate = _ref4$.certificate,
              claim = _ref4$.claim;

          if (claim) {
            byId[claim.claim_id] = claim;
            byUri[uri] = claim.claim_id;
          } else if (claim === undefined && certificate !== undefined) {
            byId[certificate.claim_id] = certificate;

            if (!uri.split(certificate.name)[1].match(/\//)) {
              byUri[uri] = certificate.claim_id;
            } else {
              byUri[uri] = null;
            }
          } else {
            byUri[uri] = null;
          }
        });
        return babelHelpers.extends({}, state, {
          byId: byId,
          claimsByUri: byUri,
          channelClaimCounts: channelClaimCounts,
          resolvingUris: (state.resolvingUris || []).filter(function (uri) {
            return !resolveInfo[uri];
          })
        });
      };

      reducers[ACTIONS.FETCH_CLAIM_LIST_MINE_STARTED] = function (state) {
        return babelHelpers.extends({}, state, {
          isFetchingClaimListMine: true
        });
      };

      reducers[ACTIONS.FETCH_CLAIM_LIST_MINE_COMPLETED] = function (state, action) {
        var claims = action.data.claims;
        var byId = babelHelpers.extends({}, state.byId);
        var pendingById = babelHelpers.extends({}, state.pendingById);
        claims.filter(function (claim) {
          return claim.category && claim.category.match(/claim/);
        }).forEach(function (claim) {
          byId[claim.claim_id] = claim;
          var pending = Object.values(pendingById).find(function (pendingClaim) {
            return pendingClaim.name === claim.name && pendingClaim.channel_name === claim.channel_name;
          });

          if (pending) {
            delete pendingById[pending.claim_id];
          }
        });
        Object.values(pendingById).filter(function (pendingClaim) {
          return Date.now() - pendingClaim.time >= 20 * 60 * 1000;
        }).forEach(function (pendingClaim) {
          delete pendingById[pendingClaim.claim_id];
        });
        return babelHelpers.extends({}, state, {
          isFetchingClaimListMine: false,
          myClaims: claims,
          byId: byId,
          pendingById: pendingById
        });
      };

      reducers[ACTIONS.FETCH_CHANNEL_LIST_MINE_STARTED] = function (state) {
        return babelHelpers.extends({}, state, {
          fetchingMyChannels: true
        });
      };

      reducers[ACTIONS.FETCH_CHANNEL_LIST_MINE_COMPLETED] = function (state, action) {
        var claims = action.data.claims;
        var myChannelClaims = new Set(state.myChannelClaims);
        var byId = babelHelpers.extends({}, state.byId);
        claims.forEach(function (claim) {
          myChannelClaims.add(claim.claim_id);
          byId[claims.claim_id] = claim;
        });
        return babelHelpers.extends({}, state, {
          byId: byId,
          fetchingMyChannels: false,
          myChannelClaims: myChannelClaims
        });
      };

      reducers[ACTIONS.FETCH_CHANNEL_CLAIMS_STARTED] = function (state, action) {
        var _action$data = action.data,
            uri = _action$data.uri,
            page = _action$data.page;
        var fetchingChannelClaims = babelHelpers.extends({}, state.fetchingChannelClaims);
        fetchingChannelClaims[uri] = page;
        return babelHelpers.extends({}, state, {
          fetchingChannelClaims: fetchingChannelClaims
        });
      };

      reducers[ACTIONS.FETCH_CHANNEL_CLAIMS_COMPLETED] = function (state, action) {
        var _action$data2 = action.data,
            uri = _action$data2.uri,
            claims = _action$data2.claims,
            page = _action$data2.page;
        var claimsByChannel = babelHelpers.extends({}, state.claimsByChannel);
        var byChannel = babelHelpers.extends({}, claimsByChannel[uri]);
        var allClaimIds = new Set(byChannel.all);
        var currentPageClaimIds = [];
        var byId = babelHelpers.extends({}, state.byId);
        var fetchingChannelClaims = babelHelpers.extends({}, state.fetchingChannelClaims);

        if (claims !== undefined) {
          claims.forEach(function (claim) {
            allClaimIds.add(claim.claim_id);
            currentPageClaimIds.push(claim.claim_id);
            byId[claim.claim_id] = claim;
          });
        }

        byChannel.all = allClaimIds;
        byChannel[page] = currentPageClaimIds;
        claimsByChannel[uri] = byChannel;
        delete fetchingChannelClaims[uri];
        return babelHelpers.extends({}, state, {
          claimsByChannel: claimsByChannel,
          byId: byId,
          fetchingChannelClaims: fetchingChannelClaims
        });
      };

      reducers[ACTIONS.ABANDON_CLAIM_STARTED] = function (state, action) {
        var claimId = action.data.claimId;
        var abandoningById = babelHelpers.extends({}, state.abandoningById);
        abandoningById[claimId] = true;
        return babelHelpers.extends({}, state, {
          abandoningById: abandoningById
        });
      };

      reducers[ACTIONS.ABANDON_CLAIM_SUCCEEDED] = function (state, action) {
        var claimId = action.data.claimId;
        var byId = babelHelpers.extends({}, state.byId);
        var claimsByUri = babelHelpers.extends({}, state.claimsByUri);
        Object.keys(claimsByUri).forEach(function (uri) {
          if (claimsByUri[uri] === claimId) {
            delete claimsByUri[uri];
          }
        });
        delete byId[claimId];
        return babelHelpers.extends({}, state, {
          byId: byId,
          claimsByUri: claimsByUri
        });
      };

      reducers[ACTIONS.CREATE_CHANNEL_COMPLETED] = function (state, action) {
        var channelClaim = action.data.channelClaim;
        var byId = babelHelpers.extends({}, state.byId);
        var myChannelClaims = new Set(state.myChannelClaims);
        byId[channelClaim.claim_id] = channelClaim;
        myChannelClaims.add(channelClaim.claim_id);
        return babelHelpers.extends({}, state, {
          byId: byId,
          myChannelClaims: myChannelClaims
        });
      };

      reducers[ACTIONS.FETCH_FEATURED_CONTENT_STARTED] = function (state) {
        return babelHelpers.extends({}, state, {
          fetchingFeaturedContent: true
        });
      };

      reducers[ACTIONS.FETCH_FEATURED_CONTENT_COMPLETED] = function (state, action) {
        var _action$data3 = action.data,
            uris = _action$data3.uris,
            success = _action$data3.success;
        return babelHelpers.extends({}, state, {
          fetchingFeaturedContent: false,
          fetchingFeaturedContentFailed: !success,
          featuredUris: uris
        });
      };

      reducers[ACTIONS.FETCH_REWARD_CONTENT_COMPLETED] = function (state, action) {
        var claimIds = action.data.claimIds;
        return babelHelpers.extends({}, state, {
          rewardedContentClaimIds: claimIds
        });
      };

      reducers[ACTIONS.RESOLVE_URIS_STARTED] = function (state, action) {
        var uris = action.data.uris;
        var oldResolving = state.resolvingUris || [];
        var newResolving = babelHelpers.extends([], oldResolving);
        uris.forEach(function (uri) {
          if (!newResolving.includes(uri)) {
            newResolving.push(uri);
          }
        });
        return babelHelpers.extends({}, state, {
          resolvingUris: newResolving
        });
      };

      reducers[ACTIONS.FETCH_CHANNEL_CLAIM_COUNT_COMPLETED] = function (state, action) {
        var channelClaimCounts = babelHelpers.extends({}, state.channelClaimCounts);
        var _action$data4 = action.data,
            uri = _action$data4.uri,
            totalClaims = _action$data4.totalClaims;
        channelClaimCounts[uri] = totalClaims;
        return babelHelpers.extends({}, state, {
          channelClaimCounts: channelClaimCounts
        });
      };

      function claimsReducer() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;
        var action = arguments[1];
        var handler = reducers[action.type];
        if (handler) return handler(state, action);
        return state;
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.costInfoReducer = costInfoReducer;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      var reducers = {};
      var defaultState = {};

      reducers[ACTIONS.FETCH_COST_INFO_STARTED] = function (state, action) {
        var uri = action.data.uri;
        var newFetching = babelHelpers.extends({}, state.fetching);
        newFetching[uri] = true;
        return babelHelpers.extends({}, state, {
          fetching: newFetching
        });
      };

      reducers[ACTIONS.FETCH_COST_INFO_COMPLETED] = function (state, action) {
        var _action$data = action.data,
            uri = _action$data.uri,
            costInfo = _action$data.costInfo;
        var newByUri = babelHelpers.extends({}, state.byUri);
        var newFetching = babelHelpers.extends({}, state.fetching);
        newByUri[uri] = costInfo;
        delete newFetching[uri];
        return babelHelpers.extends({}, state, {
          byUri: newByUri,
          fetching: newFetching
        });
      };

      function costInfoReducer() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;
        var action = arguments[1];
        var handler = reducers[action.type];
        if (handler) return handler(state, action);
        return state;
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fileInfoReducer = fileInfoReducer;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      var reducers = {};
      var defaultState = {};

      reducers[ACTIONS.FILE_LIST_STARTED] = function (state) {
        return babelHelpers.extends({}, state, {
          isFetchingFileList: true
        });
      };

      reducers[ACTIONS.FILE_LIST_SUCCEEDED] = function (state, action) {
        var fileInfos = action.data.fileInfos;
        var newByOutpoint = babelHelpers.extends({}, state.byOutpoint);
        var pendingByOutpoint = babelHelpers.extends({}, state.pendingByOutpoint);
        fileInfos.forEach(function (fileInfo) {
          var outpoint = fileInfo.outpoint;
          if (outpoint) newByOutpoint[fileInfo.outpoint] = fileInfo;
        });
        return babelHelpers.extends({}, state, {
          isFetchingFileList: false,
          byOutpoint: newByOutpoint,
          pendingByOutpoint: pendingByOutpoint
        });
      };

      reducers[ACTIONS.FETCH_FILE_INFO_STARTED] = function (state, action) {
        var outpoint = action.data.outpoint;
        var newFetching = babelHelpers.extends({}, state.fetching);
        newFetching[outpoint] = true;
        return babelHelpers.extends({}, state, {
          fetching: newFetching
        });
      };

      reducers[ACTIONS.FETCH_FILE_INFO_COMPLETED] = function (state, action) {
        var _action$data = action.data,
            fileInfo = _action$data.fileInfo,
            outpoint = _action$data.outpoint;
        var newByOutpoint = babelHelpers.extends({}, state.byOutpoint);
        var newFetching = babelHelpers.extends({}, state.fetching);
        newByOutpoint[outpoint] = fileInfo;
        delete newFetching[outpoint];
        return babelHelpers.extends({}, state, {
          byOutpoint: newByOutpoint,
          fetching: newFetching
        });
      };

      reducers[ACTIONS.DOWNLOADING_STARTED] = function (state, action) {
        var _action$data2 = action.data,
            uri = _action$data2.uri,
            outpoint = _action$data2.outpoint,
            fileInfo = _action$data2.fileInfo;
        var newByOutpoint = babelHelpers.extends({}, state.byOutpoint);
        var newDownloading = babelHelpers.extends({}, state.downloadingByOutpoint);
        var newLoading = babelHelpers.extends({}, state.urisLoading);
        newDownloading[outpoint] = true;
        newByOutpoint[outpoint] = fileInfo;
        delete newLoading[uri];
        return babelHelpers.extends({}, state, {
          downloadingByOutpoint: newDownloading,
          urisLoading: newLoading,
          byOutpoint: newByOutpoint
        });
      };

      reducers[ACTIONS.DOWNLOADING_PROGRESSED] = function (state, action) {
        var _action$data3 = action.data,
            outpoint = _action$data3.outpoint,
            fileInfo = _action$data3.fileInfo;
        var newByOutpoint = babelHelpers.extends({}, state.byOutpoint);
        var newDownloading = babelHelpers.extends({}, state.downloadingByOutpoint);
        newByOutpoint[outpoint] = fileInfo;
        newDownloading[outpoint] = true;
        return babelHelpers.extends({}, state, {
          byOutpoint: newByOutpoint,
          downloadingByOutpoint: newDownloading
        });
      };

      reducers[ACTIONS.DOWNLOADING_COMPLETED] = function (state, action) {
        var _action$data4 = action.data,
            outpoint = _action$data4.outpoint,
            fileInfo = _action$data4.fileInfo;
        var newByOutpoint = babelHelpers.extends({}, state.byOutpoint);
        var newDownloading = babelHelpers.extends({}, state.downloadingByOutpoint);
        newByOutpoint[outpoint] = fileInfo;
        delete newDownloading[outpoint];
        return babelHelpers.extends({}, state, {
          byOutpoint: newByOutpoint,
          downloadingByOutpoint: newDownloading
        });
      };

      reducers[ACTIONS.FILE_DELETE] = function (state, action) {
        var outpoint = action.data.outpoint;
        var newByOutpoint = babelHelpers.extends({}, state.byOutpoint);
        var downloadingByOutpoint = babelHelpers.extends({}, state.downloadingByOutpoint);
        delete newByOutpoint[outpoint];
        delete downloadingByOutpoint[outpoint];
        return babelHelpers.extends({}, state, {
          byOutpoint: newByOutpoint,
          downloadingByOutpoint: downloadingByOutpoint
        });
      };

      reducers[ACTIONS.LOADING_VIDEO_STARTED] = function (state, action) {
        var uri = action.data.uri;
        var newLoading = babelHelpers.extends({}, state.urisLoading);
        newLoading[uri] = true;
        return babelHelpers.extends({}, state, {
          urisLoading: newLoading
        });
      };

      reducers[ACTIONS.LOADING_VIDEO_FAILED] = function (state, action) {
        var uri = action.data.uri;
        var newLoading = babelHelpers.extends({}, state.urisLoading);
        delete newLoading[uri];
        return babelHelpers.extends({}, state, {
          urisLoading: newLoading
        });
      };

      reducers[ACTIONS.FETCH_DATE] = function (state, action) {
        var time = action.data.time;

        if (time) {
          return babelHelpers.extends({}, state, {
            publishedDate: time
          });
        }

        return null;
      };

      function fileInfoReducer() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;
        var action = arguments[1];
        var handler = reducers[action.type];
        if (handler) return handler(state, action);
        return state;
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.notificationsReducer = notificationsReducer;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      var reducers = {};
      var defaultState = {
        queue: []
      };

      reducers[ACTIONS.NOTIFICATION_CREATED] = function (state, action) {
        var _action$data = action.data,
            title = _action$data.title,
            message = _action$data.message,
            type = _action$data.type,
            errorCode = _action$data.errorCode,
            displayType = _action$data.displayType;
        var queue = babelHelpers.extends([], state.queue);
        queue.push({
          title: title,
          message: message,
          type: type,
          errorCode: errorCode,
          displayType: displayType
        });
        return babelHelpers.extends({}, state, {
          queue: queue
        });
      };

      reducers[ACTIONS.NOTIFICATION_DISPLAYED] = function (state) {
        var queue = babelHelpers.extends([], state.queue);
        queue.shift();
        return babelHelpers.extends({}, state, {
          queue: queue
        });
      };

      function notificationsReducer() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;
        var action = arguments[1];
        var handler = reducers[action.type];
        if (handler) return handler(state, action);
        return state;
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.searchReducer = searchReducer;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      var reducers = {};
      var defaultState = {
        urisByQuery: {},
        searching: false
      };

      reducers[ACTIONS.SEARCH_STARTED] = function (state) {
        return babelHelpers.extends({}, state, {
          searching: true
        });
      };

      reducers[ACTIONS.SEARCH_COMPLETED] = function (state, action) {
        var _action$data = action.data,
            query = _action$data.query,
            uris = _action$data.uris;
        return babelHelpers.extends({}, state, {
          searching: false,
          urisByQuery: babelHelpers.extends({}, state.urisByQuery, _defineProperty({}, query, uris))
        });
      };

      reducers[ACTIONS.SEARCH_CANCELLED] = function (state) {
        return babelHelpers.extends({}, state, {
          searching: false
        });
      };

      function searchReducer() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;
        var action = arguments[1];
        var handler = reducers[action.type];
        if (handler) return handler(state, action);
        return state;
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.walletReducer = walletReducer;

      var _action_types = __webpack_require__(0);

      var ACTIONS = _interopRequireWildcard(_action_types);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj.default = obj;
          return newObj;
        }
      }

      var reducers = {};
      var receiveAddress = null;

      var buildDraftTransaction = function buildDraftTransaction() {
        return {
          amount: undefined,
          address: undefined
        };
      };

      var defaultState = {
        balance: undefined,
        blocks: {},
        transactions: {},
        fetchingTransactions: false,
        receiveAddress: receiveAddress,
        gettingNewAddress: false,
        draftTransaction: buildDraftTransaction(),
        sendingSupport: false
      };

      reducers[ACTIONS.FETCH_TRANSACTIONS_STARTED] = function (state) {
        return babelHelpers.extends({}, state, {
          fetchingTransactions: true
        });
      };

      reducers[ACTIONS.FETCH_TRANSACTIONS_COMPLETED] = function (state, action) {
        var byId = babelHelpers.extends({}, state.transactions);
        var transactions = action.data.transactions;
        transactions.forEach(function (transaction) {
          byId[transaction.txid] = transaction;
        });
        return babelHelpers.extends({}, state, {
          transactions: byId,
          fetchingTransactions: false
        });
      };

      reducers[ACTIONS.GET_NEW_ADDRESS_STARTED] = function (state) {
        return babelHelpers.extends({}, state, {
          gettingNewAddress: true
        });
      };

      reducers[ACTIONS.GET_NEW_ADDRESS_COMPLETED] = function (state, action) {
        var address = action.data.address;
        return babelHelpers.extends({}, state, {
          gettingNewAddress: false,
          receiveAddress: address
        });
      };

      reducers[ACTIONS.UPDATE_BALANCE] = function (state, action) {
        return babelHelpers.extends({}, state, {
          balance: action.data.balance
        });
      };

      reducers[ACTIONS.CHECK_ADDRESS_IS_MINE_STARTED] = function (state) {
        return babelHelpers.extends({}, state, {
          checkingAddressOwnership: true
        });
      };

      reducers[ACTIONS.CHECK_ADDRESS_IS_MINE_COMPLETED] = function (state) {
        return babelHelpers.extends({}, state, {
          checkingAddressOwnership: false
        });
      };

      reducers[ACTIONS.SET_DRAFT_TRANSACTION_AMOUNT] = function (state, action) {
        var oldDraft = state.draftTransaction;
        var newDraft = babelHelpers.extends({}, oldDraft, {
          amount: parseFloat(action.data.amount)
        });
        return babelHelpers.extends({}, state, {
          draftTransaction: newDraft
        });
      };

      reducers[ACTIONS.SET_DRAFT_TRANSACTION_ADDRESS] = function (state, action) {
        var oldDraft = state.draftTransaction;
        var newDraft = babelHelpers.extends({}, oldDraft, {
          address: action.data.address
        });
        return babelHelpers.extends({}, state, {
          draftTransaction: newDraft
        });
      };

      reducers[ACTIONS.SEND_TRANSACTION_STARTED] = function (state) {
        var newDraftTransaction = babelHelpers.extends({}, state.draftTransaction, {
          sending: true
        });
        return babelHelpers.extends({}, state, {
          draftTransaction: newDraftTransaction
        });
      };

      reducers[ACTIONS.SEND_TRANSACTION_COMPLETED] = function (state) {
        return babelHelpers.extends({}, state, {
          draftTransaction: buildDraftTransaction()
        });
      };

      reducers[ACTIONS.SEND_TRANSACTION_FAILED] = function (state, action) {
        var newDraftTransaction = babelHelpers.extends({}, state.draftTransaction, {
          sending: false,
          error: action.data.error
        });
        return babelHelpers.extends({}, state, {
          draftTransaction: newDraftTransaction
        });
      };

      reducers[ACTIONS.SUPPORT_TRANSACTION_STARTED] = function (state) {
        return babelHelpers.extends({}, state, {
          sendingSupport: true
        });
      };

      reducers[ACTIONS.SUPPORT_TRANSACTION_COMPLETED] = function (state) {
        return babelHelpers.extends({}, state, {
          sendingSupport: false
        });
      };

      reducers[ACTIONS.SUPPORT_TRANSACTION_FAILED] = function (state, action) {
        return babelHelpers.extends({}, state, {
          error: action.data.error,
          sendingSupport: false
        });
      };

      reducers[ACTIONS.FETCH_BLOCK_SUCCESS] = function (state, action) {
        var _action$data = action.data,
            block = _action$data.block,
            height = _action$data.block.height;
        var blocks = babelHelpers.extends({}, state.blocks);
        blocks[height] = block;
        return babelHelpers.extends({}, state, {
          blocks: blocks
        });
      };

      function walletReducer() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;
        var action = arguments[1];
        var handler = reducers[action.type];
        if (handler) return handler(state, action);
        return state;
      }
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.selectNotification = exports.selectState = undefined;

      var _reselect = __webpack_require__(1);

      var selectState = exports.selectState = function selectState(state) {
        return state.notifications || {};
      };

      var selectNotification = exports.selectNotification = (0, _reselect.createSelector)(selectState, function (state) {
        return state.queue.length > 0 ? state.queue[0] : {};
      });
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.makeSelectFetchingCostInfoForUri = exports.selectFetchingCostInfo = exports.selectCostForCurrentPageUri = exports.makeSelectCostInfoForUri = exports.selectAllCostInfoByUri = exports.selectState = undefined;

      var _reselect = __webpack_require__(1);

      var _navigation = __webpack_require__(4);

      var selectState = exports.selectState = function selectState(state) {
        return state.costInfo || {};
      };

      var selectAllCostInfoByUri = exports.selectAllCostInfoByUri = (0, _reselect.createSelector)(selectState, function (state) {
        return state.byUri || {};
      });

      var makeSelectCostInfoForUri = exports.makeSelectCostInfoForUri = function makeSelectCostInfoForUri(uri) {
        return (0, _reselect.createSelector)(selectAllCostInfoByUri, function (costInfos) {
          return costInfos && costInfos[uri];
        });
      };

      var selectCostForCurrentPageUri = exports.selectCostForCurrentPageUri = (0, _reselect.createSelector)(selectAllCostInfoByUri, _navigation.selectCurrentParams, function (costInfo, params) {
        return params.uri && costInfo[params.uri] ? costInfo[params.uri].cost : undefined;
      });
      var selectFetchingCostInfo = exports.selectFetchingCostInfo = (0, _reselect.createSelector)(selectState, function (state) {
        return state.fetching || {};
      });

      var makeSelectFetchingCostInfoForUri = exports.makeSelectFetchingCostInfoForUri = function makeSelectFetchingCostInfoForUri(uri) {
        return (0, _reselect.createSelector)(selectFetchingCostInfo, function (fetchingByUri) {
          return fetchingByUri && fetchingByUri[uri];
        });
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.selectWunderBarIcon = exports.selectWunderBarAddress = exports.makeSelectSearchUris = exports.selectSearchUrisByQuery = exports.selectIsSearching = exports.selectSearchQuery = exports.selectState = undefined;

      var _navigation = __webpack_require__(4);

      var _reselect = __webpack_require__(1);

      var selectState = exports.selectState = function selectState(state) {
        return state.search || {};
      };

      var selectSearchQuery = exports.selectSearchQuery = (0, _reselect.createSelector)(_navigation.selectCurrentPage, _navigation.selectCurrentParams, function (page, params) {
        return page === 'search' ? params && params.query : null;
      });
      var selectIsSearching = exports.selectIsSearching = (0, _reselect.createSelector)(selectState, function (state) {
        return state.searching;
      });
      var selectSearchUrisByQuery = exports.selectSearchUrisByQuery = (0, _reselect.createSelector)(selectState, function (state) {
        return state.urisByQuery;
      });

      var makeSelectSearchUris = exports.makeSelectSearchUris = function makeSelectSearchUris(query) {
        return (0, _reselect.createSelector)(selectSearchUrisByQuery, function (byQuery) {
          return byQuery[query ? query.replace(/^lbry:\/\//i, '') : query];
        });
      };

      var selectWunderBarAddress = exports.selectWunderBarAddress = (0, _reselect.createSelector)(_navigation.selectCurrentPage, _navigation.selectPageTitle, selectSearchQuery, function (page, title, query) {
        return page !== 'search' ? title : query || title;
      });
      var selectWunderBarIcon = exports.selectWunderBarIcon = (0, _reselect.createSelector)(_navigation.selectCurrentPage, _navigation.selectCurrentParams, function (page, params) {
        switch (page) {
          case 'auth':
            return 'icon-user';

          case 'settings':
            return 'icon-gear';

          case 'help':
            return 'icon-question';

          case 'report':
            return 'icon-file';

          case 'downloaded':
            return 'icon-folder';

          case 'published':
            return 'icon-folder';

          case 'history':
            return 'icon-history';

          case 'send':
            return 'icon-send';

          case 'rewards':
            return 'icon-rocket';

          case 'invite':
            return 'icon-envelope-open';

          case 'getcredits':
            return 'icon-shopping-cart';

          case 'wallet':
          case 'backup':
            return 'icon-bank';

          case 'show':
            return 'icon-file';

          case 'publish':
            return params.id ? __('icon-pencil') : __('icon-upload');

          case 'developer':
            return 'icon-code';

          case 'discover':
          case 'search':
            return 'icon-search';

          case 'subscriptions':
            return 'icon-th-list';

          default:
            return 'icon-file';
        }
      });
    }]);
  });
},62,[],"lbry-redux/build/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/page/discover/view.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _featuredCategory = require(_dependencyMap[1], "../../component/featuredCategory");

  var _featuredCategory2 = babelHelpers.interopRequireDefault(_featuredCategory);

  var _reactNavigation = require(_dependencyMap[2], "react-navigation");

  var _reactNavigation2 = babelHelpers.interopRequireDefault(_reactNavigation);

  var _reactNative = require(_dependencyMap[3], "react-native");

  var _discover = require(_dependencyMap[4], "../../styles/discover");

  var _discover2 = babelHelpers.interopRequireDefault(_discover);

  var _Feather = require(_dependencyMap[5], "react-native-vector-icons/Feather");

  var _Feather2 = babelHelpers.interopRequireDefault(_Feather);

  var DiscoverPage = function (_React$PureComponent) {
    babelHelpers.inherits(DiscoverPage, _React$PureComponent);

    function DiscoverPage() {
      babelHelpers.classCallCheck(this, DiscoverPage);
      return babelHelpers.possibleConstructorReturn(this, (DiscoverPage.__proto__ || Object.getPrototypeOf(DiscoverPage)).apply(this, arguments));
    }

    babelHelpers.createClass(DiscoverPage, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.props.fetchFeaturedUris();
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            featuredUris = _props.featuredUris,
            fetchingFeaturedUris = _props.fetchingFeaturedUris;
        var hasContent = typeof featuredUris === 'object' && Object.keys(featuredUris).length,
            failedToLoad = !fetchingFeaturedUris && !hasContent;
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: _discover2.default.container,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 19
            }
          },
          !hasContent && fetchingFeaturedUris && _react2.default.createElement(
            _reactNative.Text,
            {
              style: _discover2.default.title,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 20
              }
            },
            "Fetching content..."
          ),
          hasContent && _react2.default.createElement(
            _reactNative.ScrollView,
            {
              style: _discover2.default.scrollContainer,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 22
              }
            },
            hasContent && Object.keys(featuredUris).map(function (category) {
              return featuredUris[category].length ? _react2.default.createElement(_featuredCategory2.default, {
                key: category,
                category: category,
                names: featuredUris[category],
                navigation: _this2.props.navigation,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 27
                }
              }) : '';
            })
          )
        );
      }
    }]);
    return DiscoverPage;
  }(_react2.default.PureComponent);

  exports.default = DiscoverPage;
},63,[12,64,376,66,454,455],"LBRYApp/src/page/discover/view.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactRedux = require(_dependencyMap[0], "react-redux");

  var _view = require(_dependencyMap[1], "./view");

  var _view2 = babelHelpers.interopRequireDefault(_view);

  var select = function select(state) {
    return {};
  };

  var perform = function perform(dispatch) {
    return {};
  };

  exports.default = (0, _reactRedux.connect)(select, perform)(_view2.default);
},64,[22,65],"LBRYApp/src/component/featuredCategory/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/component/featuredCategory/view.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _lbryRedux = require(_dependencyMap[2], "lbry-redux");

  var _fileItem = require(_dependencyMap[3], "../fileItem");

  var _fileItem2 = babelHelpers.interopRequireDefault(_fileItem);

  var _discover = require(_dependencyMap[4], "../../styles/discover");

  var _discover2 = babelHelpers.interopRequireDefault(_discover);

  var FeaturedCategory = function (_React$PureComponent) {
    babelHelpers.inherits(FeaturedCategory, _React$PureComponent);

    function FeaturedCategory() {
      babelHelpers.classCallCheck(this, FeaturedCategory);
      return babelHelpers.possibleConstructorReturn(this, (FeaturedCategory.__proto__ || Object.getPrototypeOf(FeaturedCategory)).apply(this, arguments));
    }

    babelHelpers.createClass(FeaturedCategory, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            category = _props.category,
            names = _props.names,
            categoryLink = _props.categoryLink,
            navigation = _props.navigation;
        return _react2.default.createElement(
          _reactNative.View,
          {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 12
            }
          },
          _react2.default.createElement(
            _reactNative.Text,
            {
              style: _discover2.default.categoryName,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 13
              }
            },
            category
          ),
          names && names.map(function (name) {
            return _react2.default.createElement(_fileItem2.default, {
              style: _discover2.default.fileItem,
              key: name,
              uri: (0, _lbryRedux.normalizeURI)(name),
              navigation: navigation,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 16
              }
            });
          })
        );
      }
    }]);
    return FeaturedCategory;
  }(_react2.default.PureComponent);

  exports.default = FeaturedCategory;
},65,[12,66,62,374,454],"LBRYApp/src/component/featuredCategory/view.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var ReactNative = {
    get AccessibilityInfo() {
      return require(_dependencyMap[1], 'AccessibilityInfo');
    },

    get ActivityIndicator() {
      return require(_dependencyMap[2], 'ActivityIndicator');
    },

    get ART() {
      return require(_dependencyMap[3], 'ReactNativeART');
    },

    get Button() {
      return require(_dependencyMap[4], 'Button');
    },

    get CheckBox() {
      return require(_dependencyMap[5], 'CheckBox');
    },

    get DatePickerIOS() {
      return require(_dependencyMap[6], 'DatePickerIOS');
    },

    get DrawerLayoutAndroid() {
      return require(_dependencyMap[7], 'DrawerLayoutAndroid');
    },

    get FlatList() {
      return require(_dependencyMap[8], 'FlatList');
    },

    get Image() {
      return require(_dependencyMap[9], 'Image');
    },

    get ImageBackground() {
      return require(_dependencyMap[10], 'ImageBackground');
    },

    get ImageEditor() {
      return require(_dependencyMap[11], 'ImageEditor');
    },

    get ImageStore() {
      return require(_dependencyMap[12], 'ImageStore');
    },

    get KeyboardAvoidingView() {
      return require(_dependencyMap[13], 'KeyboardAvoidingView');
    },

    get ListView() {
      return require(_dependencyMap[14], 'ListView');
    },

    get MaskedViewIOS() {
      return require(_dependencyMap[15], 'MaskedViewIOS');
    },

    get Modal() {
      return require(_dependencyMap[16], 'Modal');
    },

    get NavigatorIOS() {
      return require(_dependencyMap[17], 'NavigatorIOS');
    },

    get Picker() {
      return require(_dependencyMap[18], 'Picker');
    },

    get PickerIOS() {
      return require(_dependencyMap[19], 'PickerIOS');
    },

    get ProgressBarAndroid() {
      return require(_dependencyMap[20], 'ProgressBarAndroid');
    },

    get ProgressViewIOS() {
      return require(_dependencyMap[21], 'ProgressViewIOS');
    },

    get SafeAreaView() {
      return require(_dependencyMap[22], 'SafeAreaView');
    },

    get ScrollView() {
      return require(_dependencyMap[23], 'ScrollView');
    },

    get SectionList() {
      return require(_dependencyMap[24], 'SectionList');
    },

    get SegmentedControlIOS() {
      return require(_dependencyMap[25], 'SegmentedControlIOS');
    },

    get Slider() {
      return require(_dependencyMap[26], 'Slider');
    },

    get SnapshotViewIOS() {
      return require(_dependencyMap[27], 'SnapshotViewIOS');
    },

    get Switch() {
      return require(_dependencyMap[28], 'Switch');
    },

    get RefreshControl() {
      return require(_dependencyMap[29], 'RefreshControl');
    },

    get StatusBar() {
      return require(_dependencyMap[30], 'StatusBar');
    },

    get SwipeableFlatList() {
      return require(_dependencyMap[31], 'SwipeableFlatList');
    },

    get SwipeableListView() {
      return require(_dependencyMap[32], 'SwipeableListView');
    },

    get TabBarIOS() {
      return require(_dependencyMap[33], 'TabBarIOS');
    },

    get Text() {
      return require(_dependencyMap[34], 'Text');
    },

    get TextInput() {
      return require(_dependencyMap[35], 'TextInput');
    },

    get ToastAndroid() {
      return require(_dependencyMap[36], 'ToastAndroid');
    },

    get ToolbarAndroid() {
      return require(_dependencyMap[37], 'ToolbarAndroid');
    },

    get Touchable() {
      return require(_dependencyMap[38], 'Touchable');
    },

    get TouchableHighlight() {
      return require(_dependencyMap[39], 'TouchableHighlight');
    },

    get TouchableNativeFeedback() {
      return require(_dependencyMap[40], 'TouchableNativeFeedback');
    },

    get TouchableOpacity() {
      return require(_dependencyMap[41], 'TouchableOpacity');
    },

    get TouchableWithoutFeedback() {
      return require(_dependencyMap[42], 'TouchableWithoutFeedback');
    },

    get View() {
      return require(_dependencyMap[43], 'View');
    },

    get ViewPagerAndroid() {
      return require(_dependencyMap[44], 'ViewPagerAndroid');
    },

    get VirtualizedList() {
      return require(_dependencyMap[45], 'VirtualizedList');
    },

    get WebView() {
      return require(_dependencyMap[46], 'WebView');
    },

    get ActionSheetIOS() {
      return require(_dependencyMap[47], 'ActionSheetIOS');
    },

    get Alert() {
      return require(_dependencyMap[48], 'Alert');
    },

    get AlertIOS() {
      return require(_dependencyMap[49], 'AlertIOS');
    },

    get Animated() {
      return require(_dependencyMap[50], 'Animated');
    },

    get AppRegistry() {
      return require(_dependencyMap[51], 'AppRegistry');
    },

    get AppState() {
      return require(_dependencyMap[52], 'AppState');
    },

    get AsyncStorage() {
      return require(_dependencyMap[53], 'AsyncStorage');
    },

    get BackAndroid() {
      return require(_dependencyMap[54], 'BackAndroid');
    },

    get BackHandler() {
      return require(_dependencyMap[55], 'BackHandler');
    },

    get CameraRoll() {
      return require(_dependencyMap[56], 'CameraRoll');
    },

    get Clipboard() {
      return require(_dependencyMap[57], 'Clipboard');
    },

    get DatePickerAndroid() {
      return require(_dependencyMap[58], 'DatePickerAndroid');
    },

    get DeviceInfo() {
      return require(_dependencyMap[59], 'DeviceInfo');
    },

    get Dimensions() {
      return require(_dependencyMap[60], 'Dimensions');
    },

    get Easing() {
      return require(_dependencyMap[61], 'Easing');
    },

    get findNodeHandle() {
      return require(_dependencyMap[62], 'ReactNative').findNodeHandle;
    },

    get I18nManager() {
      return require(_dependencyMap[63], 'I18nManager');
    },

    get ImagePickerIOS() {
      return require(_dependencyMap[64], 'ImagePickerIOS');
    },

    get InteractionManager() {
      return require(_dependencyMap[65], 'InteractionManager');
    },

    get Keyboard() {
      return require(_dependencyMap[66], 'Keyboard');
    },

    get LayoutAnimation() {
      return require(_dependencyMap[67], 'LayoutAnimation');
    },

    get Linking() {
      return require(_dependencyMap[68], 'Linking');
    },

    get NativeEventEmitter() {
      return require(_dependencyMap[69], 'NativeEventEmitter');
    },

    get NetInfo() {
      return require(_dependencyMap[70], 'NetInfo');
    },

    get PanResponder() {
      return require(_dependencyMap[71], 'PanResponder');
    },

    get PermissionsAndroid() {
      return require(_dependencyMap[72], 'PermissionsAndroid');
    },

    get PixelRatio() {
      return require(_dependencyMap[73], 'PixelRatio');
    },

    get PushNotificationIOS() {
      return require(_dependencyMap[74], 'PushNotificationIOS');
    },

    get Settings() {
      return require(_dependencyMap[75], 'Settings');
    },

    get Share() {
      return require(_dependencyMap[76], 'Share');
    },

    get StatusBarIOS() {
      return require(_dependencyMap[77], 'StatusBarIOS');
    },

    get StyleSheet() {
      return require(_dependencyMap[78], 'StyleSheet');
    },

    get Systrace() {
      return require(_dependencyMap[79], 'Systrace');
    },

    get TimePickerAndroid() {
      return require(_dependencyMap[80], 'TimePickerAndroid');
    },

    get TVEventHandler() {
      return require(_dependencyMap[81], 'TVEventHandler');
    },

    get UIManager() {
      return require(_dependencyMap[82], 'UIManager');
    },

    get unstable_batchedUpdates() {
      return require(_dependencyMap[62], 'ReactNative').unstable_batchedUpdates;
    },

    get Vibration() {
      return require(_dependencyMap[83], 'Vibration');
    },

    get VibrationIOS() {
      return require(_dependencyMap[84], 'VibrationIOS');
    },

    get YellowBox() {
      return require(_dependencyMap[85], 'YellowBox');
    },

    get DeviceEventEmitter() {
      return require(_dependencyMap[86], 'RCTDeviceEventEmitter');
    },

    get NativeAppEventEmitter() {
      return require(_dependencyMap[87], 'RCTNativeAppEventEmitter');
    },

    get NativeModules() {
      return require(_dependencyMap[88], 'NativeModules');
    },

    get Platform() {
      return require(_dependencyMap[89], 'Platform');
    },

    get processColor() {
      return require(_dependencyMap[90], 'processColor');
    },

    get requireNativeComponent() {
      return require(_dependencyMap[91], 'requireNativeComponent');
    },

    get takeSnapshot() {
      return require(_dependencyMap[92], 'takeSnapshot');
    },

    get ColorPropType() {
      return require(_dependencyMap[93], 'ColorPropType');
    },

    get EdgeInsetsPropType() {
      return require(_dependencyMap[94], 'EdgeInsetsPropType');
    },

    get PointPropType() {
      return require(_dependencyMap[95], 'PointPropType');
    },

    get ViewPropTypes() {
      return require(_dependencyMap[96], 'ViewPropTypes');
    },

    get Navigator() {
      invariant(false, 'Navigator is deprecated and has been removed from this package. It can now be installed ' + 'and imported from `react-native-deprecated-custom-components` instead of `react-native`. ' + 'Learn about alternative navigation solutions at http://facebook.github.io/react-native/docs/navigation.html');
    }

  };
  module.exports = ReactNative;
},66,[18,67,166,215,221,276,277,278,280,263,293,295,296,297,282,299,301,322,323,324,170,326,320,265,327,329,330,331,332,287,279,333,337,339,222,341,148,348,223,312,230,234,231,211,349,288,350,351,135,136,235,352,150,358,359,357,360,361,362,206,205,260,74,321,363,243,269,298,364,120,365,335,139,204,366,367,368,369,209,72,370,227,158,371,372,319,121,143,68,105,193,186,373,167,173,266,172],"react-native-implementation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = require(_dependencyMap[0], 'NativeModules');

  var RCTDeviceEventEmitter = require(_dependencyMap[1], 'RCTDeviceEventEmitter');

  var RCTAccessibilityInfo = NativeModules.AccessibilityInfo;
  var TOUCH_EXPLORATION_EVENT = 'touchExplorationDidChange';

  var _subscriptions = new Map();

  var AccessibilityInfo = {
    fetch: function fetch() {
      return new Promise(function (resolve, reject) {
        RCTAccessibilityInfo.isTouchExplorationEnabled(function (resp) {
          resolve(resp);
        });
      });
    },
    addEventListener: function addEventListener(eventName, handler) {
      var listener = RCTDeviceEventEmitter.addListener(TOUCH_EXPLORATION_EVENT, function (enabled) {
        handler(enabled);
      });

      _subscriptions.set(handler, listener);
    },
    removeEventListener: function removeEventListener(eventName, handler) {
      var listener = _subscriptions.get(handler);

      if (!listener) {
        return;
      }

      listener.remove();

      _subscriptions.delete(handler);
    }
  };
  module.exports = AccessibilityInfo;
},67,[68,121],"AccessibilityInfo");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var BatchedBridge = require(_dependencyMap[0], 'BatchedBridge');

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  function genModule(config, moduleID) {
    if (!config) {
      return null;
    }

    var _config = babelHelpers.slicedToArray(config, 5),
        moduleName = _config[0],
        constants = _config[1],
        methods = _config[2],
        promiseMethods = _config[3],
        syncMethods = _config[4];

    invariant(!moduleName.startsWith('RCT') && !moduleName.startsWith('RK'), 'Module name prefixes should\'ve been stripped by the native side ' + 'but wasn\'t for ' + moduleName);

    if (!constants && !methods) {
      return {
        name: moduleName
      };
    }

    var module = {};
    methods && methods.forEach(function (methodName, methodID) {
      var isPromise = promiseMethods && arrayContains(promiseMethods, methodID);
      var isSync = syncMethods && arrayContains(syncMethods, methodID);
      invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');
      var methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';
      module[methodName] = genMethod(moduleID, methodID, methodType);
    });
    babelHelpers.extends(module, constants);

    if (__DEV__) {
      BatchedBridge.createDebugLookup(moduleID, moduleName, methods);
    }

    return {
      name: moduleName,
      module: module
    };
  }

  global.__fbGenNativeModule = genModule;

  function loadModule(name, moduleID) {
    invariant(global.nativeRequireModuleConfig, 'Can\'t lazily create module without nativeRequireModuleConfig');
    var config = global.nativeRequireModuleConfig(name);
    var info = genModule(config, moduleID);
    return info && info.module;
  }

  function genMethod(moduleID, methodID, type) {
    var fn = null;

    if (type === 'promise') {
      fn = function fn() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return new Promise(function (resolve, reject) {
          BatchedBridge.enqueueNativeCall(moduleID, methodID, args, function (data) {
            return resolve(data);
          }, function (errorData) {
            return reject(createErrorFromErrorData(errorData));
          });
        });
      };
    } else if (type === 'sync') {
      fn = function fn() {
        if (__DEV__) {
          invariant(global.nativeCallSyncHook, 'Calling synchronous methods on native ' + 'modules is not supported in Chrome.\n\n Consider providing alternative ' + 'methods to expose this method in debug mode, e.g. by exposing constants ' + 'ahead-of-time.');
        }

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return global.nativeCallSyncHook(moduleID, methodID, args);
      };
    } else {
      fn = function fn() {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var lastArg = args.length > 0 ? args[args.length - 1] : null;
        var secondLastArg = args.length > 1 ? args[args.length - 2] : null;
        var hasSuccessCallback = typeof lastArg === 'function';
        var hasErrorCallback = typeof secondLastArg === 'function';
        hasErrorCallback && invariant(hasSuccessCallback, 'Cannot have a non-function arg after a function arg.');
        var onSuccess = hasSuccessCallback ? lastArg : null;
        var onFail = hasErrorCallback ? secondLastArg : null;
        var callbackCount = hasSuccessCallback + hasErrorCallback;
        args = args.slice(0, args.length - callbackCount);
        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess);
      };
    }

    fn.type = type;
    return fn;
  }

  function arrayContains(array, value) {
    return array.indexOf(value) !== -1;
  }

  function createErrorFromErrorData(errorData) {
    var _ref = errorData || {},
        message = _ref.message,
        extraErrorInfo = babelHelpers.objectWithoutProperties(_ref, ["message"]);

    var error = new Error(message);
    error.framesToPop = 1;
    return babelHelpers.extends(error, extraErrorInfo);
  }

  var NativeModules = {};

  if (global.nativeModuleProxy) {
    NativeModules = global.nativeModuleProxy;
  } else {
    var bridgeConfig = global.__fbBatchedBridgeConfig;
    invariant(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');

    var defineLazyObjectProperty = require(_dependencyMap[2], 'defineLazyObjectProperty');

    (bridgeConfig.remoteModuleConfig || []).forEach(function (config, moduleID) {
      var info = genModule(config, moduleID);

      if (!info) {
        return;
      }

      if (info.module) {
        NativeModules[info.name] = info.module;
      } else {
          defineLazyObjectProperty(NativeModules, info.name, {
            get: function get() {
              return loadModule(info.name, moduleID);
            }
          });
        }
    });
  }

  module.exports = NativeModules;
},68,[69,18,77],"NativeModules");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var MessageQueue = require(_dependencyMap[0], 'MessageQueue');

  var BatchedBridge = new MessageQueue(typeof __fbUninstallRNGlobalErrorHandler !== 'undefined' && __fbUninstallRNGlobalErrorHandler === true);
  Object.defineProperty(global, '__fbBatchedBridge', {
    configurable: true,
    value: BatchedBridge
  });
  module.exports = BatchedBridge;
},69,[70],"BatchedBridge");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ErrorUtils = require(_dependencyMap[0], 'ErrorUtils');

  var Systrace = require(_dependencyMap[1], 'Systrace');

  var deepFreezeAndThrowOnMutationInDev = require(_dependencyMap[2], 'deepFreezeAndThrowOnMutationInDev');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var stringifySafe = require(_dependencyMap[4], 'stringifySafe');

  var TO_JS = 0;
  var TO_NATIVE = 1;
  var MODULE_IDS = 0;
  var METHOD_IDS = 1;
  var PARAMS = 2;
  var MIN_TIME_BETWEEN_FLUSHES_MS = 5;
  var TRACE_TAG_REACT_APPS = 1 << 17;
  var DEBUG_INFO_LIMIT = 32;
  var JSTimers = null;

  var MessageQueue = function () {
    function MessageQueue() {
      var shouldUninstallGlobalErrorHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      babelHelpers.classCallCheck(this, MessageQueue);
      this._lazyCallableModules = {};
      this._queue = [[], [], [], 0];
      this._successCallbacks = [];
      this._failureCallbacks = [];
      this._callID = 0;
      this._lastFlush = 0;
      this._eventLoopStartTime = new Date().getTime();

      if (shouldUninstallGlobalErrorHandler) {
        this.uninstallGlobalErrorHandler();
      } else {
        this.installGlobalErrorHandler();
      }

      if (__DEV__) {
        this._debugInfo = {};
        this._remoteModuleTable = {};
        this._remoteMethodTable = {};
      }

      this.callFunctionReturnFlushedQueue = this.callFunctionReturnFlushedQueue.bind(this);
      this.callFunctionReturnResultAndFlushedQueue = this.callFunctionReturnResultAndFlushedQueue.bind(this);
      this.flushedQueue = this.flushedQueue.bind(this);
      this.invokeCallbackAndReturnFlushedQueue = this.invokeCallbackAndReturnFlushedQueue.bind(this);
    }

    babelHelpers.createClass(MessageQueue, [{
      key: "callFunctionReturnFlushedQueue",
      value: function callFunctionReturnFlushedQueue(module, method, args) {
        var _this = this;

        this.__guard(function () {
          _this.__callFunction(module, method, args);
        });

        return this.flushedQueue();
      }
    }, {
      key: "callFunctionReturnResultAndFlushedQueue",
      value: function callFunctionReturnResultAndFlushedQueue(module, method, args) {
        var _this2 = this;

        var result = void 0;

        this.__guard(function () {
          result = _this2.__callFunction(module, method, args);
        });

        return [result, this.flushedQueue()];
      }
    }, {
      key: "invokeCallbackAndReturnFlushedQueue",
      value: function invokeCallbackAndReturnFlushedQueue(cbID, args) {
        var _this3 = this;

        this.__guard(function () {
          _this3.__invokeCallback(cbID, args);
        });

        return this.flushedQueue();
      }
    }, {
      key: "flushedQueue",
      value: function flushedQueue() {
        var _this4 = this;

        this.__guard(function () {
          _this4.__callImmediates();
        });

        var queue = this._queue;
        this._queue = [[], [], [], this._callID];
        return queue[0].length ? queue : null;
      }
    }, {
      key: "getEventLoopRunningTime",
      value: function getEventLoopRunningTime() {
        return new Date().getTime() - this._eventLoopStartTime;
      }
    }, {
      key: "registerCallableModule",
      value: function registerCallableModule(name, module) {
        this._lazyCallableModules[name] = function () {
          return module;
        };
      }
    }, {
      key: "registerLazyCallableModule",
      value: function registerLazyCallableModule(name, factory) {
        var module = void 0;
        var getValue = factory;

        this._lazyCallableModules[name] = function () {
          if (getValue) {
            module = getValue();
            getValue = null;
          }

          return module;
        };
      }
    }, {
      key: "getCallableModule",
      value: function getCallableModule(name) {
        var getValue = this._lazyCallableModules[name];
        return getValue ? getValue() : null;
      }
    }, {
      key: "enqueueNativeCall",
      value: function enqueueNativeCall(moduleID, methodID, params, onFail, onSucc) {
        if (onFail || onSucc) {
          if (__DEV__) {
            this._debugInfo[this._callID] = [moduleID, methodID];

            if (this._callID > DEBUG_INFO_LIMIT) {
              delete this._debugInfo[this._callID - DEBUG_INFO_LIMIT];
            }
          }

          onFail && params.push(this._callID << 1);
          onSucc && params.push(this._callID << 1 | 1);
          this._successCallbacks[this._callID] = onSucc;
          this._failureCallbacks[this._callID] = onFail;
        }

        if (__DEV__) {
          global.nativeTraceBeginAsyncFlow && global.nativeTraceBeginAsyncFlow(TRACE_TAG_REACT_APPS, 'native', this._callID);
        }

        this._callID++;

        this._queue[MODULE_IDS].push(moduleID);

        this._queue[METHOD_IDS].push(methodID);

        if (__DEV__) {
          var isValidArgument = function isValidArgument(val) {
            var t = typeof val;

            if (t === 'undefined' || t === 'null' || t === 'boolean' || t === 'number' || t === 'string') {
              return true;
            }

            if (t === 'function' || t !== 'object') {
              return false;
            }

            if (Array.isArray(val)) {
              return val.every(isValidArgument);
            }

            for (var k in val) {
              if (typeof val[k] !== 'function' && !isValidArgument(val[k])) {
                return false;
              }
            }

            return true;
          };

          invariant(isValidArgument(params), '%s is not usable as a native method argument', params);
          deepFreezeAndThrowOnMutationInDev(params);
        }

        this._queue[PARAMS].push(params);

        var now = new Date().getTime();

        if (global.nativeFlushQueueImmediate && (now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS || this._inCall === 0)) {
          var queue = this._queue;
          this._queue = [[], [], [], this._callID];
          this._lastFlush = now;
          global.nativeFlushQueueImmediate(queue);
        }

        Systrace.counterEvent('pending_js_to_native_queue', this._queue[0].length);

        if (__DEV__ && this.__spy && isFinite(moduleID)) {
          this.__spy({
            type: TO_NATIVE,
            module: this._remoteModuleTable[moduleID],
            method: this._remoteMethodTable[moduleID][methodID],
            args: params
          });
        } else if (this.__spy) {
          this.__spy({
            type: TO_NATIVE,
            module: moduleID + '',
            method: methodID,
            args: params
          });
        }
      }
    }, {
      key: "createDebugLookup",
      value: function createDebugLookup(moduleID, name, methods) {
        if (__DEV__) {
          this._remoteModuleTable[moduleID] = name;
          this._remoteMethodTable[moduleID] = methods;
        }
      }
    }, {
      key: "uninstallGlobalErrorHandler",
      value: function uninstallGlobalErrorHandler() {
        this.__guard = this.__guardUnsafe;
      }
    }, {
      key: "installGlobalErrorHandler",
      value: function installGlobalErrorHandler() {
        this.__guard = this.__guardSafe;
      }
    }, {
      key: "__guardUnsafe",
      value: function __guardUnsafe(fn) {
        this._inCall++;
        fn();
        this._inCall--;
      }
    }, {
      key: "__guardSafe",
      value: function __guardSafe(fn) {
        this._inCall++;

        try {
          fn();
        } catch (error) {
          ErrorUtils.reportFatalError(error);
        } finally {
          this._inCall--;
        }
      }
    }, {
      key: "__callImmediates",
      value: function __callImmediates() {
        Systrace.beginEvent('JSTimers.callImmediates()');

        if (!JSTimers) {
          JSTimers = require(_dependencyMap[5], 'JSTimers');
        }

        JSTimers.callImmediates();
        Systrace.endEvent();
      }
    }, {
      key: "__callFunction",
      value: function __callFunction(module, method, args) {
        this._lastFlush = new Date().getTime();
        this._eventLoopStartTime = this._lastFlush;
        Systrace.beginEvent(module + "." + method + "()");

        if (this.__spy) {
          this.__spy({
            type: TO_JS,
            module: module,
            method: method,
            args: args
          });
        }

        var moduleMethods = this.getCallableModule(module);
        invariant(!!moduleMethods, 'Module %s is not a registered callable module (calling %s)', module, method);
        invariant(!!moduleMethods[method], 'Method %s does not exist on module %s', method, module);
        var result = moduleMethods[method].apply(moduleMethods, args);
        Systrace.endEvent();
        return result;
      }
    }, {
      key: "__invokeCallback",
      value: function __invokeCallback(cbID, args) {
        this._lastFlush = new Date().getTime();
        this._eventLoopStartTime = this._lastFlush;
        var callID = cbID >>> 1;
        var isSuccess = cbID & 1;
        var callback = isSuccess ? this._successCallbacks[callID] : this._failureCallbacks[callID];

        if (__DEV__) {
          var debug = this._debugInfo[callID];

          var _module = debug && this._remoteModuleTable[debug[0]];

          var _method = debug && this._remoteMethodTable[debug[0]][debug[1]];

          if (!callback) {
            var errorMessage = "Callback with id " + cbID + ": " + _module + "." + _method + "() not found";

            if (_method) {
              errorMessage = "The callback " + _method + "() exists in module " + _module + ", " + 'but only one callback may be registered to a function in a native module.';
            }

            invariant(callback, errorMessage);
          }

          var profileName = debug ? '<callback for ' + _module + '.' + _method + '>' : cbID;

          if (callback && this.__spy) {
            this.__spy({
              type: TO_JS,
              module: null,
              method: profileName,
              args: args
            });
          }

          Systrace.beginEvent("MessageQueue.invokeCallback(" + profileName + ", " + stringifySafe(args) + ")");
        }

        if (!callback) {
          return;
        }

        this._successCallbacks[callID] = this._failureCallbacks[callID] = null;
        callback.apply(undefined, babelHelpers.toConsumableArray(args));

        if (__DEV__) {
          Systrace.endEvent();
        }
      }
    }], [{
      key: "spy",
      value: function spy(spyOrToggle) {
        if (spyOrToggle === true) {
          MessageQueue.prototype.__spy = function (info) {
            console.log((info.type === TO_JS ? 'N->JS' : 'JS->N') + " : " + ("" + (info.module ? info.module + '.' : '') + info.method) + ("(" + JSON.stringify(info.args) + ")"));
          };
        } else if (spyOrToggle === false) {
          MessageQueue.prototype.__spy = null;
        } else {
          MessageQueue.prototype.__spy = spyOrToggle;
        }
      }
    }]);
    return MessageQueue;
  }();

  module.exports = MessageQueue;
},70,[71,72,162,18,92,104],"MessageQueue");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = global.ErrorUtils;
},71,[],"ErrorUtils");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var TRACE_TAG_REACT_APPS = 1 << 17;
  var TRACE_TAG_JS_VM_CALLS = 1 << 27;
  var _enabled = false;
  var _asyncCookie = 0;
  var _markStack = [];

  var _markStackIndex = -1;

  var _canInstallReactHook = false;
  var _useFiber = false;
  var REACT_MARKER = "\u269B";
  var userTimingPolyfill = __DEV__ ? {
    mark: function mark(markName) {
      if (_enabled) {
        _markStackIndex++;
        _markStack[_markStackIndex] = markName;
        var systraceLabel = markName;

        if (markName[0] === REACT_MARKER) {
          var indexOfId = markName.lastIndexOf(' (#');
          var cutoffIndex = indexOfId !== -1 ? indexOfId : markName.length;
          systraceLabel = markName.slice(2, cutoffIndex);
        }

        Systrace.beginEvent(systraceLabel);
      }
    },
    measure: function measure(measureName, startMark, endMark) {
      if (_enabled) {
        invariant(typeof measureName === 'string' && typeof startMark === 'string' && typeof endMark === 'undefined', 'Only performance.measure(string, string) overload is supported.');
        var topMark = _markStack[_markStackIndex];
        invariant(startMark === topMark, 'There was a mismatching performance.measure() call. ' + 'Expected "%s" but got "%s."', topMark, startMark);
        _markStackIndex--;
        Systrace.endEvent();
      }
    },
    clearMarks: function clearMarks(markName) {
      if (_enabled) {
        if (_markStackIndex === -1) {
          return;
        }

        if (markName === _markStack[_markStackIndex]) {
          if (userTimingPolyfill != null) {
            userTimingPolyfill.measure(markName, markName);
          }
        }
      }
    },
    clearMeasures: function clearMeasures() {}
  } : null;
  var reactDebugToolHook = __DEV__ ? {
    onBeforeMountComponent: function onBeforeMountComponent(debugID) {
      var ReactComponentTreeHook = require(_dependencyMap[1], 'ReactGlobalSharedState').ReactComponentTreeHook;

      var displayName = ReactComponentTreeHook.getDisplayName(debugID);
      Systrace.beginEvent("ReactReconciler.mountComponent(" + displayName + ")");
    },
    onMountComponent: function onMountComponent(debugID) {
      Systrace.endEvent();
    },
    onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID) {
      var ReactComponentTreeHook = require(_dependencyMap[1], 'ReactGlobalSharedState').ReactComponentTreeHook;

      var displayName = ReactComponentTreeHook.getDisplayName(debugID);
      Systrace.beginEvent("ReactReconciler.updateComponent(" + displayName + ")");
    },
    onUpdateComponent: function onUpdateComponent(debugID) {
      Systrace.endEvent();
    },
    onBeforeUnmountComponent: function onBeforeUnmountComponent(debugID) {
      var ReactComponentTreeHook = require(_dependencyMap[1], 'ReactGlobalSharedState').ReactComponentTreeHook;

      var displayName = ReactComponentTreeHook.getDisplayName(debugID);
      Systrace.beginEvent("ReactReconciler.unmountComponent(" + displayName + ")");
    },
    onUnmountComponent: function onUnmountComponent(debugID) {
      Systrace.endEvent();
    },
    onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {
      var ReactComponentTreeHook = require(_dependencyMap[1], 'ReactGlobalSharedState').ReactComponentTreeHook;

      var displayName = ReactComponentTreeHook.getDisplayName(debugID);
      Systrace.beginEvent(displayName + "." + timerType + "()");
    },
    onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {
      Systrace.endEvent();
    }
  } : null;
  var Systrace = {
    installReactHook: function installReactHook(useFiber) {
      if (_enabled) {
        if (__DEV__) {
          if (useFiber) {
            global.performance = userTimingPolyfill;
          } else {
            require(_dependencyMap[2], 'ReactDebugTool').addHook(reactDebugToolHook);
          }
        }
      }

      _useFiber = useFiber;
      _canInstallReactHook = true;
    },
    setEnabled: function setEnabled(enabled) {
      if (_enabled !== enabled) {
        if (__DEV__) {
          if (enabled) {
            global.nativeTraceBeginLegacy && global.nativeTraceBeginLegacy(TRACE_TAG_JS_VM_CALLS);
          } else {
            global.nativeTraceEndLegacy && global.nativeTraceEndLegacy(TRACE_TAG_JS_VM_CALLS);
          }

          if (_canInstallReactHook) {
            if (_useFiber) {
              if (enabled && global.performance === undefined) {
                global.performance = userTimingPolyfill;
              }
            } else {
              var ReactDebugTool = require(_dependencyMap[2], 'ReactDebugTool');

              if (enabled) {
                ReactDebugTool.addHook(reactDebugToolHook);
              } else {
                ReactDebugTool.removeHook(reactDebugToolHook);
              }
            }
          }
        }

        _enabled = enabled;
      }
    },
    isEnabled: function isEnabled() {
      return _enabled;
    },
    beginEvent: function beginEvent(profileName, args) {
      if (_enabled) {
        profileName = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceBeginSection(TRACE_TAG_REACT_APPS, profileName, args);
      }
    },
    endEvent: function endEvent() {
      if (_enabled) {
        global.nativeTraceEndSection(TRACE_TAG_REACT_APPS);
      }
    },
    beginAsyncEvent: function beginAsyncEvent(profileName) {
      var cookie = _asyncCookie;

      if (_enabled) {
        _asyncCookie++;
        profileName = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceBeginAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie);
      }

      return cookie;
    },
    endAsyncEvent: function endAsyncEvent(profileName, cookie) {
      if (_enabled) {
        profileName = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceEndAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie);
      }
    },
    counterEvent: function counterEvent(profileName, value) {
      if (_enabled) {
        profileName = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceCounter && global.nativeTraceCounter(TRACE_TAG_REACT_APPS, profileName, value);
      }
    },
    attachToRelayProfiler: function attachToRelayProfiler(relayProfiler) {
      relayProfiler.attachProfileHandler('*', function (name) {
        var cookie = Systrace.beginAsyncEvent(name);
        return function () {
          Systrace.endAsyncEvent(name, cookie);
        };
      });
      relayProfiler.attachAggregateHandler('*', function (name, callback) {
        Systrace.beginEvent(name);
        callback();
        Systrace.endEvent();
      });
    },
    swizzleJSON: function swizzleJSON() {
      Systrace.measureMethods(JSON, 'JSON', ['parse', 'stringify']);
    },
    measureMethods: function measureMethods(object, objectName, methodNames) {
      if (!__DEV__) {
        return;
      }

      methodNames.forEach(function (methodName) {
        object[methodName] = Systrace.measure(objectName, methodName, object[methodName]);
      });
    },
    measure: function measure(objName, fnName, func) {
      if (!__DEV__) {
        return func;
      }

      var profileName = objName + "." + fnName;
      return function () {
        if (!_enabled) {
          return func.apply(this, arguments);
        }

        Systrace.beginEvent(profileName);
        var ret = func.apply(this, arguments);
        Systrace.endEvent();
        return ret;
      };
    }
  };

  if (__DEV__) {
    require.Systrace = Systrace;
  }

  module.exports = Systrace;
},72,[18,73,165],"Systrace");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'ReactNative'),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  module.exports = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactGlobalSharedState;
},73,[74],"ReactGlobalSharedState");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ReactNative = void 0;

  if (__DEV__) {
    ReactNative = require(_dependencyMap[0], 'ReactNativeRenderer-dev');
  } else {
    ReactNative = require(_dependencyMap[1], 'ReactNativeRenderer-prod');
  }

  module.exports = ReactNative;
},74,[75,164],"ReactNative");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  if (__DEV__) {
    (function () {
      "use strict";

      require(_dependencyMap[0], "InitializeCore");

      var invariant = require(_dependencyMap[1], "fbjs/lib/invariant");

      var warning = require(_dependencyMap[2], "fbjs/lib/warning");

      var emptyFunction = require(_dependencyMap[3], "fbjs/lib/emptyFunction");

      var RCTEventEmitter = require(_dependencyMap[4], "RCTEventEmitter");

      var UIManager = require(_dependencyMap[5], "UIManager");

      var React = require(_dependencyMap[6], "react");

      var ExceptionsManager = require(_dependencyMap[7], "ExceptionsManager");

      var TextInputState = require(_dependencyMap[8], "TextInputState");

      var deepDiffer = require(_dependencyMap[9], "deepDiffer");

      var flattenStyle = require(_dependencyMap[10], "flattenStyle");

      var emptyObject = require(_dependencyMap[11], "fbjs/lib/emptyObject");

      var checkPropTypes = require(_dependencyMap[12], "prop-types/checkPropTypes");

      var shallowEqual = require(_dependencyMap[13], "fbjs/lib/shallowEqual");

      var deepFreezeAndThrowOnMutationInDev = require(_dependencyMap[14], "deepFreezeAndThrowOnMutationInDev");

      var ReactErrorUtils = {
        _caughtError: null,
        _hasCaughtError: false,
        _rethrowError: null,
        _hasRethrowError: false,
        injection: {
          injectErrorUtils: function injectErrorUtils(injectedErrorUtils) {
            invariant(typeof injectedErrorUtils.invokeGuardedCallback === "function", "Injected invokeGuardedCallback() must be a function.");
            _invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
          }
        },
        invokeGuardedCallback: function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
          _invokeGuardedCallback.apply(ReactErrorUtils, arguments);
        },
        invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
          ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);

          if (ReactErrorUtils.hasCaughtError()) {
            var error = ReactErrorUtils.clearCaughtError();

            if (!ReactErrorUtils._hasRethrowError) {
              ReactErrorUtils._hasRethrowError = true;
              ReactErrorUtils._rethrowError = error;
            }
          }
        },
        rethrowCaughtError: function rethrowCaughtError() {
          return _rethrowCaughtError.apply(ReactErrorUtils, arguments);
        },
        hasCaughtError: function hasCaughtError() {
          return ReactErrorUtils._hasCaughtError;
        },
        clearCaughtError: function clearCaughtError() {
          if (ReactErrorUtils._hasCaughtError) {
            var error = ReactErrorUtils._caughtError;
            ReactErrorUtils._caughtError = null;
            ReactErrorUtils._hasCaughtError = false;
            return error;
          } else {
            invariant(false, "clearCaughtError was called but no error was captured. This error " + "is likely caused by a bug in React. Please file an issue.");
          }
        }
      };

      var _invokeGuardedCallback = function _invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        ReactErrorUtils._hasCaughtError = false;
        ReactErrorUtils._caughtError = null;
        var funcArgs = Array.prototype.slice.call(arguments, 3);

        try {
          func.apply(context, funcArgs);
        } catch (error) {
          ReactErrorUtils._caughtError = error;
          ReactErrorUtils._hasCaughtError = true;
        }
      };

      {
        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
          var fakeNode = document.createElement("react");

          var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
            invariant(typeof document !== "undefined", "The `document` global was defined when React was initialized, but is not " + "defined anymore. This can happen in a test environment if a component " + "schedules an update from an asynchronous callback, but the test has already " + "finished running. To solve this, you can either unmount the component at " + "the end of your test (and ensure that any asynchronous operations get " + "canceled in `componentWillUnmount`), or you can change the test itself " + "to be asynchronous.");
            var evt = document.createEvent("Event");
            var didError = true;
            var funcArgs = Array.prototype.slice.call(arguments, 3);

            function callCallback() {
              fakeNode.removeEventListener(evtType, callCallback, false);
              func.apply(context, funcArgs);
              didError = false;
            }

            var error = void 0;
            var didSetError = false;
            var isCrossOriginError = false;

            function onError(event) {
              error = event.error;
              didSetError = true;

              if (error === null && event.colno === 0 && event.lineno === 0) {
                isCrossOriginError = true;
              }
            }

            var evtType = "react-" + (name ? name : "invokeguardedcallback");
            window.addEventListener("error", onError);
            fakeNode.addEventListener(evtType, callCallback, false);
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);

            if (didError) {
              if (!didSetError) {
                error = new Error("An error was thrown inside one of your components, but React " + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + "your browser. Try triggering the error in production mode, " + "or switching to a modern browser. If you suspect that this is " + "actually an issue with React, please file an issue.");
              } else if (isCrossOriginError) {
                error = new Error("A cross-origin error was thrown. React doesn't have access to " + "the actual error object in development. " + "See https://fb.me/react-crossorigin-error for more information.");
              }

              ReactErrorUtils._hasCaughtError = true;
              ReactErrorUtils._caughtError = error;
            } else {
              ReactErrorUtils._hasCaughtError = false;
              ReactErrorUtils._caughtError = null;
            }

            window.removeEventListener("error", onError);
          };

          _invokeGuardedCallback = invokeGuardedCallbackDev;
        }
      }

      var _rethrowCaughtError = function _rethrowCaughtError() {
        if (ReactErrorUtils._hasRethrowError) {
          var error = ReactErrorUtils._rethrowError;
          ReactErrorUtils._rethrowError = null;
          ReactErrorUtils._hasRethrowError = false;
          throw error;
        }
      };

      var eventPluginOrder = null;
      var namesToPlugins = {};

      function recomputePluginOrdering() {
        if (!eventPluginOrder) {
          return;
        }

        for (var pluginName in namesToPlugins) {
          var pluginModule = namesToPlugins[pluginName];
          var pluginIndex = eventPluginOrder.indexOf(pluginName);
          invariant(pluginIndex > -1, "EventPluginRegistry: Cannot inject event plugins that do not exist in " + "the plugin ordering, `%s`.", pluginName);

          if (plugins[pluginIndex]) {
            continue;
          }

          invariant(pluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` " + "method, but `%s` does not.", pluginName);
          plugins[pluginIndex] = pluginModule;
          var publishedEvents = pluginModule.eventTypes;

          for (var eventName in publishedEvents) {
            invariant(publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName), "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName);
          }
        }
      }

      function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
        invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName), "EventPluginHub: More than one plugin attempted to publish the same " + "event name, `%s`.", eventName);
        eventNameDispatchConfigs[eventName] = dispatchConfig;
        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

        if (phasedRegistrationNames) {
          for (var phaseName in phasedRegistrationNames) {
            if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
              var phasedRegistrationName = phasedRegistrationNames[phaseName];
              publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
            }
          }

          return true;
        } else if (dispatchConfig.registrationName) {
          publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
          return true;
        }

        return false;
      }

      function publishRegistrationName(registrationName, pluginModule, eventName) {
        invariant(!registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same " + "registration name, `%s`.", registrationName);
        registrationNameModules[registrationName] = pluginModule;
        registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
        }
      }

      var plugins = [];
      var eventNameDispatchConfigs = {};
      var registrationNameModules = {};
      var registrationNameDependencies = {};

      function injectEventPluginOrder(injectedEventPluginOrder) {
        invariant(!eventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than " + "once. You are likely trying to load more than one copy of React.");
        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
        recomputePluginOrdering();
      }

      function injectEventPluginsByName(injectedNamesToPlugins) {
        var isOrderingDirty = false;

        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }

          var pluginModule = injectedNamesToPlugins[pluginName];

          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
            invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins " + "using the same name, `%s`.", pluginName);
            namesToPlugins[pluginName] = pluginModule;
            isOrderingDirty = true;
          }
        }

        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      }

      var getFiberCurrentPropsFromNode = null;
      var getInstanceFromNode = null;
      var getNodeFromInstance = null;
      var injection$1 = {
        injectComponentTree: function injectComponentTree(Injected) {
          getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
          getInstanceFromNode = Injected.getInstanceFromNode;
          getNodeFromInstance = Injected.getNodeFromInstance;
          {
            warning(getNodeFromInstance && getInstanceFromNode, "EventPluginUtils.injection.injectComponentTree(...): Injected " + "module is missing getNodeFromInstance or getInstanceFromNode.");
          }
        }
      };

      function isEndish(topLevelType) {
        return topLevelType === "topMouseUp" || topLevelType === "topTouchEnd" || topLevelType === "topTouchCancel";
      }

      function isMoveish(topLevelType) {
        return topLevelType === "topMouseMove" || topLevelType === "topTouchMove";
      }

      function isStartish(topLevelType) {
        return topLevelType === "topMouseDown" || topLevelType === "topTouchStart";
      }

      var validateEventDispatches;
      {
        validateEventDispatches = function validateEventDispatches(event) {
          var dispatchListeners = event._dispatchListeners;
          var dispatchInstances = event._dispatchInstances;
          var listenersIsArr = Array.isArray(dispatchListeners);
          var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
          var instancesIsArr = Array.isArray(dispatchInstances);
          var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
          warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, "EventPluginUtils: Invalid `event`.");
        };
      }

      function executeDispatch(event, simulated, listener, inst) {
        var type = event.type || "unknown-event";
        event.currentTarget = getNodeFromInstance(inst);
        ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
        event.currentTarget = null;
      }

      function executeDispatchesInOrder(event, simulated) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
          }
        } else if (dispatchListeners) {
          executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
        }

        event._dispatchListeners = null;
        event._dispatchInstances = null;
      }

      function executeDispatchesInOrderStopAtTrueImpl(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            if (dispatchListeners[i](event, dispatchInstances[i])) {
              return dispatchInstances[i];
            }
          }
        } else if (dispatchListeners) {
          if (dispatchListeners(event, dispatchInstances)) {
            return dispatchInstances;
          }
        }

        return null;
      }

      function executeDispatchesInOrderStopAtTrue(event) {
        var ret = executeDispatchesInOrderStopAtTrueImpl(event);
        event._dispatchInstances = null;
        event._dispatchListeners = null;
        return ret;
      }

      function executeDirectDispatch(event) {
        {
          validateEventDispatches(event);
        }
        var dispatchListener = event._dispatchListeners;
        var dispatchInstance = event._dispatchInstances;
        invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
        event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
        var res = dispatchListener ? dispatchListener(event) : null;
        event.currentTarget = null;
        event._dispatchListeners = null;
        event._dispatchInstances = null;
        return res;
      }

      function hasDispatches(event) {
        return !!event._dispatchListeners;
      }

      function accumulateInto(current, next) {
        invariant(next != null, "accumulateInto(...): Accumulated items must not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          if (Array.isArray(next)) {
            current.push.apply(current, next);
            return current;
          }

          current.push(next);
          return current;
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      function forEachAccumulated(arr, cb, scope) {
        if (Array.isArray(arr)) {
          arr.forEach(cb, scope);
        } else if (arr) {
          cb.call(scope, arr);
        }
      }

      var eventQueue = null;

      var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
        if (event) {
          executeDispatchesInOrder(event, simulated);

          if (!event.isPersistent()) {
            event.constructor.release(event);
          }
        }
      };

      var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
        return executeDispatchesAndRelease(e, true);
      };

      var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
        return executeDispatchesAndRelease(e, false);
      };

      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }

      function shouldPreventMouseEvent(name, type, props) {
        switch (name) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
            return !!(props.disabled && isInteractive(type));

          default:
            return false;
        }
      }

      var injection = {
        injectEventPluginOrder: injectEventPluginOrder,
        injectEventPluginsByName: injectEventPluginsByName
      };

      function getListener(inst, registrationName) {
        var listener;
        var stateNode = inst.stateNode;

        if (!stateNode) {
          return null;
        }

        var props = getFiberCurrentPropsFromNode(stateNode);

        if (!props) {
          return null;
        }

        listener = props[registrationName];

        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
          return null;
        }

        invariant(!listener || typeof listener === "function", "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
        return listener;
      }

      function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events;

        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];

          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);

            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }

        return events;
      }

      function enqueueEvents(events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      }

      function processEventQueue(simulated) {
        var processingEventQueue = eventQueue;
        eventQueue = null;

        if (!processingEventQueue) {
          return;
        }

        if (simulated) {
          forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
        } else {
          forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
        }

        invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing " + "an event queue. Support for this has not yet been implemented.");
        ReactErrorUtils.rethrowCaughtError();
      }

      var IndeterminateComponent = 0;
      var FunctionalComponent = 1;
      var ClassComponent = 2;
      var HostRoot = 3;
      var HostPortal = 4;
      var HostComponent = 5;
      var HostText = 6;
      var CallComponent = 7;
      var CallHandlerPhase = 8;
      var ReturnComponent = 9;
      var Fragment = 10;

      function getParent(inst) {
        do {
          inst = inst["return"];
        } while (inst && inst.tag !== HostComponent);

        if (inst) {
          return inst;
        }

        return null;
      }

      function getLowestCommonAncestor(instA, instB) {
        var depthA = 0;

        for (var tempA = instA; tempA; tempA = getParent(tempA)) {
          depthA++;
        }

        var depthB = 0;

        for (var tempB = instB; tempB; tempB = getParent(tempB)) {
          depthB++;
        }

        while (depthA - depthB > 0) {
          instA = getParent(instA);
          depthA--;
        }

        while (depthB - depthA > 0) {
          instB = getParent(instB);
          depthB--;
        }

        var depth = depthA;

        while (depth--) {
          if (instA === instB || instA === instB.alternate) {
            return instA;
          }

          instA = getParent(instA);
          instB = getParent(instB);
        }

        return null;
      }

      function isAncestor(instA, instB) {
        while (instB) {
          if (instA === instB || instA === instB.alternate) {
            return true;
          }

          instB = getParent(instB);
        }

        return false;
      }

      function getParentInstance(inst) {
        return getParent(inst);
      }

      function traverseTwoPhase(inst, fn, arg) {
        var path = [];

        while (inst) {
          path.push(inst);
          inst = getParent(inst);
        }

        var i;

        for (i = path.length; i-- > 0;) {
          fn(path[i], "captured", arg);
        }

        for (i = 0; i < path.length; i++) {
          fn(path[i], "bubbled", arg);
        }
      }

      function listenerAtPhase(inst, event, propagationPhase) {
        var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
        return getListener(inst, registrationName);
      }

      function accumulateDirectionalDispatches(inst, phase, event) {
        {
          warning(inst, "Dispatching inst must not be null");
        }
        var listener = listenerAtPhase(inst, event, phase);

        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }

      function accumulateTwoPhaseDispatchesSingle(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          var targetInst = event._targetInst;
          var parentInst = targetInst ? getParentInstance(targetInst) : null;
          traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateDispatches(inst, ignoredDirection, event) {
        if (inst && event && event.dispatchConfig.registrationName) {
          var registrationName = event.dispatchConfig.registrationName;
          var listener = getListener(inst, registrationName);

          if (listener) {
            event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
            event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
          }
        }
      }

      function accumulateDirectDispatchesSingle(event) {
        if (event && event.dispatchConfig.registrationName) {
          accumulateDispatches(event._targetInst, null, event);
        }
      }

      function accumulateTwoPhaseDispatches(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
      }

      function accumulateTwoPhaseDispatchesSkipTarget(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
      }

      function accumulateDirectDispatches(events) {
        forEachAccumulated(events, accumulateDirectDispatchesSingle);
      }

      var didWarnForAddedNewProperty = false;
      var isProxySupported = typeof Proxy === 'function' && !Object.isSealed(new Proxy({}, {}));
      var EVENT_POOL_SIZE = 10;
      var shouldBeReleasedProperties = ["dispatchConfig", "_targetInst", "nativeEvent", "isDefaultPrevented", "isPropagationStopped", "_dispatchListeners", "_dispatchInstances"];
      var EventInterface = {
        type: null,
        target: null,
        currentTarget: emptyFunction.thatReturnsNull,
        eventPhase: null,
        bubbles: null,
        cancelable: null,
        timeStamp: function timeStamp(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: null,
        isTrusted: null
      };

      function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
        {
          delete this.nativeEvent;
          delete this.preventDefault;
          delete this.stopPropagation;
        }
        this.dispatchConfig = dispatchConfig;
        this._targetInst = targetInst;
        this.nativeEvent = nativeEvent;
        var Interface = this.constructor.Interface;

        for (var propName in Interface) {
          if (!Interface.hasOwnProperty(propName)) {
            continue;
          }

          {
            delete this[propName];
          }
          var normalize = Interface[propName];

          if (normalize) {
            this[propName] = normalize(nativeEvent);
          } else {
            if (propName === "target") {
              this.target = nativeEventTarget;
            } else {
              this[propName] = nativeEvent[propName];
            }
          }
        }

        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

        if (defaultPrevented) {
          this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
        } else {
          this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
        }

        this.isPropagationStopped = emptyFunction.thatReturnsFalse;
        return this;
      }

      babelHelpers.extends(SyntheticEvent.prototype, {
        preventDefault: function preventDefault() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.preventDefault) {
            event.preventDefault();
          } else if (typeof event.returnValue !== "unknown") {
            event.returnValue = false;
          }

          this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
        },
        stopPropagation: function stopPropagation() {
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.stopPropagation) {
            event.stopPropagation();
          } else if (typeof event.cancelBubble !== "unknown") {
            event.cancelBubble = true;
          }

          this.isPropagationStopped = emptyFunction.thatReturnsTrue;
        },
        persist: function persist() {
          this.isPersistent = emptyFunction.thatReturnsTrue;
        },
        isPersistent: emptyFunction.thatReturnsFalse,
        destructor: function destructor() {
          var Interface = this.constructor.Interface;

          for (var propName in Interface) {
            {
              Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
            }
          }

          for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
            this[shouldBeReleasedProperties[i]] = null;
          }

          {
            Object.defineProperty(this, "nativeEvent", getPooledWarningPropertyDefinition("nativeEvent", null));
            Object.defineProperty(this, "preventDefault", getPooledWarningPropertyDefinition("preventDefault", emptyFunction));
            Object.defineProperty(this, "stopPropagation", getPooledWarningPropertyDefinition("stopPropagation", emptyFunction));
          }
        }
      });
      SyntheticEvent.Interface = EventInterface;

      SyntheticEvent.augmentClass = function (Class, Interface) {
        var Super = this;

        var E = function E() {};

        E.prototype = Super.prototype;
        var prototype = new E();
        babelHelpers.extends(prototype, Class.prototype);
        Class.prototype = prototype;
        Class.prototype.constructor = Class;
        Class.Interface = babelHelpers.extends({}, Super.Interface, Interface);
        Class.augmentClass = Super.augmentClass;
        addEventPoolingTo(Class);
      };

      {
        if (isProxySupported) {
          SyntheticEvent = new Proxy(SyntheticEvent, {
            construct: function construct(target, args) {
              return this.apply(target, Object.create(target.prototype), args);
            },
            apply: function apply(constructor, that, args) {
              return new Proxy(constructor.apply(that, args), {
                set: function set(target, prop, value) {
                  if (prop !== "isPersistent" && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
                    warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + "The property is never released. See " + "https://fb.me/react-event-pooling for more information.");
                    didWarnForAddedNewProperty = true;
                  }

                  target[prop] = value;
                  return true;
                }
              });
            }
          });
        }
      }
      addEventPoolingTo(SyntheticEvent);

      function getPooledWarningPropertyDefinition(propName, getVal) {
        var isFunction = typeof getVal === "function";
        return {
          configurable: true,
          set: set,
          get: get
        };

        function set(val) {
          var action = isFunction ? "setting the method" : "setting the property";
          warn(action, "This is effectively a no-op");
          return val;
        }

        function get() {
          var action = isFunction ? "accessing the method" : "accessing the property";
          var result = isFunction ? "This is a no-op function" : "This is set to null";
          warn(action, result);
          return getVal;
        }

        function warn(action, result) {
          var warningCondition = false;
          warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + "If you must keep the original synthetic event around, use event.persist(). " + "See https://fb.me/react-event-pooling for more information.", action, propName, result);
        }
      }

      function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
        var EventConstructor = this;

        if (EventConstructor.eventPool.length) {
          var instance = EventConstructor.eventPool.pop();
          EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
          return instance;
        }

        return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
      }

      function releasePooledEvent(event) {
        var EventConstructor = this;
        invariant(event instanceof EventConstructor, "Trying to release an event instance  into a pool of a different type.");
        event.destructor();

        if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
          EventConstructor.eventPool.push(event);
        }
      }

      function addEventPoolingTo(EventConstructor) {
        EventConstructor.eventPool = [];
        EventConstructor.getPooled = getPooledEvent;
        EventConstructor.release = releasePooledEvent;
      }

      var SyntheticEvent$1 = SyntheticEvent;
      var ResponderEventInterface = {
        touchHistory: function touchHistory(nativeEvent) {
          return null;
        }
      };

      function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
      }

      SyntheticEvent$1.augmentClass(ResponderSyntheticEvent, ResponderEventInterface);
      var MAX_TOUCH_BANK = 20;
      var touchBank = [];
      var touchHistory = {
        touchBank: touchBank,
        numberActiveTouches: 0,
        indexOfSingleActiveTouch: -1,
        mostRecentTimeStamp: 0
      };

      function timestampForTouch(touch) {
        return touch.timeStamp || touch.timestamp;
      }

      function createTouchRecord(touch) {
        return {
          touchActive: true,
          startPageX: touch.pageX,
          startPageY: touch.pageY,
          startTimeStamp: timestampForTouch(touch),
          currentPageX: touch.pageX,
          currentPageY: touch.pageY,
          currentTimeStamp: timestampForTouch(touch),
          previousPageX: touch.pageX,
          previousPageY: touch.pageY,
          previousTimeStamp: timestampForTouch(touch)
        };
      }

      function resetTouchRecord(touchRecord, touch) {
        touchRecord.touchActive = true;
        touchRecord.startPageX = touch.pageX;
        touchRecord.startPageY = touch.pageY;
        touchRecord.startTimeStamp = timestampForTouch(touch);
        touchRecord.currentPageX = touch.pageX;
        touchRecord.currentPageY = touch.pageY;
        touchRecord.currentTimeStamp = timestampForTouch(touch);
        touchRecord.previousPageX = touch.pageX;
        touchRecord.previousPageY = touch.pageY;
        touchRecord.previousTimeStamp = timestampForTouch(touch);
      }

      function getTouchIdentifier(_ref) {
        var identifier = _ref.identifier;
        invariant(identifier != null, "Touch object is missing identifier.");
        {
          warning(identifier <= MAX_TOUCH_BANK, "Touch identifier %s is greater than maximum supported %s which causes " + "performance issues backfilling array locations for all of the indices.", identifier, MAX_TOUCH_BANK);
        }
        return identifier;
      }

      function recordTouchStart(touch) {
        var identifier = getTouchIdentifier(touch);
        var touchRecord = touchBank[identifier];

        if (touchRecord) {
          resetTouchRecord(touchRecord, touch);
        } else {
          touchBank[identifier] = createTouchRecord(touch);
        }

        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
      }

      function recordTouchMove(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = true;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch move without a touch start.\n" + "Touch Move: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function recordTouchEnd(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = false;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch end without a touch start.\n" + "Touch End: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function printTouch(touch) {
        return JSON.stringify({
          identifier: touch.identifier,
          pageX: touch.pageX,
          pageY: touch.pageY,
          timestamp: timestampForTouch(touch)
        });
      }

      function printTouchBank() {
        var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));

        if (touchBank.length > MAX_TOUCH_BANK) {
          printed += " (original size: " + touchBank.length + ")";
        }

        return printed;
      }

      var ResponderTouchHistoryStore = {
        recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
          if (isMoveish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchMove);
          } else if (isStartish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchStart);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
            }
          } else if (isEndish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchEnd);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              for (var i = 0; i < touchBank.length; i++) {
                var touchTrackToCheck = touchBank[i];

                if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
                  touchHistory.indexOfSingleActiveTouch = i;
                  break;
                }
              }

              {
                var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
                warning(activeRecord != null && activeRecord.touchActive, "Cannot find single active touch.");
              }
            }
          }
        },
        touchHistory: touchHistory
      };

      function accumulate(current, next) {
        invariant(next != null, "accumulate(...): Accumulated items must be not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          return current.concat(next);
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      var responderInst = null;
      var trackedTouchCount = 0;
      var previousActiveTouches = 0;

      var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {
        var oldResponderInst = responderInst;
        responderInst = nextResponderInst;

        if (ResponderEventPlugin.GlobalResponderHandler !== null) {
          ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
        }
      };

      var eventTypes = {
        startShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onStartShouldSetResponder",
            captured: "onStartShouldSetResponderCapture"
          }
        },
        scrollShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onScrollShouldSetResponder",
            captured: "onScrollShouldSetResponderCapture"
          }
        },
        selectionChangeShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onSelectionChangeShouldSetResponder",
            captured: "onSelectionChangeShouldSetResponderCapture"
          }
        },
        moveShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onMoveShouldSetResponder",
            captured: "onMoveShouldSetResponderCapture"
          }
        },
        responderStart: {
          registrationName: "onResponderStart"
        },
        responderMove: {
          registrationName: "onResponderMove"
        },
        responderEnd: {
          registrationName: "onResponderEnd"
        },
        responderRelease: {
          registrationName: "onResponderRelease"
        },
        responderTerminationRequest: {
          registrationName: "onResponderTerminationRequest"
        },
        responderGrant: {
          registrationName: "onResponderGrant"
        },
        responderReject: {
          registrationName: "onResponderReject"
        },
        responderTerminate: {
          registrationName: "onResponderTerminate"
        }
      };

      function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === "topSelectionChange" ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;
        var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);
        var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
        var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
        shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;

        if (skipOverBubbleShouldSetFrom) {
          accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
        } else {
          accumulateTwoPhaseDispatches(shouldSetEvent);
        }

        var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);

        if (!shouldSetEvent.isPersistent()) {
          shouldSetEvent.constructor.release(shouldSetEvent);
        }

        if (!wantsResponderInst || wantsResponderInst === responderInst) {
          return null;
        }

        var extracted;
        var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);
        grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
        accumulateDirectDispatches(grantEvent);
        var blockHostResponder = executeDirectDispatch(grantEvent) === true;

        if (responderInst) {
          var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);
          terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(terminationRequestEvent);
          var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);

          if (!terminationRequestEvent.isPersistent()) {
            terminationRequestEvent.constructor.release(terminationRequestEvent);
          }

          if (shouldSwitch) {
            var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
            terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(terminateEvent);
            extracted = accumulate(extracted, [grantEvent, terminateEvent]);
            changeResponder(wantsResponderInst, blockHostResponder);
          } else {
            var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);
            rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(rejectEvent);
            extracted = accumulate(extracted, rejectEvent);
          }
        } else {
          extracted = accumulate(extracted, grantEvent);
          changeResponder(wantsResponderInst, blockHostResponder);
        }

        return extracted;
      }

      function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
        return topLevelInst && (topLevelType === "topScroll" && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === "topSelectionChange" || isStartish(topLevelType) || isMoveish(topLevelType));
      }

      function noResponderTouches(nativeEvent) {
        var touches = nativeEvent.touches;

        if (!touches || touches.length === 0) {
          return true;
        }

        for (var i = 0; i < touches.length; i++) {
          var activeTouch = touches[i];
          var target = activeTouch.target;

          if (target !== null && target !== undefined && target !== 0) {
            var targetInst = getInstanceFromNode(target);

            if (isAncestor(responderInst, targetInst)) {
              return false;
            }
          }
        }

        return true;
      }

      var ResponderEventPlugin = {
        _getResponder: function _getResponder() {
          return responderInst;
        },
        eventTypes: eventTypes,
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          if (isStartish(topLevelType)) {
            trackedTouchCount += 1;
          } else if (isEndish(topLevelType)) {
            if (trackedTouchCount >= 0) {
              trackedTouchCount -= 1;
            } else {
              console.error("Ended a touch event which was not counted in `trackedTouchCount`.");
              return null;
            }
          }

          ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);
          var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;
          var isResponderTouchStart = responderInst && isStartish(topLevelType);
          var isResponderTouchMove = responderInst && isMoveish(topLevelType);
          var isResponderTouchEnd = responderInst && isEndish(topLevelType);
          var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;

          if (incrementalTouch) {
            var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);
            gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(gesture);
            extracted = accumulate(extracted, gesture);
          }

          var isResponderTerminate = responderInst && topLevelType === "topTouchCancel";
          var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);
          var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;

          if (finalTouch) {
            var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);
            finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(finalEvent);
            extracted = accumulate(extracted, finalEvent);
            changeResponder(null);
          }

          var numberActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches;

          if (ResponderEventPlugin.GlobalInteractionHandler && numberActiveTouches !== previousActiveTouches) {
            ResponderEventPlugin.GlobalInteractionHandler.onChange(numberActiveTouches);
          }

          previousActiveTouches = numberActiveTouches;
          return extracted;
        },
        GlobalResponderHandler: null,
        GlobalInteractionHandler: null,
        injection: {
          injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
            ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
          },
          injectGlobalInteractionHandler: function injectGlobalInteractionHandler(GlobalInteractionHandler) {
            ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;
          }
        }
      };
      var customBubblingEventTypes = {};
      var customDirectEventTypes = {};
      var ReactNativeBridgeEventPlugin = {
        eventTypes: {},
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          var bubbleDispatchConfig = customBubblingEventTypes[topLevelType];
          var directDispatchConfig = customDirectEventTypes[topLevelType];
          invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type "%s" dispatched', topLevelType);
          var event = SyntheticEvent$1.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);

          if (bubbleDispatchConfig) {
            accumulateTwoPhaseDispatches(event);
          } else if (directDispatchConfig) {
            accumulateDirectDispatches(event);
          } else {
            return null;
          }

          return event;
        },
        processEventTypes: function processEventTypes(viewConfig) {
          var bubblingEventTypes = viewConfig.bubblingEventTypes,
              directEventTypes = viewConfig.directEventTypes;
          {
            if (bubblingEventTypes != null && directEventTypes != null) {
              for (var topLevelType in directEventTypes) {
                invariant(bubblingEventTypes[topLevelType] == null, "Event cannot be both direct and bubbling: %s", topLevelType);
              }
            }
          }

          if (bubblingEventTypes != null) {
            for (var _topLevelType in bubblingEventTypes) {
              if (customBubblingEventTypes[_topLevelType] == null) {
                ReactNativeBridgeEventPlugin.eventTypes[_topLevelType] = customBubblingEventTypes[_topLevelType] = bubblingEventTypes[_topLevelType];
              }
            }
          }

          if (directEventTypes != null) {
            for (var _topLevelType2 in directEventTypes) {
              if (customDirectEventTypes[_topLevelType2] == null) {
                ReactNativeBridgeEventPlugin.eventTypes[_topLevelType2] = customDirectEventTypes[_topLevelType2] = directEventTypes[_topLevelType2];
              }
            }
          }
        }
      };
      var instanceCache = {};
      var instanceProps = {};

      function precacheFiberNode(hostInst, tag) {
        instanceCache[tag] = hostInst;
      }

      function uncacheFiberNode(tag) {
        delete instanceCache[tag];
        delete instanceProps[tag];
      }

      function getInstanceFromTag(tag) {
        return instanceCache[tag] || null;
      }

      function getTagFromInstance(inst) {
        var tag = inst.stateNode._nativeTag;
        invariant(tag, "All native instances should have a tag.");
        return tag;
      }

      function getFiberCurrentPropsFromNode$1(stateNode) {
        return instanceProps[stateNode._nativeTag] || null;
      }

      function updateFiberProps(tag, props) {
        instanceProps[tag] = props;
      }

      var ReactNativeComponentTree = Object.freeze({
        precacheFiberNode: precacheFiberNode,
        uncacheFiberNode: uncacheFiberNode,
        getClosestInstanceFromNode: getInstanceFromTag,
        getInstanceFromNode: getInstanceFromTag,
        getNodeFromInstance: getTagFromInstance,
        getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
        updateFiberProps: updateFiberProps
      });
      var fiberHostComponent = null;
      var restoreTarget = null;
      var restoreQueue = null;

      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);

        if (!internalInstance) {
          return;
        }

        invariant(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === "function", "Fiber needs to be injected to handle a fiber target for controlled " + "events. This error is likely caused by a bug in React. Please file an issue.");
        var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
        fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
      }

      function restoreStateIfNeeded() {
        if (!restoreTarget) {
          return;
        }

        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);

        if (queuedTargets) {
          for (var i = 0; i < queuedTargets.length; i++) {
            restoreStateOfTarget(queuedTargets[i]);
          }
        }
      }

      var fiberBatchedUpdates = function fiberBatchedUpdates(fn, bookkeeping) {
        return fn(bookkeeping);
      };

      var isNestingBatched = false;

      function batchedUpdates(fn, bookkeeping) {
        if (isNestingBatched) {
          return fiberBatchedUpdates(fn, bookkeeping);
        }

        isNestingBatched = true;

        try {
          return fiberBatchedUpdates(fn, bookkeeping);
        } finally {
          isNestingBatched = false;
          restoreStateIfNeeded();
        }
      }

      var ReactGenericBatchingInjection = {
        injectFiberBatchedUpdates: function injectFiberBatchedUpdates(_batchedUpdates) {
          fiberBatchedUpdates = _batchedUpdates;
        }
      };
      var injection$2 = ReactGenericBatchingInjection;

      function runEventQueueInBatch(events) {
        enqueueEvents(events);
        processEventQueue(false);
      }

      function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        runEventQueueInBatch(events);
      }

      var INITIAL_TAG_COUNT = 1;
      var ReactNativeTagHandles = {
        tagsStartAt: INITIAL_TAG_COUNT,
        tagCount: INITIAL_TAG_COUNT,
        allocateTag: function allocateTag() {
          while (this.reactTagIsNativeTopRootID(ReactNativeTagHandles.tagCount)) {
            ReactNativeTagHandles.tagCount++;
          }

          var tag = ReactNativeTagHandles.tagCount;
          ReactNativeTagHandles.tagCount++;
          return tag;
        },
        assertRootTag: function assertRootTag(tag) {
          invariant(this.reactTagIsNativeTopRootID(tag), "Expect a native root tag, instead got %s", tag);
        },
        reactTagIsNativeTopRootID: function reactTagIsNativeTopRootID(reactTag) {
          return reactTag % 10 === 1;
        }
      };
      var EMPTY_NATIVE_EVENT = {};

      var touchSubsequence = function touchSubsequence(touches, indices) {
        var ret = [];

        for (var i = 0; i < indices.length; i++) {
          ret.push(touches[indices[i]]);
        }

        return ret;
      };

      var removeTouchesAtIndices = function removeTouchesAtIndices(touches, indices) {
        var rippedOut = [];
        var temp = touches;

        for (var i = 0; i < indices.length; i++) {
          var index = indices[i];
          rippedOut.push(touches[index]);
          temp[index] = null;
        }

        var fillAt = 0;

        for (var j = 0; j < temp.length; j++) {
          var cur = temp[j];

          if (cur !== null) {
            temp[fillAt++] = cur;
          }
        }

        temp.length = fillAt;
        return rippedOut;
      };

      function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
        var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;
        var inst = getInstanceFromTag(rootNodeID);
        batchedUpdates(function () {
          handleTopLevel(topLevelType, inst, nativeEvent, nativeEvent.target);
        });
      }

      function receiveEvent(rootNodeID, topLevelType, nativeEventParam) {
        _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);
      }

      function receiveTouches(eventTopLevelType, touches, changedIndices) {
        var changedTouches = eventTopLevelType === "topTouchEnd" || eventTopLevelType === "topTouchCancel" ? removeTouchesAtIndices(touches, changedIndices) : touchSubsequence(touches, changedIndices);

        for (var jj = 0; jj < changedTouches.length; jj++) {
          var touch = changedTouches[jj];
          touch.changedTouches = changedTouches;
          touch.touches = touches;
          var nativeEvent = touch;
          var rootNodeID = null;
          var target = nativeEvent.target;

          if (target !== null && target !== undefined) {
            if (target < ReactNativeTagHandles.tagsStartAt) {
              {
                warning(false, "A view is reporting that a touch occurred on tag zero.");
              }
            } else {
              rootNodeID = target;
            }
          }

          _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);
        }
      }

      var ReactNativeEventEmitter = Object.freeze({
        getListener: getListener,
        registrationNames: registrationNameModules,
        _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,
        receiveEvent: receiveEvent,
        receiveTouches: receiveTouches,
        handleTopLevel: handleTopLevel
      });
      var ReactNativeEventPluginOrder = ["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"];
      var ReactNativeGlobalResponderHandler = {
        onChange: function onChange(from, to, blockNativeResponder) {
          if (to !== null) {
            var tag = to.stateNode._nativeTag;
            UIManager.setJSResponder(tag, blockNativeResponder);
          } else {
            UIManager.clearJSResponder();
          }
        }
      };
      RCTEventEmitter.register(ReactNativeEventEmitter);
      injection.injectEventPluginOrder(ReactNativeEventPluginOrder);
      injection$1.injectComponentTree(ReactNativeComponentTree);
      ResponderEventPlugin.injection.injectGlobalResponderHandler(ReactNativeGlobalResponderHandler);
      injection.injectEventPluginsByName({
        ResponderEventPlugin: ResponderEventPlugin,
        ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin
      });

      var defaultShowDialog = function defaultShowDialog(capturedError) {
        return true;
      };

      var showDialog = defaultShowDialog;

      function logCapturedError(capturedError) {
        var logError = showDialog(capturedError);

        if (logError === false) {
          return;
        }

        var error = capturedError.error;
        var suppressLogging = error && error.suppressReactErrorLogging;

        if (suppressLogging) {
          return;
        }

        {
          var componentName = capturedError.componentName,
              componentStack = capturedError.componentStack,
              errorBoundaryName = capturedError.errorBoundaryName,
              errorBoundaryFound = capturedError.errorBoundaryFound,
              willRetry = capturedError.willRetry;
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
          var errorBoundaryMessage = void 0;

          if (errorBoundaryFound && errorBoundaryName) {
            if (willRetry) {
              errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            } else {
              errorBoundaryMessage = "This error was initially handled by the error boundary " + errorBoundaryName + ".\n" + "Recreating the tree from scratch failed so React will unmount the tree.";
            }
          } else {
            errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\n" + "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
          }

          var combinedMessage = "" + componentNameMessage + componentStack + "\n\n" + ("" + errorBoundaryMessage);
          console.error(combinedMessage);
        }
      }

      var injection$4 = {
        injectDialog: function injectDialog(fn) {
          invariant(showDialog === defaultShowDialog, "The custom dialog was already injected.");
          invariant(typeof fn === "function", "Injected showDialog() must be a function.");
          showDialog = fn;
        }
      };
      var hasSymbol = typeof Symbol === "function" && Symbol["for"];
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol["for"]("react.element") : 0xeac7;
      var REACT_CALL_TYPE = hasSymbol ? Symbol["for"]("react.call") : 0xeac8;
      var REACT_RETURN_TYPE = hasSymbol ? Symbol["for"]("react.return") : 0xeac9;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol["for"]("react.portal") : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol["for"]("react.fragment") : 0xeacb;
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");
      var FAUX_ITERATOR_SYMBOL = "@@iterator";

      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable === "undefined") {
          return null;
        }

        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }

        return null;
      }

      function _createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children: children,
          containerInfo: containerInfo,
          implementation: implementation
        };
      }

      var TouchHistoryMath = {
        centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
          var touchBank = touchHistory.touchBank;
          var total = 0;
          var count = 0;
          var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;

          if (oneTouchData !== null) {
            if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {
              total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
              count = 1;
            }
          } else {
            for (var i = 0; i < touchBank.length; i++) {
              var touchTrack = touchBank[i];

              if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
                var toAdd;

                if (ofCurrent && isXAxis) {
                  toAdd = touchTrack.currentPageX;
                } else if (ofCurrent && !isXAxis) {
                  toAdd = touchTrack.currentPageY;
                } else if (!ofCurrent && isXAxis) {
                  toAdd = touchTrack.previousPageX;
                } else {
                  toAdd = touchTrack.previousPageY;
                }

                total += toAdd;
                count++;
              }
            }
          }

          return count > 0 ? total / count : TouchHistoryMath.noCentroid;
        },
        currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
          return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, true);
        },
        currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
          return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, true);
        },
        previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
          return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, false);
        },
        previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
          return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, false);
        },
        currentCentroidX: function currentCentroidX(touchHistory) {
          return TouchHistoryMath.centroidDimension(touchHistory, 0, true, true);
        },
        currentCentroidY: function currentCentroidY(touchHistory) {
          return TouchHistoryMath.centroidDimension(touchHistory, 0, false, true);
        },
        noCentroid: -1
      };
      var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;
      var ReactGlobalSharedState = Object.freeze({
        ReactCurrentOwner: ReactCurrentOwner,
        ReactDebugCurrentFrame: ReactDebugCurrentFrame
      });
      var ReactVersion = "16.2.0";

      function showDialog$1(capturedError) {
        var componentStack = capturedError.componentStack,
            error = capturedError.error;
        var errorToHandle = void 0;

        if (error instanceof Error) {
          var message = error.message,
              name = error.name;
          var summary = message ? name + ": " + message : name;
          errorToHandle = error;

          try {
            errorToHandle.message = summary + "\n\nThis error is located at:" + componentStack;
          } catch (e) {}
        } else if (typeof error === "string") {
          errorToHandle = new Error(error + "\n\nThis error is located at:" + componentStack);
        } else {
          errorToHandle = new Error("Unspecified error at:" + componentStack);
        }

        ExceptionsManager.handleException(errorToHandle, false);
        return false;
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var objects = {};
      var uniqueID = 1;
      var emptyObject$2 = {};

      var ReactNativePropRegistry = function () {
        function ReactNativePropRegistry() {
          _classCallCheck(this, ReactNativePropRegistry);
        }

        ReactNativePropRegistry.register = function register(object) {
          var id = ++uniqueID;
          {
            Object.freeze(object);
          }
          objects[id] = object;
          return id;
        };

        ReactNativePropRegistry.getByID = function getByID(id) {
          if (!id) {
            return emptyObject$2;
          }

          var object = objects[id];

          if (!object) {
            console.warn("Invalid style with id `" + id + "`. Skipping ...");
            return emptyObject$2;
          }

          return object;
        };

        return ReactNativePropRegistry;
      }();

      var emptyObject$1 = {};
      var removedKeys = null;
      var removedKeyCount = 0;

      function defaultDiffer(prevProp, nextProp) {
        if (typeof nextProp !== "object" || nextProp === null) {
          return true;
        } else {
          return deepDiffer(prevProp, nextProp);
        }
      }

      function resolveObject(idOrObject) {
        if (typeof idOrObject === "number") {
          return ReactNativePropRegistry.getByID(idOrObject);
        }

        return idOrObject;
      }

      function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
        if (Array.isArray(node)) {
          var i = node.length;

          while (i-- && removedKeyCount > 0) {
            restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
          }
        } else if (node && removedKeyCount > 0) {
          var obj = resolveObject(node);

          for (var propKey in removedKeys) {
            if (!removedKeys[propKey]) {
              continue;
            }

            var nextProp = obj[propKey];

            if (nextProp === undefined) {
              continue;
            }

            var attributeConfig = validAttributes[propKey];

            if (!attributeConfig) {
              continue;
            }

            if (typeof nextProp === "function") {
              nextProp = true;
            }

            if (typeof nextProp === "undefined") {
              nextProp = null;
            }

            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            removedKeys[propKey] = false;
            removedKeyCount--;
          }
        }
      }

      function diffNestedArrayProperty(updatePayload, prevArray, nextArray, validAttributes) {
        var minLength = prevArray.length < nextArray.length ? prevArray.length : nextArray.length;
        var i;

        for (i = 0; i < minLength; i++) {
          updatePayload = diffNestedProperty(updatePayload, prevArray[i], nextArray[i], validAttributes);
        }

        for (; i < prevArray.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevArray[i], validAttributes);
        }

        for (; i < nextArray.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextArray[i], validAttributes);
        }

        return updatePayload;
      }

      function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
        if (!updatePayload && prevProp === nextProp) {
          return updatePayload;
        }

        if (!prevProp || !nextProp) {
          if (nextProp) {
            return addNestedProperty(updatePayload, nextProp, validAttributes);
          }

          if (prevProp) {
            return clearNestedProperty(updatePayload, prevProp, validAttributes);
          }

          return updatePayload;
        }

        if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {
          return diffProperties(updatePayload, resolveObject(prevProp), resolveObject(nextProp), validAttributes);
        }

        if (Array.isArray(prevProp) && Array.isArray(nextProp)) {
          return diffNestedArrayProperty(updatePayload, prevProp, nextProp, validAttributes);
        }

        if (Array.isArray(prevProp)) {
          return diffProperties(updatePayload, flattenStyle(prevProp), resolveObject(nextProp), validAttributes);
        }

        return diffProperties(updatePayload, resolveObject(prevProp), flattenStyle(nextProp), validAttributes);
      }

      function addNestedProperty(updatePayload, nextProp, validAttributes) {
        if (!nextProp) {
          return updatePayload;
        }

        if (!Array.isArray(nextProp)) {
          return addProperties(updatePayload, resolveObject(nextProp), validAttributes);
        }

        for (var i = 0; i < nextProp.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
        }

        return updatePayload;
      }

      function clearNestedProperty(updatePayload, prevProp, validAttributes) {
        if (!prevProp) {
          return updatePayload;
        }

        if (!Array.isArray(prevProp)) {
          return clearProperties(updatePayload, resolveObject(prevProp), validAttributes);
        }

        for (var i = 0; i < prevProp.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
        }

        return updatePayload;
      }

      function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
        var attributeConfig;
        var nextProp;
        var prevProp;

        for (var propKey in nextProps) {
          attributeConfig = validAttributes[propKey];

          if (!attributeConfig) {
            continue;
          }

          prevProp = prevProps[propKey];
          nextProp = nextProps[propKey];

          if (typeof nextProp === "function") {
            nextProp = true;

            if (typeof prevProp === "function") {
              prevProp = true;
            }
          }

          if (typeof nextProp === "undefined") {
            nextProp = null;

            if (typeof prevProp === "undefined") {
              prevProp = null;
            }
          }

          if (removedKeys) {
            removedKeys[propKey] = false;
          }

          if (updatePayload && updatePayload[propKey] !== undefined) {
            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            continue;
          }

          if (prevProp === nextProp) {
            continue;
          }

          if (typeof attributeConfig !== "object") {
            if (defaultDiffer(prevProp, nextProp)) {
              (updatePayload || (updatePayload = {}))[propKey] = nextProp;
            }
          } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            var shouldUpdate = prevProp === undefined || (typeof attributeConfig.diff === "function" ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp));

            if (shouldUpdate) {
              nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              (updatePayload || (updatePayload = {}))[propKey] = nextValue;
            }
          } else {
            removedKeys = null;
            removedKeyCount = 0;
            updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig);

            if (removedKeyCount > 0 && updatePayload) {
              restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig);
              removedKeys = null;
            }
          }
        }

        for (propKey in prevProps) {
          if (nextProps[propKey] !== undefined) {
            continue;
          }

          attributeConfig = validAttributes[propKey];

          if (!attributeConfig) {
            continue;
          }

          if (updatePayload && updatePayload[propKey] !== undefined) {
            continue;
          }

          prevProp = prevProps[propKey];

          if (prevProp === undefined) {
            continue;
          }

          if (typeof attributeConfig !== "object" || typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            (updatePayload || (updatePayload = {}))[propKey] = null;

            if (!removedKeys) {
              removedKeys = {};
            }

            if (!removedKeys[propKey]) {
              removedKeys[propKey] = true;
              removedKeyCount++;
            }
          } else {
            updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig);
          }
        }

        return updatePayload;
      }

      function addProperties(updatePayload, props, validAttributes) {
        return diffProperties(updatePayload, emptyObject$1, props, validAttributes);
      }

      function clearProperties(updatePayload, prevProps, validAttributes) {
        return diffProperties(updatePayload, prevProps, emptyObject$1, validAttributes);
      }

      function create(props, validAttributes) {
        return addProperties(null, props, validAttributes);
      }

      function diff(prevProps, nextProps, validAttributes) {
        return diffProperties(null, prevProps, nextProps, validAttributes);
      }

      function mountSafeCallback(context, callback) {
        return function () {
          if (!callback) {
            return undefined;
          }

          if (typeof context.__isMounted === "boolean") {
            if (!context.__isMounted) {
              return undefined;
            }
          } else if (typeof context.isMounted === "function") {
            if (!context.isMounted()) {
              return undefined;
            }
          }

          return callback.apply(context, arguments);
        };
      }

      function throwOnStylesProp(component, props) {
        if (props.styles !== undefined) {
          var owner = component._owner || null;
          var name = component.constructor.displayName;
          var msg = "`styles` is not a supported property of `" + name + "`, did " + "you mean `style` (singular)?";

          if (owner && owner.constructor && owner.constructor.displayName) {
            msg += "\n\nCheck the `" + owner.constructor.displayName + "` parent " + " component.";
          }

          throw new Error(msg);
        }
      }

      function warnForStyleProps(props, validAttributes) {
        for (var key in validAttributes.style) {
          if (!(validAttributes[key] || props[key] === undefined)) {
            console.error("You are setting the style `{ " + key + ": ... }` as a prop. You " + "should nest it in a style object. " + "E.g. `{ style: { " + key + ": ... } }`");
          }
        }
      }

      function get(key) {
        return key._reactInternalFiber;
      }

      function set(key, value) {
        key._reactInternalFiber = value;
      }

      function getComponentName(fiber) {
        var type = fiber.type;

        if (typeof type === "string") {
          return type;
        }

        if (typeof type === "function") {
          return type.displayName || type.name;
        }

        return null;
      }

      var _require = require(_dependencyMap[15], "ReactFeatureFlags");

      var debugRenderPhaseSideEffects = _require.debugRenderPhaseSideEffects;
      var enableAsyncSubtreeAPI = true;
      var enableUserTimingAPI = true;
      var enableMutatingReconciler = true;
      var enableNoopReconciler = false;
      var enablePersistentReconciler = false;
      var NoEffect = 0;
      var PerformedWork = 1;
      var Placement = 2;
      var Update = 4;
      var PlacementAndUpdate = 6;
      var Deletion = 8;
      var ContentReset = 16;
      var Callback = 32;
      var Err = 64;
      var Ref = 128;
      var MOUNTING = 1;
      var MOUNTED = 2;
      var UNMOUNTED = 3;

      function isFiberMountedImpl(fiber) {
        var node = fiber;

        if (!fiber.alternate) {
          if ((node.effectTag & Placement) !== NoEffect) {
            return MOUNTING;
          }

          while (node["return"]) {
            node = node["return"];

            if ((node.effectTag & Placement) !== NoEffect) {
              return MOUNTING;
            }
          }
        } else {
          while (node["return"]) {
            node = node["return"];
          }
        }

        if (node.tag === HostRoot) {
          return MOUNTED;
        }

        return UNMOUNTED;
      }

      function isFiberMounted(fiber) {
        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function isMounted(component) {
        {
          var owner = ReactCurrentOwner.current;

          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            warning(instance._warnedAboutRefsInRender, "%s is accessing isMounted inside its render() function. " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(ownerFiber) || "A component");
            instance._warnedAboutRefsInRender = true;
          }
        }
        var fiber = get(component);

        if (!fiber) {
          return false;
        }

        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function assertIsMounted(fiber) {
        invariant(isFiberMountedImpl(fiber) === MOUNTED, "Unable to find node on an unmounted component.");
      }

      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;

        if (!alternate) {
          var state = isFiberMountedImpl(fiber);
          invariant(state !== UNMOUNTED, "Unable to find node on an unmounted component.");

          if (state === MOUNTING) {
            return null;
          }

          return fiber;
        }

        var a = fiber;
        var b = alternate;

        while (true) {
          var parentA = a["return"];
          var parentB = parentA ? parentA.alternate : null;

          if (!parentA || !parentB) {
            break;
          }

          if (parentA.child === parentB.child) {
            var child = parentA.child;

            while (child) {
              if (child === a) {
                assertIsMounted(parentA);
                return fiber;
              }

              if (child === b) {
                assertIsMounted(parentA);
                return alternate;
              }

              child = child.sibling;
            }

            invariant(false, "Unable to find node on an unmounted component.");
          }

          if (a["return"] !== b["return"]) {
            a = parentA;
            b = parentB;
          } else {
            var didFindChild = false;
            var _child = parentA.child;

            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }

              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }

              _child = _child.sibling;
            }

            if (!didFindChild) {
              _child = parentB.child;

              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }

                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }

                _child = _child.sibling;
              }

              invariant(didFindChild, "Child was not found in either parent set. This indicates a bug " + "in React related to the return pointer. Please file an issue.");
            }
          }

          invariant(a.alternate === b, "Return fibers should always be each others' alternates. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        invariant(a.tag === HostRoot, "Unable to find node on an unmounted component.");

        if (a.stateNode.current === a) {
          return fiber;
        }

        return alternate;
      }

      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);

        if (!currentParent) {
          return null;
        }

        var node = currentParent;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          } else if (node.child) {
            node.child["return"] = node;
            node = node.child;
            continue;
          }

          if (node === currentParent) {
            return null;
          }

          while (!node.sibling) {
            if (!node["return"] || node["return"] === currentParent) {
              return null;
            }

            node = node["return"];
          }

          node.sibling["return"] = node["return"];
          node = node.sibling;
        }

        return null;
      }

      function findCurrentHostFiberWithNoPortals(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);

        if (!currentParent) {
          return null;
        }

        var node = currentParent;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          } else if (node.child && node.tag !== HostPortal) {
            node.child["return"] = node;
            node = node.child;
            continue;
          }

          if (node === currentParent) {
            return null;
          }

          while (!node.sibling) {
            if (!node["return"] || node["return"] === currentParent) {
              return null;
            }

            node = node["return"];
          }

          node.sibling["return"] = node["return"];
          node = node.sibling;
        }

        return null;
      }

      var valueStack = [];
      {
        var fiberStack = [];
      }
      var index = -1;

      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }

      function pop(cursor, fiber) {
        if (index < 0) {
          {
            warning(false, "Unexpected pop.");
          }
          return;
        }

        {
          if (fiber !== fiberStack[index]) {
            warning(false, "Unexpected Fiber popped.");
          }
        }
        cursor.current = valueStack[index];
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }

      function push(cursor, value, fiber) {
        index++;
        valueStack[index] = cursor.current;
        {
          fiberStack[index] = fiber;
        }
        cursor.current = value;
      }

      function reset() {
        while (index > -1) {
          valueStack[index] = null;
          {
            fiberStack[index] = null;
          }
          index--;
        }
      }

      var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
        return "\n    in " + (name || "Unknown") + (source ? " (at " + source.fileName.replace(/^.*[\\\/]/, "") + ":" + source.lineNumber + ")" : ownerName ? " (created by " + ownerName + ")" : "");
      };

      function describeFiber(fiber) {
        switch (fiber.tag) {
          case IndeterminateComponent:
          case FunctionalComponent:
          case ClassComponent:
          case HostComponent:
            var owner = fiber._debugOwner;
            var source = fiber._debugSource;
            var name = getComponentName(fiber);
            var ownerName = null;

            if (owner) {
              ownerName = getComponentName(owner);
            }

            return describeComponentFrame(name, source, ownerName);

          default:
            return "";
        }
      }

      function getStackAddendumByWorkInProgressFiber(workInProgress) {
        var info = "";
        var node = workInProgress;

        do {
          info += describeFiber(node);
          node = node["return"];
        } while (node);

        return info;
      }

      function getCurrentFiberOwnerName() {
        {
          var fiber = ReactDebugCurrentFiber.current;

          if (fiber === null) {
            return null;
          }

          var owner = fiber._debugOwner;

          if (owner !== null && typeof owner !== "undefined") {
            return getComponentName(owner);
          }
        }
        return null;
      }

      function getCurrentFiberStackAddendum() {
        {
          var fiber = ReactDebugCurrentFiber.current;

          if (fiber === null) {
            return null;
          }

          return getStackAddendumByWorkInProgressFiber(fiber);
        }
        return null;
      }

      function resetCurrentFiber() {
        ReactDebugCurrentFrame.getCurrentStack = null;
        ReactDebugCurrentFiber.current = null;
        ReactDebugCurrentFiber.phase = null;
      }

      function setCurrentFiber(fiber) {
        ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
        ReactDebugCurrentFiber.current = fiber;
        ReactDebugCurrentFiber.phase = null;
      }

      function setCurrentPhase(phase) {
        ReactDebugCurrentFiber.phase = phase;
      }

      var ReactDebugCurrentFiber = {
        current: null,
        phase: null,
        resetCurrentFiber: resetCurrentFiber,
        setCurrentFiber: setCurrentFiber,
        setCurrentPhase: setCurrentPhase,
        getCurrentFiberOwnerName: getCurrentFiberOwnerName,
        getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
      };
      var reactEmoji = "\u269B";
      var warningEmoji = "\u26D4";
      var supportsUserTiming = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function" && typeof performance.measure === "function" && typeof performance.clearMeasures === "function";
      var currentFiber = null;
      var currentPhase = null;
      var currentPhaseFiber = null;
      var isCommitting = false;
      var hasScheduledUpdateInCurrentCommit = false;
      var hasScheduledUpdateInCurrentPhase = false;
      var commitCountInCurrentWorkLoop = 0;
      var effectCountInCurrentCommit = 0;
      var isWaitingForCallback = false;
      var labelsInCurrentCommit = new Set();

      var formatMarkName = function formatMarkName(markName) {
        return reactEmoji + " " + markName;
      };

      var formatLabel = function formatLabel(label, warning$$1) {
        var prefix = warning$$1 ? warningEmoji + " " : reactEmoji + " ";
        var suffix = warning$$1 ? " Warning: " + warning$$1 : "";
        return "" + prefix + label + suffix;
      };

      var beginMark = function beginMark(markName) {
        performance.mark(formatMarkName(markName));
      };

      var clearMark = function clearMark(markName) {
        performance.clearMarks(formatMarkName(markName));
      };

      var endMark = function endMark(label, markName, warning$$1) {
        var formattedMarkName = formatMarkName(markName);
        var formattedLabel = formatLabel(label, warning$$1);

        try {
          performance.measure(formattedLabel, formattedMarkName);
        } catch (err) {}

        performance.clearMarks(formattedMarkName);
        performance.clearMeasures(formattedLabel);
      };

      var getFiberMarkName = function getFiberMarkName(label, debugID) {
        return label + " (#" + debugID + ")";
      };

      var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {
        if (phase === null) {
          return componentName + " [" + (isMounted ? "update" : "mount") + "]";
        } else {
          return componentName + "." + phase;
        }
      };

      var beginFiberMark = function beginFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);

        if (isCommitting && labelsInCurrentCommit.has(label)) {
          return false;
        }

        labelsInCurrentCommit.add(label);
        var markName = getFiberMarkName(label, debugID);
        beginMark(markName);
        return true;
      };

      var clearFiberMark = function clearFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        clearMark(markName);
      };

      var endFiberMark = function endFiberMark(fiber, phase, warning$$1) {
        var componentName = getComponentName(fiber) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        endMark(label, markName, warning$$1);
      };

      var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {
        switch (fiber.tag) {
          case HostRoot:
          case HostComponent:
          case HostText:
          case HostPortal:
          case ReturnComponent:
          case Fragment:
            return true;

          default:
            return false;
        }
      };

      var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
        if (currentPhase !== null && currentPhaseFiber !== null) {
          clearFiberMark(currentPhaseFiber, currentPhase);
        }

        currentPhaseFiber = null;
        currentPhase = null;
        hasScheduledUpdateInCurrentPhase = false;
      };

      var pauseTimers = function pauseTimers() {
        var fiber = currentFiber;

        while (fiber) {
          if (fiber._debugIsCurrentlyTiming) {
            endFiberMark(fiber, null, null);
          }

          fiber = fiber["return"];
        }
      };

      var resumeTimersRecursively = function resumeTimersRecursively(fiber) {
        if (fiber["return"] !== null) {
          resumeTimersRecursively(fiber["return"]);
        }

        if (fiber._debugIsCurrentlyTiming) {
          beginFiberMark(fiber, null);
        }
      };

      var resumeTimers = function resumeTimers() {
        if (currentFiber !== null) {
          resumeTimersRecursively(currentFiber);
        }
      };

      function recordEffect() {
        if (enableUserTimingAPI) {
          effectCountInCurrentCommit++;
        }
      }

      function recordScheduleUpdate() {
        if (enableUserTimingAPI) {
          if (isCommitting) {
            hasScheduledUpdateInCurrentCommit = true;
          }

          if (currentPhase !== null && currentPhase !== "componentWillMount" && currentPhase !== "componentWillReceiveProps") {
            hasScheduledUpdateInCurrentPhase = true;
          }
        }
      }

      function startRequestCallbackTimer() {
        if (enableUserTimingAPI) {
          if (supportsUserTiming && !isWaitingForCallback) {
            isWaitingForCallback = true;
            beginMark("(Waiting for async callback...)");
          }
        }
      }

      function stopRequestCallbackTimer(didExpire) {
        if (enableUserTimingAPI) {
          if (supportsUserTiming) {
            isWaitingForCallback = false;
            var warning$$1 = didExpire ? "React was blocked by main thread" : null;
            endMark("(Waiting for async callback...)", "(Waiting for async callback...)", warning$$1);
          }
        }
      }

      function startWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber;

          if (!beginFiberMark(fiber, null)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = true;
        }
      }

      function cancelWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          clearFiberMark(fiber, null);
        }
      }

      function stopWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber["return"];

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          endFiberMark(fiber, null, null);
        }
      }

      function stopFailedWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber["return"];

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          var warning$$1 = "An error was thrown inside this error boundary";
          endFiberMark(fiber, null, warning$$1);
        }
      }

      function startPhaseTimer(fiber, phase) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          clearPendingPhaseMeasurement();

          if (!beginFiberMark(fiber, phase)) {
            return;
          }

          currentPhaseFiber = fiber;
          currentPhase = phase;
        }
      }

      function stopPhaseTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          if (currentPhase !== null && currentPhaseFiber !== null) {
            var warning$$1 = hasScheduledUpdateInCurrentPhase ? "Scheduled a cascading update" : null;
            endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
          }

          currentPhase = null;
          currentPhaseFiber = null;
        }
      }

      function startWorkLoopTimer(nextUnitOfWork) {
        if (enableUserTimingAPI) {
          currentFiber = nextUnitOfWork;

          if (!supportsUserTiming) {
            return;
          }

          commitCountInCurrentWorkLoop = 0;
          beginMark("(React Tree Reconciliation)");
          resumeTimers();
        }
      }

      function stopWorkLoopTimer(interruptedBy) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning$$1 = null;

          if (interruptedBy !== null) {
            if (interruptedBy.tag === HostRoot) {
              warning$$1 = "A top-level update interrupted the previous render";
            } else {
              var componentName = getComponentName(interruptedBy) || "Unknown";
              warning$$1 = "An update to " + componentName + " interrupted the previous render";
            }
          } else if (commitCountInCurrentWorkLoop > 1) {
            warning$$1 = "There were cascading updates";
          }

          commitCountInCurrentWorkLoop = 0;
          pauseTimers();
          endMark("(React Tree Reconciliation)", "(React Tree Reconciliation)", warning$$1);
        }
      }

      function startCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          isCommitting = true;
          hasScheduledUpdateInCurrentCommit = false;
          labelsInCurrentCommit.clear();
          beginMark("(Committing Changes)");
        }
      }

      function stopCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning$$1 = null;

          if (hasScheduledUpdateInCurrentCommit) {
            warning$$1 = "Lifecycle hook scheduled a cascading update";
          } else if (commitCountInCurrentWorkLoop > 0) {
            warning$$1 = "Caused by a cascading update in earlier commit";
          }

          hasScheduledUpdateInCurrentCommit = false;
          commitCountInCurrentWorkLoop++;
          isCommitting = false;
          labelsInCurrentCommit.clear();
          endMark("(Committing Changes)", "(Committing Changes)", warning$$1);
        }
      }

      function startCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Committing Host Effects)");
        }
      }

      function stopCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Committing Host Effects: " + count + " Total)", "(Committing Host Effects)", null);
        }
      }

      function startCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Calling Lifecycle Methods)");
        }
      }

      function stopCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Calling Lifecycle Methods: " + count + " Total)", "(Calling Lifecycle Methods)", null);
        }
      }

      {
        var warnedAboutMissingGetChildContext = {};
      }
      var contextStackCursor = createCursor(emptyObject);
      var didPerformWorkStackCursor = createCursor(false);
      var previousContext = emptyObject;

      function getUnmaskedContext(workInProgress) {
        var hasOwnContext = isContextProvider(workInProgress);

        if (hasOwnContext) {
          return previousContext;
        }

        return contextStackCursor.current;
      }

      function cacheContext(workInProgress, unmaskedContext, maskedContext) {
        var instance = workInProgress.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
      }

      function getMaskedContext(workInProgress, unmaskedContext) {
        var type = workInProgress.type;
        var contextTypes = type.contextTypes;

        if (!contextTypes) {
          return emptyObject;
        }

        var instance = workInProgress.stateNode;

        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
          return instance.__reactInternalMemoizedMaskedChildContext;
        }

        var context = {};

        for (var key in contextTypes) {
          context[key] = unmaskedContext[key];
        }

        {
          var name = getComponentName(workInProgress) || "Unknown";
          checkPropTypes(contextTypes, context, "context", name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
        }

        if (instance) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return context;
      }

      function hasContextChanged() {
        return didPerformWorkStackCursor.current;
      }

      function isContextConsumer(fiber) {
        return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
      }

      function isContextProvider(fiber) {
        return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
      }

      function popContextProvider(fiber) {
        if (!isContextProvider(fiber)) {
          return;
        }

        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function popTopLevelContextObject(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function pushTopLevelContextObject(fiber, context, didChange) {
        invariant(contextStackCursor.cursor == null, "Unexpected context found on stack. " + "This error is likely caused by a bug in React. Please file an issue.");
        push(contextStackCursor, context, fiber);
        push(didPerformWorkStackCursor, didChange, fiber);
      }

      function processChildContext(fiber, parentContext) {
        var instance = fiber.stateNode;
        var childContextTypes = fiber.type.childContextTypes;

        if (typeof instance.getChildContext !== "function") {
          {
            var componentName = getComponentName(fiber) || "Unknown";

            if (!warnedAboutMissingGetChildContext[componentName]) {
              warnedAboutMissingGetChildContext[componentName] = true;
              warning(false, "%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
            }
          }
          return parentContext;
        }

        var childContext = void 0;
        {
          ReactDebugCurrentFiber.setCurrentPhase("getChildContext");
        }
        startPhaseTimer(fiber, "getChildContext");
        childContext = instance.getChildContext();
        stopPhaseTimer();
        {
          ReactDebugCurrentFiber.setCurrentPhase(null);
        }

        for (var contextKey in childContext) {
          invariant(contextKey in childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || "Unknown", contextKey);
        }

        {
          var name = getComponentName(fiber) || "Unknown";
          checkPropTypes(childContextTypes, childContext, "child context", name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
        }
        return babelHelpers.extends({}, parentContext, childContext);
      }

      function pushContextProvider(workInProgress) {
        if (!isContextProvider(workInProgress)) {
          return false;
        }

        var instance = workInProgress.stateNode;
        var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;
        previousContext = contextStackCursor.current;
        push(contextStackCursor, memoizedMergedChildContext, workInProgress);
        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
        return true;
      }

      function invalidateContextProvider(workInProgress, didChange) {
        var instance = workInProgress.stateNode;
        invariant(instance, "Expected to have an instance by this point. " + "This error is likely caused by a bug in React. Please file an issue.");

        if (didChange) {
          var mergedContext = processChildContext(workInProgress, previousContext);
          instance.__reactInternalMemoizedMergedChildContext = mergedContext;
          pop(didPerformWorkStackCursor, workInProgress);
          pop(contextStackCursor, workInProgress);
          push(contextStackCursor, mergedContext, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        } else {
          pop(didPerformWorkStackCursor, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        }
      }

      function resetContext() {
        previousContext = emptyObject;
        contextStackCursor.current = emptyObject;
        didPerformWorkStackCursor.current = false;
      }

      function findCurrentUnmaskedContext(fiber) {
        invariant(isFiberMounted(fiber) && fiber.tag === ClassComponent, "Expected subtree parent to be a mounted class component. " + "This error is likely caused by a bug in React. Please file an issue.");
        var node = fiber;

        while (node.tag !== HostRoot) {
          if (isContextProvider(node)) {
            return node.stateNode.__reactInternalMemoizedMergedChildContext;
          }

          var parent = node["return"];
          invariant(parent, "Found unexpected detached subtree parent. " + "This error is likely caused by a bug in React. Please file an issue.");
          node = parent;
        }

        return node.stateNode.context;
      }

      var NoWork = 0;
      var Sync = 1;
      var Never = 2147483647;
      var UNIT_SIZE = 10;
      var MAGIC_NUMBER_OFFSET = 2;

      function msToExpirationTime(ms) {
        return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
      }

      function expirationTimeToMs(expirationTime) {
        return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
      }

      function ceiling(num, precision) {
        return ((num / precision | 0) + 1) * precision;
      }

      function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
        return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
      }

      var NoContext = 0;
      var AsyncUpdates = 1;
      {
        var hasBadMapPolyfill = false;

        try {
          var nonExtensibleObject = Object.preventExtensions({});
          new Map([[nonExtensibleObject, null]]);
          new Set([nonExtensibleObject]);
        } catch (e) {
          hasBadMapPolyfill = true;
        }
      }
      {
        var debugCounter = 1;
      }

      function FiberNode(tag, pendingProps, key, internalContextTag) {
        this.tag = tag;
        this.key = key;
        this.type = null;
        this.stateNode = null;
        this["return"] = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.internalContextTag = internalContextTag;
        this.effectTag = NoEffect;
        this.nextEffect = null;
        this.firstEffect = null;
        this.lastEffect = null;
        this.expirationTime = NoWork;
        this.alternate = null;
        {
          this._debugID = debugCounter++;
          this._debugSource = null;
          this._debugOwner = null;
          this._debugIsCurrentlyTiming = false;

          if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
            Object.preventExtensions(this);
          }
        }
      }

      var createFiber = function createFiber(tag, pendingProps, key, internalContextTag) {
        return new FiberNode(tag, pendingProps, key, internalContextTag);
      };

      function shouldConstruct(Component) {
        return !!(Component.prototype && Component.prototype.isReactComponent);
      }

      function createWorkInProgress(current, pendingProps, expirationTime) {
        var workInProgress = current.alternate;

        if (workInProgress === null) {
          workInProgress = createFiber(current.tag, pendingProps, current.key, current.internalContextTag);
          workInProgress.type = current.type;
          workInProgress.stateNode = current.stateNode;
          {
            workInProgress._debugID = current._debugID;
            workInProgress._debugSource = current._debugSource;
            workInProgress._debugOwner = current._debugOwner;
          }
          workInProgress.alternate = current;
          current.alternate = workInProgress;
        } else {
          workInProgress.pendingProps = pendingProps;
          workInProgress.effectTag = NoEffect;
          workInProgress.nextEffect = null;
          workInProgress.firstEffect = null;
          workInProgress.lastEffect = null;
        }

        workInProgress.expirationTime = expirationTime;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.sibling = current.sibling;
        workInProgress.index = current.index;
        workInProgress.ref = current.ref;
        return workInProgress;
      }

      function createHostRootFiber() {
        var fiber = createFiber(HostRoot, null, NoContext);
        return fiber;
      }

      function createFiberFromElement(element, internalContextTag, expirationTime) {
        var owner = null;
        {
          owner = element._owner;
        }
        var fiber = void 0;
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;

        if (typeof type === "function") {
          fiber = shouldConstruct(type) ? createFiber(ClassComponent, pendingProps, key, internalContextTag) : createFiber(IndeterminateComponent, pendingProps, key, internalContextTag);
          fiber.type = type;
        } else if (typeof type === "string") {
          fiber = createFiber(HostComponent, pendingProps, key, internalContextTag);
          fiber.type = type;
        } else if (typeof type === "object" && type !== null && typeof type.tag === "number") {
          fiber = type;
          fiber.pendingProps = pendingProps;
        } else {
          var info = "";
          {
            if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
            }

            var ownerName = owner ? getComponentName(owner) : null;

            if (ownerName) {
              info += "\n\nCheck the render method of `" + ownerName + "`.";
            }
          }
          invariant(false, "Element type is invalid: expected a string (for built-in components) " + "or a class/function (for composite components) but got: %s.%s", type == null ? type : typeof type, info);
        }

        {
          fiber._debugSource = element._source;
          fiber._debugOwner = element._owner;
        }
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
        var fiber = createFiber(Fragment, elements, key, internalContextTag);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromText(content, internalContextTag, expirationTime) {
        var fiber = createFiber(HostText, content, null, internalContextTag);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoContext);
        fiber.type = "DELETED";
        return fiber;
      }

      function createFiberFromCall(call, internalContextTag, expirationTime) {
        var fiber = createFiber(CallComponent, call, call.key, internalContextTag);
        fiber.type = call.handler;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
        var fiber = createFiber(ReturnComponent, null, null, internalContextTag);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromPortal(portal, internalContextTag, expirationTime) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, internalContextTag);
        fiber.expirationTime = expirationTime;
        fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return fiber;
      }

      function createFiberRoot(containerInfo, hydrate) {
        var uninitializedFiber = createHostRootFiber();
        var root = {
          current: uninitializedFiber,
          containerInfo: containerInfo,
          pendingChildren: null,
          remainingExpirationTime: NoWork,
          isReadyForCommit: false,
          finishedWork: null,
          context: null,
          pendingContext: null,
          hydrate: hydrate,
          firstBatch: null,
          nextScheduledRoot: null
        };
        uninitializedFiber.stateNode = root;
        return root;
      }

      var onCommitFiberRoot = null;
      var onCommitFiberUnmount = null;
      var hasLoggedError = false;

      function catchErrors(fn) {
        return function (arg) {
          try {
            return fn(arg);
          } catch (err) {
            if (true && !hasLoggedError) {
              hasLoggedError = true;
              warning(false, "React DevTools encountered an error: %s", err);
            }
          }
        };
      }

      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          return false;
        }

        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

        if (hook.isDisabled) {
          return true;
        }

        if (!hook.supportsFiber) {
          {
            warning(false, "The installed version of React DevTools is too old and will not work " + "with the current version of React. Please update React DevTools. " + "https://fb.me/react-devtools");
          }
          return true;
        }

        try {
          var rendererID = hook.inject(internals);
          onCommitFiberRoot = catchErrors(function (root) {
            return hook.onCommitFiberRoot(rendererID, root);
          });
          onCommitFiberUnmount = catchErrors(function (fiber) {
            return hook.onCommitFiberUnmount(rendererID, fiber);
          });
        } catch (err) {
          {
            warning(false, "React DevTools encountered an error: %s.", err);
          }
        }

        return true;
      }

      function onCommitRoot(root) {
        if (typeof onCommitFiberRoot === "function") {
          onCommitFiberRoot(root);
        }
      }

      function onCommitUnmount(fiber) {
        if (typeof onCommitFiberUnmount === "function") {
          onCommitFiberUnmount(fiber);
        }
      }

      {
        var didWarnUpdateInsideUpdate = false;
      }

      function createUpdateQueue(baseState) {
        var queue = {
          baseState: baseState,
          expirationTime: NoWork,
          first: null,
          last: null,
          callbackList: null,
          hasForceUpdate: false,
          isInitialized: false
        };
        {
          queue.isProcessing = false;
        }
        return queue;
      }

      function insertUpdateIntoQueue(queue, update) {
        if (queue.last === null) {
          queue.first = queue.last = update;
        } else {
          queue.last.next = update;
          queue.last = update;
        }

        if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
          queue.expirationTime = update.expirationTime;
        }
      }

      function insertUpdateIntoFiber(fiber, update) {
        var alternateFiber = fiber.alternate;
        var queue1 = fiber.updateQueue;

        if (queue1 === null) {
          queue1 = fiber.updateQueue = createUpdateQueue(null);
        }

        var queue2 = void 0;

        if (alternateFiber !== null) {
          queue2 = alternateFiber.updateQueue;

          if (queue2 === null) {
            queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
          }
        } else {
          queue2 = null;
        }

        queue2 = queue2 !== queue1 ? queue2 : null;
        {
          if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
            warning(false, "An update (setState, replaceState, or forceUpdate) was scheduled " + "from inside an update function. Update functions should be pure, " + "with zero side-effects. Consider using componentDidUpdate or a " + "callback.");
            didWarnUpdateInsideUpdate = true;
          }
        }

        if (queue2 === null) {
          insertUpdateIntoQueue(queue1, update);
          return;
        }

        if (queue1.last === null || queue2.last === null) {
          insertUpdateIntoQueue(queue1, update);
          insertUpdateIntoQueue(queue2, update);
          return;
        }

        insertUpdateIntoQueue(queue1, update);
        queue2.last = update;
      }

      function getUpdateExpirationTime(fiber) {
        if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
          return NoWork;
        }

        var updateQueue = fiber.updateQueue;

        if (updateQueue === null) {
          return NoWork;
        }

        return updateQueue.expirationTime;
      }

      function getStateFromUpdate(update, instance, prevState, props) {
        var partialState = update.partialState;

        if (typeof partialState === "function") {
          var updateFn = partialState;

          if (debugRenderPhaseSideEffects) {
            updateFn.call(instance, prevState, props);
          }

          return updateFn.call(instance, prevState, props);
        } else {
          return partialState;
        }
      }

      function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
        if (current !== null && current.updateQueue === queue) {
          var currentQueue = queue;
          queue = workInProgress.updateQueue = {
            baseState: currentQueue.baseState,
            expirationTime: currentQueue.expirationTime,
            first: currentQueue.first,
            last: currentQueue.last,
            isInitialized: currentQueue.isInitialized,
            callbackList: null,
            hasForceUpdate: false
          };
        }

        {
          queue.isProcessing = true;
        }
        queue.expirationTime = NoWork;
        var state = void 0;

        if (queue.isInitialized) {
          state = queue.baseState;
        } else {
          state = queue.baseState = workInProgress.memoizedState;
          queue.isInitialized = true;
        }

        var dontMutatePrevState = true;
        var update = queue.first;
        var didSkip = false;

        while (update !== null) {
          var updateExpirationTime = update.expirationTime;

          if (updateExpirationTime > renderExpirationTime) {
            var remainingExpirationTime = queue.expirationTime;

            if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
              queue.expirationTime = updateExpirationTime;
            }

            if (!didSkip) {
              didSkip = true;
              queue.baseState = state;
            }

            update = update.next;
            continue;
          }

          if (!didSkip) {
            queue.first = update.next;

            if (queue.first === null) {
              queue.last = null;
            }
          }

          var _partialState = void 0;

          if (update.isReplace) {
            state = getStateFromUpdate(update, instance, state, props);
            dontMutatePrevState = true;
          } else {
            _partialState = getStateFromUpdate(update, instance, state, props);

            if (_partialState) {
              if (dontMutatePrevState) {
                state = babelHelpers.extends({}, state, _partialState);
              } else {
                state = babelHelpers.extends(state, _partialState);
              }

              dontMutatePrevState = false;
            }
          }

          if (update.isForced) {
            queue.hasForceUpdate = true;
          }

          if (update.callback !== null) {
            var _callbackList = queue.callbackList;

            if (_callbackList === null) {
              _callbackList = queue.callbackList = [];
            }

            _callbackList.push(update);
          }

          update = update.next;
        }

        if (queue.callbackList !== null) {
          workInProgress.effectTag |= Callback;
        } else if (queue.first === null && !queue.hasForceUpdate) {
          workInProgress.updateQueue = null;
        }

        if (!didSkip) {
          didSkip = true;
          queue.baseState = state;
        }

        {
          queue.isProcessing = false;
        }
        return state;
      }

      function commitCallbacks(queue, context) {
        var callbackList = queue.callbackList;

        if (callbackList === null) {
          return;
        }

        queue.callbackList = null;

        for (var i = 0; i < callbackList.length; i++) {
          var update = callbackList[i];
          var _callback = update.callback;
          update.callback = null;
          invariant(typeof _callback === "function", "Invalid argument passed as callback. Expected a function. Instead " + "received: %s", _callback);

          _callback.call(context);
        }
      }

      var fakeInternalInstance = {};
      var isArray = Array.isArray;
      {
        var didWarnAboutStateAssignmentForComponent = {};

        var warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
          warning(callback === null || typeof callback === "function", "%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
        };

        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: false,
          value: function value() {
            invariant(false, "_processChildContext is not available in React 16+. This likely " + "means you have multiple copies of React and are attempting to nest " + "a React 15 tree inside a React 16 tree using " + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + "to make sure you have only one copy of React (and ideally, switch " + "to ReactDOM.createPortal).");
          }
        });
        Object.freeze(fakeInternalInstance);
      }

      var ReactFiberClassComponent = function ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
        var updater = {
          isMounted: isMounted,
          enqueueSetState: function enqueueSetState(instance, partialState, callback) {
            var fiber = get(instance);
            callback = callback === undefined ? null : callback;
            {
              warnOnInvalidCallback(callback, "setState");
            }
            var expirationTime = computeExpirationForFiber(fiber);
            var update = {
              expirationTime: expirationTime,
              partialState: partialState,
              callback: callback,
              isReplace: false,
              isForced: false,
              nextCallback: null,
              next: null
            };
            insertUpdateIntoFiber(fiber, update);
            scheduleWork(fiber, expirationTime);
          },
          enqueueReplaceState: function enqueueReplaceState(instance, state, callback) {
            var fiber = get(instance);
            callback = callback === undefined ? null : callback;
            {
              warnOnInvalidCallback(callback, "replaceState");
            }
            var expirationTime = computeExpirationForFiber(fiber);
            var update = {
              expirationTime: expirationTime,
              partialState: state,
              callback: callback,
              isReplace: true,
              isForced: false,
              nextCallback: null,
              next: null
            };
            insertUpdateIntoFiber(fiber, update);
            scheduleWork(fiber, expirationTime);
          },
          enqueueForceUpdate: function enqueueForceUpdate(instance, callback) {
            var fiber = get(instance);
            callback = callback === undefined ? null : callback;
            {
              warnOnInvalidCallback(callback, "forceUpdate");
            }
            var expirationTime = computeExpirationForFiber(fiber);
            var update = {
              expirationTime: expirationTime,
              partialState: null,
              callback: callback,
              isReplace: false,
              isForced: true,
              nextCallback: null,
              next: null
            };
            insertUpdateIntoFiber(fiber, update);
            scheduleWork(fiber, expirationTime);
          }
        };

        function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
          if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
            return true;
          }

          var instance = workInProgress.stateNode;
          var type = workInProgress.type;

          if (typeof instance.shouldComponentUpdate === "function") {
            startPhaseTimer(workInProgress, "shouldComponentUpdate");
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
            stopPhaseTimer();

            if (debugRenderPhaseSideEffects) {
              instance.shouldComponentUpdate(newProps, newState, newContext);
            }

            {
              warning(shouldUpdate !== undefined, "%s.shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.", getComponentName(workInProgress) || "Unknown");
            }
            return shouldUpdate;
          }

          if (type.prototype && type.prototype.isPureReactComponent) {
            return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
          }

          return true;
        }

        function checkClassInstance(workInProgress) {
          var instance = workInProgress.stateNode;
          var type = workInProgress.type;
          {
            var name = getComponentName(workInProgress);
            var renderPresent = instance.render;

            if (!renderPresent) {
              if (type.prototype && typeof type.prototype.render === "function") {
                warning(false, "%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name);
              } else {
                warning(false, "%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name);
              }
            }

            var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
            warning(noGetInitialStateOnES6, "getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name);
            var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
            warning(noGetDefaultPropsOnES6, "getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name);
            var noInstancePropTypes = !instance.propTypes;
            warning(noInstancePropTypes, "propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name);
            var noInstanceContextTypes = !instance.contextTypes;
            warning(noInstanceContextTypes, "contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name);
            var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== "function";
            warning(noComponentShouldUpdate, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name);

            if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              warning(false, "%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentName(workInProgress) || "A pure component");
            }

            var noComponentDidUnmount = typeof instance.componentDidUnmount !== "function";
            warning(noComponentDidUnmount, "%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name);
            var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== "function";
            warning(noComponentDidReceiveProps, "%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== "function";
            warning(noComponentWillRecieveProps, "%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            var hasMutatedProps = instance.props !== workInProgress.pendingProps;
            warning(instance.props === undefined || !hasMutatedProps, "%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name, name);
            var noInstanceDefaultProps = !instance.defaultProps;
            warning(noInstanceDefaultProps, "Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name, name);
          }
          var state = instance.state;

          if (state && (typeof state !== "object" || isArray(state))) {
            warning(false, "%s.state: must be set to an object or null", getComponentName(workInProgress));
          }

          if (typeof instance.getChildContext === "function") {
            warning(typeof workInProgress.type.childContextTypes === "object", "%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", getComponentName(workInProgress));
          }
        }

        function resetInputPointers(workInProgress, instance) {
          instance.props = workInProgress.memoizedProps;
          instance.state = workInProgress.memoizedState;
        }

        function adoptClassInstance(workInProgress, instance) {
          instance.updater = updater;
          workInProgress.stateNode = instance;
          set(instance, workInProgress);
          {
            instance._reactInternalInstance = fakeInternalInstance;
          }
        }

        function constructClassInstance(workInProgress, props) {
          var ctor = workInProgress.type;
          var unmaskedContext = getUnmaskedContext(workInProgress);
          var needsContext = isContextConsumer(workInProgress);
          var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
          var instance = new ctor(props, context);
          adoptClassInstance(workInProgress, instance);

          if (needsContext) {
            cacheContext(workInProgress, unmaskedContext, context);
          }

          return instance;
        }

        function callComponentWillMount(workInProgress, instance) {
          startPhaseTimer(workInProgress, "componentWillMount");
          var oldState = instance.state;
          instance.componentWillMount();
          stopPhaseTimer();

          if (debugRenderPhaseSideEffects) {
            instance.componentWillMount();
          }

          if (oldState !== instance.state) {
            {
              warning(false, "%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentName(workInProgress));
            }
            updater.enqueueReplaceState(instance, instance.state, null);
          }
        }

        function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
          startPhaseTimer(workInProgress, "componentWillReceiveProps");
          var oldState = instance.state;
          instance.componentWillReceiveProps(newProps, newContext);
          stopPhaseTimer();

          if (debugRenderPhaseSideEffects) {
            instance.componentWillReceiveProps(newProps, newContext);
          }

          if (instance.state !== oldState) {
            {
              var componentName = getComponentName(workInProgress) || "Component";

              if (!didWarnAboutStateAssignmentForComponent[componentName]) {
                warning(false, "%s.componentWillReceiveProps(): Assigning directly to " + "this.state is deprecated (except inside a component's " + "constructor). Use setState instead.", componentName);
                didWarnAboutStateAssignmentForComponent[componentName] = true;
              }
            }
            updater.enqueueReplaceState(instance, instance.state, null);
          }
        }

        function mountClassInstance(workInProgress, renderExpirationTime) {
          var current = workInProgress.alternate;
          {
            checkClassInstance(workInProgress);
          }
          var instance = workInProgress.stateNode;
          var state = instance.state || null;
          var props = workInProgress.pendingProps;
          var unmaskedContext = getUnmaskedContext(workInProgress);
          instance.props = props;
          instance.state = workInProgress.memoizedState = state;
          instance.refs = emptyObject;
          instance.context = getMaskedContext(workInProgress, unmaskedContext);

          if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
            workInProgress.internalContextTag |= AsyncUpdates;
          }

          if (typeof instance.componentWillMount === "function") {
            callComponentWillMount(workInProgress, instance);
            var updateQueue = workInProgress.updateQueue;

            if (updateQueue !== null) {
              instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
            }
          }

          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }
        }

        function updateClassInstance(current, workInProgress, renderExpirationTime) {
          var instance = workInProgress.stateNode;
          resetInputPointers(workInProgress, instance);
          var oldProps = workInProgress.memoizedProps;
          var newProps = workInProgress.pendingProps;
          var oldContext = instance.context;
          var newUnmaskedContext = getUnmaskedContext(workInProgress);
          var newContext = getMaskedContext(workInProgress, newUnmaskedContext);

          if (typeof instance.componentWillReceiveProps === "function" && (oldProps !== newProps || oldContext !== newContext)) {
            callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
          }

          var oldState = workInProgress.memoizedState;
          var newState = void 0;

          if (workInProgress.updateQueue !== null) {
            newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
          } else {
            newState = oldState;
          }

          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
            if (typeof instance.componentDidUpdate === "function") {
              if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                workInProgress.effectTag |= Update;
              }
            }

            return false;
          }

          var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

          if (shouldUpdate) {
            if (typeof instance.componentWillUpdate === "function") {
              startPhaseTimer(workInProgress, "componentWillUpdate");
              instance.componentWillUpdate(newProps, newState, newContext);
              stopPhaseTimer();

              if (debugRenderPhaseSideEffects) {
                instance.componentWillUpdate(newProps, newState, newContext);
              }
            }

            if (typeof instance.componentDidUpdate === "function") {
              workInProgress.effectTag |= Update;
            }
          } else {
            if (typeof instance.componentDidUpdate === "function") {
              if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                workInProgress.effectTag |= Update;
              }
            }

            memoizeProps(workInProgress, newProps);
            memoizeState(workInProgress, newState);
          }

          instance.props = newProps;
          instance.state = newState;
          instance.context = newContext;
          return shouldUpdate;
        }

        return {
          adoptClassInstance: adoptClassInstance,
          constructClassInstance: constructClassInstance,
          mountClassInstance: mountClassInstance,
          updateClassInstance: updateClassInstance
        };
      };

      var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
      {
        var didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};

        var warnForMissingKey = function warnForMissingKey(child) {
          if (child === null || typeof child !== "object") {
            return;
          }

          if (!child._store || child._store.validated || child.key != null) {
            return;
          }

          invariant(typeof child._store === "object", "React Component in warnForMissingKey should have a _store. " + "This error is likely caused by a bug in React. Please file an issue.");
          child._store.validated = true;
          var currentComponentErrorInfo = "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information." + (getCurrentFiberStackAddendum$1() || "");

          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }

          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          warning(false, "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information.%s", getCurrentFiberStackAddendum$1());
        };
      }
      var isArray$1 = Array.isArray;

      function coerceRef(current, element) {
        var mixedRef = element.ref;

        if (mixedRef !== null && typeof mixedRef !== "function") {
          if (element._owner) {
            var owner = element._owner;
            var inst = void 0;

            if (owner) {
              var ownerFiber = owner;
              invariant(ownerFiber.tag === ClassComponent, "Stateless function components cannot have refs.");
              inst = ownerFiber.stateNode;
            }

            invariant(inst, "Missing owner for string ref %s. This error is likely caused by a " + "bug in React. Please file an issue.", mixedRef);
            var stringRef = "" + mixedRef;

            if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
              return current.ref;
            }

            var ref = function ref(value) {
              var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;

              if (value === null) {
                delete refs[stringRef];
              } else {
                refs[stringRef] = value;
              }
            };

            ref._stringRef = stringRef;
            return ref;
          } else {
            invariant(typeof mixedRef === "string", "Expected ref to be a function or a string.");
            invariant(element._owner, "Element ref was specified as a string (%s) but no owner was " + "set. You may have multiple copies of React loaded. " + "(details: https://fb.me/react-refs-must-have-owner).", mixedRef);
          }
        }

        return mixedRef;
      }

      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (returnFiber.type !== "textarea") {
          var addendum = "";
          {
            addendum = " If you meant to render a collection of children, use an array " + "instead." + (getCurrentFiberStackAddendum$1() || "");
          }
          invariant(false, "Objects are not valid as a React child (found: %s).%s", Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, addendum);
        }
      }

      function warnOnFunctionType() {
        var currentComponentErrorInfo = "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it." + (getCurrentFiberStackAddendum$1() || "");

        if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
        warning(false, "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.%s", getCurrentFiberStackAddendum$1() || "");
      }

      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
            return;
          }

          var last = returnFiber.lastEffect;

          if (last !== null) {
            last.nextEffect = childToDelete;
            returnFiber.lastEffect = childToDelete;
          } else {
            returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
          }

          childToDelete.nextEffect = null;
          childToDelete.effectTag = Deletion;
        }

        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
            return null;
          }

          var childToDelete = currentFirstChild;

          while (childToDelete !== null) {
            deleteChild(returnFiber, childToDelete);
            childToDelete = childToDelete.sibling;
          }

          return null;
        }

        function mapRemainingChildren(returnFiber, currentFirstChild) {
          var existingChildren = new Map();
          var existingChild = currentFirstChild;

          while (existingChild !== null) {
            if (existingChild.key !== null) {
              existingChildren.set(existingChild.key, existingChild);
            } else {
              existingChildren.set(existingChild.index, existingChild);
            }

            existingChild = existingChild.sibling;
          }

          return existingChildren;
        }

        function useFiber(fiber, pendingProps, expirationTime) {
          var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
          clone.index = 0;
          clone.sibling = null;
          return clone;
        }

        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;

          if (!shouldTrackSideEffects) {
            return lastPlacedIndex;
          }

          var current = newFiber.alternate;

          if (current !== null) {
            var oldIndex = current.index;

            if (oldIndex < lastPlacedIndex) {
              newFiber.effectTag = Placement;
              return lastPlacedIndex;
            } else {
              return oldIndex;
            }
          } else {
            newFiber.effectTag = Placement;
            return lastPlacedIndex;
          }
        }

        function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
            newFiber.effectTag = Placement;
          }

          return newFiber;
        }

        function updateTextNode(returnFiber, current, textContent, expirationTime) {
          if (current === null || current.tag !== HostText) {
            var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
            created["return"] = returnFiber;
            return created;
          } else {
            var existing = useFiber(current, textContent, expirationTime);
            existing["return"] = returnFiber;
            return existing;
          }
        }

        function updateElement(returnFiber, current, element, expirationTime) {
          if (current !== null && current.type === element.type) {
            var existing = useFiber(current, element.props, expirationTime);
            existing.ref = coerceRef(current, element);
            existing["return"] = returnFiber;
            {
              existing._debugSource = element._source;
              existing._debugOwner = element._owner;
            }
            return existing;
          } else {
            var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
            created.ref = coerceRef(current, element);
            created["return"] = returnFiber;
            return created;
          }
        }

        function updateCall(returnFiber, current, call, expirationTime) {
          if (current === null || current.tag !== CallComponent) {
            var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
            created["return"] = returnFiber;
            return created;
          } else {
            var existing = useFiber(current, call, expirationTime);
            existing["return"] = returnFiber;
            return existing;
          }
        }

        function updateReturn(returnFiber, current, returnNode, expirationTime) {
          if (current === null || current.tag !== ReturnComponent) {
            var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
            created.type = returnNode.value;
            created["return"] = returnFiber;
            return created;
          } else {
            var existing = useFiber(current, null, expirationTime);
            existing.type = returnNode.value;
            existing["return"] = returnFiber;
            return existing;
          }
        }

        function updatePortal(returnFiber, current, portal, expirationTime) {
          if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
            created["return"] = returnFiber;
            return created;
          } else {
            var existing = useFiber(current, portal.children || [], expirationTime);
            existing["return"] = returnFiber;
            return existing;
          }
        }

        function updateFragment(returnFiber, current, fragment, expirationTime, key) {
          if (current === null || current.tag !== Fragment) {
            var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
            created["return"] = returnFiber;
            return created;
          } else {
            var existing = useFiber(current, fragment, expirationTime);
            existing["return"] = returnFiber;
            return existing;
          }
        }

        function createChild(returnFiber, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var created = createFiberFromText("" + newChild, returnFiber.internalContextTag, expirationTime);
            created["return"] = returnFiber;
            return created;
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);

                    _created["return"] = returnFiber;
                    return _created;
                  } else {
                    var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);

                    _created2.ref = coerceRef(null, newChild);
                    _created2["return"] = returnFiber;
                    return _created2;
                  }
                }

              case REACT_CALL_TYPE:
                {
                  var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);

                  _created3["return"] = returnFiber;
                  return _created3;
                }

              case REACT_RETURN_TYPE:
                {
                  var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);

                  _created4.type = newChild.value;
                  _created4["return"] = returnFiber;
                  return _created4;
                }

              case REACT_PORTAL_TYPE:
                {
                  var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);

                  _created5["return"] = returnFiber;
                  return _created5;
                }
            }

            if (isArray$1(newChild) || getIteratorFn(newChild)) {
              var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);

              _created6["return"] = returnFiber;
              return _created6;
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
          var key = oldFiber !== null ? oldFiber.key : null;

          if (typeof newChild === "string" || typeof newChild === "number") {
            if (key !== null) {
              return null;
            }

            return updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  if (newChild.key === key) {
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                    }

                    return updateElement(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }

              case REACT_CALL_TYPE:
                {
                  if (newChild.key === key) {
                    return updateCall(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }

              case REACT_RETURN_TYPE:
                {
                  if (key === null) {
                    return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }

              case REACT_PORTAL_TYPE:
                {
                  if (newChild.key === key) {
                    return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }
            }

            if (isArray$1(newChild) || getIteratorFn(newChild)) {
              if (key !== null) {
                return null;
              }

              return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                  }

                  return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
                }

              case REACT_CALL_TYPE:
                {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
                }

              case REACT_RETURN_TYPE:
                {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;

                  return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
                }

              case REACT_PORTAL_TYPE:
                {
                  var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
                }
            }

            if (isArray$1(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber5 = existingChildren.get(newIdx) || null;

              return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function warnOnInvalidKey(child, knownKeys) {
          {
            if (typeof child !== "object" || child === null) {
              return knownKeys;
            }

            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_CALL_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child);
                var key = child.key;

                if (typeof key !== "string") {
                  break;
                }

                if (knownKeys === null) {
                  knownKeys = new Set();
                  knownKeys.add(key);
                  break;
                }

                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }

                warning(false, "Encountered two children with the same key, `%s`. " + "Keys should be unique so that components maintain their identity " + "across updates. Non-unique keys may cause children to be " + "duplicated and/or omitted  the behavior is unsupported and " + "could change in a future version.%s", key, getCurrentFiberStackAddendum$1());
                break;

              default:
                break;
            }
          }
          return knownKeys;
        }

        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
          {
            var knownKeys = null;

            for (var i = 0; i < newChildren.length; i++) {
              var child = newChildren[i];
              knownKeys = warnOnInvalidKey(child, knownKeys);
            }
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;

          for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (newIdx === newChildren.length) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);

              if (!_newFiber) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber;
              } else {
                previousNewFiber.sibling = _newFiber;
              }

              previousNewFiber = _newFiber;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);

            if (_newFiber2) {
              if (shouldTrackSideEffects) {
                if (_newFiber2.alternate !== null) {
                  existingChildren["delete"](_newFiber2.key === null ? newIdx : _newFiber2.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber2;
              } else {
                previousNewFiber.sibling = _newFiber2;
              }

              previousNewFiber = _newFiber2;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          invariant(typeof iteratorFn === "function", "An object is not an iterable. This error is likely caused by a bug in " + "React. Please file an issue.");
          {
            if (typeof newChildrenIterable.entries === "function") {
              var possibleMap = newChildrenIterable;

              if (possibleMap.entries === iteratorFn) {
                warning(didWarnAboutMaps, "Using Maps as children is unsupported and will likely yield " + "unexpected results. Convert it to a sequence/iterable of keyed " + "ReactElements instead.%s", getCurrentFiberStackAddendum$1());
                didWarnAboutMaps = true;
              }
            }

            var _newChildren = iteratorFn.call(newChildrenIterable);

            if (_newChildren) {
              var knownKeys = null;

              var _step = _newChildren.next();

              for (; !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys);
              }
            }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          invariant(newChildren != null, "An iterable object provided no iterator.");
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          var step = newChildren.next();

          for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

            if (newFiber === null) {
              if (!oldFiber) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (step.done) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, expirationTime);

              if (_newFiber3 === null) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber3;
              } else {
                previousNewFiber.sibling = _newFiber3;
              }

              previousNewFiber = _newFiber3;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);

            if (_newFiber4 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber4.alternate !== null) {
                  existingChildren["delete"](_newFiber4.key === null ? newIdx : _newFiber4.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber4;
              } else {
                previousNewFiber.sibling = _newFiber4;
              }

              previousNewFiber = _newFiber4;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent, expirationTime);
            existing["return"] = returnFiber;
            return existing;
          }

          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
          created["return"] = returnFiber;
          return created;
        }

        function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
          var key = element.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
                existing.ref = coerceRef(child, element);
                existing["return"] = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
            created["return"] = returnFiber;
            return created;
          } else {
            var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);

            _created7.ref = coerceRef(currentFirstChild, element);
            _created7["return"] = returnFiber;
            return _created7;
          }
        }

        function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
          var key = call.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === CallComponent) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, call, expirationTime);
                existing["return"] = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
          created["return"] = returnFiber;
          return created;
        }

        function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
          var child = currentFirstChild;

          if (child !== null) {
            if (child.tag === ReturnComponent) {
              deleteRemainingChildren(returnFiber, child.sibling);
              var existing = useFiber(child, null, expirationTime);
              existing.type = returnNode.value;
              existing["return"] = returnFiber;
              return existing;
            } else {
              deleteRemainingChildren(returnFiber, child);
            }
          }

          var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
          created.type = returnNode.value;
          created["return"] = returnFiber;
          return created;
        }

        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
          var key = portal.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || [], expirationTime);
                existing["return"] = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
          created["return"] = returnFiber;
          return created;
        }

        function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
          if (typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
            newChild = newChild.props.children;
          }

          var isObject = typeof newChild === "object" && newChild !== null;

          if (isObject) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

              case REACT_CALL_TYPE:
                return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));

              case REACT_RETURN_TYPE:
                return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));

              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
            }
          }

          if (typeof newChild === "string" || typeof newChild === "number") {
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, expirationTime));
          }

          if (isArray$1(newChild)) {
            return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (getIteratorFn(newChild)) {
            return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (isObject) {
            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }

          if (typeof newChild === "undefined") {
            switch (returnFiber.tag) {
              case ClassComponent:
                {
                  {
                    var instance = returnFiber.stateNode;

                    if (instance.render._isMockFunction) {
                      break;
                    }
                  }
                }

              case FunctionalComponent:
                {
                  var Component = returnFiber.type;
                  invariant(false, "%s(...): Nothing was returned from render. This usually means a " + "return statement is missing. Or, to render nothing, " + "return null.", Component.displayName || Component.name || "Component");
                }
            }
          }

          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }

        return reconcileChildFibers;
      }

      var reconcileChildFibers = ChildReconciler(true);
      var mountChildFibers = ChildReconciler(false);

      function cloneChildFibers(current, workInProgress) {
        invariant(current === null || workInProgress.child === current.child, "Resuming work not yet implemented.");

        if (workInProgress.child === null) {
          return;
        }

        var currentChild = workInProgress.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
        workInProgress.child = newChild;
        newChild["return"] = workInProgress;

        while (currentChild.sibling !== null) {
          currentChild = currentChild.sibling;
          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
          newChild["return"] = workInProgress;
        }

        newChild.sibling = null;
      }

      {
        var warnedAboutStatelessRefs = {};
      }

      var ReactFiberBeginWork = function ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
        var shouldSetTextContent = config.shouldSetTextContent,
            useSyncScheduling = config.useSyncScheduling,
            shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
        var pushHostContext = hostContext.pushHostContext,
            pushHostContainer = hostContext.pushHostContainer;
        var enterHydrationState = hydrationContext.enterHydrationState,
            resetHydrationState = hydrationContext.resetHydrationState,
            tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

        var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
            adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
            constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
            mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
            updateClassInstance = _ReactFiberClassCompo.updateClassInstance;

        function reconcileChildren(current, workInProgress, nextChildren) {
          reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
        }

        function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
          if (current === null) {
            workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
          } else {
            workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
          }
        }

        function updateFragment(current, workInProgress) {
          var nextChildren = workInProgress.pendingProps;

          if (hasContextChanged()) {} else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
            return bailoutOnAlreadyFinishedWork(current, workInProgress);
          }

          reconcileChildren(current, workInProgress, nextChildren);
          memoizeProps(workInProgress, nextChildren);
          return workInProgress.child;
        }

        function markRef(current, workInProgress) {
          var ref = workInProgress.ref;

          if (ref !== null && (!current || current.ref !== ref)) {
            workInProgress.effectTag |= Ref;
          }
        }

        function updateFunctionalComponent(current, workInProgress) {
          var fn = workInProgress.type;
          var nextProps = workInProgress.pendingProps;

          if (hasContextChanged()) {} else {
            if (workInProgress.memoizedProps === nextProps) {
              return bailoutOnAlreadyFinishedWork(current, workInProgress);
            }
          }

          var unmaskedContext = getUnmaskedContext(workInProgress);
          var context = getMaskedContext(workInProgress, unmaskedContext);
          var nextChildren;
          {
            ReactCurrentOwner.current = workInProgress;
            ReactDebugCurrentFiber.setCurrentPhase("render");
            nextChildren = fn(nextProps, context);
            ReactDebugCurrentFiber.setCurrentPhase(null);
          }
          workInProgress.effectTag |= PerformedWork;
          reconcileChildren(current, workInProgress, nextChildren);
          memoizeProps(workInProgress, nextProps);
          return workInProgress.child;
        }

        function updateClassComponent(current, workInProgress, renderExpirationTime) {
          var hasContext = pushContextProvider(workInProgress);
          var shouldUpdate = void 0;

          if (current === null) {
            if (!workInProgress.stateNode) {
              constructClassInstance(workInProgress, workInProgress.pendingProps);
              mountClassInstance(workInProgress, renderExpirationTime);
              shouldUpdate = true;
            } else {
              invariant(false, "Resuming work not yet implemented.");
            }
          } else {
            shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
          }

          return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
        }

        function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
          markRef(current, workInProgress);

          if (!shouldUpdate) {
            if (hasContext) {
              invalidateContextProvider(workInProgress, false);
            }

            return bailoutOnAlreadyFinishedWork(current, workInProgress);
          }

          var instance = workInProgress.stateNode;
          ReactCurrentOwner.current = workInProgress;
          var nextChildren = void 0;
          {
            ReactDebugCurrentFiber.setCurrentPhase("render");
            nextChildren = instance.render();

            if (debugRenderPhaseSideEffects) {
              instance.render();
            }

            ReactDebugCurrentFiber.setCurrentPhase(null);
          }
          workInProgress.effectTag |= PerformedWork;
          reconcileChildren(current, workInProgress, nextChildren);
          memoizeState(workInProgress, instance.state);
          memoizeProps(workInProgress, instance.props);

          if (hasContext) {
            invalidateContextProvider(workInProgress, true);
          }

          return workInProgress.child;
        }

        function pushHostRootContext(workInProgress) {
          var root = workInProgress.stateNode;

          if (root.pendingContext) {
            pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
          } else if (root.context) {
            pushTopLevelContextObject(workInProgress, root.context, false);
          }

          pushHostContainer(workInProgress, root.containerInfo);
        }

        function updateHostRoot(current, workInProgress, renderExpirationTime) {
          pushHostRootContext(workInProgress);
          var updateQueue = workInProgress.updateQueue;

          if (updateQueue !== null) {
            var prevState = workInProgress.memoizedState;
            var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);

            if (prevState === state) {
              resetHydrationState();
              return bailoutOnAlreadyFinishedWork(current, workInProgress);
            }

            var element = state.element;
            var root = workInProgress.stateNode;

            if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
              workInProgress.effectTag |= Placement;
              workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
            } else {
              resetHydrationState();
              reconcileChildren(current, workInProgress, element);
            }

            memoizeState(workInProgress, state);
            return workInProgress.child;
          }

          resetHydrationState();
          return bailoutOnAlreadyFinishedWork(current, workInProgress);
        }

        function updateHostComponent(current, workInProgress, renderExpirationTime) {
          pushHostContext(workInProgress);

          if (current === null) {
            tryToClaimNextHydratableInstance(workInProgress);
          }

          var type = workInProgress.type;
          var memoizedProps = workInProgress.memoizedProps;
          var nextProps = workInProgress.pendingProps;
          var prevProps = current !== null ? current.memoizedProps : null;

          if (hasContextChanged()) {} else if (memoizedProps === nextProps) {
            return bailoutOnAlreadyFinishedWork(current, workInProgress);
          }

          var nextChildren = nextProps.children;
          var isDirectTextChild = shouldSetTextContent(type, nextProps);

          if (isDirectTextChild) {
            nextChildren = null;
          } else if (prevProps && shouldSetTextContent(type, prevProps)) {
            workInProgress.effectTag |= ContentReset;
          }

          markRef(current, workInProgress);

          if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
            workInProgress.expirationTime = Never;
            return null;
          }

          reconcileChildren(current, workInProgress, nextChildren);
          memoizeProps(workInProgress, nextProps);
          return workInProgress.child;
        }

        function updateHostText(current, workInProgress) {
          if (current === null) {
            tryToClaimNextHydratableInstance(workInProgress);
          }

          var nextProps = workInProgress.pendingProps;
          memoizeProps(workInProgress, nextProps);
          return null;
        }

        function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
          invariant(current === null, "An indeterminate component should never have mounted. This error is " + "likely caused by a bug in React. Please file an issue.");
          var fn = workInProgress.type;
          var props = workInProgress.pendingProps;
          var unmaskedContext = getUnmaskedContext(workInProgress);
          var context = getMaskedContext(workInProgress, unmaskedContext);
          var value;
          {
            if (fn.prototype && typeof fn.prototype.render === "function") {
              var componentName = getComponentName(workInProgress);
              warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
            }

            ReactCurrentOwner.current = workInProgress;
            value = fn(props, context);
          }
          workInProgress.effectTag |= PerformedWork;

          if (typeof value === "object" && value !== null && typeof value.render === "function") {
            workInProgress.tag = ClassComponent;
            var hasContext = pushContextProvider(workInProgress);
            adoptClassInstance(workInProgress, value);
            mountClassInstance(workInProgress, renderExpirationTime);
            return finishClassComponent(current, workInProgress, true, hasContext);
          } else {
            workInProgress.tag = FunctionalComponent;
            {
              var Component = workInProgress.type;

              if (Component) {
                warning(!Component.childContextTypes, "%s(...): childContextTypes cannot be defined on a functional component.", Component.displayName || Component.name || "Component");
              }

              if (workInProgress.ref !== null) {
                var info = "";
                var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();

                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }

                var warningKey = ownerName || workInProgress._debugID || "";
                var debugSource = workInProgress._debugSource;

                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }

                if (!warnedAboutStatelessRefs[warningKey]) {
                  warnedAboutStatelessRefs[warningKey] = true;
                  warning(false, "Stateless function components cannot be given refs. " + "Attempts to access this ref will fail.%s%s", info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
                }
              }
            }
            reconcileChildren(current, workInProgress, value);
            memoizeProps(workInProgress, props);
            return workInProgress.child;
          }
        }

        function updateCallComponent(current, workInProgress, renderExpirationTime) {
          var nextCall = workInProgress.pendingProps;

          if (hasContextChanged()) {} else if (workInProgress.memoizedProps === nextCall) {
            nextCall = workInProgress.memoizedProps;
          }

          var nextChildren = nextCall.children;

          if (current === null) {
            workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
          } else {
            workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
          }

          memoizeProps(workInProgress, nextCall);
          return workInProgress.stateNode;
        }

        function updatePortalComponent(current, workInProgress, renderExpirationTime) {
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          var nextChildren = workInProgress.pendingProps;

          if (hasContextChanged()) {} else if (workInProgress.memoizedProps === nextChildren) {
            return bailoutOnAlreadyFinishedWork(current, workInProgress);
          }

          if (current === null) {
            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
            memoizeProps(workInProgress, nextChildren);
          } else {
            reconcileChildren(current, workInProgress, nextChildren);
            memoizeProps(workInProgress, nextChildren);
          }

          return workInProgress.child;
        }

        function bailoutOnAlreadyFinishedWork(current, workInProgress) {
          cancelWorkTimer(workInProgress);
          cloneChildFibers(current, workInProgress);
          return workInProgress.child;
        }

        function bailoutOnLowPriority(current, workInProgress) {
          cancelWorkTimer(workInProgress);

          switch (workInProgress.tag) {
            case HostRoot:
              pushHostRootContext(workInProgress);
              break;

            case ClassComponent:
              pushContextProvider(workInProgress);
              break;

            case HostPortal:
              pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
              break;
          }

          return null;
        }

        function memoizeProps(workInProgress, nextProps) {
          workInProgress.memoizedProps = nextProps;
        }

        function memoizeState(workInProgress, nextState) {
          workInProgress.memoizedState = nextState;
        }

        function beginWork(current, workInProgress, renderExpirationTime) {
          if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
            return bailoutOnLowPriority(current, workInProgress);
          }

          switch (workInProgress.tag) {
            case IndeterminateComponent:
              return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);

            case FunctionalComponent:
              return updateFunctionalComponent(current, workInProgress);

            case ClassComponent:
              return updateClassComponent(current, workInProgress, renderExpirationTime);

            case HostRoot:
              return updateHostRoot(current, workInProgress, renderExpirationTime);

            case HostComponent:
              return updateHostComponent(current, workInProgress, renderExpirationTime);

            case HostText:
              return updateHostText(current, workInProgress);

            case CallHandlerPhase:
              workInProgress.tag = CallComponent;

            case CallComponent:
              return updateCallComponent(current, workInProgress, renderExpirationTime);

            case ReturnComponent:
              return null;

            case HostPortal:
              return updatePortalComponent(current, workInProgress, renderExpirationTime);

            case Fragment:
              return updateFragment(current, workInProgress);

            default:
              invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
          }
        }

        function beginFailedWork(current, workInProgress, renderExpirationTime) {
          switch (workInProgress.tag) {
            case ClassComponent:
              pushContextProvider(workInProgress);
              break;

            case HostRoot:
              pushHostRootContext(workInProgress);
              break;

            default:
              invariant(false, "Invalid type of work. This error is likely caused by a bug in React. " + "Please file an issue.");
          }

          workInProgress.effectTag |= Err;

          if (current === null) {
            workInProgress.child = null;
          } else if (workInProgress.child !== current.child) {
            workInProgress.child = current.child;
          }

          if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
            return bailoutOnLowPriority(current, workInProgress);
          }

          workInProgress.firstEffect = null;
          workInProgress.lastEffect = null;
          var nextChildren = null;
          reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

          if (workInProgress.tag === ClassComponent) {
            var instance = workInProgress.stateNode;
            workInProgress.memoizedProps = instance.props;
            workInProgress.memoizedState = instance.state;
          }

          return workInProgress.child;
        }

        return {
          beginWork: beginWork,
          beginFailedWork: beginFailedWork
        };
      };

      var ReactFiberCompleteWork = function ReactFiberCompleteWork(config, hostContext, hydrationContext) {
        var createInstance = config.createInstance,
            createTextInstance = config.createTextInstance,
            appendInitialChild = config.appendInitialChild,
            finalizeInitialChildren = config.finalizeInitialChildren,
            prepareUpdate = config.prepareUpdate,
            mutation = config.mutation,
            persistence = config.persistence;
        var getRootHostContainer = hostContext.getRootHostContainer,
            popHostContext = hostContext.popHostContext,
            getHostContext = hostContext.getHostContext,
            popHostContainer = hostContext.popHostContainer;
        var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
            prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
            popHydrationState = hydrationContext.popHydrationState;

        function markUpdate(workInProgress) {
          workInProgress.effectTag |= Update;
        }

        function markRef(workInProgress) {
          workInProgress.effectTag |= Ref;
        }

        function appendAllReturns(returns, workInProgress) {
          var node = workInProgress.stateNode;

          if (node) {
            node["return"] = workInProgress;
          }

          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
              invariant(false, "A call cannot have host component children.");
            } else if (node.tag === ReturnComponent) {
              returns.push(node.type);
            } else if (node.child !== null) {
              node.child["return"] = node;
              node = node.child;
              continue;
            }

            while (node.sibling === null) {
              if (node["return"] === null || node["return"] === workInProgress) {
                return;
              }

              node = node["return"];
            }

            node.sibling["return"] = node["return"];
            node = node.sibling;
          }
        }

        function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
          var call = workInProgress.memoizedProps;
          invariant(call, "Should be resolved by now. This error is likely caused by a bug in " + "React. Please file an issue.");
          workInProgress.tag = CallHandlerPhase;
          var returns = [];
          appendAllReturns(returns, workInProgress);
          var fn = call.handler;
          var props = call.props;
          var nextChildren = fn(props, returns);
          var currentFirstChild = current !== null ? current.child : null;
          workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
          return workInProgress.child;
        }

        function appendAllChildren(parent, workInProgress) {
          var node = workInProgress.child;

          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
            } else if (node.tag === HostPortal) {} else if (node.child !== null) {
              node.child["return"] = node;
              node = node.child;
              continue;
            }

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node["return"] === null || node["return"] === workInProgress) {
                return;
              }

              node = node["return"];
            }

            node.sibling["return"] = node["return"];
            node = node.sibling;
          }
        }

        var updateHostContainer = void 0;
        var updateHostComponent = void 0;
        var updateHostText = void 0;

        if (mutation) {
          if (enableMutatingReconciler) {
            updateHostContainer = function updateHostContainer(workInProgress) {};

            updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
              workInProgress.updateQueue = updatePayload;

              if (updatePayload) {
                markUpdate(workInProgress);
              }
            };

            updateHostText = function updateHostText(current, workInProgress, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress);
              }
            };
          } else {
            invariant(false, "Mutating reconciler is disabled.");
          }
        } else if (persistence) {
          if (enablePersistentReconciler) {
            var cloneInstance = persistence.cloneInstance,
                createContainerChildSet = persistence.createContainerChildSet,
                appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
                finalizeContainerChildren = persistence.finalizeContainerChildren;

            var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress) {
              var node = workInProgress.child;

              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendChildToContainerChildSet(containerChildSet, node.stateNode);
                } else if (node.tag === HostPortal) {} else if (node.child !== null) {
                  node.child["return"] = node;
                  node = node.child;
                  continue;
                }

                if (node === workInProgress) {
                  return;
                }

                while (node.sibling === null) {
                  if (node["return"] === null || node["return"] === workInProgress) {
                    return;
                  }

                  node = node["return"];
                }

                node.sibling["return"] = node["return"];
                node = node.sibling;
              }
            };

            updateHostContainer = function updateHostContainer(workInProgress) {
              var portalOrRoot = workInProgress.stateNode;
              var childrenUnchanged = workInProgress.firstEffect === null;

              if (childrenUnchanged) {} else {
                var container = portalOrRoot.containerInfo;
                var newChildSet = createContainerChildSet(container);

                if (finalizeContainerChildren(container, newChildSet)) {
                  markUpdate(workInProgress);
                }

                portalOrRoot.pendingChildren = newChildSet;
                appendAllChildrenToContainer(newChildSet, workInProgress);
                markUpdate(workInProgress);
              }
            };

            updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
              var childrenUnchanged = workInProgress.firstEffect === null;
              var currentInstance = current.stateNode;

              if (childrenUnchanged && updatePayload === null) {
                workInProgress.stateNode = currentInstance;
              } else {
                var recyclableInstance = workInProgress.stateNode;
                var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);

                if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
                  markUpdate(workInProgress);
                }

                workInProgress.stateNode = newInstance;

                if (childrenUnchanged) {
                  markUpdate(workInProgress);
                } else {
                  appendAllChildren(newInstance, workInProgress);
                }
              }
            };

            updateHostText = function updateHostText(current, workInProgress, oldText, newText) {
              if (oldText !== newText) {
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();
                workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
                markUpdate(workInProgress);
              }
            };
          } else {
            invariant(false, "Persistent reconciler is disabled.");
          }
        } else {
          if (enableNoopReconciler) {
            updateHostContainer = function updateHostContainer(workInProgress) {};

            updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {};

            updateHostText = function updateHostText(current, workInProgress, oldText, newText) {};
          } else {
            invariant(false, "Noop reconciler is disabled.");
          }
        }

        function completeWork(current, workInProgress, renderExpirationTime) {
          var newProps = workInProgress.pendingProps;

          switch (workInProgress.tag) {
            case FunctionalComponent:
              return null;

            case ClassComponent:
              {
                popContextProvider(workInProgress);
                return null;
              }

            case HostRoot:
              {
                popHostContainer(workInProgress);
                popTopLevelContextObject(workInProgress);
                var fiberRoot = workInProgress.stateNode;

                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }

                if (current === null || current.child === null) {
                  popHydrationState(workInProgress);
                  workInProgress.effectTag &= ~Placement;
                }

                updateHostContainer(workInProgress);
                return null;
              }

            case HostComponent:
              {
                popHostContext(workInProgress);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress.type;

                if (current !== null && workInProgress.stateNode != null) {
                  var oldProps = current.memoizedProps;
                  var instance = workInProgress.stateNode;
                  var currentHostContext = getHostContext();
                  var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
                  updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

                  if (current.ref !== workInProgress.ref) {
                    markRef(workInProgress);
                  }
                } else {
                  if (!newProps) {
                    invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                    return null;
                  }

                  var _currentHostContext = getHostContext();

                  var wasHydrated = popHydrationState(workInProgress);

                  if (wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                      markUpdate(workInProgress);
                    }
                  } else {
                    var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

                    appendAllChildren(_instance, workInProgress);

                    if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress);
                    }

                    workInProgress.stateNode = _instance;
                  }

                  if (workInProgress.ref !== null) {
                    markRef(workInProgress);
                  }
                }

                return null;
              }

            case HostText:
              {
                var newText = newProps;

                if (current && workInProgress.stateNode != null) {
                  var oldText = current.memoizedProps;
                  updateHostText(current, workInProgress, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                    return null;
                  }

                  var _rootContainerInstance = getRootHostContainer();

                  var _currentHostContext2 = getHostContext();

                  var _wasHydrated = popHydrationState(workInProgress);

                  if (_wasHydrated) {
                    if (prepareToHydrateHostTextInstance(workInProgress)) {
                      markUpdate(workInProgress);
                    }
                  } else {
                    workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
                  }
                }

                return null;
              }

            case CallComponent:
              return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);

            case CallHandlerPhase:
              workInProgress.tag = CallComponent;
              return null;

            case ReturnComponent:
              return null;

            case Fragment:
              return null;

            case HostPortal:
              popHostContainer(workInProgress);
              updateHostContainer(workInProgress);
              return null;

            case IndeterminateComponent:
              invariant(false, "An indeterminate component should have become determinate before " + "completing. This error is likely caused by a bug in React. Please " + "file an issue.");

            default:
              invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
          }
        }

        return {
          completeWork: completeWork
        };
      };

      var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
      var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
      var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;

      var ReactFiberCommitWork = function ReactFiberCommitWork(config, captureError) {
        var getPublicInstance = config.getPublicInstance,
            mutation = config.mutation,
            persistence = config.persistence;

        var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current, instance) {
          startPhaseTimer(current, "componentWillUnmount");
          instance.props = current.memoizedProps;
          instance.state = current.memoizedState;
          instance.componentWillUnmount();
          stopPhaseTimer();
        };

        function safelyCallComponentWillUnmount(current, instance) {
          {
            invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);

            if (hasCaughtError$1()) {
              var unmountError = clearCaughtError$1();
              captureError(current, unmountError);
            }
          }
        }

        function safelyDetachRef(current) {
          var ref = current.ref;

          if (ref !== null) {
            {
              invokeGuardedCallback$2(null, ref, null, null);

              if (hasCaughtError$1()) {
                var refError = clearCaughtError$1();
                captureError(current, refError);
              }
            }
          }
        }

        function commitLifeCycles(current, finishedWork) {
          switch (finishedWork.tag) {
            case ClassComponent:
              {
                var instance = finishedWork.stateNode;

                if (finishedWork.effectTag & Update) {
                  if (current === null) {
                    startPhaseTimer(finishedWork, "componentDidMount");
                    instance.props = finishedWork.memoizedProps;
                    instance.state = finishedWork.memoizedState;
                    instance.componentDidMount();
                    stopPhaseTimer();
                  } else {
                    var prevProps = current.memoizedProps;
                    var prevState = current.memoizedState;
                    startPhaseTimer(finishedWork, "componentDidUpdate");
                    instance.props = finishedWork.memoizedProps;
                    instance.state = finishedWork.memoizedState;
                    instance.componentDidUpdate(prevProps, prevState);
                    stopPhaseTimer();
                  }
                }

                var updateQueue = finishedWork.updateQueue;

                if (updateQueue !== null) {
                  commitCallbacks(updateQueue, instance);
                }

                return;
              }

            case HostRoot:
              {
                var _updateQueue = finishedWork.updateQueue;

                if (_updateQueue !== null) {
                  var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;

                  commitCallbacks(_updateQueue, _instance);
                }

                return;
              }

            case HostComponent:
              {
                var _instance2 = finishedWork.stateNode;

                if (current === null && finishedWork.effectTag & Update) {
                  var type = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type, props, finishedWork);
                }

                return;
              }

            case HostText:
              {
                return;
              }

            case HostPortal:
              {
                return;
              }

            default:
              {
                invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
              }
          }
        }

        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;

          if (ref !== null) {
            var instance = finishedWork.stateNode;

            switch (finishedWork.tag) {
              case HostComponent:
                ref(getPublicInstance(instance));
                break;

              default:
                ref(instance);
            }
          }
        }

        function commitDetachRef(current) {
          var currentRef = current.ref;

          if (currentRef !== null) {
            currentRef(null);
          }
        }

        function commitUnmount(current) {
          if (typeof onCommitUnmount === "function") {
            onCommitUnmount(current);
          }

          switch (current.tag) {
            case ClassComponent:
              {
                safelyDetachRef(current);
                var instance = current.stateNode;

                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(current, instance);
                }

                return;
              }

            case HostComponent:
              {
                safelyDetachRef(current);
                return;
              }

            case CallComponent:
              {
                commitNestedUnmounts(current.stateNode);
                return;
              }

            case HostPortal:
              {
                if (enableMutatingReconciler && mutation) {
                  unmountHostComponents(current);
                } else if (enablePersistentReconciler && persistence) {
                  emptyPortalContainer(current);
                }

                return;
              }
          }
        }

        function commitNestedUnmounts(root) {
          var node = root;

          while (true) {
            commitUnmount(node);

            if (node.child !== null && (!mutation || node.tag !== HostPortal)) {
              node.child["return"] = node;
              node = node.child;
              continue;
            }

            if (node === root) {
              return;
            }

            while (node.sibling === null) {
              if (node["return"] === null || node["return"] === root) {
                return;
              }

              node = node["return"];
            }

            node.sibling["return"] = node["return"];
            node = node.sibling;
          }
        }

        function detachFiber(current) {
          current["return"] = null;
          current.child = null;

          if (current.alternate) {
            current.alternate.child = null;
            current.alternate["return"] = null;
          }
        }

        if (!mutation) {
          var commitContainer = void 0;

          if (persistence) {
            var replaceContainerChildren = persistence.replaceContainerChildren,
                createContainerChildSet = persistence.createContainerChildSet;

            var emptyPortalContainer = function emptyPortalContainer(current) {
              var portal = current.stateNode;
              var containerInfo = portal.containerInfo;
              var emptyChildSet = createContainerChildSet(containerInfo);
              replaceContainerChildren(containerInfo, emptyChildSet);
            };

            commitContainer = function commitContainer(finishedWork) {
              switch (finishedWork.tag) {
                case ClassComponent:
                  {
                    return;
                  }

                case HostComponent:
                  {
                    return;
                  }

                case HostText:
                  {
                    return;
                  }

                case HostRoot:
                case HostPortal:
                  {
                    var portalOrRoot = finishedWork.stateNode;
                    var containerInfo = portalOrRoot.containerInfo,
                        _pendingChildren = portalOrRoot.pendingChildren;
                    replaceContainerChildren(containerInfo, _pendingChildren);
                    return;
                  }

                default:
                  {
                    invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
                  }
              }
            };
          } else {
            commitContainer = function commitContainer(finishedWork) {};
          }

          if (enablePersistentReconciler || enableNoopReconciler) {
            return {
              commitResetTextContent: function commitResetTextContent(finishedWork) {},
              commitPlacement: function commitPlacement(finishedWork) {},
              commitDeletion: function commitDeletion(current) {
                commitNestedUnmounts(current);
                detachFiber(current);
              },
              commitWork: function commitWork(current, finishedWork) {
                commitContainer(finishedWork);
              },
              commitLifeCycles: commitLifeCycles,
              commitAttachRef: commitAttachRef,
              commitDetachRef: commitDetachRef
            };
          } else if (persistence) {
            invariant(false, "Persistent reconciler is disabled.");
          } else {
            invariant(false, "Noop reconciler is disabled.");
          }
        }

        var commitMount = mutation.commitMount,
            commitUpdate = mutation.commitUpdate,
            resetTextContent = mutation.resetTextContent,
            commitTextUpdate = mutation.commitTextUpdate,
            appendChild = mutation.appendChild,
            appendChildToContainer = mutation.appendChildToContainer,
            insertBefore = mutation.insertBefore,
            insertInContainerBefore = mutation.insertInContainerBefore,
            removeChild = mutation.removeChild,
            removeChildFromContainer = mutation.removeChildFromContainer;

        function getHostParentFiber(fiber) {
          var parent = fiber["return"];

          while (parent !== null) {
            if (isHostParent(parent)) {
              return parent;
            }

            parent = parent["return"];
          }

          invariant(false, "Expected to find a host parent. This error is likely caused by a bug " + "in React. Please file an issue.");
        }

        function isHostParent(fiber) {
          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }

        function getHostSibling(fiber) {
          var node = fiber;

          siblings: while (true) {
            while (node.sibling === null) {
              if (node["return"] === null || isHostParent(node["return"])) {
                return null;
              }

              node = node["return"];
            }

            node.sibling["return"] = node["return"];
            node = node.sibling;

            while (node.tag !== HostComponent && node.tag !== HostText) {
              if (node.effectTag & Placement) {
                continue siblings;
              }

              if (node.child === null || node.tag === HostPortal) {
                continue siblings;
              } else {
                node.child["return"] = node;
                node = node.child;
              }
            }

            if (!(node.effectTag & Placement)) {
              return node.stateNode;
            }
          }
        }

        function commitPlacement(finishedWork) {
          var parentFiber = getHostParentFiber(finishedWork);
          var parent = void 0;
          var isContainer = void 0;

          switch (parentFiber.tag) {
            case HostComponent:
              parent = parentFiber.stateNode;
              isContainer = false;
              break;

            case HostRoot:
              parent = parentFiber.stateNode.containerInfo;
              isContainer = true;
              break;

            case HostPortal:
              parent = parentFiber.stateNode.containerInfo;
              isContainer = true;
              break;

            default:
              invariant(false, "Invalid host parent fiber. This error is likely caused by a bug " + "in React. Please file an issue.");
          }

          if (parentFiber.effectTag & ContentReset) {
            resetTextContent(parent);
            parentFiber.effectTag &= ~ContentReset;
          }

          var before = getHostSibling(finishedWork);
          var node = finishedWork;

          while (true) {
            if (node.tag === HostComponent || node.tag === HostText) {
              if (before) {
                if (isContainer) {
                  insertInContainerBefore(parent, node.stateNode, before);
                } else {
                  insertBefore(parent, node.stateNode, before);
                }
              } else {
                if (isContainer) {
                  appendChildToContainer(parent, node.stateNode);
                } else {
                  appendChild(parent, node.stateNode);
                }
              }
            } else if (node.tag === HostPortal) {} else if (node.child !== null) {
              node.child["return"] = node;
              node = node.child;
              continue;
            }

            if (node === finishedWork) {
              return;
            }

            while (node.sibling === null) {
              if (node["return"] === null || node["return"] === finishedWork) {
                return;
              }

              node = node["return"];
            }

            node.sibling["return"] = node["return"];
            node = node.sibling;
          }
        }

        function unmountHostComponents(current) {
          var node = current;
          var currentParentIsValid = false;
          var currentParent = void 0;
          var currentParentIsContainer = void 0;

          while (true) {
            if (!currentParentIsValid) {
              var parent = node["return"];

              findParent: while (true) {
                invariant(parent !== null, "Expected to find a host parent. This error is likely caused by " + "a bug in React. Please file an issue.");

                switch (parent.tag) {
                  case HostComponent:
                    currentParent = parent.stateNode;
                    currentParentIsContainer = false;
                    break findParent;

                  case HostRoot:
                    currentParent = parent.stateNode.containerInfo;
                    currentParentIsContainer = true;
                    break findParent;

                  case HostPortal:
                    currentParent = parent.stateNode.containerInfo;
                    currentParentIsContainer = true;
                    break findParent;
                }

                parent = parent["return"];
              }

              currentParentIsValid = true;
            }

            if (node.tag === HostComponent || node.tag === HostText) {
              commitNestedUnmounts(node);

              if (currentParentIsContainer) {
                removeChildFromContainer(currentParent, node.stateNode);
              } else {
                removeChild(currentParent, node.stateNode);
              }
            } else if (node.tag === HostPortal) {
              currentParent = node.stateNode.containerInfo;

              if (node.child !== null) {
                node.child["return"] = node;
                node = node.child;
                continue;
              }
            } else {
              commitUnmount(node);

              if (node.child !== null) {
                node.child["return"] = node;
                node = node.child;
                continue;
              }
            }

            if (node === current) {
              return;
            }

            while (node.sibling === null) {
              if (node["return"] === null || node["return"] === current) {
                return;
              }

              node = node["return"];

              if (node.tag === HostPortal) {
                currentParentIsValid = false;
              }
            }

            node.sibling["return"] = node["return"];
            node = node.sibling;
          }
        }

        function commitDeletion(current) {
          unmountHostComponents(current);
          detachFiber(current);
        }

        function commitWork(current, finishedWork) {
          switch (finishedWork.tag) {
            case ClassComponent:
              {
                return;
              }

            case HostComponent:
              {
                var instance = finishedWork.stateNode;

                if (instance != null) {
                  var newProps = finishedWork.memoizedProps;
                  var oldProps = current !== null ? current.memoizedProps : newProps;
                  var type = finishedWork.type;
                  var updatePayload = finishedWork.updateQueue;
                  finishedWork.updateQueue = null;

                  if (updatePayload !== null) {
                    commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
                  }
                }

                return;
              }

            case HostText:
              {
                invariant(finishedWork.stateNode !== null, "This should have a text node initialized. This error is likely " + "caused by a bug in React. Please file an issue.");
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps;
                var oldText = current !== null ? current.memoizedProps : newText;
                commitTextUpdate(textInstance, oldText, newText);
                return;
              }

            case HostRoot:
              {
                return;
              }

            default:
              {
                invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
              }
          }
        }

        function commitResetTextContent(current) {
          resetTextContent(current.stateNode);
        }

        if (enableMutatingReconciler) {
          return {
            commitResetTextContent: commitResetTextContent,
            commitPlacement: commitPlacement,
            commitDeletion: commitDeletion,
            commitWork: commitWork,
            commitLifeCycles: commitLifeCycles,
            commitAttachRef: commitAttachRef,
            commitDetachRef: commitDetachRef
          };
        } else {
          invariant(false, "Mutating reconciler is disabled.");
        }
      };

      var NO_CONTEXT = {};

      var ReactFiberHostContext = function ReactFiberHostContext(config) {
        var getChildHostContext = config.getChildHostContext,
            getRootHostContext = config.getRootHostContext;
        var contextStackCursor = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);

        function requiredContext(c) {
          invariant(c !== NO_CONTEXT, "Expected host context to exist. This error is likely caused by a bug " + "in React. Please file an issue.");
          return c;
        }

        function getRootHostContainer() {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          return rootInstance;
        }

        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          var nextRootContext = getRootHostContext(nextRootInstance);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }

        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }

        function getHostContext() {
          var context = requiredContext(contextStackCursor.current);
          return context;
        }

        function pushHostContext(fiber) {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          var context = requiredContext(contextStackCursor.current);
          var nextContext = getChildHostContext(context, fiber.type, rootInstance);

          if (context === nextContext) {
            return;
          }

          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, nextContext, fiber);
        }

        function popHostContext(fiber) {
          if (contextFiberStackCursor.current !== fiber) {
            return;
          }

          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
        }

        function resetHostContainer() {
          contextStackCursor.current = NO_CONTEXT;
          rootInstanceStackCursor.current = NO_CONTEXT;
        }

        return {
          getHostContext: getHostContext,
          getRootHostContainer: getRootHostContainer,
          popHostContainer: popHostContainer,
          popHostContext: popHostContext,
          pushHostContainer: pushHostContainer,
          pushHostContext: pushHostContext,
          resetHostContainer: resetHostContainer
        };
      };

      var ReactFiberHydrationContext = function ReactFiberHydrationContext(config) {
        var shouldSetTextContent = config.shouldSetTextContent,
            hydration = config.hydration;

        if (!hydration) {
          return {
            enterHydrationState: function enterHydrationState() {
              return false;
            },
            resetHydrationState: function resetHydrationState() {},
            tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {},
            prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
              invariant(false, "Expected prepareToHydrateHostInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
            },
            prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
              invariant(false, "Expected prepareToHydrateHostTextInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
            },
            popHydrationState: function popHydrationState(fiber) {
              return false;
            }
          };
        }

        var canHydrateInstance = hydration.canHydrateInstance,
            canHydrateTextInstance = hydration.canHydrateTextInstance,
            getNextHydratableSibling = hydration.getNextHydratableSibling,
            getFirstHydratableChild = hydration.getFirstHydratableChild,
            hydrateInstance = hydration.hydrateInstance,
            hydrateTextInstance = hydration.hydrateTextInstance,
            didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
            didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
            didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
            didNotHydrateInstance = hydration.didNotHydrateInstance,
            didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
            didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
            didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
            didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;

        function enterHydrationState(fiber) {
          var parentInstance = fiber.stateNode.containerInfo;
          nextHydratableInstance = getFirstHydratableChild(parentInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          return true;
        }

        function deleteHydratableInstance(returnFiber, instance) {
          {
            switch (returnFiber.tag) {
              case HostRoot:
                didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
                break;

              case HostComponent:
                didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
                break;
            }
          }
          var childToDelete = createFiberFromHostInstanceForDeletion();
          childToDelete.stateNode = instance;
          childToDelete["return"] = returnFiber;
          childToDelete.effectTag = Deletion;

          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = childToDelete;
            returnFiber.lastEffect = childToDelete;
          } else {
            returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
          }
        }

        function insertNonHydratedInstance(returnFiber, fiber) {
          fiber.effectTag |= Placement;
          {
            switch (returnFiber.tag) {
              case HostRoot:
                {
                  var parentContainer = returnFiber.stateNode.containerInfo;

                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableContainerInstance(parentContainer, type, props);
                      break;

                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableContainerTextInstance(parentContainer, text);
                      break;
                  }

                  break;
                }

              case HostComponent:
                {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;

                  switch (fiber.tag) {
                    case HostComponent:
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                      break;

                    case HostText:
                      var _text = fiber.pendingProps;
                      didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                      break;
                  }

                  break;
                }

              default:
                return;
            }
          }
        }

        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case HostComponent:
              {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type, props);

                if (instance !== null) {
                  fiber.stateNode = instance;
                  return true;
                }

                return false;
              }

            case HostText:
              {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);

                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  return true;
                }

                return false;
              }

            default:
              return false;
          }
        }

        function tryToClaimNextHydratableInstance(fiber) {
          if (!isHydrating) {
            return;
          }

          var nextInstance = nextHydratableInstance;

          if (!nextInstance) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }

          if (!tryHydrate(fiber, nextInstance)) {
            nextInstance = getNextHydratableSibling(nextInstance);

            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }

            deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
          }

          hydrationParentFiber = fiber;
          nextHydratableInstance = getFirstHydratableChild(nextInstance);
        }

        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
          var instance = fiber.stateNode;
          var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
          fiber.updateQueue = updatePayload;

          if (updatePayload !== null) {
            return true;
          }

          return false;
        }

        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode;
          var textContent = fiber.memoizedProps;
          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
          {
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;

              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot:
                    {
                      var parentContainer = returnFiber.stateNode.containerInfo;
                      didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                      break;
                    }

                  case HostComponent:
                    {
                      var parentType = returnFiber.type;
                      var parentProps = returnFiber.memoizedProps;
                      var parentInstance = returnFiber.stateNode;
                      didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                      break;
                    }
                }
              }
            }
          }
          return shouldUpdate;
        }

        function popToNextHostParent(fiber) {
          var parent = fiber["return"];

          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
            parent = parent["return"];
          }

          hydrationParentFiber = parent;
        }

        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) {
            return false;
          }

          if (!isHydrating) {
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
          }

          var type = fiber.type;

          if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
            var nextInstance = nextHydratableInstance;

            while (nextInstance) {
              deleteHydratableInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }

          popToNextHostParent(fiber);
          nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
          return true;
        }

        function resetHydrationState() {
          hydrationParentFiber = null;
          nextHydratableInstance = null;
          isHydrating = false;
        }

        return {
          enterHydrationState: enterHydrationState,
          resetHydrationState: resetHydrationState,
          tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
          prepareToHydrateHostInstance: prepareToHydrateHostInstance,
          prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
          popHydrationState: popHydrationState
        };
      };

      var ReactFiberInstrumentation = {
        debugTool: null
      };
      var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;
      var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
      var hasCaughtError = ReactErrorUtils.hasCaughtError;
      var clearCaughtError = ReactErrorUtils.clearCaughtError;
      {
        var didWarnAboutStateTransition = false;
        var didWarnSetStateChildContext = false;
        var didWarnStateUpdateForUnmountedComponent = {};

        var warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber) {
          var componentName = getComponentName(fiber) || "ReactClass";

          if (didWarnStateUpdateForUnmountedComponent[componentName]) {
            return;
          }

          warning(false, "Can only update a mounted or mounting " + "component. This usually means you called setState, replaceState, " + "or forceUpdate on an unmounted component. This is a no-op.\n\nPlease " + "check the code for the %s component.", componentName);
          didWarnStateUpdateForUnmountedComponent[componentName] = true;
        };

        var warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {
          switch (ReactDebugCurrentFiber.phase) {
            case "getChildContext":
              if (didWarnSetStateChildContext) {
                return;
              }

              warning(false, "setState(...): Cannot call setState() inside getChildContext()");
              didWarnSetStateChildContext = true;
              break;

            case "render":
              if (didWarnAboutStateTransition) {
                return;
              }

              warning(false, "Cannot update during an existing state transition (such as within " + "`render` or another component's constructor). Render methods should " + "be a pure function of props and state; constructor side-effects are " + "an anti-pattern, but can be moved to `componentWillMount`.");
              didWarnAboutStateTransition = true;
              break;
          }
        };
      }

      var ReactFiberScheduler = function ReactFiberScheduler(config) {
        var hostContext = ReactFiberHostContext(config);
        var hydrationContext = ReactFiberHydrationContext(config);
        var popHostContainer = hostContext.popHostContainer,
            popHostContext = hostContext.popHostContext,
            resetHostContainer = hostContext.resetHostContainer;

        var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
            beginWork = _ReactFiberBeginWork.beginWork,
            beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

        var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
            completeWork = _ReactFiberCompleteWo.completeWork;

        var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
            commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
            commitPlacement = _ReactFiberCommitWork.commitPlacement,
            commitDeletion = _ReactFiberCommitWork.commitDeletion,
            commitWork = _ReactFiberCommitWork.commitWork,
            commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
            commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
            commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

        var now = config.now,
            scheduleDeferredCallback = config.scheduleDeferredCallback,
            cancelDeferredCallback = config.cancelDeferredCallback,
            useSyncScheduling = config.useSyncScheduling,
            prepareForCommit = config.prepareForCommit,
            resetAfterCommit = config.resetAfterCommit;
        var startTime = now();
        var mostRecentCurrentTime = msToExpirationTime(0);
        var lastUniqueAsyncExpiration = 0;
        var expirationContext = NoWork;
        var isWorking = false;
        var nextUnitOfWork = null;
        var nextRoot = null;
        var nextRenderExpirationTime = NoWork;
        var nextEffect = null;
        var capturedErrors = null;
        var failedBoundaries = null;
        var commitPhaseBoundaries = null;
        var firstUncaughtError = null;
        var didFatal = false;
        var isCommitting = false;
        var isUnmounting = false;
        var interruptedBy = null;

        function resetContextStack() {
          reset();
          resetContext();
          resetHostContainer();
        }

        function commitAllHostEffects() {
          while (nextEffect !== null) {
            {
              ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
            }
            recordEffect();
            var effectTag = nextEffect.effectTag;

            if (effectTag & ContentReset) {
              commitResetTextContent(nextEffect);
            }

            if (effectTag & Ref) {
              var current = nextEffect.alternate;

              if (current !== null) {
                commitDetachRef(current);
              }
            }

            var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);

            switch (primaryEffectTag) {
              case Placement:
                {
                  commitPlacement(nextEffect);
                  nextEffect.effectTag &= ~Placement;
                  break;
                }

              case PlacementAndUpdate:
                {
                  commitPlacement(nextEffect);
                  nextEffect.effectTag &= ~Placement;
                  var _current = nextEffect.alternate;
                  commitWork(_current, nextEffect);
                  break;
                }

              case Update:
                {
                  var _current2 = nextEffect.alternate;
                  commitWork(_current2, nextEffect);
                  break;
                }

              case Deletion:
                {
                  isUnmounting = true;
                  commitDeletion(nextEffect);
                  isUnmounting = false;
                  break;
                }
            }

            nextEffect = nextEffect.nextEffect;
          }

          {
            ReactDebugCurrentFiber.resetCurrentFiber();
          }
        }

        function commitAllLifeCycles() {
          while (nextEffect !== null) {
            var effectTag = nextEffect.effectTag;

            if (effectTag & (Update | Callback)) {
              recordEffect();
              var current = nextEffect.alternate;
              commitLifeCycles(current, nextEffect);
            }

            if (effectTag & Ref) {
              recordEffect();
              commitAttachRef(nextEffect);
            }

            if (effectTag & Err) {
              recordEffect();
              commitErrorHandling(nextEffect);
            }

            var next = nextEffect.nextEffect;
            nextEffect.nextEffect = null;
            nextEffect = next;
          }
        }

        function commitRoot(finishedWork) {
          isWorking = true;
          isCommitting = true;
          startCommitTimer();
          var root = finishedWork.stateNode;
          invariant(root.current !== finishedWork, "Cannot commit the same tree as before. This is probably a bug " + "related to the return field. This error is likely caused by a bug " + "in React. Please file an issue.");
          root.isReadyForCommit = false;
          ReactCurrentOwner.current = null;
          var firstEffect = void 0;

          if (finishedWork.effectTag > PerformedWork) {
            if (finishedWork.lastEffect !== null) {
              finishedWork.lastEffect.nextEffect = finishedWork;
              firstEffect = finishedWork.firstEffect;
            } else {
              firstEffect = finishedWork;
            }
          } else {
            firstEffect = finishedWork.firstEffect;
          }

          prepareForCommit();
          nextEffect = firstEffect;
          startCommitHostEffectsTimer();

          while (nextEffect !== null) {
            var didError = false;

            var _error = void 0;

            {
              invokeGuardedCallback$1(null, commitAllHostEffects, null);

              if (hasCaughtError()) {
                didError = true;
                _error = clearCaughtError();
              }
            }

            if (didError) {
              invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
              captureError(nextEffect, _error);

              if (nextEffect !== null) {
                nextEffect = nextEffect.nextEffect;
              }
            }
          }

          stopCommitHostEffectsTimer();
          resetAfterCommit();
          root.current = finishedWork;
          nextEffect = firstEffect;
          startCommitLifeCyclesTimer();

          while (nextEffect !== null) {
            var _didError = false;

            var _error2 = void 0;

            {
              invokeGuardedCallback$1(null, commitAllLifeCycles, null);

              if (hasCaughtError()) {
                _didError = true;
                _error2 = clearCaughtError();
              }
            }

            if (_didError) {
              invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
              captureError(nextEffect, _error2);

              if (nextEffect !== null) {
                nextEffect = nextEffect.nextEffect;
              }
            }
          }

          isCommitting = false;
          isWorking = false;
          stopCommitLifeCyclesTimer();
          stopCommitTimer();

          if (typeof onCommitRoot === "function") {
            onCommitRoot(finishedWork.stateNode);
          }

          if (true && ReactFiberInstrumentation_1.debugTool) {
            ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
          }

          if (commitPhaseBoundaries) {
            commitPhaseBoundaries.forEach(scheduleErrorRecovery);
            commitPhaseBoundaries = null;
          }

          if (firstUncaughtError !== null) {
            var _error3 = firstUncaughtError;
            firstUncaughtError = null;
            onUncaughtError(_error3);
          }

          var remainingTime = root.current.expirationTime;

          if (remainingTime === NoWork) {
            capturedErrors = null;
            failedBoundaries = null;
          }

          return remainingTime;
        }

        function resetExpirationTime(workInProgress, renderTime) {
          if (renderTime !== Never && workInProgress.expirationTime === Never) {
            return;
          }

          var newExpirationTime = getUpdateExpirationTime(workInProgress);
          var child = workInProgress.child;

          while (child !== null) {
            if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
              newExpirationTime = child.expirationTime;
            }

            child = child.sibling;
          }

          workInProgress.expirationTime = newExpirationTime;
        }

        function completeUnitOfWork(workInProgress) {
          while (true) {
            var current = workInProgress.alternate;
            {
              ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
            }
            var next = completeWork(current, workInProgress, nextRenderExpirationTime);
            {
              ReactDebugCurrentFiber.resetCurrentFiber();
            }
            var returnFiber = workInProgress["return"];
            var siblingFiber = workInProgress.sibling;
            resetExpirationTime(workInProgress, nextRenderExpirationTime);

            if (next !== null) {
              stopWorkTimer(workInProgress);

              if (true && ReactFiberInstrumentation_1.debugTool) {
                ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
              }

              return next;
            }

            if (returnFiber !== null) {
              if (returnFiber.firstEffect === null) {
                returnFiber.firstEffect = workInProgress.firstEffect;
              }

              if (workInProgress.lastEffect !== null) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
                }

                returnFiber.lastEffect = workInProgress.lastEffect;
              }

              var effectTag = workInProgress.effectTag;

              if (effectTag > PerformedWork) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress;
                } else {
                  returnFiber.firstEffect = workInProgress;
                }

                returnFiber.lastEffect = workInProgress;
              }
            }

            stopWorkTimer(workInProgress);

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (siblingFiber !== null) {
              return siblingFiber;
            } else if (returnFiber !== null) {
              workInProgress = returnFiber;
              continue;
            } else {
              var root = workInProgress.stateNode;
              root.isReadyForCommit = true;
              return null;
            }
          }

          return null;
        }

        function performUnitOfWork(workInProgress) {
          var current = workInProgress.alternate;
          startWorkTimer(workInProgress);
          {
            ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
          }
          var next = beginWork(current, workInProgress, nextRenderExpirationTime);
          {
            ReactDebugCurrentFiber.resetCurrentFiber();
          }

          if (true && ReactFiberInstrumentation_1.debugTool) {
            ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
          }

          if (next === null) {
            next = completeUnitOfWork(workInProgress);
          }

          ReactCurrentOwner.current = null;
          return next;
        }

        function performFailedUnitOfWork(workInProgress) {
          var current = workInProgress.alternate;
          startWorkTimer(workInProgress);
          {
            ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
          }
          var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
          {
            ReactDebugCurrentFiber.resetCurrentFiber();
          }

          if (true && ReactFiberInstrumentation_1.debugTool) {
            ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
          }

          if (next === null) {
            next = completeUnitOfWork(workInProgress);
          }

          ReactCurrentOwner.current = null;
          return next;
        }

        function workLoop(expirationTime) {
          if (capturedErrors !== null) {
            slowWorkLoopThatChecksForFailedWork(expirationTime);
            return;
          }

          if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
            return;
          }

          if (nextRenderExpirationTime <= mostRecentCurrentTime) {
            while (nextUnitOfWork !== null) {
              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
            }
          } else {
            while (nextUnitOfWork !== null && !shouldYield()) {
              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
            }
          }
        }

        function slowWorkLoopThatChecksForFailedWork(expirationTime) {
          if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
            return;
          }

          if (nextRenderExpirationTime <= mostRecentCurrentTime) {
            while (nextUnitOfWork !== null) {
              if (hasCapturedError(nextUnitOfWork)) {
                nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
              } else {
                nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
              }
            }
          } else {
            while (nextUnitOfWork !== null && !shouldYield()) {
              if (hasCapturedError(nextUnitOfWork)) {
                nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
              } else {
                nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
              }
            }
          }
        }

        function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
          unwindContexts(failedWork, boundary);
          nextUnitOfWork = performFailedUnitOfWork(boundary);
          workLoop(expirationTime);
        }

        function renderRoot(root, expirationTime) {
          invariant(!isWorking, "renderRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
          isWorking = true;
          root.isReadyForCommit = false;

          if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
            resetContextStack();
            nextRoot = root;
            nextRenderExpirationTime = expirationTime;
            nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
          }

          startWorkLoopTimer(nextUnitOfWork);
          var didError = false;
          var error = null;
          {
            invokeGuardedCallback$1(null, workLoop, null, expirationTime);

            if (hasCaughtError()) {
              didError = true;
              error = clearCaughtError();
            }
          }

          while (didError) {
            if (didFatal) {
              firstUncaughtError = error;
              break;
            }

            var failedWork = nextUnitOfWork;

            if (failedWork === null) {
              didFatal = true;
              continue;
            }

            var boundary = captureError(failedWork, error);
            invariant(boundary !== null, "Should have found an error boundary. This error is likely " + "caused by a bug in React. Please file an issue.");

            if (didFatal) {
              continue;
            }

            didError = false;
            error = null;
            {
              invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);

              if (hasCaughtError()) {
                didError = true;
                error = clearCaughtError();
                continue;
              }
            }
            break;
          }

          var uncaughtError = firstUncaughtError;
          stopWorkLoopTimer(interruptedBy);
          interruptedBy = null;
          isWorking = false;
          didFatal = false;
          firstUncaughtError = null;

          if (uncaughtError !== null) {
            onUncaughtError(uncaughtError);
          }

          return root.isReadyForCommit ? root.current.alternate : null;
        }

        function captureError(failedWork, error) {
          ReactCurrentOwner.current = null;
          {
            ReactDebugCurrentFiber.resetCurrentFiber();
          }
          var boundary = null;
          var errorBoundaryFound = false;
          var willRetry = false;
          var errorBoundaryName = null;

          if (failedWork.tag === HostRoot) {
            boundary = failedWork;

            if (isFailedBoundary(failedWork)) {
              didFatal = true;
            }
          } else {
            var node = failedWork["return"];

            while (node !== null && boundary === null) {
              if (node.tag === ClassComponent) {
                var instance = node.stateNode;

                if (typeof instance.componentDidCatch === "function") {
                  errorBoundaryFound = true;
                  errorBoundaryName = getComponentName(node);
                  boundary = node;
                  willRetry = true;
                }
              } else if (node.tag === HostRoot) {
                boundary = node;
              }

              if (isFailedBoundary(node)) {
                if (isUnmounting) {
                  return null;
                }

                if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
                  return null;
                }

                boundary = null;
                willRetry = false;
              }

              node = node["return"];
            }
          }

          if (boundary !== null) {
            if (failedBoundaries === null) {
              failedBoundaries = new Set();
            }

            failedBoundaries.add(boundary);

            var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);

            var _componentName = getComponentName(failedWork);

            if (capturedErrors === null) {
              capturedErrors = new Map();
            }

            var capturedError = {
              componentName: _componentName,
              componentStack: _componentStack,
              error: error,
              errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
              errorBoundaryFound: errorBoundaryFound,
              errorBoundaryName: errorBoundaryName,
              willRetry: willRetry
            };
            capturedErrors.set(boundary, capturedError);

            try {
              logCapturedError(capturedError);
            } catch (e) {
              var suppressLogging = e && e.suppressReactErrorLogging;

              if (!suppressLogging) {
                console.error(e);
              }
            }

            if (isCommitting) {
              if (commitPhaseBoundaries === null) {
                commitPhaseBoundaries = new Set();
              }

              commitPhaseBoundaries.add(boundary);
            } else {
              scheduleErrorRecovery(boundary);
            }

            return boundary;
          } else if (firstUncaughtError === null) {
            firstUncaughtError = error;
          }

          return null;
        }

        function hasCapturedError(fiber) {
          return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
        }

        function isFailedBoundary(fiber) {
          return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
        }

        function commitErrorHandling(effectfulFiber) {
          var capturedError = void 0;

          if (capturedErrors !== null) {
            capturedError = capturedErrors.get(effectfulFiber);
            capturedErrors["delete"](effectfulFiber);

            if (capturedError == null) {
              if (effectfulFiber.alternate !== null) {
                effectfulFiber = effectfulFiber.alternate;
                capturedError = capturedErrors.get(effectfulFiber);
                capturedErrors["delete"](effectfulFiber);
              }
            }
          }

          invariant(capturedError != null, "No error for given unit of work. This error is likely caused by a " + "bug in React. Please file an issue.");

          switch (effectfulFiber.tag) {
            case ClassComponent:
              var instance = effectfulFiber.stateNode;
              var info = {
                componentStack: capturedError.componentStack
              };
              instance.componentDidCatch(capturedError.error, info);
              return;

            case HostRoot:
              if (firstUncaughtError === null) {
                firstUncaughtError = capturedError.error;
              }

              return;

            default:
              invariant(false, "Invalid type of work. This error is likely caused by a bug in " + "React. Please file an issue.");
          }
        }

        function unwindContexts(from, to) {
          var node = from;

          while (node !== null) {
            switch (node.tag) {
              case ClassComponent:
                popContextProvider(node);
                break;

              case HostComponent:
                popHostContext(node);
                break;

              case HostRoot:
                popHostContainer(node);
                break;

              case HostPortal:
                popHostContainer(node);
                break;
            }

            if (node === to || node.alternate === to) {
              stopFailedWorkTimer(node);
              break;
            } else {
              stopWorkTimer(node);
            }

            node = node["return"];
          }
        }

        function computeAsyncExpiration() {
          var currentTime = recalculateCurrentTime();
          var expirationMs = 1000;
          var bucketSizeMs = 200;
          return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
        }

        function computeUniqueAsyncExpiration() {
          var result = computeAsyncExpiration();

          if (result <= lastUniqueAsyncExpiration) {
            result = lastUniqueAsyncExpiration + 1;
          }

          lastUniqueAsyncExpiration = result;
          return lastUniqueAsyncExpiration;
        }

        function computeExpirationForFiber(fiber) {
          var expirationTime = void 0;

          if (expirationContext !== NoWork) {
            expirationTime = expirationContext;
          } else if (isWorking) {
            if (isCommitting) {
              expirationTime = Sync;
            } else {
              expirationTime = nextRenderExpirationTime;
            }
          } else {
            if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
              expirationTime = Sync;
            } else {
              expirationTime = computeAsyncExpiration();
            }
          }

          return expirationTime;
        }

        function scheduleWork(fiber, expirationTime) {
          return scheduleWorkImpl(fiber, expirationTime, false);
        }

        function checkRootNeedsClearing(root, fiber, expirationTime) {
          if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
            if (nextUnitOfWork !== null) {
              interruptedBy = fiber;
            }

            nextRoot = null;
            nextUnitOfWork = null;
            nextRenderExpirationTime = NoWork;
          }
        }

        function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
          recordScheduleUpdate();
          {
            if (!isErrorRecovery && fiber.tag === ClassComponent) {
              var instance = fiber.stateNode;
              warnAboutInvalidUpdates(instance);
            }
          }
          var node = fiber;

          while (node !== null) {
            if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
              node.expirationTime = expirationTime;
            }

            if (node.alternate !== null) {
              if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
                node.alternate.expirationTime = expirationTime;
              }
            }

            if (node["return"] === null) {
              if (node.tag === HostRoot) {
                var root = node.stateNode;
                checkRootNeedsClearing(root, fiber, expirationTime);
                requestWork(root, expirationTime);
                checkRootNeedsClearing(root, fiber, expirationTime);
              } else {
                {
                  if (!isErrorRecovery && fiber.tag === ClassComponent) {
                    warnAboutUpdateOnUnmounted(fiber);
                  }
                }
                return;
              }
            }

            node = node["return"];
          }
        }

        function scheduleErrorRecovery(fiber) {
          scheduleWorkImpl(fiber, Sync, true);
        }

        function recalculateCurrentTime() {
          var ms = now() - startTime;
          mostRecentCurrentTime = msToExpirationTime(ms);
          return mostRecentCurrentTime;
        }

        function deferredUpdates(fn) {
          var previousExpirationContext = expirationContext;
          expirationContext = computeAsyncExpiration();

          try {
            return fn();
          } finally {
            expirationContext = previousExpirationContext;
          }
        }

        function syncUpdates(fn) {
          var previousExpirationContext = expirationContext;
          expirationContext = Sync;

          try {
            return fn();
          } finally {
            expirationContext = previousExpirationContext;
          }
        }

        var firstScheduledRoot = null;
        var lastScheduledRoot = null;
        var callbackExpirationTime = NoWork;
        var callbackID = -1;
        var isRendering = false;
        var nextFlushedRoot = null;
        var nextFlushedExpirationTime = NoWork;
        var deadlineDidExpire = false;
        var hasUnhandledError = false;
        var unhandledError = null;
        var deadline = null;
        var isBatchingUpdates = false;
        var isUnbatchingUpdates = false;
        var completedBatches = null;
        var NESTED_UPDATE_LIMIT = 1000;
        var nestedUpdateCount = 0;
        var timeHeuristicForUnitOfWork = 1;

        function scheduleCallbackWithExpiration(expirationTime) {
          if (callbackExpirationTime !== NoWork) {
            if (expirationTime > callbackExpirationTime) {
              return;
            } else {
              cancelDeferredCallback(callbackID);
            }
          } else {
            startRequestCallbackTimer();
          }

          var currentMs = now() - startTime;
          var expirationMs = expirationTimeToMs(expirationTime);
          var timeout = expirationMs - currentMs;
          callbackExpirationTime = expirationTime;
          callbackID = scheduleDeferredCallback(performAsyncWork, {
            timeout: timeout
          });
        }

        function requestWork(root, expirationTime) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            invariant(false, "Maximum update depth exceeded. This can happen when a " + "component repeatedly calls setState inside componentWillUpdate or " + "componentDidUpdate. React limits the number of nested updates to " + "prevent infinite loops.");
          }

          if (root.nextScheduledRoot === null) {
            root.remainingExpirationTime = expirationTime;

            if (lastScheduledRoot === null) {
              firstScheduledRoot = lastScheduledRoot = root;
              root.nextScheduledRoot = root;
            } else {
              lastScheduledRoot.nextScheduledRoot = root;
              lastScheduledRoot = root;
              lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            }
          } else {
            var remainingExpirationTime = root.remainingExpirationTime;

            if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
              root.remainingExpirationTime = expirationTime;
            }
          }

          if (isRendering) {
            return;
          }

          if (isBatchingUpdates) {
            if (isUnbatchingUpdates) {
              nextFlushedRoot = root;
              nextFlushedExpirationTime = Sync;
              performWorkOnRoot(root, Sync, recalculateCurrentTime());
            }

            return;
          }

          if (expirationTime === Sync) {
            performWork(Sync, null);
          } else {
            scheduleCallbackWithExpiration(expirationTime);
          }
        }

        function findHighestPriorityRoot() {
          var highestPriorityWork = NoWork;
          var highestPriorityRoot = null;

          if (lastScheduledRoot !== null) {
            var previousScheduledRoot = lastScheduledRoot;
            var root = firstScheduledRoot;

            while (root !== null) {
              var remainingExpirationTime = root.remainingExpirationTime;

              if (remainingExpirationTime === NoWork) {
                invariant(previousScheduledRoot !== null && lastScheduledRoot !== null, "Should have a previous and last root. This error is likely " + "caused by a bug in React. Please file an issue.");

                if (root === root.nextScheduledRoot) {
                  root.nextScheduledRoot = null;
                  firstScheduledRoot = lastScheduledRoot = null;
                  break;
                } else if (root === firstScheduledRoot) {
                  var next = root.nextScheduledRoot;
                  firstScheduledRoot = next;
                  lastScheduledRoot.nextScheduledRoot = next;
                  root.nextScheduledRoot = null;
                } else if (root === lastScheduledRoot) {
                  lastScheduledRoot = previousScheduledRoot;
                  lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                  root.nextScheduledRoot = null;
                  break;
                } else {
                  previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
                  root.nextScheduledRoot = null;
                }

                root = previousScheduledRoot.nextScheduledRoot;
              } else {
                if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
                  highestPriorityWork = remainingExpirationTime;
                  highestPriorityRoot = root;
                }

                if (root === lastScheduledRoot) {
                  break;
                }

                previousScheduledRoot = root;
                root = root.nextScheduledRoot;
              }
            }
          }

          var previousFlushedRoot = nextFlushedRoot;

          if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
            nestedUpdateCount++;
          } else {
            nestedUpdateCount = 0;
          }

          nextFlushedRoot = highestPriorityRoot;
          nextFlushedExpirationTime = highestPriorityWork;
        }

        function performAsyncWork(dl) {
          performWork(NoWork, dl);
        }

        function performWork(minExpirationTime, dl) {
          deadline = dl;
          findHighestPriorityRoot();

          if (enableUserTimingAPI && deadline !== null) {
            var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
            stopRequestCallbackTimer(didExpire);
          }

          while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, recalculateCurrentTime());
            findHighestPriorityRoot();
          }

          if (deadline !== null) {
            callbackExpirationTime = NoWork;
            callbackID = -1;
          }

          if (nextFlushedExpirationTime !== NoWork) {
            scheduleCallbackWithExpiration(nextFlushedExpirationTime);
          }

          deadline = null;
          deadlineDidExpire = false;
          nestedUpdateCount = 0;
          finishRendering();
        }

        function flushRoot(root, expirationTime) {
          invariant(!isRendering, "work.commit(): Cannot commit while already rendering. This likely " + "means you attempted to commit from inside a lifecycle method.");
          performWorkOnRoot(root, expirationTime, expirationTime);
          finishRendering();
        }

        function finishRendering() {
          if (completedBatches !== null) {
            var batches = completedBatches;
            completedBatches = null;

            for (var i = 0; i < batches.length; i++) {
              var batch = batches[i];

              try {
                batch._onComplete();
              } catch (error) {
                if (!hasUnhandledError) {
                  hasUnhandledError = true;
                  unhandledError = error;
                }
              }
            }
          }

          if (hasUnhandledError) {
            var _error4 = unhandledError;
            unhandledError = null;
            hasUnhandledError = false;
            throw _error4;
          }
        }

        function performWorkOnRoot(root, expirationTime, currentTime) {
          invariant(!isRendering, "performWorkOnRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
          isRendering = true;

          if (expirationTime <= currentTime) {
            var finishedWork = root.finishedWork;

            if (finishedWork !== null) {
              completeRoot(root, finishedWork, expirationTime);
            } else {
              root.finishedWork = null;
              finishedWork = renderRoot(root, expirationTime);

              if (finishedWork !== null) {
                completeRoot(root, finishedWork, expirationTime);
              }
            }
          } else {
            var _finishedWork = root.finishedWork;

            if (_finishedWork !== null) {
              completeRoot(root, _finishedWork, expirationTime);
            } else {
              root.finishedWork = null;
              _finishedWork = renderRoot(root, expirationTime);

              if (_finishedWork !== null) {
                if (!shouldYield()) {
                  completeRoot(root, _finishedWork, expirationTime);
                } else {
                  root.finishedWork = _finishedWork;
                }
              }
            }
          }

          isRendering = false;
        }

        function completeRoot(root, finishedWork, expirationTime) {
          var firstBatch = root.firstBatch;

          if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {
            if (completedBatches === null) {
              completedBatches = [firstBatch];
            } else {
              completedBatches.push(firstBatch);
            }

            if (firstBatch._defer) {
              root.finishedWork = finishedWork;
              root.remainingExpirationTime = NoWork;
              return;
            }
          }

          root.finishedWork = null;
          root.remainingExpirationTime = commitRoot(finishedWork);
        }

        function shouldYield() {
          if (deadline === null) {
            return false;
          }

          if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
            return false;
          }

          deadlineDidExpire = true;
          return true;
        }

        function onUncaughtError(error) {
          invariant(nextFlushedRoot !== null, "Should be working on a root. This error is likely caused by a bug in " + "React. Please file an issue.");
          nextFlushedRoot.remainingExpirationTime = NoWork;

          if (!hasUnhandledError) {
            hasUnhandledError = true;
            unhandledError = error;
          }
        }

        function batchedUpdates(fn, a) {
          var previousIsBatchingUpdates = isBatchingUpdates;
          isBatchingUpdates = true;

          try {
            return fn(a);
          } finally {
            isBatchingUpdates = previousIsBatchingUpdates;

            if (!isBatchingUpdates && !isRendering) {
              performWork(Sync, null);
            }
          }
        }

        function unbatchedUpdates(fn) {
          if (isBatchingUpdates && !isUnbatchingUpdates) {
            isUnbatchingUpdates = true;

            try {
              return fn();
            } finally {
              isUnbatchingUpdates = false;
            }
          }

          return fn();
        }

        function flushSync(fn) {
          var previousIsBatchingUpdates = isBatchingUpdates;
          isBatchingUpdates = true;

          try {
            return syncUpdates(fn);
          } finally {
            isBatchingUpdates = previousIsBatchingUpdates;
            invariant(!isRendering, "flushSync was called from inside a lifecycle method. It cannot be " + "called when React is already rendering.");
            performWork(Sync, null);
          }
        }

        return {
          computeAsyncExpiration: computeAsyncExpiration,
          computeExpirationForFiber: computeExpirationForFiber,
          scheduleWork: scheduleWork,
          requestWork: requestWork,
          flushRoot: flushRoot,
          batchedUpdates: batchedUpdates,
          unbatchedUpdates: unbatchedUpdates,
          flushSync: flushSync,
          deferredUpdates: deferredUpdates,
          computeUniqueAsyncExpiration: computeUniqueAsyncExpiration
        };
      };

      {
        var didWarnAboutNestedUpdates = false;
      }

      function getContextForSubtree(parentComponent) {
        if (!parentComponent) {
          return emptyObject;
        }

        var fiber = get(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);
        return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
      }

      var ReactFiberReconciler$1 = function ReactFiberReconciler$1(config) {
        var getPublicInstance = config.getPublicInstance;

        var _ReactFiberScheduler = ReactFiberScheduler(config),
            computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
            computeUniqueAsyncExpiration = _ReactFiberScheduler.computeUniqueAsyncExpiration,
            computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
            scheduleWork = _ReactFiberScheduler.scheduleWork,
            requestWork = _ReactFiberScheduler.requestWork,
            flushRoot = _ReactFiberScheduler.flushRoot,
            batchedUpdates = _ReactFiberScheduler.batchedUpdates,
            unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
            flushSync = _ReactFiberScheduler.flushSync,
            deferredUpdates = _ReactFiberScheduler.deferredUpdates;

        function computeRootExpirationTime(current, element) {
          var expirationTime = void 0;

          if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
            expirationTime = computeAsyncExpiration();
          } else {
            expirationTime = computeExpirationForFiber(current);
          }

          return expirationTime;
        }

        function scheduleRootUpdate(current, element, expirationTime, callback) {
          {
            if (ReactDebugCurrentFiber.phase === "render" && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
              didWarnAboutNestedUpdates = true;
              warning(false, "Render methods should be a pure function of props and state; " + "triggering nested component updates from render is not allowed. " + "If necessary, trigger nested updates in componentDidUpdate.\n\n" + "Check the render method of %s.", getComponentName(ReactDebugCurrentFiber.current) || "Unknown");
            }
          }
          callback = callback === undefined ? null : callback;
          {
            warning(callback === null || typeof callback === "function", "render(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callback);
          }
          var update = {
            expirationTime: expirationTime,
            partialState: {
              element: element
            },
            callback: callback,
            isReplace: false,
            isForced: false,
            next: null
          };
          insertUpdateIntoFiber(current, update);
          scheduleWork(current, expirationTime);
          return expirationTime;
        }

        function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
          var current = container.current;
          {
            if (ReactFiberInstrumentation_1.debugTool) {
              if (current.alternate === null) {
                ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
              } else if (element === null) {
                ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
              } else {
                ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
              }
            }
          }
          var context = getContextForSubtree(parentComponent);

          if (container.context === null) {
            container.context = context;
          } else {
            container.pendingContext = context;
          }

          return scheduleRootUpdate(current, element, expirationTime, callback);
        }

        function findHostInstance(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);

          if (hostFiber === null) {
            return null;
          }

          return hostFiber.stateNode;
        }

        return {
          createContainer: function createContainer(containerInfo, hydrate) {
            return createFiberRoot(containerInfo, hydrate);
          },
          updateContainer: function updateContainer(element, container, parentComponent, callback) {
            var current = container.current;
            var expirationTime = computeRootExpirationTime(current, element);
            return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
          },
          updateContainerAtExpirationTime: updateContainerAtExpirationTime,
          flushRoot: flushRoot,
          requestWork: requestWork,
          computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,
          batchedUpdates: batchedUpdates,
          unbatchedUpdates: unbatchedUpdates,
          deferredUpdates: deferredUpdates,
          flushSync: flushSync,
          getPublicRootInstance: function getPublicRootInstance(container) {
            var containerFiber = container.current;

            if (!containerFiber.child) {
              return null;
            }

            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);

              default:
                return containerFiber.child.stateNode;
            }
          },
          findHostInstance: findHostInstance,
          findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);

            if (hostFiber === null) {
              return null;
            }

            return hostFiber.stateNode;
          },
          injectIntoDevTools: function injectIntoDevTools(devToolsConfig) {
            var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            return injectInternals(babelHelpers.extends({}, devToolsConfig, {
              findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
                return findHostInstance(fiber);
              },
              findFiberByHostInstance: function findFiberByHostInstance(instance) {
                if (!_findFiberByHostInstance) {
                  return null;
                }

                return _findFiberByHostInstance(instance);
              }
            }));
          }
        };
      };

      var ReactFiberReconciler$2 = Object.freeze({
        default: ReactFiberReconciler$1
      });
      var ReactFiberReconciler$3 = ReactFiberReconciler$2 && ReactFiberReconciler$1 || ReactFiberReconciler$2;
      var reactReconciler = ReactFiberReconciler$3["default"] ? ReactFiberReconciler$3["default"] : ReactFiberReconciler$3;
      var viewConfigCallbacks = new Map();
      var viewConfigs = new Map();

      function register(name, callback) {
        invariant(!viewConfigCallbacks.has(name), "Tried to register two views with the same name %s", name);
        viewConfigCallbacks.set(name, callback);
        return name;
      }

      function get$1(name) {
        var viewConfig = void 0;

        if (!viewConfigs.has(name)) {
          var callback = viewConfigCallbacks.get(name);
          invariant(typeof callback === "function", "View config not found for name %s", name);
          viewConfigCallbacks.set(name, null);
          viewConfig = callback();
          viewConfigs.set(name, viewConfig);
        } else {
          viewConfig = viewConfigs.get(name);
        }

        invariant(viewConfig, "View config not found for name %s", name);
        return viewConfig;
      }

      function _classCallCheck$1(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var ReactNativeFiberHostComponent = function () {
        function ReactNativeFiberHostComponent(tag, viewConfig) {
          _classCallCheck$1(this, ReactNativeFiberHostComponent);

          this._nativeTag = tag;
          this._children = [];
          this.viewConfig = viewConfig;
        }

        ReactNativeFiberHostComponent.prototype.blur = function blur() {
          TextInputState.blurTextInput(this._nativeTag);
        };

        ReactNativeFiberHostComponent.prototype.focus = function focus() {
          TextInputState.focusTextInput(this._nativeTag);
        };

        ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {
          UIManager.measure(this._nativeTag, mountSafeCallback(this, callback));
        };

        ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(callback) {
          UIManager.measureInWindow(this._nativeTag, mountSafeCallback(this, callback));
        };

        ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback(this, onFail), mountSafeCallback(this, onSuccess));
        };

        ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
          {
            warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
          }
          var updatePayload = create(nativeProps, this.viewConfig.validAttributes);

          if (updatePayload != null) {
            UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, updatePayload);
          }
        };

        return ReactNativeFiberHostComponent;
      }();

      var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
      var now = hasNativePerformanceNow ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      };
      var scheduledCallback = null;
      var frameDeadline = 0;
      var frameDeadlineObject = {
        timeRemaining: function timeRemaining() {
          return frameDeadline - now();
        }
      };

      function setTimeoutCallback() {
        frameDeadline = now() + 5;
        var callback = scheduledCallback;
        scheduledCallback = null;

        if (callback !== null) {
          callback(frameDeadlineObject);
        }
      }

      function scheduleDeferredCallback(callback) {
        scheduledCallback = callback;
        return setTimeout(setTimeoutCallback, 1);
      }

      function cancelDeferredCallback(callbackID) {
        scheduledCallback = null;
        clearTimeout(callbackID);
      }

      function recursivelyUncacheFiberNode(node) {
        if (typeof node === "number") {
          uncacheFiberNode(node);
        } else {
          uncacheFiberNode(node._nativeTag);

          node._children.forEach(recursivelyUncacheFiberNode);
        }
      }

      var NativeRenderer = reactReconciler({
        appendInitialChild: function appendInitialChild(parentInstance, child) {
          parentInstance._children.push(child);
        },
        createInstance: function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          var tag = ReactNativeTagHandles.allocateTag();
          var viewConfig = get$1(type);
          {
            for (var key in viewConfig.validAttributes) {
              if (props.hasOwnProperty(key)) {
                deepFreezeAndThrowOnMutationInDev(props[key]);
              }
            }
          }
          var updatePayload = create(props, viewConfig.validAttributes);
          UIManager.createView(tag, viewConfig.uiViewClassName, rootContainerInstance, updatePayload);
          var component = new ReactNativeFiberHostComponent(tag, viewConfig);
          precacheFiberNode(internalInstanceHandle, tag);
          updateFiberProps(tag, props);
          return component;
        },
        createTextInstance: function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
          var tag = ReactNativeTagHandles.allocateTag();
          UIManager.createView(tag, "RCTRawText", rootContainerInstance, {
            text: text
          });
          precacheFiberNode(internalInstanceHandle, tag);
          return tag;
        },
        finalizeInitialChildren: function finalizeInitialChildren(parentInstance, type, props, rootContainerInstance) {
          if (parentInstance._children.length === 0) {
            return false;
          }

          var nativeTags = parentInstance._children.map(function (child) {
            return typeof child === "number" ? child : child._nativeTag;
          });

          UIManager.setChildren(parentInstance._nativeTag, nativeTags);
          return false;
        },
        getRootHostContext: function getRootHostContext() {
          return emptyObject;
        },
        getChildHostContext: function getChildHostContext() {
          return emptyObject;
        },
        getPublicInstance: function getPublicInstance(instance) {
          return instance;
        },
        now: now,
        prepareForCommit: function prepareForCommit() {},
        prepareUpdate: function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {
          return emptyObject;
        },
        resetAfterCommit: function resetAfterCommit() {},
        scheduleDeferredCallback: scheduleDeferredCallback,
        cancelDeferredCallback: cancelDeferredCallback,
        shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(type, props) {
          return false;
        },
        shouldSetTextContent: function shouldSetTextContent(type, props) {
          return false;
        },
        useSyncScheduling: true,
        mutation: {
          appendChild: function appendChild(parentInstance, child) {
            var childTag = typeof child === "number" ? child : child._nativeTag;
            var children = parentInstance._children;
            var index = children.indexOf(child);

            if (index >= 0) {
              children.splice(index, 1);
              children.push(child);
              UIManager.manageChildren(parentInstance._nativeTag, [index], [children.length - 1], [], [], []);
            } else {
              children.push(child);
              UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [children.length - 1], []);
            }
          },
          appendChildToContainer: function appendChildToContainer(parentInstance, child) {
            var childTag = typeof child === "number" ? child : child._nativeTag;
            UIManager.setChildren(parentInstance, [childTag]);
          },
          commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {
            UIManager.updateView(textInstance, "RCTRawText", {
              text: newText
            });
          },
          commitMount: function commitMount(instance, type, newProps, internalInstanceHandle) {},
          commitUpdate: function commitUpdate(instance, updatePayloadTODO, type, oldProps, newProps, internalInstanceHandle) {
            var viewConfig = instance.viewConfig;
            updateFiberProps(instance._nativeTag, newProps);
            var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);

            if (updatePayload != null) {
              UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
            }
          },
          insertBefore: function insertBefore(parentInstance, child, beforeChild) {
            var children = parentInstance._children;
            var index = children.indexOf(child);

            if (index >= 0) {
              children.splice(index, 1);
              var beforeChildIndex = children.indexOf(beforeChild);
              children.splice(beforeChildIndex, 0, child);
              UIManager.manageChildren(parentInstance._nativeTag, [index], [beforeChildIndex], [], [], []);
            } else {
              var _beforeChildIndex = children.indexOf(beforeChild);

              children.splice(_beforeChildIndex, 0, child);
              var childTag = typeof child === "number" ? child : child._nativeTag;
              UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [_beforeChildIndex], []);
            }
          },
          insertInContainerBefore: function insertInContainerBefore(parentInstance, child, beforeChild) {
            invariant(typeof parentInstance !== "number", "Container does not support insertBefore operation");
          },
          removeChild: function removeChild(parentInstance, child) {
            recursivelyUncacheFiberNode(child);
            var children = parentInstance._children;
            var index = children.indexOf(child);
            children.splice(index, 1);
            UIManager.manageChildren(parentInstance._nativeTag, [], [], [], [], [index]);
          },
          removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {
            recursivelyUncacheFiberNode(child);
            UIManager.manageChildren(parentInstance, [], [], [], [], [0]);
          },
          resetTextContent: function resetTextContent(instance) {}
        }
      });

      function findNodeHandle(componentOrHandle) {
        {
          var owner = ReactCurrentOwner.current;

          if (owner !== null && owner.stateNode !== null) {
            warning(owner.stateNode._warnedAboutRefsInRender, "%s is accessing findNodeHandle inside its render(). " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(owner) || "A component");
            owner.stateNode._warnedAboutRefsInRender = true;
          }
        }

        if (componentOrHandle == null) {
          return null;
        }

        if (typeof componentOrHandle === "number") {
          return componentOrHandle;
        }

        var component = componentOrHandle;
        var internalInstance = get(component);

        if (internalInstance) {
          return NativeRenderer.findHostInstance(internalInstance);
        } else {
          if (component) {
            return component;
          } else {
            invariant(typeof component === "object" && "_nativeTag" in component || component.render != null && typeof component.render === "function", "findNodeHandle(...): Argument is not a component " + "(type: %s, keys: %s)", typeof component, Object.keys(component));
            invariant(false, "findNodeHandle(...): Unable to find node handle for unmounted " + "component.");
          }
        }
      }

      function findNumericNodeHandleFiber(componentOrHandle) {
        var instance = findNodeHandle(componentOrHandle);

        if (instance == null || typeof instance === "number") {
          return instance;
        }

        return instance._nativeTag;
      }

      var NativeMethodsMixin = {
        measure: function measure(callback) {
          UIManager.measure(findNumericNodeHandleFiber(this), mountSafeCallback(this, callback));
        },
        measureInWindow: function measureInWindow(callback) {
          UIManager.measureInWindow(findNumericNodeHandleFiber(this), mountSafeCallback(this, callback));
        },
        measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(findNumericNodeHandleFiber(this), relativeToNativeNode, mountSafeCallback(this, onFail), mountSafeCallback(this, onSuccess));
        },
        setNativeProps: function setNativeProps(nativeProps) {
          var maybeInstance = void 0;

          try {
            maybeInstance = findNodeHandle(this);
          } catch (error) {}

          if (maybeInstance == null) {
            return;
          }

          var viewConfig = maybeInstance.viewConfig;
          {
            warnForStyleProps(nativeProps, viewConfig.validAttributes);
          }
          var updatePayload = create(nativeProps, viewConfig.validAttributes);

          if (updatePayload != null) {
            UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);
          }
        },
        focus: function focus() {
          TextInputState.focusTextInput(findNumericNodeHandleFiber(this));
        },
        blur: function blur() {
          TextInputState.blurTextInput(findNumericNodeHandleFiber(this));
        }
      };
      {
        var NativeMethodsMixin_DEV = NativeMethodsMixin;
        invariant(!NativeMethodsMixin_DEV.componentWillMount && !NativeMethodsMixin_DEV.componentWillReceiveProps, "Do not override existing functions.");

        NativeMethodsMixin_DEV.componentWillMount = function () {
          throwOnStylesProp(this, this.props);
        };

        NativeMethodsMixin_DEV.componentWillReceiveProps = function (newProps) {
          throwOnStylesProp(this, newProps);
        };
      }

      function _classCallCheck$2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var ReactNativeComponent = function (_React$Component) {
        _inherits(ReactNativeComponent, _React$Component);

        function ReactNativeComponent() {
          _classCallCheck$2(this, ReactNativeComponent);

          return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }

        ReactNativeComponent.prototype.blur = function blur() {
          TextInputState.blurTextInput(findNumericNodeHandleFiber(this));
        };

        ReactNativeComponent.prototype.focus = function focus() {
          TextInputState.focusTextInput(findNumericNodeHandleFiber(this));
        };

        ReactNativeComponent.prototype.measure = function measure(callback) {
          UIManager.measure(findNumericNodeHandleFiber(this), mountSafeCallback(this, callback));
        };

        ReactNativeComponent.prototype.measureInWindow = function measureInWindow(callback) {
          UIManager.measureInWindow(findNumericNodeHandleFiber(this), mountSafeCallback(this, callback));
        };

        ReactNativeComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(findNumericNodeHandleFiber(this), relativeToNativeNode, mountSafeCallback(this, onFail), mountSafeCallback(this, onSuccess));
        };

        ReactNativeComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
          var maybeInstance = void 0;

          try {
            maybeInstance = findNodeHandle(this);
          } catch (error) {}

          if (maybeInstance == null) {
            return;
          }

          var viewConfig = maybeInstance.viewConfig;
          var updatePayload = create(nativeProps, viewConfig.validAttributes);

          if (updatePayload != null) {
            UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);
          }
        };

        return ReactNativeComponent;
      }(React.Component);

      var getInspectorDataForViewTag = void 0;
      {
        var traverseOwnerTreeUp = function traverseOwnerTreeUp(hierarchy, instance) {
          if (instance) {
            hierarchy.unshift(instance);
            traverseOwnerTreeUp(hierarchy, instance._debugOwner);
          }
        };

        var getOwnerHierarchy = function getOwnerHierarchy(instance) {
          var hierarchy = [];
          traverseOwnerTreeUp(hierarchy, instance);
          return hierarchy;
        };

        var lastNonHostInstance = function lastNonHostInstance(hierarchy) {
          for (var i = hierarchy.length - 1; i > 1; i--) {
            var instance = hierarchy[i];

            if (instance.tag !== HostComponent) {
              return instance;
            }
          }

          return hierarchy[0];
        };

        var getHostProps = function getHostProps(fiber) {
          var host = findCurrentHostFiber(fiber);

          if (host) {
            return host.memoizedProps || emptyObject;
          }

          return emptyObject;
        };

        var getHostNode = function getHostNode(fiber, findNodeHandle) {
          var hostNode = void 0;

          while (fiber) {
            if (fiber.stateNode !== null && fiber.tag === HostComponent) {
              hostNode = findNodeHandle(fiber.stateNode);
            }

            if (hostNode) {
              return hostNode;
            }

            fiber = fiber.child;
          }

          return null;
        };

        var createHierarchy = function createHierarchy(fiberHierarchy) {
          return fiberHierarchy.map(function (fiber) {
            return {
              name: getComponentName(fiber),
              getInspectorData: function getInspectorData(findNodeHandle) {
                return {
                  measure: function measure(callback) {
                    return UIManager.measure(getHostNode(fiber, findNodeHandle), callback);
                  },
                  props: getHostProps(fiber),
                  source: fiber._debugSource
                };
              }
            };
          });
        };

        getInspectorDataForViewTag = function getInspectorDataForViewTag(viewTag) {
          var closestInstance = getInstanceFromTag(viewTag);

          if (!closestInstance) {
            return {
              hierarchy: [],
              props: emptyObject,
              selection: null,
              source: null
            };
          }

          var fiber = findCurrentFiberUsingSlowPath(closestInstance);
          var fiberHierarchy = getOwnerHierarchy(fiber);
          var instance = lastNonHostInstance(fiberHierarchy);
          var hierarchy = createHierarchy(fiberHierarchy);
          var props = getHostProps(instance);
          var source = instance._debugSource;
          var selection = fiberHierarchy.indexOf(instance);
          return {
            hierarchy: hierarchy,
            props: props,
            selection: selection,
            source: source
          };
        };
      }

      var createReactNativeComponentClass = function createReactNativeComponentClass(name, callback) {
        return register(name, callback);
      };

      function takeSnapshot(view, options) {
        if (typeof view !== "number" && view !== "window") {
          view = findNumericNodeHandleFiber(view) || "window";
        }

        return UIManager.__takeSnapshot(view, options);
      }

      injection$2.injectFiberBatchedUpdates(NativeRenderer.batchedUpdates);
      var roots = new Map();
      injection$4.injectDialog(showDialog$1);
      var ReactNativeRenderer = {
        NativeComponent: ReactNativeComponent,
        findNodeHandle: findNumericNodeHandleFiber,
        render: function render(element, containerTag, callback) {
          var root = roots.get(containerTag);

          if (!root) {
            root = NativeRenderer.createContainer(containerTag, false);
            roots.set(containerTag, root);
          }

          NativeRenderer.updateContainer(element, root, null, callback);
          return NativeRenderer.getPublicRootInstance(root);
        },
        unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
          var root = roots.get(containerTag);

          if (root) {
            NativeRenderer.updateContainer(null, root, null, function () {
              roots["delete"](containerTag);
            });
          }
        },
        unmountComponentAtNodeAndRemoveContainer: function unmountComponentAtNodeAndRemoveContainer(containerTag) {
          ReactNativeRenderer.unmountComponentAtNode(containerTag);
          UIManager.removeRootView(containerTag);
        },
        createPortal: function createPortal(children, containerTag) {
          var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return _createPortal(children, containerTag, null, key);
        },
        unstable_batchedUpdates: batchedUpdates,
        flushSync: NativeRenderer.flushSync,
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
          NativeMethodsMixin: NativeMethodsMixin,
          ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin,
          ReactGlobalSharedState: ReactGlobalSharedState,
          ReactNativeComponentTree: ReactNativeComponentTree,
          ReactNativePropRegistry: ReactNativePropRegistry,
          TouchHistoryMath: TouchHistoryMath,
          createReactNativeComponentClass: createReactNativeComponentClass,
          takeSnapshot: takeSnapshot
        }
      };
      {
        babelHelpers.extends(ReactNativeRenderer.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
          ReactDebugTool: {
            addHook: function addHook() {},
            removeHook: function removeHook() {}
          },
          ReactPerf: {
            start: function start() {},
            stop: function stop() {},
            printInclusive: function printInclusive() {},
            printWasted: function printWasted() {}
          }
        });
      }
      NativeRenderer.injectIntoDevTools({
        findFiberByHostInstance: getInstanceFromTag,
        getInspectorDataForViewTag: getInspectorDataForViewTag,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-native-renderer"
      });
      var ReactNativeRenderer$2 = Object.freeze({
        default: ReactNativeRenderer
      });
      var ReactNativeRenderer$3 = ReactNativeRenderer$2 && ReactNativeRenderer || ReactNativeRenderer$2;
      var reactNativeRenderer = ReactNativeRenderer$3["default"] ? ReactNativeRenderer$3["default"] : ReactNativeRenderer$3;
      module.exports = reactNativeRenderer;
    })();
  }
},75,[76,18,19,16,157,158,12,84,159,160,152,15,20,161,162,163],"ReactNativeRenderer-dev");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  if (global.GLOBAL === undefined) {
    global.GLOBAL = global;
  }

  if (global.window === undefined) {
    global.window = global;
  }

  var defineLazyObjectProperty = require(_dependencyMap[0], 'defineLazyObjectProperty');

  var _shouldPolyfillCollection = require(_dependencyMap[1], '_shouldPolyfillES6Collection');

  if (_shouldPolyfillCollection('Map')) {
    polyfillGlobal('Map', function () {
      return require(_dependencyMap[2], 'Map');
    });
  }

  if (_shouldPolyfillCollection('Set')) {
    polyfillGlobal('Set', function () {
      return require(_dependencyMap[3], 'Set');
    });
  }

  function defineLazyProperty(object, name, getValue) {
    var descriptor = Object.getOwnPropertyDescriptor(object, name);

    if (__DEV__ && descriptor) {
      var backupName = "original" + name[0].toUpperCase() + name.substr(1);
      Object.defineProperty(object, backupName, babelHelpers.extends({}, descriptor, {
        value: object[name]
      }));
    }

    var _ref = descriptor || {},
        enumerable = _ref.enumerable,
        writable = _ref.writable,
        configurable = _ref.configurable;

    if (descriptor && !configurable) {
      console.error('Failed to set polyfill. ' + name + ' is not configurable.');
      return;
    }

    defineLazyObjectProperty(object, name, {
      get: getValue,
      enumerable: enumerable !== false,
      writable: writable !== false
    });
  }

  function polyfillGlobal(name, getValue) {
    defineLazyProperty(global, name, getValue);
  }

  global.process = global.process || {};
  global.process.env = global.process.env || {};

  if (!global.process.env.NODE_ENV) {
    global.process.env.NODE_ENV = __DEV__ ? 'development' : 'production';
  }

  if (global.__RCTProfileIsProfiling) {
    var Systrace = require(_dependencyMap[4], 'Systrace');

    Systrace.installReactHook(true);
    Systrace.setEnabled(true);
  }

  var ExceptionsManager = require(_dependencyMap[5], 'ExceptionsManager');

  ExceptionsManager.installConsoleErrorReporter();

  if (!global.__fbDisableExceptionsManager) {
    var handleError = function handleError(e, isFatal) {
      try {
        ExceptionsManager.handleException(e, isFatal);
      } catch (ee) {
        console.log('Failed to print error: ', ee.message);
        throw e;
      }
    };

    var ErrorUtils = require(_dependencyMap[6], 'ErrorUtils');

    ErrorUtils.setGlobalHandler(handleError);
  }

  var ReactNativeVersionCheck = require(_dependencyMap[7], 'ReactNativeVersionCheck');

  ReactNativeVersionCheck.checkVersions();
  polyfillGlobal('Promise', function () {
    return require(_dependencyMap[8], 'Promise');
  });
  polyfillGlobal('regeneratorRuntime', function () {
    delete global.regeneratorRuntime;

    require(_dependencyMap[9], 'regenerator-runtime/runtime');

    return global.regeneratorRuntime;
  });

  var defineLazyTimer = function defineLazyTimer(name) {
    polyfillGlobal(name, function () {
      return require(_dependencyMap[10], 'JSTimers')[name];
    });
  };

  defineLazyTimer('setTimeout');
  defineLazyTimer('setInterval');
  defineLazyTimer('setImmediate');
  defineLazyTimer('clearTimeout');
  defineLazyTimer('clearInterval');
  defineLazyTimer('clearImmediate');
  defineLazyTimer('requestAnimationFrame');
  defineLazyTimer('cancelAnimationFrame');
  defineLazyTimer('requestIdleCallback');
  defineLazyTimer('cancelIdleCallback');
  polyfillGlobal('XMLHttpRequest', function () {
    return require(_dependencyMap[11], 'XMLHttpRequest');
  });
  polyfillGlobal('FormData', function () {
    return require(_dependencyMap[12], 'FormData');
  });
  polyfillGlobal('fetch', function () {
    return require(_dependencyMap[13], 'fetch').fetch;
  });
  polyfillGlobal('Headers', function () {
    return require(_dependencyMap[13], 'fetch').Headers;
  });
  polyfillGlobal('Request', function () {
    return require(_dependencyMap[13], 'fetch').Request;
  });
  polyfillGlobal('Response', function () {
    return require(_dependencyMap[13], 'fetch').Response;
  });
  polyfillGlobal('WebSocket', function () {
    return require(_dependencyMap[14], 'WebSocket');
  });
  polyfillGlobal('Blob', function () {
    return require(_dependencyMap[15], 'Blob');
  });
  polyfillGlobal('URL', function () {
    return require(_dependencyMap[16], 'URL');
  });

  if (!global.alert) {
    global.alert = function (text) {
      require(_dependencyMap[17], 'Alert').alert('Alert', '' + text);
    };
  }

  var navigator = global.navigator;

  if (navigator === undefined) {
    global.navigator = navigator = {};
  }

  defineLazyProperty(navigator, 'product', function () {
    return 'ReactNative';
  });
  defineLazyProperty(navigator, 'geolocation', function () {
    return require(_dependencyMap[18], 'Geolocation');
  });

  var BatchedBridge = require(_dependencyMap[19], 'BatchedBridge');

  BatchedBridge.registerLazyCallableModule('Systrace', function () {
    return require(_dependencyMap[4], 'Systrace');
  });
  BatchedBridge.registerLazyCallableModule('JSTimers', function () {
    return require(_dependencyMap[10], 'JSTimers');
  });
  BatchedBridge.registerLazyCallableModule('HeapCapture', function () {
    return require(_dependencyMap[20], 'HeapCapture');
  });
  BatchedBridge.registerLazyCallableModule('SamplingProfiler', function () {
    return require(_dependencyMap[21], 'SamplingProfiler');
  });
  BatchedBridge.registerLazyCallableModule('RCTLog', function () {
    return require(_dependencyMap[22], 'RCTLog');
  });
  BatchedBridge.registerLazyCallableModule('RCTDeviceEventEmitter', function () {
    return require(_dependencyMap[23], 'RCTDeviceEventEmitter');
  });
  BatchedBridge.registerLazyCallableModule('RCTNativeAppEventEmitter', function () {
    return require(_dependencyMap[24], 'RCTNativeAppEventEmitter');
  });
  BatchedBridge.registerLazyCallableModule('PerformanceLogger', function () {
    return require(_dependencyMap[25], 'PerformanceLogger');
  });

  global.fetchSegment = function (segmentId, callback) {
    var _require = require(_dependencyMap[26], 'NativeModules'),
        SegmentFetcher = _require.SegmentFetcher;

    if (!SegmentFetcher) {
      throw new Error('SegmentFetcher is missing. Please ensure that it is ' + 'included as a NativeModule.');
    }

    SegmentFetcher.fetchSegment(segmentId, function (errorObject) {
      if (errorObject) {
        var error = new Error(errorObject.message);
        error.code = errorObject.code;
        callback(error);
      }

      callback(null);
    });
  };

  if (__DEV__) {
    if (!global.__RCTProfileIsProfiling) {
      BatchedBridge.registerCallableModule('HMRClient', require(_dependencyMap[27], 'HMRClient'));

      if (!window.document) {
        require(_dependencyMap[28], 'setupDevtools');
      }

      var JSInspector = require(_dependencyMap[29], 'JSInspector');

      JSInspector.registerAgent(require(_dependencyMap[30], 'NetworkAgent'));
    }
  }
},76,[77,78,79,83,72,84,71,93,95,103,104,109,125,90,126,127,134,135,137,69,140,141,142,121,143,144,68,146,149,154,155],"InitializeCore");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function defineLazyObjectProperty(object, name, descriptor) {
    var get = descriptor.get;
    var enumerable = descriptor.enumerable !== false;
    var writable = descriptor.writable !== false;
    var value = void 0;
    var valueSet = false;

    function getValue() {
      if (!valueSet) {
        valueSet = true;
        setValue(get());
      }

      return value;
    }

    function setValue(newValue) {
      value = newValue;
      valueSet = true;
      Object.defineProperty(object, name, {
        value: newValue,
        configurable: true,
        enumerable: enumerable,
        writable: writable
      });
    }

    Object.defineProperty(object, name, {
      get: getValue,
      set: setValue,
      configurable: true,
      enumerable: enumerable
    });
  }

  module.exports = defineLazyObjectProperty;
},77,[],"defineLazyObjectProperty");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function _shouldActuallyPolyfillES6Collection(collectionName) {
    var Collection = global[collectionName];

    if (Collection == null) {
      return true;
    }

    if (typeof global.Symbol !== 'function') {
      return true;
    }

    var proto = Collection.prototype;
    return Collection == null || typeof Collection !== 'function' || typeof proto.clear !== 'function' || new Collection().size !== 0 || typeof proto.keys !== 'function' || typeof proto.forEach !== 'function';
  }

  var cache = {};

  function _shouldPolyfillES6Collection(collectionName) {
    var result = cache[collectionName];

    if (result !== undefined) {
      return result;
    }

    result = _shouldActuallyPolyfillES6Collection(collectionName);
    cache[collectionName] = result;
    return result;
  }

  module.exports = _shouldPolyfillES6Collection;
},78,[],"_shouldPolyfillES6Collection");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _shouldPolyfillES6Collection = require(_dependencyMap[0], '_shouldPolyfillES6Collection');

  var guid = require(_dependencyMap[1], 'guid');

  var isNode = require(_dependencyMap[2], 'fbjs/lib/isNode');

  var toIterator = require(_dependencyMap[3], 'toIterator');

  module.exports = function (global, undefined) {
    if (!_shouldPolyfillES6Collection('Map')) {
      return global.Map;
    }

    var KIND_KEY = 'key';
    var KIND_VALUE = 'value';
    var KIND_KEY_VALUE = 'key+value';
    var KEY_PREFIX = '$map_';
    var SECRET_SIZE_PROP;

    if (__DEV__) {
      SECRET_SIZE_PROP = '$size' + guid();
    }

    var OLD_IE_HASH_PREFIX = 'IE_HASH_';

    var Map = function () {
      function Map(iterable) {
        babelHelpers.classCallCheck(this, Map);

        if (!isObject(this)) {
          throw new TypeError('Wrong map object type.');
        }

        initMap(this);

        if (iterable != null) {
          var it = toIterator(iterable);
          var next;

          while (!(next = it.next()).done) {
            if (!isObject(next.value)) {
              throw new TypeError('Expected iterable items to be pair objects.');
            }

            this.set(next.value[0], next.value[1]);
          }
        }
      }

      babelHelpers.createClass(Map, [{
        key: "clear",
        value: function clear() {
          initMap(this);
        }
      }, {
        key: "has",
        value: function has(key) {
          var index = getIndex(this, key);
          return !!(index != null && this._mapData[index]);
        }
      }, {
        key: "set",
        value: function set(key, value) {
          var index = getIndex(this, key);

          if (index != null && this._mapData[index]) {
            this._mapData[index][1] = value;
          } else {
            index = this._mapData.push([key, value]) - 1;
            setIndex(this, key, index);

            if (__DEV__) {
              this[SECRET_SIZE_PROP] += 1;
            } else {
              this.size += 1;
            }
          }

          return this;
        }
      }, {
        key: "get",
        value: function get(key) {
          var index = getIndex(this, key);

          if (index == null) {
            return undefined;
          } else {
            return this._mapData[index][1];
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var index = getIndex(this, key);

          if (index != null && this._mapData[index]) {
            setIndex(this, key, undefined);
            this._mapData[index] = undefined;

            if (__DEV__) {
              this[SECRET_SIZE_PROP] -= 1;
            } else {
              this.size -= 1;
            }

            return true;
          } else {
            return false;
          }
        }
      }, {
        key: "entries",
        value: function entries() {
          return new MapIterator(this, KIND_KEY_VALUE);
        }
      }, {
        key: "keys",
        value: function keys() {
          return new MapIterator(this, KIND_KEY);
        }
      }, {
        key: "values",
        value: function values() {
          return new MapIterator(this, KIND_VALUE);
        }
      }, {
        key: "forEach",
        value: function forEach(callback, thisArg) {
          if (typeof callback !== 'function') {
            throw new TypeError('Callback must be callable.');
          }

          var boundCallback = callback.bind(thisArg || undefined);
          var mapData = this._mapData;

          for (var i = 0; i < mapData.length; i++) {
            var entry = mapData[i];

            if (entry != null) {
              boundCallback(entry[1], entry[0], this);
            }
          }
        }
      }]);
      return Map;
    }();

    Map.prototype[toIterator.ITERATOR_SYMBOL] = Map.prototype.entries;

    var MapIterator = function () {
      function MapIterator(map, kind) {
        babelHelpers.classCallCheck(this, MapIterator);

        if (!(isObject(map) && map._mapData)) {
          throw new TypeError('Object is not a map.');
        }

        if ([KIND_KEY, KIND_KEY_VALUE, KIND_VALUE].indexOf(kind) === -1) {
          throw new Error('Invalid iteration kind.');
        }

        this._map = map;
        this._nextIndex = 0;
        this._kind = kind;
      }

      babelHelpers.createClass(MapIterator, [{
        key: "next",
        value: function next() {
          if (!this instanceof Map) {
            throw new TypeError('Expected to be called on a MapIterator.');
          }

          var map = this._map;
          var index = this._nextIndex;
          var kind = this._kind;

          if (map == null) {
            return createIterResultObject(undefined, true);
          }

          var entries = map._mapData;

          while (index < entries.length) {
            var record = entries[index];
            index += 1;
            this._nextIndex = index;

            if (record) {
              if (kind === KIND_KEY) {
                return createIterResultObject(record[0], false);
              } else if (kind === KIND_VALUE) {
                return createIterResultObject(record[1], false);
              } else if (kind) {
                return createIterResultObject(record, false);
              }
            }
          }

          this._map = undefined;
          return createIterResultObject(undefined, true);
        }
      }]);
      return MapIterator;
    }();

    MapIterator.prototype[toIterator.ITERATOR_SYMBOL] = function () {
      return this;
    };

    function getIndex(map, key) {
      if (isObject(key)) {
        var hash = getHash(key);
        return map._objectIndex[hash];
      } else {
        var prefixedKey = KEY_PREFIX + key;

        if (typeof key === 'string') {
          return map._stringIndex[prefixedKey];
        } else {
          return map._otherIndex[prefixedKey];
        }
      }
    }

    function setIndex(map, key, index) {
      var shouldDelete = index == null;

      if (isObject(key)) {
        var hash = getHash(key);

        if (shouldDelete) {
          delete map._objectIndex[hash];
        } else {
          map._objectIndex[hash] = index;
        }
      } else {
        var prefixedKey = KEY_PREFIX + key;

        if (typeof key === 'string') {
          if (shouldDelete) {
            delete map._stringIndex[prefixedKey];
          } else {
            map._stringIndex[prefixedKey] = index;
          }
        } else {
          if (shouldDelete) {
            delete map._otherIndex[prefixedKey];
          } else {
            map._otherIndex[prefixedKey] = index;
          }
        }
      }
    }

    function initMap(map) {
      map._mapData = [];
      map._objectIndex = {};
      map._stringIndex = {};
      map._otherIndex = {};

      if (__DEV__) {
        if (isES5) {
          if (map.hasOwnProperty(SECRET_SIZE_PROP)) {
            map[SECRET_SIZE_PROP] = 0;
          } else {
            Object.defineProperty(map, SECRET_SIZE_PROP, {
              value: 0,
              writable: true
            });
            Object.defineProperty(map, 'size', {
              set: function set(v) {
                console.error('PLEASE FIX ME: You are changing the map size property which ' + 'should not be writable and will break in production.');
                throw new Error('The map size property is not writable.');
              },
              get: function get() {
                return map[SECRET_SIZE_PROP];
              }
            });
          }

          return;
        }
      }

      map.size = 0;
    }

    function isObject(o) {
      return o != null && (typeof o === 'object' || typeof o === 'function');
    }

    function createIterResultObject(value, done) {
      return {
        value: value,
        done: done
      };
    }

    var isES5 = function () {
      try {
        Object.defineProperty({}, 'x', {});
        return true;
      } catch (e) {
        return false;
      }
    }();

    function isExtensible(o) {
      if (!isES5) {
        return true;
      } else {
        return Object.isExtensible(o);
      }
    }

    function getIENodeHash(node) {
      var uniqueID;

      switch (node.nodeType) {
        case 1:
          uniqueID = node.uniqueID;
          break;

        case 9:
          uniqueID = node.documentElement.uniqueID;
          break;

        default:
          return null;
      }

      if (uniqueID) {
        return OLD_IE_HASH_PREFIX + uniqueID;
      } else {
        return null;
      }
    }

    var getHash = function () {
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      var hashProperty = guid();
      var hashCounter = 0;
      return function getHash(o) {
        if (o[hashProperty]) {
          return o[hashProperty];
        } else if (!isES5 && o.propertyIsEnumerable && o.propertyIsEnumerable[hashProperty]) {
          return o.propertyIsEnumerable[hashProperty];
        } else if (!isES5 && isNode(o) && getIENodeHash(o)) {
          return getIENodeHash(o);
        } else if (!isES5 && o[hashProperty]) {
          return o[hashProperty];
        }

        if (isExtensible(o)) {
          hashCounter += 1;

          if (isES5) {
            Object.defineProperty(o, hashProperty, {
              enumerable: false,
              writable: false,
              configurable: false,
              value: hashCounter
            });
          } else if (o.propertyIsEnumerable) {
            o.propertyIsEnumerable = function () {
              return propIsEnumerable.apply(this, arguments);
            };

            o.propertyIsEnumerable[hashProperty] = hashCounter;
          } else if (isNode(o)) {
            o[hashProperty] = hashCounter;
          } else {
            throw new Error('Unable to set a non-enumerable property on object.');
          }

          return hashCounter;
        } else {
          throw new Error('Non-extensible objects are not allowed as keys.');
        }
      };
    }();

    return Map;
  }(Function('return this')());
},79,[78,80,81,82],"Map");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function guid() {
    return 'f' + (Math.random() * (1 << 30)).toString(16).replace('.', '');
  }

  module.exports = guid;
},80,[],"guid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function isNode(object) {
    var doc = object ? object.ownerDocument || object : document;
    var defaultView = doc.defaultView || window;
    return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }

  module.exports = isNode;
},81,[],"fbjs/lib/isNode.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var KIND_KEY = 'key';
  var KIND_VALUE = 'value';
  var KIND_KEY_VAL = 'key+value';
  var ITERATOR_SYMBOL = typeof Symbol === 'function' ? typeof Symbol === "function" ? Symbol.iterator : "@@iterator" : '@@iterator';

  var toIterator = function () {
    if (!(Array.prototype[ITERATOR_SYMBOL] && String.prototype[ITERATOR_SYMBOL])) {
      return function () {
        var ArrayIterator = function () {
          function ArrayIterator(array, kind) {
            babelHelpers.classCallCheck(this, ArrayIterator);

            if (!Array.isArray(array)) {
              throw new TypeError('Object is not an Array');
            }

            this._iteratedObject = array;
            this._kind = kind;
            this._nextIndex = 0;
          }

          babelHelpers.createClass(ArrayIterator, [{
            key: "next",
            value: function next() {
              if (!this instanceof ArrayIterator) {
                throw new TypeError('Object is not an ArrayIterator');
              }

              if (this._iteratedObject == null) {
                return createIterResultObject(undefined, true);
              }

              var array = this._iteratedObject;
              var len = this._iteratedObject.length;
              var index = this._nextIndex;
              var kind = this._kind;

              if (index >= len) {
                this._iteratedObject = undefined;
                return createIterResultObject(undefined, true);
              }

              this._nextIndex = index + 1;

              if (kind === KIND_KEY) {
                return createIterResultObject(index, false);
              } else if (kind === KIND_VALUE) {
                return createIterResultObject(array[index], false);
              } else if (kind === KIND_KEY_VAL) {
                return createIterResultObject([index, array[index]], false);
              }
            }
          }, {
            key: '@@iterator',
            value: function iterator() {
              return this;
            }
          }]);
          return ArrayIterator;
        }();

        var StringIterator = function () {
          function StringIterator(string) {
            babelHelpers.classCallCheck(this, StringIterator);

            if (typeof string !== 'string') {
              throw new TypeError('Object is not a string');
            }

            this._iteratedString = string;
            this._nextIndex = 0;
          }

          babelHelpers.createClass(StringIterator, [{
            key: "next",
            value: function next() {
              if (!this instanceof StringIterator) {
                throw new TypeError('Object is not a StringIterator');
              }

              if (this._iteratedString == null) {
                return createIterResultObject(undefined, true);
              }

              var index = this._nextIndex;
              var s = this._iteratedString;
              var len = s.length;

              if (index >= len) {
                this._iteratedString = undefined;
                return createIterResultObject(undefined, true);
              }

              var ret;
              var first = s.charCodeAt(index);

              if (first < 0xD800 || first > 0xDBFF || index + 1 === len) {
                ret = s[index];
              } else {
                var second = s.charCodeAt(index + 1);

                if (second < 0xDC00 || second > 0xDFFF) {
                  ret = s[index];
                } else {
                  ret = s[index] + s[index + 1];
                }
              }

              this._nextIndex = index + ret.length;
              return createIterResultObject(ret, false);
            }
          }, {
            key: '@@iterator',
            value: function iterator() {
              return this;
            }
          }]);
          return StringIterator;
        }();

        function createIterResultObject(value, done) {
          return {
            value: value,
            done: done
          };
        }

        return function (object, kind) {
          if (typeof object === 'string') {
            return new StringIterator(object);
          } else if (Array.isArray(object)) {
            return new ArrayIterator(object, kind || KIND_VALUE);
          } else {
            return object[ITERATOR_SYMBOL]();
          }
        };
      }();
    } else {
      return function (object) {
        return object[ITERATOR_SYMBOL]();
      };
    }
  }();

  babelHelpers.extends(toIterator, {
    KIND_KEY: KIND_KEY,
    KIND_VALUE: KIND_VALUE,
    KIND_KEY_VAL: KIND_KEY_VAL,
    ITERATOR_SYMBOL: ITERATOR_SYMBOL
  });
  module.exports = toIterator;
},82,[],"toIterator");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Map = require(_dependencyMap[0], 'Map');

  var _shouldPolyfillES6Collection = require(_dependencyMap[1], '_shouldPolyfillES6Collection');

  var toIterator = require(_dependencyMap[2], 'toIterator');

  module.exports = function (global) {
    if (!_shouldPolyfillES6Collection('Set')) {
      return global.Set;
    }

    var Set = function () {
      function Set(iterable) {
        babelHelpers.classCallCheck(this, Set);

        if (this == null || typeof this !== 'object' && typeof this !== 'function') {
          throw new TypeError('Wrong set object type.');
        }

        initSet(this);

        if (iterable != null) {
          var it = toIterator(iterable);
          var next;

          while (!(next = it.next()).done) {
            this.add(next.value);
          }
        }
      }

      babelHelpers.createClass(Set, [{
        key: "add",
        value: function add(value) {
          this._map.set(value, value);

          this.size = this._map.size;
          return this;
        }
      }, {
        key: "clear",
        value: function clear() {
          initSet(this);
        }
      }, {
        key: "delete",
        value: function _delete(value) {
          var ret = this._map.delete(value);

          this.size = this._map.size;
          return ret;
        }
      }, {
        key: "entries",
        value: function entries() {
          return this._map.entries();
        }
      }, {
        key: "forEach",
        value: function forEach(callback) {
          var thisArg = arguments[1];

          var it = this._map.keys();

          var next;

          while (!(next = it.next()).done) {
            callback.call(thisArg, next.value, next.value, this);
          }
        }
      }, {
        key: "has",
        value: function has(value) {
          return this._map.has(value);
        }
      }, {
        key: "values",
        value: function values() {
          return this._map.values();
        }
      }]);
      return Set;
    }();

    Set.prototype[toIterator.ITERATOR_SYMBOL] = Set.prototype.values;
    Set.prototype.keys = Set.prototype.values;

    function initSet(set) {
      set._map = new Map();
      set.size = set._map.size;
    }

    return Set;
  }(Function('return this')());
},83,[79,78,82],"Set");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var exceptionID = 0;

  function reportException(e, isFatal) {
    var _require = require(_dependencyMap[0], 'NativeModules'),
        ExceptionsManager = _require.ExceptionsManager;

    if (ExceptionsManager) {
      var parseErrorStack = require(_dependencyMap[1], 'parseErrorStack');

      var stack = parseErrorStack(e);
      var currentExceptionID = ++exceptionID;

      if (isFatal) {
        ExceptionsManager.reportFatalException(e.message, stack, currentExceptionID);
      } else {
        ExceptionsManager.reportSoftException(e.message, stack, currentExceptionID);
      }

      if (__DEV__) {
        var symbolicateStackTrace = require(_dependencyMap[2], 'symbolicateStackTrace');

        symbolicateStackTrace(stack).then(function (prettyStack) {
          if (prettyStack) {
            ExceptionsManager.updateExceptionMessage(e.message, prettyStack, currentExceptionID);
          } else {
            throw new Error('The stack is null');
          }
        }).catch(function (error) {
          return console.warn('Unable to symbolicate stack trace: ' + error.message);
        });
      }
    }
  }

  function handleException(e, isFatal) {
    if (!e.message) {
      e = new Error(e);
    }

    if (console._errorOriginal) {
      console._errorOriginal(e.message);
    } else {
      console.error(e.message);
    }

    reportException(e, isFatal);
  }

  function reactConsoleErrorHandler() {
    console._errorOriginal.apply(console, arguments);

    if (!console.reportErrorsAsExceptions) {
      return;
    }

    if (arguments[0] && arguments[0].stack) {
      reportException(arguments[0], false);
    } else {
      var stringifySafe = require(_dependencyMap[3], 'stringifySafe');

      var str = Array.prototype.map.call(arguments, stringifySafe).join(', ');

      if (str.slice(0, 10) === '"Warning: ') {
        return;
      }

      var error = new Error('console.error: ' + str);
      error.framesToPop = 1;
      reportException(error, false);
    }
  }

  function installConsoleErrorReporter() {
    if (console._errorOriginal) {
      return;
    }

    console._errorOriginal = console.error.bind(console);
    console.error = reactConsoleErrorHandler;

    if (console.reportErrorsAsExceptions === undefined) {
      console.reportErrorsAsExceptions = true;
    }
  }

  module.exports = {
    handleException: handleException,
    installConsoleErrorReporter: installConsoleErrorReporter
  };
},84,[68,85,88,92],"ExceptionsManager");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function parseErrorStack(e) {
    if (!e || !e.stack) {
      return [];
    }

    var stacktraceParser = require(_dependencyMap[0], 'stacktrace-parser');

    var stack = Array.isArray(e.stack) ? e.stack : stacktraceParser.parse(e.stack);
    var framesToPop = typeof e.framesToPop === 'number' ? e.framesToPop : 0;

    while (framesToPop--) {
      stack.shift();
    }

    return stack;
  }

  module.exports = parseErrorStack;
},85,[86],"parseErrorStack");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = require(_dependencyMap[0], './lib/stacktrace-parser.js');
},86,[87],"stacktrace-parser/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var UNKNOWN_FUNCTION = '<unknown>';
    var StackTraceParser = {
        parse: function parse(stackString) {
            var chrome = /^\s*at (?:(?:(?:Anonymous function)?|((?:\[object object\])?\S+(?: \[as \S+\])?)) )?\(?((?:file|http|https):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
                gecko = /^(?:\s*([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i,
                node = /^\s*at (?:((?:\[object object\])?\S+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i,
                lines = stackString.split('\n'),
                stack = [],
                parts,
                element;

            for (var i = 0, j = lines.length; i < j; ++i) {
                if (parts = gecko.exec(lines[i])) {
                    element = {
                        'file': parts[3],
                        'methodName': parts[1] || UNKNOWN_FUNCTION,
                        'lineNumber': +parts[4],
                        'column': parts[5] ? +parts[5] : null
                    };
                } else if (parts = chrome.exec(lines[i])) {
                    element = {
                        'file': parts[2],
                        'methodName': parts[1] || UNKNOWN_FUNCTION,
                        'lineNumber': +parts[3],
                        'column': parts[4] ? +parts[4] : null
                    };
                } else if (parts = node.exec(lines[i])) {
                    element = {
                        'file': parts[2],
                        'methodName': parts[1] || UNKNOWN_FUNCTION,
                        'lineNumber': +parts[3],
                        'column': parts[4] ? +parts[4] : null
                    };
                } else {
                    continue;
                }

                stack.push(element);
            }

            return stack;
        }
    };
    module.exports = StackTraceParser;
},87,[],"stacktrace-parser/lib/stacktrace-parser.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var getDevServer = require(_dependencyMap[0], 'getDevServer');

  var _require = require(_dependencyMap[1], 'NativeModules'),
      SourceCode = _require.SourceCode;

  var fetch = void 0;

  function isSourcedFromDisk(sourcePath) {
    return !/^http/.test(sourcePath) && /[\\/]/.test(sourcePath);
  }

  function symbolicateStackTrace(stack) {
    var devServer, stackCopy, foundInternalSource, response, json;
    return regeneratorRuntime.async(function symbolicateStackTrace$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!fetch) {
              fetch = global.fetch || require(_dependencyMap[2], 'fetch').fetch;
            }

            devServer = getDevServer();

            if (devServer.bundleLoadedFromServer) {
              _context.next = 4;
              break;
            }

            throw new Error('Bundle was not loaded from the packager');

          case 4:
            stackCopy = stack;

            if (SourceCode.scriptURL) {
              foundInternalSource = false;
              stackCopy = stack.map(function (frame) {
                if (!foundInternalSource && isSourcedFromDisk(frame.file)) {
                  return babelHelpers.extends({}, frame, {
                    file: SourceCode.scriptURL
                  });
                }

                foundInternalSource = true;
                return frame;
              });
            }

            _context.next = 8;
            return regeneratorRuntime.awrap(fetch(devServer.url + 'symbolicate', {
              method: 'POST',
              body: JSON.stringify({
                stack: stackCopy
              })
            }));

          case 8:
            response = _context.sent;
            _context.next = 11;
            return regeneratorRuntime.awrap(response.json());

          case 11:
            json = _context.sent;
            return _context.abrupt("return", json.stack);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, null, this);
  }

  module.exports = symbolicateStackTrace;
},88,[89,68,90],"symbolicateStackTrace");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'NativeModules'),
      SourceCode = _require.SourceCode;

  var _cachedDevServerURL = void 0;

  var FALLBACK = 'http://localhost:8081/';

  function getDevServer() {
    if (_cachedDevServerURL === undefined) {
      var match = SourceCode.scriptURL && SourceCode.scriptURL.match(/^https?:\/\/.*?\//);
      _cachedDevServerURL = match ? match[0] : null;
    }

    return {
      url: _cachedDevServerURL || FALLBACK,
      bundleLoadedFromServer: _cachedDevServerURL !== null
    };
  }

  module.exports = getDevServer;
},89,[68],"getDevServer");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _whatwgFetch = require(_dependencyMap[0], "whatwg-fetch");

  var _whatwgFetch2 = babelHelpers.interopRequireDefault(_whatwgFetch);

  if (_whatwgFetch2.default && _whatwgFetch2.default.fetch) {
    module.exports = _whatwgFetch2.default;
  } else {
    module.exports = {
      fetch: fetch,
      Headers: Headers,
      Request: Request,
      Response: Response
    };
  }
},90,[91],"fetch");
__d(function (global, require, module, exports, _dependencyMap) {
  (function (self) {
    'use strict';

    if (self.fetch) {
      return;
    }

    var support = {
      searchParams: 'URLSearchParams' in self,
      iterable: 'Symbol' in self && 'iterator' in Symbol,
      blob: 'FileReader' in self && 'Blob' in self && function () {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: 'FormData' in self,
      arrayBuffer: 'ArrayBuffer' in self
    };

    if (support.arrayBuffer) {
      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

      var isDataView = function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      };

      var isArrayBufferView = ArrayBuffer.isView || function (obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }

    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }

      if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
      }

      return name.toLowerCase();
    }

    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }

      return value;
    }

    function iteratorFor(items) {
      var iterator = {
        next: function next() {
          var value = items.shift();
          return {
            done: value === undefined,
            value: value
          };
        }
      };

      if (support.iterable) {
        iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
          return iterator;
        };
      }

      return iterator;
    }

    function Headers(headers) {
      this.map = {};

      if (headers instanceof Headers) {
        headers.forEach(function (value, name) {
          this.append(name, value);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function (name) {
          this.append(name, headers[name]);
        }, this);
      }
    }

    Headers.prototype.append = function (name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var list = this.map[name];

      if (!list) {
        list = [];
        this.map[name] = list;
      }

      list.push(value);
    };

    Headers.prototype['delete'] = function (name) {
      delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function (name) {
      var values = this.map[normalizeName(name)];
      return values ? values[0] : null;
    };

    Headers.prototype.getAll = function (name) {
      return this.map[normalizeName(name)] || [];
    };

    Headers.prototype.has = function (name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };

    Headers.prototype.set = function (name, value) {
      this.map[normalizeName(name)] = [normalizeValue(value)];
    };

    Headers.prototype.forEach = function (callback, thisArg) {
      Object.getOwnPropertyNames(this.map).forEach(function (name) {
        this.map[name].forEach(function (value) {
          callback.call(thisArg, value, name, this);
        }, this);
      }, this);
    };

    Headers.prototype.keys = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };

    Headers.prototype.values = function () {
      var items = [];
      this.forEach(function (value) {
        items.push(value);
      });
      return iteratorFor(items);
    };

    Headers.prototype.entries = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };

    if (support.iterable) {
      Headers.prototype[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = Headers.prototype.entries;
    }

    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }

      body.bodyUsed = true;
    }

    function fileReaderReady(reader) {
      return new Promise(function (resolve, reject) {
        reader.onload = function () {
          resolve(reader.result);
        };

        reader.onerror = function () {
          reject(reader.error);
        };
      });
    }

    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise;
    }

    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise;
    }

    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);

      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }

      return chars.join('');
    }

    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0);
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
      }
    }

    function Body() {
      this.bodyUsed = false;

      this._initBody = function (body) {
        this._bodyInit = body;

        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          throw new Error('unsupported BodyInit type');
        }

        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };

      if (support.blob) {
        this.blob = function () {
          var rejected = consumed(this);

          if (rejected) {
            return rejected;
          }

          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob');
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };

        this.arrayBuffer = function () {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
          } else {
            return this.blob().then(readBlobAsArrayBuffer);
          }
        };
      }

      this.text = function () {
        var rejected = consumed(this);

        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };

      if (support.formData) {
        this.formData = function () {
          return this.text().then(decode);
        };
      }

      this.json = function () {
        return this.text().then(JSON.parse);
      };

      return this;
    }

    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method;
    }

    function Request(input, options) {
      options = options || {};
      var body = options.body;

      if (typeof input === 'string') {
        this.url = input;
      } else {
        if (input.bodyUsed) {
          throw new TypeError('Already read');
        }

        this.url = input.url;
        this.credentials = input.credentials;

        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }

        this.method = input.method;
        this.mode = input.mode;

        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      }

      this.credentials = options.credentials || this.credentials || 'omit';

      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }

      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.referrer = null;

      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests');
      }

      this._initBody(body);
    }

    Request.prototype.clone = function () {
      return new Request(this, {
        body: this._bodyInit
      });
    };

    function decode(body) {
      var form = new FormData();
      body.trim().split('&').forEach(function (bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form;
    }

    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      rawHeaders.split('\r\n').forEach(function (line) {
        var parts = line.split(':');
        var key = parts.shift().trim();

        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers;
    }

    Body.call(Request.prototype);

    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }

      this.type = 'default';
      this.status = 'status' in options ? options.status : 200;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = 'statusText' in options ? options.statusText : 'OK';
      this.headers = new Headers(options.headers);
      this.url = options.url || '';

      this._initBody(bodyInit);
    }

    Body.call(Response.prototype);

    Response.prototype.clone = function () {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };

    Response.error = function () {
      var response = new Response(null, {
        status: 0,
        statusText: ''
      });
      response.type = 'error';
      return response;
    };

    var redirectStatuses = [301, 302, 303, 307, 308];

    Response.redirect = function (url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code');
      }

      return new Response(null, {
        status: status,
        headers: {
          location: url
        }
      });
    };

    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;

    self.fetch = function (input, init) {
      return new Promise(function (resolve, reject) {
        var request = new Request(input, init);
        var xhr = new XMLHttpRequest();

        xhr.onload = function () {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          resolve(new Response(body, options));
        };

        xhr.onerror = function () {
          reject(new TypeError('Network request failed'));
        };

        xhr.ontimeout = function () {
          reject(new TypeError('Network request failed'));
        };

        xhr.open(request.method, request.url, true);

        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        }

        if ('responseType' in xhr && support.blob) {
          xhr.responseType = 'blob';
        }

        request.headers.forEach(function (value, name) {
          xhr.setRequestHeader(name, value);
        });
        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      });
    };

    self.fetch.polyfill = true;
  })(typeof self !== 'undefined' ? self : this);
},91,[],"whatwg-fetch/fetch.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function stringifySafe(arg) {
    var ret;
    var type = typeof arg;

    if (arg === undefined) {
      ret = 'undefined';
    } else if (arg === null) {
      ret = 'null';
    } else if (type === 'string') {
      ret = '"' + arg + '"';
    } else if (type === 'function') {
      try {
        ret = arg.toString();
      } catch (e) {
        ret = '[function unknown]';
      }
    } else {
      try {
        ret = JSON.stringify(arg);
      } catch (e) {
        if (typeof arg.toString === 'function') {
          try {
            ret = arg.toString();
          } catch (E) {}
        }
      }
    }

    return ret || '["' + type + '" failed to stringify]';
  }

  module.exports = stringifySafe;
},92,[],"stringifySafe");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'NativeModules'),
      PlatformConstants = _require.PlatformConstants;

  var ReactNativeVersion = require(_dependencyMap[1], 'ReactNativeVersion');

  exports.checkVersions = function checkVersions() {
    if (!PlatformConstants) {
      return;
    }

    var nativeVersion = PlatformConstants.reactNativeVersion;

    if (ReactNativeVersion.version.major !== nativeVersion.major || ReactNativeVersion.version.minor !== nativeVersion.minor) {
      console.error("React Native version mismatch.\n\nJavaScript version: " + _formatVersion(ReactNativeVersion.version) + "\n" + ("Native version: " + _formatVersion(nativeVersion) + "\n\n") + 'Make sure that you have rebuilt the native code. If the problem ' + 'persists try clearing the Watchman and packager caches with ' + '`watchman watch-del-all && react-native start --reset-cache`.');
    }
  };

  function _formatVersion(version) {
    return version.major + "." + version.minor + "." + version.patch + (version.prerelease !== null ? "-" + version.prerelease : '');
  }
},93,[68,94],"ReactNativeVersionCheck");
__d(function (global, require, module, exports, _dependencyMap) {
  exports.version = {
    major: 0,
    minor: 52,
    patch: 0,
    prerelease: null
  };
},94,[],"ReactNativeVersion");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Promise = require(_dependencyMap[0], 'fbjs/lib/Promise.native');

  if (__DEV__) {
    require(_dependencyMap[1], 'promise/setimmediate/rejection-tracking').enable({
      allRejections: true,
      onUnhandled: function onUnhandled(id) {
        var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var message = void 0;
        var stack = void 0;
        var stringValue = Object.prototype.toString.call(error);

        if (stringValue === '[object Error]') {
          message = Error.prototype.toString.call(error);
          stack = error.stack;
        } else {
          message = require(_dependencyMap[2], 'pretty-format')(error);
        }

        var warning = "Possible Unhandled Promise Rejection (id: " + id + "):\n" + (message + "\n") + (stack == null ? '' : stack);
        console.warn(warning);
      },
      onHandled: function onHandled(id) {
        var warning = "Promise Rejection Handled (id: " + id + ")\n" + 'This means you can ignore any previous messages of the form ' + ("\"Possible Unhandled Promise Rejection (id: " + id + "):\"");
        console.warn(warning);
      }
    });
  }

  module.exports = Promise;
},95,[96,100,101],"Promise");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Promise = require(_dependencyMap[0], 'promise/setimmediate/es6-extensions');

  require(_dependencyMap[1], 'promise/setimmediate/done');

  Promise.prototype['finally'] = function (onSettled) {
    return this.then(onSettled, onSettled);
  };

  module.exports = Promise;
},96,[97,99],"fbjs/lib/Promise.native.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Promise = require(_dependencyMap[0], './core.js');

  module.exports = Promise;
  var TRUE = valuePromise(true);
  var FALSE = valuePromise(false);
  var NULL = valuePromise(null);
  var UNDEFINED = valuePromise(undefined);
  var ZERO = valuePromise(0);
  var EMPTYSTRING = valuePromise('');

  function valuePromise(value) {
    var p = new Promise(Promise._61);
    p._65 = 1;
    p._55 = value;
    return p;
  }

  Promise.resolve = function (value) {
    if (value instanceof Promise) return value;
    if (value === null) return NULL;
    if (value === undefined) return UNDEFINED;
    if (value === true) return TRUE;
    if (value === false) return FALSE;
    if (value === 0) return ZERO;
    if (value === '') return EMPTYSTRING;

    if (typeof value === 'object' || typeof value === 'function') {
      try {
        var then = value.then;

        if (typeof then === 'function') {
          return new Promise(then.bind(value));
        }
      } catch (ex) {
        return new Promise(function (resolve, reject) {
          reject(ex);
        });
      }
    }

    return valuePromise(value);
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);
    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          if (val instanceof Promise && val.then === Promise.prototype.then) {
            while (val._65 === 3) {
              val = val._55;
            }

            if (val._65 === 1) return res(i, val._55);
            if (val._65 === 2) reject(val._55);
            val.then(function (val) {
              res(i, val);
            }, reject);
            return;
          } else {
            var then = val.then;

            if (typeof then === 'function') {
              var p = new Promise(then.bind(val));
              p.then(function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
        }

        args[i] = val;

        if (--remaining === 0) {
          resolve(args);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      values.forEach(function (value) {
        Promise.resolve(value).then(resolve, reject);
      });
    });
  };

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };
},97,[98],"promise/setimmediate/es6-extensions.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function noop() {}

  var LAST_ERROR = null;
  var IS_ERROR = {};

  function getThen(obj) {
    try {
      return obj.then;
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }

  function tryCallOne(fn, a) {
    try {
      return fn(a);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }

  function tryCallTwo(fn, a, b) {
    try {
      fn(a, b);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }

  module.exports = Promise;

  function Promise(fn) {
    if (typeof this !== 'object') {
      throw new TypeError('Promises must be constructed via new');
    }

    if (typeof fn !== 'function') {
      throw new TypeError('Promise constructor\'s argument is not a function');
    }

    this._40 = 0;
    this._65 = 0;
    this._55 = null;
    this._72 = null;
    if (fn === noop) return;
    doResolve(fn, this);
  }

  Promise._37 = null;
  Promise._87 = null;
  Promise._61 = noop;

  Promise.prototype.then = function (onFulfilled, onRejected) {
    if (this.constructor !== Promise) {
      return safeThen(this, onFulfilled, onRejected);
    }

    var res = new Promise(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
  };

  function safeThen(self, onFulfilled, onRejected) {
    return new self.constructor(function (resolve, reject) {
      var res = new Promise(noop);
      res.then(resolve, reject);
      handle(self, new Handler(onFulfilled, onRejected, res));
    });
  }

  function handle(self, deferred) {
    while (self._65 === 3) {
      self = self._55;
    }

    if (Promise._37) {
      Promise._37(self);
    }

    if (self._65 === 0) {
      if (self._40 === 0) {
        self._40 = 1;
        self._72 = deferred;
        return;
      }

      if (self._40 === 1) {
        self._40 = 2;
        self._72 = [self._72, deferred];
        return;
      }

      self._72.push(deferred);

      return;
    }

    handleResolved(self, deferred);
  }

  function handleResolved(self, deferred) {
    setImmediate(function () {
      var cb = self._65 === 1 ? deferred.onFulfilled : deferred.onRejected;

      if (cb === null) {
        if (self._65 === 1) {
          resolve(deferred.promise, self._55);
        } else {
          reject(deferred.promise, self._55);
        }

        return;
      }

      var ret = tryCallOne(cb, self._55);

      if (ret === IS_ERROR) {
        reject(deferred.promise, LAST_ERROR);
      } else {
        resolve(deferred.promise, ret);
      }
    });
  }

  function resolve(self, newValue) {
    if (newValue === self) {
      return reject(self, new TypeError('A promise cannot be resolved with itself.'));
    }

    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
      var then = getThen(newValue);

      if (then === IS_ERROR) {
        return reject(self, LAST_ERROR);
      }

      if (then === self.then && newValue instanceof Promise) {
        self._65 = 3;
        self._55 = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(then.bind(newValue), self);
        return;
      }
    }

    self._65 = 1;
    self._55 = newValue;
    finale(self);
  }

  function reject(self, newValue) {
    self._65 = 2;
    self._55 = newValue;

    if (Promise._87) {
      Promise._87(self, newValue);
    }

    finale(self);
  }

  function finale(self) {
    if (self._40 === 1) {
      handle(self, self._72);
      self._72 = null;
    }

    if (self._40 === 2) {
      for (var i = 0; i < self._72.length; i++) {
        handle(self, self._72[i]);
      }

      self._72 = null;
    }
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  function doResolve(fn, promise) {
    var done = false;
    var res = tryCallTwo(fn, function (value) {
      if (done) return;
      done = true;
      resolve(promise, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(promise, reason);
    });

    if (!done && res === IS_ERROR) {
      done = true;
      reject(promise, LAST_ERROR);
    }
  }
},98,[],"promise/setimmediate/core.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Promise = require(_dependencyMap[0], './core.js');

  module.exports = Promise;

  Promise.prototype.done = function (onFulfilled, onRejected) {
    var self = arguments.length ? this.then.apply(this, arguments) : this;
    self.then(null, function (err) {
      setTimeout(function () {
        throw err;
      }, 0);
    });
  };
},99,[98],"promise/setimmediate/done.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Promise = require(_dependencyMap[0], './core');

  var DEFAULT_WHITELIST = [ReferenceError, TypeError, RangeError];
  var enabled = false;
  exports.disable = disable;

  function disable() {
    enabled = false;
    Promise._37 = null;
    Promise._87 = null;
  }

  exports.enable = enable;

  function enable(options) {
    options = options || {};
    if (enabled) disable();
    enabled = true;
    var id = 0;
    var displayId = 0;
    var rejections = {};

    Promise._37 = function (promise) {
      if (promise._65 === 2 && rejections[promise._51]) {
        if (rejections[promise._51].logged) {
          onHandled(promise._51);
        } else {
          clearTimeout(rejections[promise._51].timeout);
        }

        delete rejections[promise._51];
      }
    };

    Promise._87 = function (promise, err) {
      if (promise._40 === 0) {
        promise._51 = id++;
        rejections[promise._51] = {
          displayId: null,
          error: err,
          timeout: setTimeout(onUnhandled.bind(null, promise._51), matchWhitelist(err, DEFAULT_WHITELIST) ? 100 : 2000),
          logged: false
        };
      }
    };

    function onUnhandled(id) {
      if (options.allRejections || matchWhitelist(rejections[id].error, options.whitelist || DEFAULT_WHITELIST)) {
        rejections[id].displayId = displayId++;

        if (options.onUnhandled) {
          rejections[id].logged = true;
          options.onUnhandled(rejections[id].displayId, rejections[id].error);
        } else {
          rejections[id].logged = true;
          logError(rejections[id].displayId, rejections[id].error);
        }
      }
    }

    function onHandled(id) {
      if (rejections[id].logged) {
        if (options.onHandled) {
          options.onHandled(rejections[id].displayId, rejections[id].error);
        } else if (!rejections[id].onUnhandled) {
          console.warn('Promise Rejection Handled (id: ' + rejections[id].displayId + '):');
          console.warn('  This means you can ignore any previous messages of the form "Possible Unhandled Promise Rejection" with id ' + rejections[id].displayId + '.');
        }
      }
    }
  }

  function logError(id, error) {
    console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');
    var errStr = (error && (error.stack || error)) + '';
    errStr.split('\n').forEach(function (line) {
      console.warn('  ' + line);
    });
  }

  function matchWhitelist(error, list) {
    return list.some(function (cls) {
      return error instanceof cls;
    });
  }
},100,[98],"promise/setimmediate/rejection-tracking.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var printString = require(_dependencyMap[0], './printString');

  var toString = Object.prototype.toString;
  var toISOString = Date.prototype.toISOString;
  var errorToString = Error.prototype.toString;
  var regExpToString = RegExp.prototype.toString;
  var symbolToString = (typeof Symbol === "function" ? Symbol.prototype : "@@prototype").toString;
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  var NEWLINE_REGEXP = /\n/ig;

  var getSymbols = Object.getOwnPropertySymbols || function (obj) {
    return [];
  };

  function isToStringedArrayType(toStringed) {
    return toStringed === '[object Array]' || toStringed === '[object ArrayBuffer]' || toStringed === '[object DataView]' || toStringed === '[object Float32Array]' || toStringed === '[object Float64Array]' || toStringed === '[object Int8Array]' || toStringed === '[object Int16Array]' || toStringed === '[object Int32Array]' || toStringed === '[object Uint8Array]' || toStringed === '[object Uint8ClampedArray]' || toStringed === '[object Uint16Array]' || toStringed === '[object Uint32Array]';
  }

  function printNumber(val) {
    if (val != +val) return 'NaN';
    var isNegativeZero = val === 0 && 1 / val < 0;
    return isNegativeZero ? '-0' : '' + val;
  }

  function printFunction(val, printFunctionName) {
    if (!printFunctionName) {
      return '[Function]';
    } else if (val.name === '') {
      return '[Function anonymous]';
    } else {
      return '[Function ' + val.name + ']';
    }
  }

  function printSymbol(val) {
    return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
  }

  function printError(val) {
    return '[' + errorToString.call(val) + ']';
  }

  function printBasicValue(val, printFunctionName, escapeRegex) {
    if (val === true || val === false) return '' + val;
    if (val === undefined) return 'undefined';
    if (val === null) return 'null';
    var typeOf = typeof val;
    if (typeOf === 'number') return printNumber(val);
    if (typeOf === 'string') return '"' + printString(val) + '"';
    if (typeOf === 'function') return printFunction(val, printFunctionName);
    if (typeOf === 'symbol') return printSymbol(val);
    var toStringed = toString.call(val);
    if (toStringed === '[object WeakMap]') return 'WeakMap {}';
    if (toStringed === '[object WeakSet]') return 'WeakSet {}';
    if (toStringed === '[object Function]' || toStringed === '[object GeneratorFunction]') return printFunction(val, printFunctionName);
    if (toStringed === '[object Symbol]') return printSymbol(val);
    if (toStringed === '[object Date]') return toISOString.call(val);
    if (toStringed === '[object Error]') return printError(val);

    if (toStringed === '[object RegExp]') {
      if (escapeRegex) {
        return printString(regExpToString.call(val));
      }

      return regExpToString.call(val);
    }

    ;
    if (toStringed === '[object Arguments]' && val.length === 0) return 'Arguments []';
    if (isToStringedArrayType(toStringed) && val.length === 0) return val.constructor.name + ' []';
    if (val instanceof Error) return printError(val);
    return false;
  }

  function printList(list, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var body = '';

    if (list.length) {
      body += edgeSpacing;
      var innerIndent = prevIndent + indent;

      for (var i = 0; i < list.length; i++) {
        body += innerIndent + print(list[i], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);

        if (i < list.length - 1) {
          body += ',' + spacing;
        }
      }

      body += (min ? '' : ',') + edgeSpacing + prevIndent;
    }

    return '[' + body + ']';
  }

  function printArguments(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    return (min ? '' : 'Arguments ') + printList(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
  }

  function printArray(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    return (min ? '' : val.constructor.name + ' ') + printList(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
  }

  function printMap(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var result = 'Map {';
    var iterator = val.entries();
    var current = iterator.next();

    if (!current.done) {
      result += edgeSpacing;
      var innerIndent = prevIndent + indent;

      while (!current.done) {
        var key = print(current.value[0], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        var value = print(current.value[1], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        result += innerIndent + key + ' => ' + value;
        current = iterator.next();

        if (!current.done) {
          result += ',' + spacing;
        }
      }

      result += (min ? '' : ',') + edgeSpacing + prevIndent;
    }

    return result + '}';
  }

  function printObject(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var constructor = min ? '' : val.constructor ? val.constructor.name + ' ' : 'Object ';
    var result = constructor + '{';
    var keys = Object.keys(val).sort();
    var symbols = getSymbols(val);

    if (symbols.length) {
      keys = keys.filter(function (key) {
        return !(typeof key === 'symbol' || toString.call(key) === '[object Symbol]');
      }).concat(symbols);
    }

    if (keys.length) {
      result += edgeSpacing;
      var innerIndent = prevIndent + indent;

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var name = print(key, indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        var value = print(val[key], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        result += innerIndent + name + ': ' + value;

        if (i < keys.length - 1) {
          result += ',' + spacing;
        }
      }

      result += (min ? '' : ',') + edgeSpacing + prevIndent;
    }

    return result + '}';
  }

  function printSet(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var result = 'Set {';
    var iterator = val.entries();
    var current = iterator.next();

    if (!current.done) {
      result += edgeSpacing;
      var innerIndent = prevIndent + indent;

      while (!current.done) {
        result += innerIndent + print(current.value[1], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        current = iterator.next();

        if (!current.done) {
          result += ',' + spacing;
        }
      }

      result += (min ? '' : ',') + edgeSpacing + prevIndent;
    }

    return result + '}';
  }

  function printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    refs = refs.slice();

    if (refs.indexOf(val) > -1) {
      return '[Circular]';
    } else {
      refs.push(val);
    }

    currentDepth++;
    var hitMaxDepth = currentDepth > maxDepth;

    if (callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === 'function') {
      return print(val.toJSON(), indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    }

    var toStringed = toString.call(val);

    if (toStringed === '[object Arguments]') {
      return hitMaxDepth ? '[Arguments]' : printArguments(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    } else if (isToStringedArrayType(toStringed)) {
      return hitMaxDepth ? '[Array]' : printArray(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    } else if (toStringed === '[object Map]') {
      return hitMaxDepth ? '[Map]' : printMap(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    } else if (toStringed === '[object Set]') {
      return hitMaxDepth ? '[Set]' : printSet(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    } else if (typeof val === 'object') {
      return hitMaxDepth ? '[Object]' : printObject(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    }
  }

  function printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var match = false;
    var plugin = void 0;

    for (var p = 0; p < plugins.length; p++) {
      plugin = plugins[p];

      if (plugin.test(val)) {
        match = true;
        break;
      }
    }

    if (!match) {
      return false;
    }

    function boundPrint(val) {
      return print(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    }

    function boundIndent(str) {
      var indentation = prevIndent + indent;
      return indentation + str.replace(NEWLINE_REGEXP, '\n' + indentation);
    }

    return plugin.print(val, boundPrint, boundIndent, {
      edgeSpacing: edgeSpacing,
      spacing: spacing
    });
  }

  function print(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var basic = printBasicValue(val, printFunctionName, escapeRegex);
    if (basic) return basic;
    var plugin = printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    if (plugin) return plugin;
    return printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
  }

  var DEFAULTS = {
    callToJSON: true,
    indent: 2,
    maxDepth: Infinity,
    min: false,
    plugins: [],
    printFunctionName: true,
    escapeRegex: false
  };

  function validateOptions(opts) {
    Object.keys(opts).forEach(function (key) {
      if (!DEFAULTS.hasOwnProperty(key)) {
        throw new Error('prettyFormat: Invalid option: ' + key);
      }
    });

    if (opts.min && opts.indent !== undefined && opts.indent !== 0) {
      throw new Error('prettyFormat: Cannot run with min option and indent');
    }
  }

  function normalizeOptions(opts) {
    var result = {};
    Object.keys(DEFAULTS).forEach(function (key) {
      return result[key] = opts.hasOwnProperty(key) ? opts[key] : DEFAULTS[key];
    });

    if (result.min) {
      result.indent = 0;
    }

    return result;
  }

  function createIndent(indent) {
    return new Array(indent + 1).join(' ');
  }

  function prettyFormat(val, opts) {
    if (!opts) {
      opts = DEFAULTS;
    } else {
      validateOptions(opts);
      opts = normalizeOptions(opts);
    }

    var indent = void 0;
    var refs = void 0;
    var prevIndent = '';
    var currentDepth = 0;
    var spacing = opts.min ? ' ' : '\n';
    var edgeSpacing = opts.min ? '' : '\n';

    if (opts && opts.plugins.length) {
      indent = createIndent(opts.indent);
      refs = [];
      var pluginsResult = printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, opts.maxDepth, currentDepth, opts.plugins, opts.min, opts.callToJSON, opts.printFunctionName, opts.escapeRegex);
      if (pluginsResult) return pluginsResult;
    }

    var basicResult = printBasicValue(val, opts.printFunctionName, opts.escapeRegex);
    if (basicResult) return basicResult;
    if (!indent) indent = createIndent(opts.indent);
    if (!refs) refs = [];
    return printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, opts.maxDepth, currentDepth, opts.plugins, opts.min, opts.callToJSON, opts.printFunctionName, opts.escapeRegex);
  }

  module.exports = prettyFormat;
},101,[102],"pretty-format/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ESCAPED_CHARACTERS = /(\\|\"|\')/g;

  module.exports = function printString(val) {
    return val.replace(ESCAPED_CHARACTERS, '\\$1');
  };
},102,[],"pretty-format/printString.js");
__d(function (global, require, module, exports, _dependencyMap) {
  !function (global) {
    "use strict";

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    var inModule = typeof module === "object";
    var runtime = global.regeneratorRuntime;

    if (runtime) {
      if (inModule) {
        module.exports = runtime;
      }

      return;
    }

    runtime = global.regeneratorRuntime = inModule ? module.exports : {};

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    runtime.wrap = wrap;

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    runtime.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;

        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    runtime.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function (unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, reject);
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    runtime.AsyncIterator = AsyncIterator;

    runtime.async = function (innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
      return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined) {
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator.return) {
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
      } else {
        return info;
      }

      context.delegate = null;
      return ContinueSentinel;
    }

    defineIteratorMethods(Gp);
    Gp[toStringTagSymbol] = "Generator";

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    runtime.values = values;

    function doneResult() {
      return {
        value: undefined,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            context.method = "next";
            context.arg = undefined;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          this.arg = undefined;
        }

        return ContinueSentinel;
      }
    };
  }(function () {
    return this;
  }() || Function("return this")());
},103,[],"regenerator-runtime/runtime.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Platform = require(_dependencyMap[0], 'Platform');

  var Systrace = require(_dependencyMap[1], 'Systrace');

  var invariant = require(_dependencyMap[2], 'fbjs/lib/invariant');

  var _require = require(_dependencyMap[3], 'NativeModules'),
      Timing = _require.Timing;

  var _performanceNow = null;

  function performanceNow() {
    if (!_performanceNow) {
      _performanceNow = require(_dependencyMap[4], 'fbjs/lib/performanceNow');
    }

    return _performanceNow();
  }

  var FRAME_DURATION = 1000 / 60;
  var IDLE_CALLBACK_FRAME_DEADLINE = 1;
  var MAX_TIMER_DURATION_MS = 60 * 1000;
  var IS_ANDROID = Platform.OS === 'android';
  var ANDROID_LONG_TIMER_MESSAGE = 'Setting a timer for a long period of time, i.e. multiple minutes, is a ' + 'performance and correctness issue on Android as it keeps the timer ' + 'module awake, and timers can only be called when the app is in the foreground. ' + 'See https://github.com/facebook/react-native/issues/12981 for more info.';
  var callbacks = [];
  var types = [];
  var timerIDs = [];
  var immediates = [];
  var requestIdleCallbacks = [];
  var requestIdleCallbackTimeouts = {};
  var identifiers = [];
  var GUID = 1;
  var errors = null;
  var hasEmittedTimeDriftWarning = false;

  function _getFreeIndex() {
    var freeIndex = timerIDs.indexOf(null);

    if (freeIndex === -1) {
      freeIndex = timerIDs.length;
    }

    return freeIndex;
  }

  function _allocateCallback(func, type) {
    var id = GUID++;

    var freeIndex = _getFreeIndex();

    timerIDs[freeIndex] = id;
    callbacks[freeIndex] = func;
    types[freeIndex] = type;

    if (__DEV__) {
      var parseErrorStack = require(_dependencyMap[5], 'parseErrorStack');

      var error = new Error();
      error.framesToPop = 1;
      var stack = parseErrorStack(error);

      if (stack) {
        identifiers[freeIndex] = stack.shift();
      }
    }

    return id;
  }

  function _callTimer(timerID, frameTime, didTimeout) {
    require(_dependencyMap[6], 'fbjs/lib/warning')(timerID <= GUID, 'Tried to call timer with ID %s but no such timer exists.', timerID);

    var timerIndex = timerIDs.indexOf(timerID);

    if (timerIndex === -1) {
      return;
    }

    var type = types[timerIndex];
    var callback = callbacks[timerIndex];

    if (!callback || !type) {
      console.error('No callback found for timerID ' + timerID);
      return;
    }

    if (__DEV__) {
      var identifier = identifiers[timerIndex] || {};
      Systrace.beginEvent('Systrace.callTimer: ' + identifier.methodName);
    }

    if (type === 'setTimeout' || type === 'setImmediate' || type === 'requestAnimationFrame' || type === 'requestIdleCallback') {
      _clearIndex(timerIndex);
    }

    try {
      if (type === 'setTimeout' || type === 'setInterval' || type === 'setImmediate') {
        callback();
      } else if (type === 'requestAnimationFrame') {
        callback(performanceNow());
      } else if (type === 'requestIdleCallback') {
        callback({
          timeRemaining: function timeRemaining() {
            return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));
          },
          didTimeout: !!didTimeout
        });
      } else {
        console.error('Tried to call a callback with invalid type: ' + type);
      }
    } catch (e) {
      if (!errors) {
        errors = [e];
      } else {
        errors.push(e);
      }
    }

    if (__DEV__) {
      Systrace.endEvent();
    }
  }

  function _callImmediatesPass() {
    if (__DEV__) {
      Systrace.beginEvent('callImmediatesPass()');
    }

    if (immediates.length > 0) {
      var passImmediates = immediates.slice();
      immediates = [];

      for (var i = 0; i < passImmediates.length; ++i) {
        _callTimer(passImmediates[i], 0);
      }
    }

    if (__DEV__) {
      Systrace.endEvent();
    }

    return immediates.length > 0;
  }

  function _clearIndex(i) {
    timerIDs[i] = null;
    callbacks[i] = null;
    types[i] = null;
    identifiers[i] = null;
  }

  function _freeCallback(timerID) {
    if (timerID == null) {
      return;
    }

    var index = timerIDs.indexOf(timerID);

    if (index !== -1) {
      _clearIndex(index);

      var type = types[index];

      if (type !== 'setImmediate' && type !== 'requestIdleCallback') {
        Timing.deleteTimer(timerID);
      }
    }
  }

  var JSTimers = {
    setTimeout: function setTimeout(func, duration) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {
        console.warn(ANDROID_LONG_TIMER_MESSAGE + '\n' + '(Saw setTimeout with duration ' + duration + 'ms)');
      }

      var id = _allocateCallback(function () {
        return func.apply(undefined, args);
      }, 'setTimeout');

      Timing.createTimer(id, duration || 0, Date.now(), false);
      return id;
    },
    setInterval: function setInterval(func, duration) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {
        console.warn(ANDROID_LONG_TIMER_MESSAGE + '\n' + '(Saw setInterval with duration ' + duration + 'ms)');
      }

      var id = _allocateCallback(function () {
        return func.apply(undefined, args);
      }, 'setInterval');

      Timing.createTimer(id, duration || 0, Date.now(), true);
      return id;
    },
    setImmediate: function setImmediate(func) {
      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      var id = _allocateCallback(function () {
        return func.apply(undefined, args);
      }, 'setImmediate');

      immediates.push(id);
      return id;
    },
    requestAnimationFrame: function requestAnimationFrame(func) {
      var id = _allocateCallback(func, 'requestAnimationFrame');

      Timing.createTimer(id, 1, Date.now(), false);
      return id;
    },
    requestIdleCallback: function requestIdleCallback(func, options) {
      if (requestIdleCallbacks.length === 0) {
        Timing.setSendIdleEvents(true);
      }

      var timeout = options && options.timeout;

      var id = _allocateCallback(timeout != null ? function (deadline) {
        var timeoutId = requestIdleCallbackTimeouts[id];

        if (timeoutId) {
          JSTimers.clearTimeout(timeoutId);
          delete requestIdleCallbackTimeouts[id];
        }

        return func(deadline);
      } : func, 'requestIdleCallback');

      requestIdleCallbacks.push(id);

      if (timeout != null) {
        var timeoutId = JSTimers.setTimeout(function () {
          var index = requestIdleCallbacks.indexOf(id);

          if (index > -1) {
            requestIdleCallbacks.splice(index, 1);

            _callTimer(id, performanceNow(), true);
          }

          delete requestIdleCallbackTimeouts[id];

          if (requestIdleCallbacks.length === 0) {
            Timing.setSendIdleEvents(false);
          }
        }, timeout);
        requestIdleCallbackTimeouts[id] = timeoutId;
      }

      return id;
    },
    cancelIdleCallback: function cancelIdleCallback(timerID) {
      _freeCallback(timerID);

      var index = requestIdleCallbacks.indexOf(timerID);

      if (index !== -1) {
        requestIdleCallbacks.splice(index, 1);
      }

      var timeoutId = requestIdleCallbackTimeouts[timerID];

      if (timeoutId) {
        JSTimers.clearTimeout(timeoutId);
        delete requestIdleCallbackTimeouts[timerID];
      }

      if (requestIdleCallbacks.length === 0) {
        Timing.setSendIdleEvents(false);
      }
    },
    clearTimeout: function clearTimeout(timerID) {
      _freeCallback(timerID);
    },
    clearInterval: function clearInterval(timerID) {
      _freeCallback(timerID);
    },
    clearImmediate: function clearImmediate(timerID) {
      _freeCallback(timerID);

      var index = immediates.indexOf(timerID);

      if (index !== -1) {
        immediates.splice(index, 1);
      }
    },
    cancelAnimationFrame: function cancelAnimationFrame(timerID) {
      _freeCallback(timerID);
    },
    callTimers: function callTimers(timersToCall) {
      invariant(timersToCall.length !== 0, 'Cannot call `callTimers` with an empty list of IDs.');
      errors = null;

      for (var i = 0; i < timersToCall.length; i++) {
        _callTimer(timersToCall[i], 0);
      }

      if (errors) {
        var errorCount = errors.length;

        if (errorCount > 1) {
          for (var ii = 1; ii < errorCount; ii++) {
            JSTimers.setTimeout(function (error) {
              throw error;
            }.bind(null, errors[ii]), 0);
          }
        }

        throw errors[0];
      }
    },
    callIdleCallbacks: function callIdleCallbacks(frameTime) {
      if (FRAME_DURATION - (performanceNow() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {
        return;
      }

      errors = null;

      if (requestIdleCallbacks.length > 0) {
        var passIdleCallbacks = requestIdleCallbacks.slice();
        requestIdleCallbacks = [];

        for (var i = 0; i < passIdleCallbacks.length; ++i) {
          _callTimer(passIdleCallbacks[i], frameTime);
        }
      }

      if (requestIdleCallbacks.length === 0) {
        Timing.setSendIdleEvents(false);
      }

      if (errors) {
        errors.forEach(function (error) {
          return JSTimers.setTimeout(function () {
            throw error;
          }, 0);
        });
      }
    },
    callImmediates: function callImmediates() {
      errors = null;

      while (_callImmediatesPass()) {}

      if (errors) {
        errors.forEach(function (error) {
          return JSTimers.setTimeout(function () {
            throw error;
          }, 0);
        });
      }
    },
    emitTimeDriftWarning: function emitTimeDriftWarning(warningMessage) {
      if (hasEmittedTimeDriftWarning) {
        return;
      }

      hasEmittedTimeDriftWarning = true;
      console.warn(warningMessage);
    }
  };

  if (!Timing) {
    console.warn("Timing native module is not available, can't set timers.");
    module.exports = {
      callImmediates: JSTimers.callImmediates,
      setImmediate: JSTimers.setImmediate
    };
  } else {
    module.exports = JSTimers;
  }
},104,[105,72,18,68,106,85,19],"JSTimers");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = require(_dependencyMap[0], 'NativeModules');

  var Platform = {
    OS: 'android',

    get Version() {
      var constants = NativeModules.PlatformConstants;
      return constants && constants.Version;
    },

    get isTesting() {
      var constants = NativeModules.PlatformConstants;
      return constants && constants.isTesting;
    },

    select: function select(obj) {
      return 'android' in obj ? obj.android : obj.default;
    }
  };
  module.exports = Platform;
},105,[68],"Platform");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var performance = require(_dependencyMap[0], './performance');

  var performanceNow;

  if (performance.now) {
    performanceNow = function performanceNow() {
      return performance.now();
    };
  } else {
    performanceNow = function performanceNow() {
      return Date.now();
    };
  }

  module.exports = performanceNow;
},106,[107],"fbjs/lib/performanceNow.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ExecutionEnvironment = require(_dependencyMap[0], './ExecutionEnvironment');

  var performance;

  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }

  module.exports = performance || {};
},107,[108],"fbjs/lib/performance.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  module.exports = ExecutionEnvironment;
},108,[],"fbjs/lib/ExecutionEnvironment.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EventTarget = require(_dependencyMap[0], 'event-target-shim');

  var RCTNetworking = require(_dependencyMap[1], 'RCTNetworking');

  var base64 = require(_dependencyMap[2], 'base64-js');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var warning = require(_dependencyMap[4], 'fbjs/lib/warning');

  var UNSENT = 0;
  var OPENED = 1;
  var HEADERS_RECEIVED = 2;
  var LOADING = 3;
  var DONE = 4;
  var SUPPORTED_RESPONSE_TYPES = {
    arraybuffer: typeof global.ArrayBuffer === 'function',
    blob: typeof global.Blob === 'function',
    document: false,
    json: true,
    text: true,
    '': true
  };
  var REQUEST_EVENTS = ['abort', 'error', 'load', 'loadstart', 'progress', 'timeout', 'loadend'];
  var XHR_EVENTS = REQUEST_EVENTS.concat('readystatechange');

  var XMLHttpRequestEventTarget = function (_EventTarget) {
    babelHelpers.inherits(XMLHttpRequestEventTarget, _EventTarget);

    function XMLHttpRequestEventTarget() {
      babelHelpers.classCallCheck(this, XMLHttpRequestEventTarget);
      return babelHelpers.possibleConstructorReturn(this, (XMLHttpRequestEventTarget.__proto__ || Object.getPrototypeOf(XMLHttpRequestEventTarget)).apply(this, arguments));
    }

    return XMLHttpRequestEventTarget;
  }(EventTarget.apply(undefined, REQUEST_EVENTS));

  var XMLHttpRequest = function (_EventTarget2) {
    babelHelpers.inherits(XMLHttpRequest, _EventTarget2);
    babelHelpers.createClass(XMLHttpRequest, null, [{
      key: "setInterceptor",
      value: function setInterceptor(interceptor) {
        XMLHttpRequest._interceptor = interceptor;
      }
    }]);

    function XMLHttpRequest() {
      babelHelpers.classCallCheck(this, XMLHttpRequest);

      var _this2 = babelHelpers.possibleConstructorReturn(this, (XMLHttpRequest.__proto__ || Object.getPrototypeOf(XMLHttpRequest)).call(this));

      _this2.UNSENT = UNSENT;
      _this2.OPENED = OPENED;
      _this2.HEADERS_RECEIVED = HEADERS_RECEIVED;
      _this2.LOADING = LOADING;
      _this2.DONE = DONE;
      _this2.readyState = UNSENT;
      _this2.status = 0;
      _this2.timeout = 0;
      _this2.withCredentials = true;
      _this2.upload = new XMLHttpRequestEventTarget();
      _this2._aborted = false;
      _this2._hasError = false;
      _this2._method = null;
      _this2._response = '';
      _this2._url = null;
      _this2._timedOut = false;
      _this2._trackingName = 'unknown';
      _this2._incrementalEvents = false;

      _this2._reset();

      return _this2;
    }

    babelHelpers.createClass(XMLHttpRequest, [{
      key: "_reset",
      value: function _reset() {
        this.readyState = this.UNSENT;
        this.responseHeaders = undefined;
        this.status = 0;
        delete this.responseURL;
        this._requestId = null;
        this._cachedResponse = undefined;
        this._hasError = false;
        this._headers = {};
        this._response = '';
        this._responseType = '';
        this._sent = false;
        this._lowerCaseResponseHeaders = {};

        this._clearSubscriptions();

        this._timedOut = false;
      }
    }, {
      key: "__didCreateRequest",
      value: function __didCreateRequest(requestId) {
        this._requestId = requestId;
        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.requestSent(requestId, this._url || '', this._method || 'GET', this._headers);
      }
    }, {
      key: "__didUploadProgress",
      value: function __didUploadProgress(requestId, progress, total) {
        if (requestId === this._requestId) {
          this.upload.dispatchEvent({
            type: 'progress',
            lengthComputable: true,
            loaded: progress,
            total: total
          });
        }
      }
    }, {
      key: "__didReceiveResponse",
      value: function __didReceiveResponse(requestId, status, responseHeaders, responseURL) {
        if (requestId === this._requestId) {
          this.status = status;
          this.setResponseHeaders(responseHeaders);
          this.setReadyState(this.HEADERS_RECEIVED);

          if (responseURL || responseURL === '') {
            this.responseURL = responseURL;
          } else {
            delete this.responseURL;
          }

          XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.responseReceived(requestId, responseURL || this._url || '', status, responseHeaders || {});
        }
      }
    }, {
      key: "__didReceiveData",
      value: function __didReceiveData(requestId, response) {
        if (requestId !== this._requestId) {
          return;
        }

        this._response = response;
        this._cachedResponse = undefined;
        this.setReadyState(this.LOADING);
        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, response);
      }
    }, {
      key: "__didReceiveIncrementalData",
      value: function __didReceiveIncrementalData(requestId, responseText, progress, total) {
        if (requestId !== this._requestId) {
          return;
        }

        if (!this._response) {
          this._response = responseText;
        } else {
          this._response += responseText;
        }

        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, responseText);
        this.setReadyState(this.LOADING);

        this.__didReceiveDataProgress(requestId, progress, total);
      }
    }, {
      key: "__didReceiveDataProgress",
      value: function __didReceiveDataProgress(requestId, loaded, total) {
        if (requestId !== this._requestId) {
          return;
        }

        this.dispatchEvent({
          type: 'progress',
          lengthComputable: total >= 0,
          loaded: loaded,
          total: total
        });
      }
    }, {
      key: "__didCompleteResponse",
      value: function __didCompleteResponse(requestId, error, timeOutError) {
        if (requestId === this._requestId) {
          if (error) {
            if (this._responseType === '' || this._responseType === 'text') {
              this._response = error;
            }

            this._hasError = true;

            if (timeOutError) {
              this._timedOut = true;
            }
          }

          this._clearSubscriptions();

          this._requestId = null;
          this.setReadyState(this.DONE);

          if (error) {
            XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFailed(requestId, error);
          } else {
            XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFinished(requestId, this._response.length);
          }
        }
      }
    }, {
      key: "_clearSubscriptions",
      value: function _clearSubscriptions() {
        (this._subscriptions || []).forEach(function (sub) {
          if (sub) {
            sub.remove();
          }
        });
        this._subscriptions = [];
      }
    }, {
      key: "getAllResponseHeaders",
      value: function getAllResponseHeaders() {
        if (!this.responseHeaders) {
          return null;
        }

        var headers = this.responseHeaders || {};
        return Object.keys(headers).map(function (headerName) {
          return headerName + ': ' + headers[headerName];
        }).join('\r\n');
      }
    }, {
      key: "getResponseHeader",
      value: function getResponseHeader(header) {
        var value = this._lowerCaseResponseHeaders[header.toLowerCase()];

        return value !== undefined ? value : null;
      }
    }, {
      key: "setRequestHeader",
      value: function setRequestHeader(header, value) {
        if (this.readyState !== this.OPENED) {
          throw new Error('Request has not been opened');
        }

        this._headers[header.toLowerCase()] = String(value);
      }
    }, {
      key: "setTrackingName",
      value: function setTrackingName(trackingName) {
        this._trackingName = trackingName;
        return this;
      }
    }, {
      key: "open",
      value: function open(method, url, async) {
        if (this.readyState !== this.UNSENT) {
          throw new Error('Cannot open, already sending');
        }

        if (async !== undefined && !async) {
          throw new Error('Synchronous http requests are not supported');
        }

        if (!url) {
          throw new Error('Cannot load an empty url');
        }

        this._method = method.toUpperCase();
        this._url = url;
        this._aborted = false;
        this.setReadyState(this.OPENED);
      }
    }, {
      key: "send",
      value: function send(data) {
        var _this3 = this;

        if (this.readyState !== this.OPENED) {
          throw new Error('Request has not been opened');
        }

        if (this._sent) {
          throw new Error('Request has already been sent');
        }

        this._sent = true;
        var incrementalEvents = this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;

        this._subscriptions.push(RCTNetworking.addListener('didSendNetworkData', function (args) {
          return _this3.__didUploadProgress.apply(_this3, babelHelpers.toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkResponse', function (args) {
          return _this3.__didReceiveResponse.apply(_this3, babelHelpers.toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkData', function (args) {
          return _this3.__didReceiveData.apply(_this3, babelHelpers.toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkIncrementalData', function (args) {
          return _this3.__didReceiveIncrementalData.apply(_this3, babelHelpers.toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkDataProgress', function (args) {
          return _this3.__didReceiveDataProgress.apply(_this3, babelHelpers.toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didCompleteNetworkResponse', function (args) {
          return _this3.__didCompleteResponse.apply(_this3, babelHelpers.toConsumableArray(args));
        }));

        var nativeResponseType = 'text';

        if (this._responseType === 'arraybuffer' || this._responseType === 'blob') {
          nativeResponseType = 'base64';
        }

        invariant(this._method, 'Request method needs to be defined.');
        invariant(this._url, 'Request URL needs to be defined.');
        RCTNetworking.sendRequest(this._method, this._trackingName, this._url, this._headers, data, nativeResponseType, incrementalEvents, this.timeout, this.__didCreateRequest.bind(this), this.withCredentials);
      }
    }, {
      key: "abort",
      value: function abort() {
        this._aborted = true;

        if (this._requestId) {
          RCTNetworking.abortRequest(this._requestId);
        }

        if (!(this.readyState === this.UNSENT || this.readyState === this.OPENED && !this._sent || this.readyState === this.DONE)) {
          this._reset();

          this.setReadyState(this.DONE);
        }

        this._reset();
      }
    }, {
      key: "setResponseHeaders",
      value: function setResponseHeaders(responseHeaders) {
        this.responseHeaders = responseHeaders || null;
        var headers = responseHeaders || {};
        this._lowerCaseResponseHeaders = Object.keys(headers).reduce(function (lcaseHeaders, headerName) {
          lcaseHeaders[headerName.toLowerCase()] = headers[headerName];
          return lcaseHeaders;
        }, {});
      }
    }, {
      key: "setReadyState",
      value: function setReadyState(newState) {
        this.readyState = newState;
        this.dispatchEvent({
          type: 'readystatechange'
        });

        if (newState === this.DONE) {
          if (this._aborted) {
            this.dispatchEvent({
              type: 'abort'
            });
          } else if (this._hasError) {
            if (this._timedOut) {
              this.dispatchEvent({
                type: 'timeout'
              });
            } else {
              this.dispatchEvent({
                type: 'error'
              });
            }
          } else {
            this.dispatchEvent({
              type: 'load'
            });
          }

          this.dispatchEvent({
            type: 'loadend'
          });
        }
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        if (type === 'readystatechange' || type === 'progress') {
          this._incrementalEvents = true;
        }

        babelHelpers.get(XMLHttpRequest.prototype.__proto__ || Object.getPrototypeOf(XMLHttpRequest.prototype), "addEventListener", this).call(this, type, listener);
      }
    }, {
      key: "responseType",
      get: function get() {
        return this._responseType;
      },
      set: function set(responseType) {
        if (this._sent) {
          throw new Error('Failed to set the \'responseType\' property on \'XMLHttpRequest\': The ' + 'response type cannot be set after the request has been sent.');
        }

        if (!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {
          warning(false, "The provided value '" + responseType + "' is not a valid 'responseType'.");
          return;
        }

        invariant(SUPPORTED_RESPONSE_TYPES[responseType] || responseType === 'document', "The provided value '" + responseType + "' is unsupported in this environment.");
        this._responseType = responseType;
      }
    }, {
      key: "responseText",
      get: function get() {
        if (this._responseType !== '' && this._responseType !== 'text') {
          throw new Error("The 'responseText' property is only available if 'responseType' " + ("is set to '' or 'text', but it is '" + this._responseType + "'."));
        }

        if (this.readyState < LOADING) {
          return '';
        }

        return this._response;
      }
    }, {
      key: "response",
      get: function get() {
        var responseType = this.responseType;

        if (responseType === '' || responseType === 'text') {
          return this.readyState < LOADING || this._hasError ? '' : this._response;
        }

        if (this.readyState !== DONE) {
          return null;
        }

        if (this._cachedResponse !== undefined) {
          return this._cachedResponse;
        }

        switch (responseType) {
          case 'document':
            this._cachedResponse = null;
            break;

          case 'arraybuffer':
            this._cachedResponse = base64.toByteArray(this._response).buffer;
            break;

          case 'blob':
            this._cachedResponse = new global.Blob([base64.toByteArray(this._response).buffer], {
              type: this.getResponseHeader('content-type') || ''
            });
            break;

          case 'json':
            try {
              this._cachedResponse = JSON.parse(this._response);
            } catch (_) {
              this._cachedResponse = null;
            }

            break;

          default:
            this._cachedResponse = null;
        }

        return this._cachedResponse;
      }
    }]);
    return XMLHttpRequest;
  }(EventTarget.apply(undefined, babelHelpers.toConsumableArray(XHR_EVENTS)));

  XMLHttpRequest.UNSENT = UNSENT;
  XMLHttpRequest.OPENED = OPENED;
  XMLHttpRequest.HEADERS_RECEIVED = HEADERS_RECEIVED;
  XMLHttpRequest.LOADING = LOADING;
  XMLHttpRequest.DONE = DONE;
  XMLHttpRequest._interceptor = null;
  module.exports = XMLHttpRequest;
},109,[110,114,124,18,19],"XMLHttpRequest");
__d(function (global, require, module, exports, _dependencyMap) {
    "use strict";

    var Commons = require(_dependencyMap[0], "./commons");

    var CustomEventTarget = require(_dependencyMap[1], "./custom-event-target");

    var EventWrapper = require(_dependencyMap[2], "./event-wrapper");

    var LISTENERS = Commons.LISTENERS;
    var CAPTURE = Commons.CAPTURE;
    var BUBBLE = Commons.BUBBLE;
    var ATTRIBUTE = Commons.ATTRIBUTE;
    var newNode = Commons.newNode;
    var defineCustomEventTarget = CustomEventTarget.defineCustomEventTarget;
    var createEventWrapper = EventWrapper.createEventWrapper;
    var STOP_IMMEDIATE_PROPAGATION_FLAG = EventWrapper.STOP_IMMEDIATE_PROPAGATION_FLAG;
    var HAS_EVENTTARGET_INTERFACE = typeof window !== "undefined" && typeof window.EventTarget !== "undefined";

    var EventTarget = module.exports = function EventTarget() {
        if (this instanceof EventTarget) {
            Object.defineProperty(this, LISTENERS, {
                value: Object.create(null)
            });
        } else if (arguments.length === 1 && Array.isArray(arguments[0])) {
            return defineCustomEventTarget(EventTarget, arguments[0]);
        } else if (arguments.length > 0) {
            var types = Array(arguments.length);

            for (var i = 0; i < arguments.length; ++i) {
                types[i] = arguments[i];
            }

            return defineCustomEventTarget(EventTarget, types);
        } else {
            throw new TypeError("Cannot call a class as a function");
        }
    };

    EventTarget.prototype = Object.create((HAS_EVENTTARGET_INTERFACE ? window.EventTarget : Object).prototype, {
        constructor: {
            value: EventTarget,
            writable: true,
            configurable: true
        },
        addEventListener: {
            value: function addEventListener(type, listener, capture) {
                if (listener == null) {
                    return false;
                }

                if (typeof listener !== "function" && typeof listener !== "object") {
                    throw new TypeError("\"listener\" is not an object.");
                }

                var kind = capture ? CAPTURE : BUBBLE;
                var node = this[LISTENERS][type];

                if (node == null) {
                    this[LISTENERS][type] = newNode(listener, kind);
                    return true;
                }

                var prev = null;

                while (node != null) {
                    if (node.listener === listener && node.kind === kind) {
                        return false;
                    }

                    prev = node;
                    node = node.next;
                }

                prev.next = newNode(listener, kind);
                return true;
            },
            configurable: true,
            writable: true
        },
        removeEventListener: {
            value: function removeEventListener(type, listener, capture) {
                if (listener == null) {
                    return false;
                }

                var kind = capture ? CAPTURE : BUBBLE;
                var prev = null;
                var node = this[LISTENERS][type];

                while (node != null) {
                    if (node.listener === listener && node.kind === kind) {
                        if (prev == null) {
                            this[LISTENERS][type] = node.next;
                        } else {
                            prev.next = node.next;
                        }

                        return true;
                    }

                    prev = node;
                    node = node.next;
                }

                return false;
            },
            configurable: true,
            writable: true
        },
        dispatchEvent: {
            value: function dispatchEvent(event) {
                var node = this[LISTENERS][event.type];

                if (node == null) {
                    return true;
                }

                var wrapped = createEventWrapper(event, this);

                while (node != null) {
                    if (typeof node.listener === "function") {
                        node.listener.call(this, wrapped);
                    } else if (node.kind !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
                        node.listener.handleEvent(wrapped);
                    }

                    if (wrapped[STOP_IMMEDIATE_PROPAGATION_FLAG]) {
                        break;
                    }

                    node = node.next;
                }

                return !wrapped.defaultPrevented;
            },
            configurable: true,
            writable: true
        }
    });
},110,[111,112,113],"event-target-shim/lib/event-target.js");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  var createUniqueKey = exports.createUniqueKey = typeof Symbol !== "undefined" ? Symbol : function createUniqueKey(name) {
    return "[[" + name + "_" + Math.random().toFixed(8).slice(2) + "]]";
  };
  exports.LISTENERS = createUniqueKey("listeners");
  exports.CAPTURE = 1;
  exports.BUBBLE = 2;
  exports.ATTRIBUTE = 3;

  exports.newNode = function newNode(listener, kind) {
    return {
      listener: listener,
      kind: kind,
      next: null
    };
  };
},111,[],"event-target-shim/lib/commons.js");
__d(function (global, require, module, exports, _dependencyMap) {
    "use strict";

    var Commons = require(_dependencyMap[0], "./commons");

    var LISTENERS = Commons.LISTENERS;
    var ATTRIBUTE = Commons.ATTRIBUTE;
    var newNode = Commons.newNode;

    function getAttributeListener(eventTarget, type) {
        var node = eventTarget[LISTENERS][type];

        while (node != null) {
            if (node.kind === ATTRIBUTE) {
                return node.listener;
            }

            node = node.next;
        }

        return null;
    }

    function setAttributeListener(eventTarget, type, listener) {
        if (typeof listener !== "function" && typeof listener !== "object") {
            listener = null;
        }

        var prev = null;
        var node = eventTarget[LISTENERS][type];

        while (node != null) {
            if (node.kind === ATTRIBUTE) {
                if (prev == null) {
                    eventTarget[LISTENERS][type] = node.next;
                } else {
                    prev.next = node.next;
                }
            } else {
                prev = node;
            }

            node = node.next;
        }

        if (listener != null) {
            if (prev == null) {
                eventTarget[LISTENERS][type] = newNode(listener, ATTRIBUTE);
            } else {
                prev.next = newNode(listener, ATTRIBUTE);
            }
        }
    }

    exports.defineCustomEventTarget = function (EventTargetBase, types) {
        function EventTarget() {
            EventTargetBase.call(this);
        }

        var descripter = {
            constructor: {
                value: EventTarget,
                configurable: true,
                writable: true
            }
        };
        types.forEach(function (type) {
            descripter["on" + type] = {
                get: function get() {
                    return getAttributeListener(this, type);
                },
                set: function set(listener) {
                    setAttributeListener(this, type, listener);
                },
                configurable: true,
                enumerable: true
            };
        });
        EventTarget.prototype = Object.create(EventTargetBase.prototype, descripter);
        return EventTarget;
    };
},112,[111],"event-target-shim/lib/custom-event-target.js");
__d(function (global, require, module, exports, _dependencyMap) {
    "use strict";

    var createUniqueKey = require(_dependencyMap[0], "./commons").createUniqueKey;

    var STOP_IMMEDIATE_PROPAGATION_FLAG = createUniqueKey("stop_immediate_propagation_flag");
    var CANCELED_FLAG = createUniqueKey("canceled_flag");
    var ORIGINAL_EVENT = createUniqueKey("original_event");
    var wrapperPrototypeDefinition = Object.freeze({
        stopPropagation: Object.freeze({
            value: function stopPropagation() {
                var e = this[ORIGINAL_EVENT];

                if (typeof e.stopPropagation === "function") {
                    e.stopPropagation();
                }
            },
            writable: true,
            configurable: true
        }),
        stopImmediatePropagation: Object.freeze({
            value: function stopImmediatePropagation() {
                this[STOP_IMMEDIATE_PROPAGATION_FLAG] = true;
                var e = this[ORIGINAL_EVENT];

                if (typeof e.stopImmediatePropagation === "function") {
                    e.stopImmediatePropagation();
                }
            },
            writable: true,
            configurable: true
        }),
        preventDefault: Object.freeze({
            value: function preventDefault() {
                if (this.cancelable === true) {
                    this[CANCELED_FLAG] = true;
                }

                var e = this[ORIGINAL_EVENT];

                if (typeof e.preventDefault === "function") {
                    e.preventDefault();
                }
            },
            writable: true,
            configurable: true
        }),
        defaultPrevented: Object.freeze({
            get: function defaultPrevented() {
                return this[CANCELED_FLAG];
            },
            enumerable: true,
            configurable: true
        })
    });
    exports.STOP_IMMEDIATE_PROPAGATION_FLAG = STOP_IMMEDIATE_PROPAGATION_FLAG;

    exports.createEventWrapper = function createEventWrapper(event, eventTarget) {
        var timeStamp = typeof event.timeStamp === "number" ? event.timeStamp : Date.now();
        var propertyDefinition = {
            type: {
                value: event.type,
                enumerable: true
            },
            target: {
                value: eventTarget,
                enumerable: true
            },
            currentTarget: {
                value: eventTarget,
                enumerable: true
            },
            eventPhase: {
                value: 2,
                enumerable: true
            },
            bubbles: {
                value: Boolean(event.bubbles),
                enumerable: true
            },
            cancelable: {
                value: Boolean(event.cancelable),
                enumerable: true
            },
            timeStamp: {
                value: timeStamp,
                enumerable: true
            },
            isTrusted: {
                value: false,
                enumerable: true
            }
        };
        propertyDefinition[STOP_IMMEDIATE_PROPAGATION_FLAG] = {
            value: false,
            writable: true
        };
        propertyDefinition[CANCELED_FLAG] = {
            value: false,
            writable: true
        };
        propertyDefinition[ORIGINAL_EVENT] = {
            value: event
        };

        if (typeof event.detail !== "undefined") {
            propertyDefinition.detail = {
                value: event.detail,
                enumerable: true
            };
        }

        return Object.create(Object.create(event, wrapperPrototypeDefinition), propertyDefinition);
    };
},113,[111],"event-target-shim/lib/event-wrapper.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var MissingNativeEventEmitterShim = require(_dependencyMap[0], 'MissingNativeEventEmitterShim');

  var NativeEventEmitter = require(_dependencyMap[1], 'NativeEventEmitter');

  var RCTNetworkingNative = require(_dependencyMap[2], 'NativeModules').Networking;

  var convertRequestBody = require(_dependencyMap[3], 'convertRequestBody');

  function convertHeadersMapToArray(headers) {
    var headerArray = [];

    for (var name in headers) {
      headerArray.push([name, headers[name]]);
    }

    return headerArray;
  }

  var _requestId = 1;

  function generateRequestId() {
    return _requestId++;
  }

  var RCTNetworking = function (_NativeEventEmitter) {
    babelHelpers.inherits(RCTNetworking, _NativeEventEmitter);

    function RCTNetworking() {
      babelHelpers.classCallCheck(this, RCTNetworking);

      var _this = babelHelpers.possibleConstructorReturn(this, (RCTNetworking.__proto__ || Object.getPrototypeOf(RCTNetworking)).call(this, RCTNetworkingNative));

      _this.isAvailable = true;
      return _this;
    }

    babelHelpers.createClass(RCTNetworking, [{
      key: "sendRequest",
      value: function sendRequest(method, trackingName, url, headers, data, responseType, incrementalUpdates, timeout, callback, withCredentials) {
        var body = convertRequestBody(data);

        if (body && body.formData) {
          body.formData = body.formData.map(function (part) {
            return babelHelpers.extends({}, part, {
              headers: convertHeadersMapToArray(part.headers)
            });
          });
        }

        var requestId = generateRequestId();
        RCTNetworkingNative.sendRequest(method, url, requestId, convertHeadersMapToArray(headers), babelHelpers.extends({}, body, {
          trackingName: trackingName
        }), responseType, incrementalUpdates, timeout, withCredentials);
        callback(requestId);
      }
    }, {
      key: "abortRequest",
      value: function abortRequest(requestId) {
        RCTNetworkingNative.abortRequest(requestId);
      }
    }, {
      key: "clearCookies",
      value: function clearCookies(callback) {
        RCTNetworkingNative.clearCookies(callback);
      }
    }]);
    return RCTNetworking;
  }(NativeEventEmitter);

  if (__DEV__ && !RCTNetworkingNative) {
    var MissingNativeRCTNetworkingShim = function (_MissingNativeEventEm) {
      babelHelpers.inherits(MissingNativeRCTNetworkingShim, _MissingNativeEventEm);

      function MissingNativeRCTNetworkingShim() {
        babelHelpers.classCallCheck(this, MissingNativeRCTNetworkingShim);
        return babelHelpers.possibleConstructorReturn(this, (MissingNativeRCTNetworkingShim.__proto__ || Object.getPrototypeOf(MissingNativeRCTNetworkingShim)).call(this, 'RCTNetworking', 'Networking'));
      }

      babelHelpers.createClass(MissingNativeRCTNetworkingShim, [{
        key: "sendRequest",
        value: function sendRequest() {
          this.throwMissingNativeModule();
        }
      }, {
        key: "abortRequest",
        value: function abortRequest() {
          this.throwMissingNativeModule();
        }
      }, {
        key: "clearCookies",
        value: function clearCookies() {
          this.throwMissingNativeModule();
        }
      }]);
      return MissingNativeRCTNetworkingShim;
    }(MissingNativeEventEmitterShim);

    RCTNetworking = new MissingNativeRCTNetworkingShim();
  } else {
    RCTNetworking = new RCTNetworking();
  }

  module.exports = RCTNetworking;
},114,[115,120,68,122],"RCTNetworking");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EmitterSubscription = require(_dependencyMap[0], 'EmitterSubscription');

  var EventEmitter = require(_dependencyMap[1], 'EventEmitter');

  var invariant = require(_dependencyMap[2], 'fbjs/lib/invariant');

  var MissingNativeEventEmitterShim = function (_EventEmitter) {
    babelHelpers.inherits(MissingNativeEventEmitterShim, _EventEmitter);

    function MissingNativeEventEmitterShim(nativeModuleName, nativeEventEmitterName) {
      babelHelpers.classCallCheck(this, MissingNativeEventEmitterShim);

      var _this = babelHelpers.possibleConstructorReturn(this, (MissingNativeEventEmitterShim.__proto__ || Object.getPrototypeOf(MissingNativeEventEmitterShim)).call(this, null));

      _this.isAvailable = false;
      _this._nativeModuleName = nativeModuleName;
      _this._nativeEventEmitterName = nativeEventEmitterName;
      return _this;
    }

    babelHelpers.createClass(MissingNativeEventEmitterShim, [{
      key: "throwMissingNativeModule",
      value: function throwMissingNativeModule() {
        invariant(false, "Cannot use '" + this._nativeEventEmitterName + "' module when " + ("native '" + this._nativeModuleName + "' is not included in the build. ") + ("Either include it, or check '" + this._nativeEventEmitterName + "'.isAvailable ") + 'before calling any methods.');
      }
    }, {
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        this.throwMissingNativeModule();
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        this.throwMissingNativeModule();
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        this.throwMissingNativeModule();
      }
    }]);
    return MissingNativeEventEmitterShim;
  }(EventEmitter);

  module.exports = MissingNativeEventEmitterShim;
},115,[116,118,18],"MissingNativeEventEmitterShim");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EventSubscription = require(_dependencyMap[0], 'EventSubscription');

  var EmitterSubscription = function (_EventSubscription) {
    babelHelpers.inherits(EmitterSubscription, _EventSubscription);

    function EmitterSubscription(emitter, subscriber, listener, context) {
      babelHelpers.classCallCheck(this, EmitterSubscription);

      var _this = babelHelpers.possibleConstructorReturn(this, (EmitterSubscription.__proto__ || Object.getPrototypeOf(EmitterSubscription)).call(this, subscriber));

      _this.emitter = emitter;
      _this.listener = listener;
      _this.context = context;
      return _this;
    }

    babelHelpers.createClass(EmitterSubscription, [{
      key: "remove",
      value: function remove() {
        this.emitter.removeSubscription(this);
      }
    }]);
    return EmitterSubscription;
  }(EventSubscription);

  module.exports = EmitterSubscription;
},116,[117],"EmitterSubscription");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EventSubscription = function () {
    function EventSubscription(subscriber) {
      babelHelpers.classCallCheck(this, EventSubscription);
      this.subscriber = subscriber;
    }

    babelHelpers.createClass(EventSubscription, [{
      key: "remove",
      value: function remove() {
        this.subscriber.removeSubscription(this);
      }
    }]);
    return EventSubscription;
  }();

  module.exports = EventSubscription;
},117,[],"EventSubscription");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EmitterSubscription = require(_dependencyMap[0], 'EmitterSubscription');

  var EventSubscriptionVendor = require(_dependencyMap[1], 'EventSubscriptionVendor');

  var emptyFunction = require(_dependencyMap[2], 'fbjs/lib/emptyFunction');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var EventEmitter = function () {
    function EventEmitter(subscriber) {
      babelHelpers.classCallCheck(this, EventEmitter);
      this._subscriber = subscriber || new EventSubscriptionVendor();
    }

    babelHelpers.createClass(EventEmitter, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        return this._subscriber.addSubscription(eventType, new EmitterSubscription(this, this._subscriber, listener, context));
      }
    }, {
      key: "once",
      value: function once(eventType, listener, context) {
        var _this = this;

        return this.addListener(eventType, function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this.removeCurrentListener();

          listener.apply(context, args);
        });
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        this._subscriber.removeAllSubscriptions(eventType);
      }
    }, {
      key: "removeCurrentListener",
      value: function removeCurrentListener() {
        invariant(!!this._currentSubscription, 'Not in an emitting cycle; there is no current subscription');
        this.removeSubscription(this._currentSubscription);
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        invariant(subscription.emitter === this, 'Subscription does not belong to this emitter.');

        this._subscriber.removeSubscription(subscription);
      }
    }, {
      key: "listeners",
      value: function listeners(eventType) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

        return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {
          return subscription.listener;
        }) : [];
      }
    }, {
      key: "emit",
      value: function emit(eventType) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

        if (subscriptions) {
          for (var i = 0, l = subscriptions.length; i < l; i++) {
            var subscription = subscriptions[i];

            if (subscription) {
              this._currentSubscription = subscription;
              subscription.listener.apply(subscription.context, Array.prototype.slice.call(arguments, 1));
            }
          }

          this._currentSubscription = null;
        }
      }
    }, {
      key: "removeListener",
      value: function removeListener(eventType, listener) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

        if (subscriptions) {
          for (var i = 0, l = subscriptions.length; i < l; i++) {
            var subscription = subscriptions[i];

            if (subscription && subscription.listener === listener) {
              subscription.remove();
            }
          }
        }
      }
    }]);
    return EventEmitter;
  }();

  module.exports = EventEmitter;
},118,[116,119,16,18],"EventEmitter");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var EventSubscriptionVendor = function () {
    function EventSubscriptionVendor() {
      babelHelpers.classCallCheck(this, EventSubscriptionVendor);
      this._subscriptionsForType = {};
      this._currentSubscription = null;
    }

    babelHelpers.createClass(EventSubscriptionVendor, [{
      key: "addSubscription",
      value: function addSubscription(eventType, subscription) {
        invariant(subscription.subscriber === this, 'The subscriber of the subscription is incorrectly set.');

        if (!this._subscriptionsForType[eventType]) {
          this._subscriptionsForType[eventType] = [];
        }

        var key = this._subscriptionsForType[eventType].length;

        this._subscriptionsForType[eventType].push(subscription);

        subscription.eventType = eventType;
        subscription.key = key;
        return subscription;
      }
    }, {
      key: "removeAllSubscriptions",
      value: function removeAllSubscriptions(eventType) {
        if (eventType === undefined) {
          this._subscriptionsForType = {};
        } else {
          delete this._subscriptionsForType[eventType];
        }
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        var eventType = subscription.eventType;
        var key = subscription.key;
        var subscriptionsForType = this._subscriptionsForType[eventType];

        if (subscriptionsForType) {
          delete subscriptionsForType[key];
        }
      }
    }, {
      key: "getSubscriptionsForType",
      value: function getSubscriptionsForType(eventType) {
        return this._subscriptionsForType[eventType];
      }
    }]);
    return EventSubscriptionVendor;
  }();

  module.exports = EventSubscriptionVendor;
},119,[18],"EventSubscriptionVendor");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EventEmitter = require(_dependencyMap[0], 'EventEmitter');

  var Platform = require(_dependencyMap[1], 'Platform');

  var RCTDeviceEventEmitter = require(_dependencyMap[2], 'RCTDeviceEventEmitter');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var NativeEventEmitter = function (_EventEmitter) {
    babelHelpers.inherits(NativeEventEmitter, _EventEmitter);

    function NativeEventEmitter(nativeModule) {
      babelHelpers.classCallCheck(this, NativeEventEmitter);

      var _this = babelHelpers.possibleConstructorReturn(this, (NativeEventEmitter.__proto__ || Object.getPrototypeOf(NativeEventEmitter)).call(this, RCTDeviceEventEmitter.sharedSubscriber));

      if (Platform.OS === 'ios') {
        invariant(nativeModule, 'Native module cannot be null.');
        _this._nativeModule = nativeModule;
      }

      return _this;
    }

    babelHelpers.createClass(NativeEventEmitter, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        if (this._nativeModule != null) {
          this._nativeModule.addListener(eventType);
        }

        return babelHelpers.get(NativeEventEmitter.prototype.__proto__ || Object.getPrototypeOf(NativeEventEmitter.prototype), "addListener", this).call(this, eventType, listener, context);
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        invariant(eventType, 'eventType argument is required.');
        var count = this.listeners(eventType).length;

        if (this._nativeModule != null) {
          this._nativeModule.removeListeners(count);
        }

        babelHelpers.get(NativeEventEmitter.prototype.__proto__ || Object.getPrototypeOf(NativeEventEmitter.prototype), "removeAllListeners", this).call(this, eventType);
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        if (this._nativeModule != null) {
          this._nativeModule.removeListeners(1);
        }

        babelHelpers.get(NativeEventEmitter.prototype.__proto__ || Object.getPrototypeOf(NativeEventEmitter.prototype), "removeSubscription", this).call(this, subscription);
      }
    }]);
    return NativeEventEmitter;
  }(EventEmitter);

  module.exports = NativeEventEmitter;
},120,[118,105,121,18],"NativeEventEmitter");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EventEmitter = require(_dependencyMap[0], 'EventEmitter');

  var EventSubscriptionVendor = require(_dependencyMap[1], 'EventSubscriptionVendor');

  function checkNativeEventModule(eventType) {
    if (eventType) {
      if (eventType.lastIndexOf('statusBar', 0) === 0) {
        throw new Error('`' + eventType + '` event should be registered via the StatusBarIOS module');
      }

      if (eventType.lastIndexOf('keyboard', 0) === 0) {
        throw new Error('`' + eventType + '` event should be registered via the Keyboard module');
      }

      if (eventType === 'appStateDidChange' || eventType === 'memoryWarning') {
        throw new Error('`' + eventType + '` event should be registered via the AppState module');
      }
    }
  }

  var RCTDeviceEventEmitter = function (_EventEmitter) {
    babelHelpers.inherits(RCTDeviceEventEmitter, _EventEmitter);

    function RCTDeviceEventEmitter() {
      babelHelpers.classCallCheck(this, RCTDeviceEventEmitter);
      var sharedSubscriber = new EventSubscriptionVendor();

      var _this = babelHelpers.possibleConstructorReturn(this, (RCTDeviceEventEmitter.__proto__ || Object.getPrototypeOf(RCTDeviceEventEmitter)).call(this, sharedSubscriber));

      _this.sharedSubscriber = sharedSubscriber;
      return _this;
    }

    babelHelpers.createClass(RCTDeviceEventEmitter, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        if (__DEV__) {
          checkNativeEventModule(eventType);
        }

        return babelHelpers.get(RCTDeviceEventEmitter.prototype.__proto__ || Object.getPrototypeOf(RCTDeviceEventEmitter.prototype), "addListener", this).call(this, eventType, listener, context);
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        if (__DEV__) {
          checkNativeEventModule(eventType);
        }

        babelHelpers.get(RCTDeviceEventEmitter.prototype.__proto__ || Object.getPrototypeOf(RCTDeviceEventEmitter.prototype), "removeAllListeners", this).call(this, eventType);
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        if (subscription.emitter !== this) {
          subscription.emitter.removeSubscription(subscription);
        } else {
          babelHelpers.get(RCTDeviceEventEmitter.prototype.__proto__ || Object.getPrototypeOf(RCTDeviceEventEmitter.prototype), "removeSubscription", this).call(this, subscription);
        }
      }
    }]);
    return RCTDeviceEventEmitter;
  }(EventEmitter);

  module.exports = new RCTDeviceEventEmitter();
},121,[118,119],"RCTDeviceEventEmitter");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var binaryToBase64 = require(_dependencyMap[0], 'binaryToBase64');

  var FormData = require(_dependencyMap[1], 'FormData');

  function convertRequestBody(body) {
    if (typeof body === 'string') {
      return {
        string: body
      };
    }

    if (body instanceof FormData) {
      return {
        formData: body.getParts()
      };
    }

    if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
      return {
        base64: binaryToBase64(body)
      };
    }

    return body;
  }

  module.exports = convertRequestBody;
},122,[123,125],"convertRequestBody");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var base64 = require(_dependencyMap[0], 'base64-js');

  function binaryToBase64(data) {
    if (data instanceof ArrayBuffer) {
      data = new Uint8Array(data);
    }

    if (data instanceof Uint8Array) {
      return base64.fromByteArray(data);
    }

    if (!ArrayBuffer.isView(data)) {
      throw new Error('data must be ArrayBuffer or typed array');
    }

    var _data = data,
        buffer = _data.buffer,
        byteOffset = _data.byteOffset,
        byteLength = _data.byteLength;
    return base64.fromByteArray(new Uint8Array(buffer, byteOffset, byteLength));
  }

  module.exports = binaryToBase64;
},123,[124],"binaryToBase64");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function placeHoldersCount(b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
  }

  function byteLength(b64) {
    return b64.length * 3 / 4 - placeHoldersCount(b64);
  }

  function toByteArray(b64) {
    var i, l, tmp, placeHolders, arr;
    var len = b64.length;
    placeHolders = placeHoldersCount(b64);
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;

    for (i = 0; i < l; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 0xFF;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = '';
    var parts = [];
    var maxChunkLength = 16383;

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 0x3F];
      output += lookup[tmp << 2 & 0x3F];
      output += '=';
    }

    parts.push(output);
    return parts.join('');
  }
},124,[],"base64-js/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var FormData = function () {
    function FormData() {
      babelHelpers.classCallCheck(this, FormData);
      this._parts = [];
    }

    babelHelpers.createClass(FormData, [{
      key: "append",
      value: function append(key, value) {
        this._parts.push([key, value]);
      }
    }, {
      key: "getParts",
      value: function getParts() {
        return this._parts.map(function (_ref) {
          var _ref2 = babelHelpers.slicedToArray(_ref, 2),
              name = _ref2[0],
              value = _ref2[1];

          var contentDisposition = 'form-data; name="' + name + '"';
          var headers = {
            'content-disposition': contentDisposition
          };

          if (typeof value === 'object' && value) {
            if (typeof value.name === 'string') {
              headers['content-disposition'] += '; filename="' + value.name + '"';
            }

            if (typeof value.type === 'string') {
              headers['content-type'] = value.type;
            }

            return babelHelpers.extends({}, value, {
              headers: headers,
              fieldName: name
            });
          }

          return {
            string: String(value),
            headers: headers,
            fieldName: name
          };
        });
      }
    }]);
    return FormData;
  }();

  module.exports = FormData;
},125,[],"FormData");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Blob = require(_dependencyMap[0], 'Blob');

  var EventTarget = require(_dependencyMap[1], 'event-target-shim');

  var NativeEventEmitter = require(_dependencyMap[2], 'NativeEventEmitter');

  var NativeModules = require(_dependencyMap[3], 'NativeModules');

  var Platform = require(_dependencyMap[4], 'Platform');

  var WebSocketEvent = require(_dependencyMap[5], 'WebSocketEvent');

  var base64 = require(_dependencyMap[6], 'base64-js');

  var binaryToBase64 = require(_dependencyMap[7], 'binaryToBase64');

  var invariant = require(_dependencyMap[8], 'fbjs/lib/invariant');

  var WebSocketModule = NativeModules.WebSocketModule;
  var CONNECTING = 0;
  var OPEN = 1;
  var CLOSING = 2;
  var CLOSED = 3;
  var CLOSE_NORMAL = 1000;
  var WEBSOCKET_EVENTS = ['close', 'error', 'message', 'open'];
  var nextWebSocketId = 0;

  var WebSocket = function (_EventTarget) {
    babelHelpers.inherits(WebSocket, _EventTarget);

    function WebSocket(url, protocols, options) {
      babelHelpers.classCallCheck(this, WebSocket);

      var _this = babelHelpers.possibleConstructorReturn(this, (WebSocket.__proto__ || Object.getPrototypeOf(WebSocket)).call(this));

      _this.CONNECTING = CONNECTING;
      _this.OPEN = OPEN;
      _this.CLOSING = CLOSING;
      _this.CLOSED = CLOSED;
      _this.readyState = CONNECTING;

      if (typeof protocols === 'string') {
        protocols = [protocols];
      }

      var _ref = options || {},
          _ref$headers = _ref.headers,
          headers = _ref$headers === undefined ? {} : _ref$headers,
          unrecognized = babelHelpers.objectWithoutProperties(_ref, ["headers"]);

      if (unrecognized && typeof unrecognized.origin === 'string') {
        console.warn('Specifying `origin` as a WebSocket connection option is deprecated. Include it under `headers` instead.');
        headers.origin = unrecognized.origin;
        delete unrecognized.origin;
      }

      if (Object.keys(unrecognized).length > 0) {
        console.warn('Unrecognized WebSocket connection option(s) `' + Object.keys(unrecognized).join('`, `') + '`. ' + 'Did you mean to put these under `headers`?');
      }

      if (!Array.isArray(protocols)) {
        protocols = null;
      }

      if (!WebSocket.isAvailable) {
        throw new Error('Cannot initialize WebSocket module. ' + 'Native module WebSocketModule is missing.');
      }

      _this._eventEmitter = new NativeEventEmitter(WebSocketModule);
      _this._socketId = nextWebSocketId++;

      _this._registerEvents();

      WebSocketModule.connect(url, protocols, {
        headers: headers
      }, _this._socketId);
      return _this;
    }

    babelHelpers.createClass(WebSocket, [{
      key: "close",
      value: function close(code, reason) {
        if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {
          return;
        }

        this.readyState = this.CLOSING;

        this._close(code, reason);
      }
    }, {
      key: "send",
      value: function send(data) {
        if (this.readyState === this.CONNECTING) {
          throw new Error('INVALID_STATE_ERR');
        }

        if (data instanceof Blob) {
          var BlobModule = NativeModules.BlobModule;
          invariant(BlobModule, 'Native module BlobModule is required for blob support');
          BlobModule.sendBlob(data, this._socketId);
          return;
        }

        if (typeof data === 'string') {
          WebSocketModule.send(data, this._socketId);
          return;
        }

        if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
          WebSocketModule.sendBinary(binaryToBase64(data), this._socketId);
          return;
        }

        throw new Error('Unsupported data type');
      }
    }, {
      key: "ping",
      value: function ping() {
        if (this.readyState === this.CONNECTING) {
          throw new Error('INVALID_STATE_ERR');
        }

        WebSocketModule.ping(this._socketId);
      }
    }, {
      key: "_close",
      value: function _close(code, reason) {
        if (Platform.OS === 'android') {
          var statusCode = typeof code === 'number' ? code : CLOSE_NORMAL;
          var closeReason = typeof reason === 'string' ? reason : '';
          WebSocketModule.close(statusCode, closeReason, this._socketId);
        } else {
          WebSocketModule.close(this._socketId);
        }
      }
    }, {
      key: "_unregisterEvents",
      value: function _unregisterEvents() {
        this._subscriptions.forEach(function (e) {
          return e.remove();
        });

        this._subscriptions = [];
      }
    }, {
      key: "_registerEvents",
      value: function _registerEvents() {
        var _this2 = this;

        this._subscriptions = [this._eventEmitter.addListener('websocketMessage', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          var data = ev.data;

          switch (ev.type) {
            case 'binary':
              data = base64.toByteArray(ev.data).buffer;
              break;

            case 'blob':
              data = Blob.create(ev.data);
              break;
          }

          _this2.dispatchEvent(new WebSocketEvent('message', {
            data: data
          }));
        }), this._eventEmitter.addListener('websocketOpen', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          _this2.readyState = _this2.OPEN;

          _this2.dispatchEvent(new WebSocketEvent('open'));
        }), this._eventEmitter.addListener('websocketClosed', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          _this2.readyState = _this2.CLOSED;

          _this2.dispatchEvent(new WebSocketEvent('close', {
            code: ev.code,
            reason: ev.reason
          }));

          _this2._unregisterEvents();

          _this2.close();
        }), this._eventEmitter.addListener('websocketFailed', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          _this2.readyState = _this2.CLOSED;

          _this2.dispatchEvent(new WebSocketEvent('error', {
            message: ev.message
          }));

          _this2.dispatchEvent(new WebSocketEvent('close', {
            message: ev.message
          }));

          _this2._unregisterEvents();

          _this2.close();
        })];
      }
    }, {
      key: "binaryType",
      get: function get() {
        return this._binaryType;
      },
      set: function set(binaryType) {
        if (binaryType !== 'blob' && binaryType !== 'arraybuffer') {
          throw new Error('binaryType must be either \'blob\' or \'arraybuffer\'');
        }

        if (this._binaryType === 'blob' || binaryType === 'blob') {
          var BlobModule = NativeModules.BlobModule;
          invariant(BlobModule, 'Native module BlobModule is required for blob support');

          if (BlobModule) {
            if (binaryType === 'blob') {
              BlobModule.enableBlobSupport(this._socketId);
            } else {
              BlobModule.disableBlobSupport(this._socketId);
            }
          }
        }

        this._binaryType = binaryType;
      }
    }]);
    return WebSocket;
  }(EventTarget.apply(undefined, WEBSOCKET_EVENTS));

  WebSocket.CONNECTING = CONNECTING;
  WebSocket.OPEN = OPEN;
  WebSocket.CLOSING = CLOSING;
  WebSocket.CLOSED = CLOSED;
  WebSocket.isAvailable = !!WebSocketModule;
  module.exports = WebSocket;
},126,[127,110,120,68,105,133,124,123,18],"WebSocket");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var uuid = require(_dependencyMap[1], 'uuid');

  var _require = require(_dependencyMap[2], 'NativeModules'),
      BlobModule = _require.BlobModule;

  var Blob = function () {
    babelHelpers.createClass(Blob, null, [{
      key: "create",
      value: function create(props) {
        return babelHelpers.extends(Object.create(Blob.prototype), props);
      }
    }]);

    function Blob(parts, options) {
      babelHelpers.classCallCheck(this, Blob);
      var blobId = uuid();
      var size = 0;
      parts.forEach(function (part) {
        invariant(part instanceof Blob, 'Can currently only create a Blob from other Blobs');
        size += part.size;
      });
      BlobModule.createFromParts(parts, blobId);
      return Blob.create({
        blobId: blobId,
        offset: 0,
        size: size
      });
    }

    babelHelpers.createClass(Blob, [{
      key: "slice",
      value: function slice(start, end) {
        var offset = this.offset;
        var size = this.size;

        if (typeof start === 'number') {
          if (start > size) {
            start = size;
          }

          offset += start;
          size -= start;

          if (typeof end === 'number') {
            if (end < 0) {
              end = this.size + end;
            }

            size = end - start;
          }
        }

        return Blob.create({
          blobId: this.blobId,
          offset: offset,
          size: size
        });
      }
    }, {
      key: "close",
      value: function close() {
        BlobModule.release(this.blobId);
      }
    }]);
    return Blob;
  }();

  module.exports = Blob;
},127,[18,128,68],"Blob");
__d(function (global, require, module, exports, _dependencyMap) {
  var v1 = require(_dependencyMap[0], './v1');

  var v4 = require(_dependencyMap[1], './v4');

  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  module.exports = uuid;
},128,[129,132],"uuid/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var rng = require(_dependencyMap[0], './lib/rng');

  var bytesToUuid = require(_dependencyMap[1], './lib/bytesToUuid');

  var _nodeId;

  var _clockseq;

  var _lastMSecs = 0;
  var _lastNSecs = 0;

  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

    if (node == null || clockseq == null) {
      var seedBytes = rng();

      if (node == null) {
        node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }

      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
      }
    }

    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }

    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;
    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;
    b[i++] = tmh >>> 24 & 0xf | 0x10;
    b[i++] = tmh >>> 16 & 0xff;
    b[i++] = clockseq >>> 8 | 0x80;
    b[i++] = clockseq & 0xff;

    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }

    return buf ? buf : bytesToUuid(b);
  }

  module.exports = v1;
},129,[130,131],"uuid/v1.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && msCrypto.getRandomValues.bind(msCrypto);

  if (getRandomValues) {
    var rnds8 = new Uint8Array(16);

    module.exports = function whatwgRNG() {
      getRandomValues(rnds8);
      return rnds8;
    };
  } else {
    var rnds = new Array(16);

    module.exports = function mathRNG() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return rnds;
    };
  }
},130,[],"uuid/lib/rng-browser.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var byteToHex = [];

  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
  }

  function bytesToUuid(buf, offset) {
    var i = offset || 0;
    var bth = byteToHex;
    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
  }

  module.exports = bytesToUuid;
},131,[],"uuid/lib/bytesToUuid.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var rng = require(_dependencyMap[0], './lib/rng');

  var bytesToUuid = require(_dependencyMap[1], './lib/bytesToUuid');

  function v4(options, buf, offset) {
    var i = buf && offset || 0;

    if (typeof options == 'string') {
      buf = options === 'binary' ? new Array(16) : null;
      options = null;
    }

    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80;

    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || bytesToUuid(rnds);
  }

  module.exports = v4;
},132,[130,131],"uuid/v4.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var WebSocketEvent = function WebSocketEvent(type, eventInitDict) {
    babelHelpers.classCallCheck(this, WebSocketEvent);
    this.type = type.toString();
    babelHelpers.extends(this, eventInitDict);
  };

  module.exports = WebSocketEvent;
},133,[],"WebSocketEvent");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Blob = require(_dependencyMap[0], 'Blob');

  var _require = require(_dependencyMap[1], 'NativeModules'),
      BlobModule = _require.BlobModule;

  var BLOB_URL_PREFIX = null;

  if (BlobModule && typeof BlobModule.BLOB_URI_SCHEME === 'string') {
    BLOB_URL_PREFIX = BlobModule.BLOB_URI_SCHEME + ':';

    if (typeof BlobModule.BLOB_URI_HOST === 'string') {
      BLOB_URL_PREFIX += "//" + BlobModule.BLOB_URI_HOST + "/";
    }
  }

  var URL = function () {
    function URL() {
      babelHelpers.classCallCheck(this, URL);
      throw new Error('Creating BlobURL objects is not supported yet.');
    }

    babelHelpers.createClass(URL, null, [{
      key: "createObjectURL",
      value: function createObjectURL(blob) {
        if (BLOB_URL_PREFIX === null) {
          throw new Error('Cannot create URL for blob!');
        }

        return "" + BLOB_URL_PREFIX + blob.blobId + "?offset=" + blob.offset + "&size=" + blob.size;
      }
    }, {
      key: "revokeObjectURL",
      value: function revokeObjectURL(url) {}
    }]);
    return URL;
  }();

  module.exports = URL;
},134,[127,68],"URL");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AlertIOS = require(_dependencyMap[0], 'AlertIOS');

  var NativeModules = require(_dependencyMap[1], 'NativeModules');

  var Platform = require(_dependencyMap[2], 'Platform');

  var Alert = function () {
    function Alert() {
      babelHelpers.classCallCheck(this, Alert);
    }

    babelHelpers.createClass(Alert, null, [{
      key: "alert",
      value: function alert(title, message, buttons, options, type) {
        if (Platform.OS === 'ios') {
          if (typeof type !== 'undefined') {
            console.warn('Alert.alert() with a 5th "type" parameter is deprecated and will be removed. Use AlertIOS.prompt() instead.');
            AlertIOS.alert(title, message, buttons, type);
            return;
          }

          AlertIOS.alert(title, message, buttons);
        } else if (Platform.OS === 'android') {
          AlertAndroid.alert(title, message, buttons, options);
        }
      }
    }]);
    return Alert;
  }();

  var AlertAndroid = function () {
    function AlertAndroid() {
      babelHelpers.classCallCheck(this, AlertAndroid);
    }

    babelHelpers.createClass(AlertAndroid, null, [{
      key: "alert",
      value: function alert(title, message, buttons, options) {
        var config = {
          title: title || '',
          message: message || ''
        };

        if (options) {
          config = babelHelpers.extends({}, config, {
            cancelable: options.cancelable
          });
        }

        var validButtons = buttons ? buttons.slice(0, 3) : [{
          text: 'OK'
        }];
        var buttonPositive = validButtons.pop();
        var buttonNegative = validButtons.pop();
        var buttonNeutral = validButtons.pop();

        if (buttonNeutral) {
          config = babelHelpers.extends({}, config, {
            buttonNeutral: buttonNeutral.text || ''
          });
        }

        if (buttonNegative) {
          config = babelHelpers.extends({}, config, {
            buttonNegative: buttonNegative.text || ''
          });
        }

        if (buttonPositive) {
          config = babelHelpers.extends({}, config, {
            buttonPositive: buttonPositive.text || ''
          });
        }

        NativeModules.DialogManagerAndroid.showAlert(config, function (errorMessage) {
          return console.warn(errorMessage);
        }, function (action, buttonKey) {
          if (action === NativeModules.DialogManagerAndroid.buttonClicked) {
            if (buttonKey === NativeModules.DialogManagerAndroid.buttonNeutral) {
              buttonNeutral.onPress && buttonNeutral.onPress();
            } else if (buttonKey === NativeModules.DialogManagerAndroid.buttonNegative) {
              buttonNegative.onPress && buttonNegative.onPress();
            } else if (buttonKey === NativeModules.DialogManagerAndroid.buttonPositive) {
              buttonPositive.onPress && buttonPositive.onPress();
            }
          } else if (action === NativeModules.DialogManagerAndroid.dismissed) {
            options && options.onDismiss && options.onDismiss();
          }
        });
      }
    }]);
    return AlertAndroid;
  }();

  module.exports = Alert;
},135,[136,68,105],"Alert");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTAlertManager = require(_dependencyMap[0], 'NativeModules').AlertManager;

  var AlertIOS = function () {
    function AlertIOS() {
      babelHelpers.classCallCheck(this, AlertIOS);
    }

    babelHelpers.createClass(AlertIOS, null, [{
      key: "alert",
      value: function alert(title, message, callbackOrButtons, type) {
        if (typeof type !== 'undefined') {
          console.warn('AlertIOS.alert() with a 4th "type" parameter is deprecated and will be removed. Use AlertIOS.prompt() instead.');
          this.prompt(title, message, callbackOrButtons, type);
          return;
        }

        this.prompt(title, message, callbackOrButtons, 'default');
      }
    }, {
      key: "prompt",
      value: function prompt(title, message, callbackOrButtons) {
        var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'plain-text';
        var defaultValue = arguments[4];
        var keyboardType = arguments[5];

        if (typeof type === 'function') {
          console.warn('You passed a callback function as the "type" argument to AlertIOS.prompt(). React Native is ' + 'assuming  you want to use the deprecated AlertIOS.prompt(title, defaultValue, buttons, callback) ' + 'signature. The current signature is AlertIOS.prompt(title, message, callbackOrButtons, type, defaultValue, ' + 'keyboardType) and the old syntax will be removed in a future version.');
          var callback = type;
          var defaultValue = message;
          RCTAlertManager.alertWithArgs({
            title: title || '',
            type: 'plain-text',
            defaultValue: defaultValue
          }, function (id, value) {
            callback(value);
          });
          return;
        }

        var callbacks = [];
        var buttons = [];
        var cancelButtonKey;
        var destructiveButtonKey;

        if (typeof callbackOrButtons === 'function') {
          callbacks = [callbackOrButtons];
        } else if (callbackOrButtons instanceof Array) {
          callbackOrButtons.forEach(function (btn, index) {
            callbacks[index] = btn.onPress;

            if (btn.style === 'cancel') {
              cancelButtonKey = String(index);
            } else if (btn.style === 'destructive') {
              destructiveButtonKey = String(index);
            }

            if (btn.text || index < (callbackOrButtons || []).length - 1) {
              var btnDef = {};
              btnDef[index] = btn.text || '';
              buttons.push(btnDef);
            }
          });
        }

        RCTAlertManager.alertWithArgs({
          title: title || '',
          message: message || undefined,
          buttons: buttons,
          type: type || undefined,
          defaultValue: defaultValue,
          cancelButtonKey: cancelButtonKey,
          destructiveButtonKey: destructiveButtonKey,
          keyboardType: keyboardType
        }, function (id, value) {
          var cb = callbacks[id];
          cb && cb(value);
        });
      }
    }]);
    return AlertIOS;
  }();

  module.exports = AlertIOS;
},136,[68],"AlertIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeEventEmitter = require(_dependencyMap[0], 'NativeEventEmitter');

  var RCTLocationObserver = require(_dependencyMap[1], 'NativeModules').LocationObserver;

  var invariant = require(_dependencyMap[2], 'fbjs/lib/invariant');

  var logError = require(_dependencyMap[3], 'logError');

  var warning = require(_dependencyMap[4], 'fbjs/lib/warning');

  var LocationEventEmitter = new NativeEventEmitter(RCTLocationObserver);

  var Platform = require(_dependencyMap[5], 'Platform');

  var PermissionsAndroid = require(_dependencyMap[6], 'PermissionsAndroid');

  var subscriptions = [];
  var updatesEnabled = false;
  var Geolocation = {
    setRNConfiguration: function setRNConfiguration(config) {
      if (RCTLocationObserver.setConfiguration) {
        RCTLocationObserver.setConfiguration(config);
      }
    },
    requestAuthorization: function requestAuthorization() {
      RCTLocationObserver.requestAuthorization();
    },
    getCurrentPosition: function getCurrentPosition(geo_success, geo_error, geo_options) {
      var hasPermission, status;
      return regeneratorRuntime.async(function getCurrentPosition$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              invariant(typeof geo_success === 'function', 'Must provide a valid geo_success callback.');
              hasPermission = true;

              if (!(Platform.OS === 'android' && Platform.Version >= 23)) {
                _context.next = 11;
                break;
              }

              _context.next = 5;
              return regeneratorRuntime.awrap(PermissionsAndroid.check(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION));

            case 5:
              hasPermission = _context.sent;

              if (hasPermission) {
                _context.next = 11;
                break;
              }

              _context.next = 9;
              return regeneratorRuntime.awrap(PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION));

            case 9:
              status = _context.sent;
              hasPermission = status === PermissionsAndroid.RESULTS.GRANTED;

            case 11:
              if (hasPermission) {
                RCTLocationObserver.getCurrentPosition(geo_options || {}, geo_success, geo_error || logError);
              }

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    },
    watchPosition: function watchPosition(success, error, options) {
      if (!updatesEnabled) {
        RCTLocationObserver.startObserving(options || {});
        updatesEnabled = true;
      }

      var watchID = subscriptions.length;
      subscriptions.push([LocationEventEmitter.addListener('geolocationDidChange', success), error ? LocationEventEmitter.addListener('geolocationError', error) : null]);
      return watchID;
    },
    clearWatch: function clearWatch(watchID) {
      var sub = subscriptions[watchID];

      if (!sub) {
        return;
      }

      sub[0].remove();
      var sub1 = sub[1];
      sub1 && sub1.remove();
      subscriptions[watchID] = undefined;
      var noWatchers = true;

      for (var ii = 0; ii < subscriptions.length; ii++) {
        if (subscriptions[ii]) {
          noWatchers = false;
        }
      }

      if (noWatchers) {
        Geolocation.stopObserving();
      }
    },
    stopObserving: function stopObserving() {
      if (updatesEnabled) {
        RCTLocationObserver.stopObserving();
        updatesEnabled = false;

        for (var ii = 0; ii < subscriptions.length; ii++) {
          var sub = subscriptions[ii];

          if (sub) {
            warning(false, 'Called stopObserving with existing subscriptions.');
            sub[0].remove();
            var sub1 = sub[1];
            sub1 && sub1.remove();
          }
        }

        subscriptions = [];
      }
    }
  };
  module.exports = Geolocation;
},137,[120,68,18,138,19,105,139],"Geolocation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var logError = function logError() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && args[0] instanceof Error) {
      var err = args[0];
      console.error('Error: "' + err.message + '".  Stack:\n' + err.stack);
    } else {
      console.error.apply(console, args);
    }
  };

  module.exports = logError;
},138,[],"logError");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = require(_dependencyMap[0], 'NativeModules');

  var PermissionsAndroid = function () {
    function PermissionsAndroid() {
      babelHelpers.classCallCheck(this, PermissionsAndroid);
      this.PERMISSIONS = {
        READ_CALENDAR: 'android.permission.READ_CALENDAR',
        WRITE_CALENDAR: 'android.permission.WRITE_CALENDAR',
        CAMERA: 'android.permission.CAMERA',
        READ_CONTACTS: 'android.permission.READ_CONTACTS',
        WRITE_CONTACTS: 'android.permission.WRITE_CONTACTS',
        GET_ACCOUNTS: 'android.permission.GET_ACCOUNTS',
        ACCESS_FINE_LOCATION: 'android.permission.ACCESS_FINE_LOCATION',
        ACCESS_COARSE_LOCATION: 'android.permission.ACCESS_COARSE_LOCATION',
        RECORD_AUDIO: 'android.permission.RECORD_AUDIO',
        READ_PHONE_STATE: 'android.permission.READ_PHONE_STATE',
        CALL_PHONE: 'android.permission.CALL_PHONE',
        READ_CALL_LOG: 'android.permission.READ_CALL_LOG',
        WRITE_CALL_LOG: 'android.permission.WRITE_CALL_LOG',
        ADD_VOICEMAIL: 'com.android.voicemail.permission.ADD_VOICEMAIL',
        USE_SIP: 'android.permission.USE_SIP',
        PROCESS_OUTGOING_CALLS: 'android.permission.PROCESS_OUTGOING_CALLS',
        BODY_SENSORS: 'android.permission.BODY_SENSORS',
        SEND_SMS: 'android.permission.SEND_SMS',
        RECEIVE_SMS: 'android.permission.RECEIVE_SMS',
        READ_SMS: 'android.permission.READ_SMS',
        RECEIVE_WAP_PUSH: 'android.permission.RECEIVE_WAP_PUSH',
        RECEIVE_MMS: 'android.permission.RECEIVE_MMS',
        READ_EXTERNAL_STORAGE: 'android.permission.READ_EXTERNAL_STORAGE',
        WRITE_EXTERNAL_STORAGE: 'android.permission.WRITE_EXTERNAL_STORAGE'
      };
      this.RESULTS = {
        GRANTED: 'granted',
        DENIED: 'denied',
        NEVER_ASK_AGAIN: 'never_ask_again'
      };
    }

    babelHelpers.createClass(PermissionsAndroid, [{
      key: "checkPermission",
      value: function checkPermission(permission) {
        console.warn('"PermissionsAndroid.checkPermission" is deprecated. Use "PermissionsAndroid.check" instead');
        return NativeModules.PermissionsAndroid.checkPermission(permission);
      }
    }, {
      key: "check",
      value: function check(permission) {
        return NativeModules.PermissionsAndroid.checkPermission(permission);
      }
    }, {
      key: "requestPermission",
      value: function requestPermission(permission, rationale) {
        var response;
        return regeneratorRuntime.async(function requestPermission$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                console.warn('"PermissionsAndroid.requestPermission" is deprecated. Use "PermissionsAndroid.request" instead');
                _context.next = 3;
                return regeneratorRuntime.awrap(this.request(permission, rationale));

              case 3:
                response = _context.sent;
                return _context.abrupt("return", response === this.RESULTS.GRANTED);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }
    }, {
      key: "request",
      value: function request(permission, rationale) {
        var shouldShowRationale;
        return regeneratorRuntime.async(function request$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!rationale) {
                  _context2.next = 6;
                  break;
                }

                _context2.next = 3;
                return regeneratorRuntime.awrap(NativeModules.PermissionsAndroid.shouldShowRequestPermissionRationale(permission));

              case 3:
                shouldShowRationale = _context2.sent;

                if (!shouldShowRationale) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  NativeModules.DialogManagerAndroid.showAlert(rationale, function () {
                    return reject(new Error('Error showing rationale'));
                  }, function () {
                    return resolve(NativeModules.PermissionsAndroid.requestPermission(permission));
                  });
                }));

              case 6:
                return _context2.abrupt("return", NativeModules.PermissionsAndroid.requestPermission(permission));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, null, this);
      }
    }, {
      key: "requestMultiple",
      value: function requestMultiple(permissions) {
        return NativeModules.PermissionsAndroid.requestMultiplePermissions(permissions);
      }
    }]);
    return PermissionsAndroid;
  }();

  PermissionsAndroid = new PermissionsAndroid();
  module.exports = PermissionsAndroid;
},139,[68],"PermissionsAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var HeapCapture = {
    captureHeap: function captureHeap(path) {
      var error = null;

      try {
        global.nativeCaptureHeap(path);
        console.log('HeapCapture.captureHeap succeeded: ' + path);
      } catch (e) {
        console.log('HeapCapture.captureHeap error: ' + e.toString());
        error = e.toString();
      }

      require(_dependencyMap[0], 'NativeModules').JSCHeapCapture.captureComplete(path, error);
    }
  };
  module.exports = HeapCapture;
},140,[68],"HeapCapture");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var SamplingProfiler = {
    poke: function poke(token) {
      var error = null;
      var result = null;

      try {
        result = global.pokeSamplingProfiler();

        if (result === null) {
          console.log('The JSC Sampling Profiler has started');
        } else {
          console.log('The JSC Sampling Profiler has stopped');
        }
      } catch (e) {
        console.log('Error occured when restarting Sampling Profiler: ' + e.toString());
        error = e.toString();
      }

      var _require = require(_dependencyMap[0], 'NativeModules'),
          JSCSamplingProfiler = _require.JSCSamplingProfiler;

      JSCSamplingProfiler.operationComplete(token, result, error);
    }
  };
  module.exports = SamplingProfiler;
},141,[68],"SamplingProfiler");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var levelsMap = {
    log: 'log',
    info: 'info',
    warn: 'warn',
    error: 'error',
    fatal: 'error'
  };
  var warningHandler = null;
  var RCTLog = {
    logIfNoNativeHook: function logIfNoNativeHook(level) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (typeof global.nativeLoggingHook === 'undefined') {
        RCTLog.logToConsole.apply(RCTLog, [level].concat(babelHelpers.toConsumableArray(args)));
      } else {
        if (warningHandler && level === 'warn') {
          warningHandler.apply(undefined, babelHelpers.toConsumableArray(args));
        }
      }
    },
    logToConsole: function logToConsole(level) {
      var _console;

      var logFn = levelsMap[level];
      invariant(logFn, 'Level "' + level + '" not one of ' + Object.keys(levelsMap).toString());

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (_console = console)[logFn].apply(_console, babelHelpers.toConsumableArray(args));
    },
    setWarningHandler: function setWarningHandler(handler) {
      warningHandler = handler;
    }
  };
  module.exports = RCTLog;
},142,[18],"RCTLog");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTDeviceEventEmitter = require(_dependencyMap[0], 'RCTDeviceEventEmitter');

  var RCTNativeAppEventEmitter = RCTDeviceEventEmitter;
  module.exports = RCTNativeAppEventEmitter;
},143,[121],"RCTNativeAppEventEmitter");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Systrace = require(_dependencyMap[0], 'Systrace');

  var infoLog = require(_dependencyMap[1], 'infoLog');

  var performanceNow = global.nativePerformanceNow || require(_dependencyMap[2], 'fbjs/lib/performanceNow');

  var timespans = {};
  var extras = {};
  var cookies = {};
  var PRINT_TO_CONSOLE = false;
  var PerformanceLogger = {
    addTimespan: function addTimespan(key, lengthInMs, description) {
      if (timespans[key]) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to add a timespan that already exists ', key);
        }

        return;
      }

      timespans[key] = {
        description: description,
        totalTime: lengthInMs
      };
    },
    startTimespan: function startTimespan(key, description) {
      if (timespans[key]) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to start a timespan that already exists ', key);
        }

        return;
      }

      timespans[key] = {
        description: description,
        startTime: performanceNow()
      };
      cookies[key] = Systrace.beginAsyncEvent(key);

      if (__DEV__ && PRINT_TO_CONSOLE) {
        infoLog('PerformanceLogger.js', 'start: ' + key);
      }
    },
    stopTimespan: function stopTimespan(key) {
      var timespan = timespans[key];

      if (!timespan || !timespan.startTime) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to end a timespan that has not started ', key);
        }

        return;
      }

      if (timespan.endTime) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to end a timespan that has already ended ', key);
        }

        return;
      }

      timespan.endTime = performanceNow();
      timespan.totalTime = timespan.endTime - (timespan.startTime || 0);

      if (__DEV__ && PRINT_TO_CONSOLE) {
        infoLog('PerformanceLogger.js', 'end: ' + key);
      }

      Systrace.endAsyncEvent(key, cookies[key]);
      delete cookies[key];
    },
    clear: function clear() {
      timespans = {};
      extras = {};
    },
    clearCompleted: function clearCompleted() {
      for (var _key in timespans) {
        if (timespans[_key].totalTime) {
          delete timespans[_key];
        }
      }

      extras = {};
    },
    clearExceptTimespans: function clearExceptTimespans(keys) {
      timespans = Object.keys(timespans).reduce(function (previous, key) {
        if (keys.indexOf(key) !== -1) {
          previous[key] = timespans[key];
        }

        return previous;
      }, {});
      extras = {};
    },
    currentTimestamp: function currentTimestamp() {
      return performanceNow();
    },
    getTimespans: function getTimespans() {
      return timespans;
    },
    hasTimespan: function hasTimespan(key) {
      return !!timespans[key];
    },
    logTimespans: function logTimespans() {
      for (var _key2 in timespans) {
        if (timespans[_key2].totalTime) {
          infoLog(_key2 + ': ' + timespans[_key2].totalTime + 'ms');
        }
      }
    },
    addTimespans: function addTimespans(newTimespans, labels) {
      for (var ii = 0, l = newTimespans.length; ii < l; ii += 2) {
        var label = labels[ii / 2];
        PerformanceLogger.addTimespan(label, newTimespans[ii + 1] - newTimespans[ii], label);
      }
    },
    setExtra: function setExtra(key, value) {
      if (extras[key]) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to set an extra that already exists ', {
            key: key,
            currentValue: extras[key],
            attemptedValue: value
          });
        }

        return;
      }

      extras[key] = value;
    },
    getExtras: function getExtras() {
      return extras;
    }
  };
  module.exports = PerformanceLogger;
},144,[72,145,106],"PerformanceLogger");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function infoLog() {
    var _console;

    return (_console = console).log.apply(_console, arguments);
  }

  module.exports = infoLog;
},145,[],"infoLog");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Platform = require(_dependencyMap[0], 'Platform');

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  var HMRClient = {
    enable: function enable(platform, bundleEntry, host, port) {
      invariant(platform, 'Missing required parameter `platform`');
      invariant(bundleEntry, 'Missing required paramenter `bundleEntry`');
      invariant(host, 'Missing required paramenter `host`');

      var WebSocket = require(_dependencyMap[2], 'WebSocket');

      var wsHostPort = port !== null && port !== '' ? host + ":" + port : host;
      bundleEntry = bundleEntry.replace(/\.(bundle|delta)/, '.js');
      var wsUrl = "ws://" + wsHostPort + "/hot?" + ("platform=" + platform + "&") + ("bundleEntry=" + bundleEntry);
      var activeWS = new WebSocket(wsUrl);

      activeWS.onerror = function (e) {
        var error = "Hot loading isn't working because it cannot connect to the development server.\n\nTry the following to fix the issue:\n- Ensure that the packager server is running and available on the same network";

        if (Platform.OS === 'ios') {
          error += "\n- Ensure that the Packager server URL is correctly set in AppDelegate";
        } else {
          error += "\n- Ensure that your device/emulator is connected to your machine and has USB debugging enabled - run 'adb devices' to see a list of connected devices\n- If you're on a physical device connected to the same machine, run 'adb reverse tcp:8081 tcp:8081' to forward requests from your device\n- If your device is on the same Wi-Fi network, set 'Debug server host & port for device' in 'Dev settings' to your machine's IP address and the port of the local dev server - e.g. 10.0.1.1:8081";
        }

        error += "\n\nURL: " + host + ":" + port + "\n\nError: " + e.message;
        throw new Error(error);
      };

      activeWS.onmessage = function (_ref) {
        var data = _ref.data;

        var HMRLoadingView = require(_dependencyMap[3], 'HMRLoadingView');

        data = JSON.parse(data);

        switch (data.type) {
          case 'update-start':
            {
              HMRLoadingView.showMessage('Hot Loading...');
              break;
            }

          case 'update':
            {
              var _data$body = data.body,
                  modules = _data$body.modules,
                  sourceMappingURLs = _data$body.sourceMappingURLs,
                  sourceURLs = _data$body.sourceURLs;

              if (Platform.OS === 'ios') {
                var RCTRedBox = require(_dependencyMap[4], 'NativeModules').RedBox;

                RCTRedBox && RCTRedBox.dismiss && RCTRedBox.dismiss();
              } else {
                var RCTExceptionsManager = require(_dependencyMap[4], 'NativeModules').ExceptionsManager;

                RCTExceptionsManager && RCTExceptionsManager.dismissRedbox && RCTExceptionsManager.dismissRedbox();
              }

              modules.forEach(function (_ref2, i) {
                var id = _ref2.id,
                    code = _ref2.code;
                code = code + '\n\n' + sourceMappingURLs[i];
                var injectFunction = typeof global.nativeInjectHMRUpdate === 'function' ? global.nativeInjectHMRUpdate : eval;
                injectFunction(code, sourceURLs[i]);
              });
              HMRLoadingView.hide();
              break;
            }

          case 'update-done':
            {
              HMRLoadingView.hide();
              break;
            }

          case 'error':
            {
              HMRLoadingView.hide();
              throw new Error(data.body.type + ' ' + data.body.description);
            }

          default:
            {
              throw new Error("Unexpected message: " + data);
            }
        }
      };
    }
  };
  module.exports = HMRClient;
},146,[105,18,126,147,68],"HMRClient");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ToastAndroid = require(_dependencyMap[0], 'ToastAndroid');

  var TOAST_SHORT_DELAY = 2000;

  var HMRLoadingView = function () {
    function HMRLoadingView() {
      babelHelpers.classCallCheck(this, HMRLoadingView);
    }

    babelHelpers.createClass(HMRLoadingView, null, [{
      key: "showMessage",
      value: function showMessage(message) {
        if (HMRLoadingView._showing) {
          return;
        }

        ToastAndroid.show(message, ToastAndroid.SHORT);
        HMRLoadingView._showing = true;
        setTimeout(function () {
          HMRLoadingView._showing = false;
        }, TOAST_SHORT_DELAY);
      }
    }, {
      key: "hide",
      value: function hide() {}
    }]);
    return HMRLoadingView;
  }();

  module.exports = HMRLoadingView;
},147,[148],"HMRLoadingView");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTToastAndroid = require(_dependencyMap[0], 'NativeModules').ToastAndroid;

  var ToastAndroid = {
    SHORT: RCTToastAndroid.SHORT,
    LONG: RCTToastAndroid.LONG,
    TOP: RCTToastAndroid.TOP,
    BOTTOM: RCTToastAndroid.BOTTOM,
    CENTER: RCTToastAndroid.CENTER,
    show: function show(message, duration) {
      RCTToastAndroid.show(message, duration);
    },
    showWithGravity: function showWithGravity(message, duration, gravity) {
      RCTToastAndroid.showWithGravity(message, duration, gravity);
    },
    showWithGravityAndOffset: function showWithGravityAndOffset(message, duration, gravity, xOffset, yOffset) {
      RCTToastAndroid.showWithGravityAndOffset(message, duration, gravity, xOffset, yOffset);
    }
  };
  module.exports = ToastAndroid;
},148,[68],"ToastAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var register = function register() {};

  if (__DEV__) {
    var AppState = require(_dependencyMap[0], 'AppState');

    var WebSocket = require(_dependencyMap[1], 'WebSocket');

    var _require = require(_dependencyMap[2], 'NativeModules'),
        PlatformConstants = _require.PlatformConstants;

    var reactDevTools = require(_dependencyMap[3], 'react-devtools-core');

    if (WebSocket.isAvailable) {
      var _isAppActive = function _isAppActive() {
        return AppState.currentState !== 'background';
      };

      var _host = PlatformConstants && PlatformConstants.ServerHost ? PlatformConstants.ServerHost.split(':')[0] : 'localhost';

      reactDevTools.connectToDevTools({
        isAppActive: _isAppActive,
        host: _host,
        port: window.__REACT_DEVTOOLS_PORT__,
        resolveRNStyle: require(_dependencyMap[4], 'flattenStyle')
      });
    }
  }

  module.exports = {
    register: register
  };
},149,[150,126,68,151,152],"setupDevtools");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var MissingNativeEventEmitterShim = require(_dependencyMap[0], 'MissingNativeEventEmitterShim');

  var NativeEventEmitter = require(_dependencyMap[1], 'NativeEventEmitter');

  var NativeModules = require(_dependencyMap[2], 'NativeModules');

  var RCTAppState = NativeModules.AppState;

  var logError = require(_dependencyMap[3], 'logError');

  var invariant = require(_dependencyMap[4], 'fbjs/lib/invariant');

  var AppState = function (_NativeEventEmitter) {
    babelHelpers.inherits(AppState, _NativeEventEmitter);

    function AppState() {
      babelHelpers.classCallCheck(this, AppState);

      var _this = babelHelpers.possibleConstructorReturn(this, (AppState.__proto__ || Object.getPrototypeOf(AppState)).call(this, RCTAppState));

      _this.isAvailable = true;
      _this.isAvailable = true;
      _this._eventHandlers = {
        change: new Map(),
        memoryWarning: new Map()
      };
      _this.currentState = RCTAppState.initialAppState || 'active';
      var eventUpdated = false;

      _this.addListener('appStateDidChange', function (appStateData) {
        eventUpdated = true;
        _this.currentState = appStateData.app_state;
      });

      RCTAppState.getCurrentAppState(function (appStateData) {
        if (!eventUpdated) {
          _this.currentState = appStateData.app_state;
        }
      }, logError);
      return _this;
    }

    babelHelpers.createClass(AppState, [{
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        invariant(['change', 'memoryWarning'].indexOf(type) !== -1, 'Trying to subscribe to unknown event: "%s"', type);

        if (type === 'change') {
          this._eventHandlers[type].set(handler, this.addListener('appStateDidChange', function (appStateData) {
            handler(appStateData.app_state);
          }));
        } else if (type === 'memoryWarning') {
          this._eventHandlers[type].set(handler, this.addListener('memoryWarning', handler));
        }
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        invariant(['change', 'memoryWarning'].indexOf(type) !== -1, 'Trying to remove listener for unknown event: "%s"', type);

        if (!this._eventHandlers[type].has(handler)) {
          return;
        }

        this._eventHandlers[type].get(handler).remove();

        this._eventHandlers[type].delete(handler);
      }
    }]);
    return AppState;
  }(NativeEventEmitter);

  if (__DEV__ && !RCTAppState) {
    var MissingNativeAppStateShim = function (_MissingNativeEventEm) {
      babelHelpers.inherits(MissingNativeAppStateShim, _MissingNativeEventEm);

      function MissingNativeAppStateShim() {
        babelHelpers.classCallCheck(this, MissingNativeAppStateShim);
        return babelHelpers.possibleConstructorReturn(this, (MissingNativeAppStateShim.__proto__ || Object.getPrototypeOf(MissingNativeAppStateShim)).call(this, 'RCTAppState', 'AppState'));
      }

      babelHelpers.createClass(MissingNativeAppStateShim, [{
        key: "addEventListener",
        value: function addEventListener() {
          this.throwMissingNativeModule();
        }
      }, {
        key: "removeEventListener",
        value: function removeEventListener() {
          this.throwMissingNativeModule();
        }
      }, {
        key: "currentState",
        get: function get() {
          this.throwMissingNativeModule();
        }
      }]);
      return MissingNativeAppStateShim;
    }(MissingNativeEventEmitterShim);

    AppState = new MissingNativeAppStateShim();
  } else {
    AppState = new AppState();
  }

  module.exports = AppState;
},150,[115,120,68,138,18],"AppState");
__d(function (global, require, module, exports, _dependencyMap) {
    !function (root, factory) {
        "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.ReactDevToolsBackend = factory() : root.ReactDevToolsBackend = factory();
    }(this, function () {
        return function (modules) {
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) return installedModules[moduleId].exports;
                var module = installedModules[moduleId] = {
                    exports: {},
                    id: moduleId,
                    loaded: !1
                };
                return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.loaded = !0, module.exports;
            }

            var installedModules = {};
            return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "", __webpack_require__(0);
        }([function (module, exports, __webpack_require__) {
            "use strict";

            function connectToDevTools(options) {
                function scheduleRetry() {
                    setTimeout(function () {
                        return connectToDevTools(options);
                    }, 2e3);
                }

                function handleClose() {
                    hasClosed || (hasClosed = !0, scheduleRetry(), closeListeners.forEach(function (fn) {
                        return fn();
                    }));
                }

                function handleMessage(evt) {
                    var data;

                    try {
                        data = JSON.parse(evt.data);
                    } catch (e) {
                        return void console.error("failed to parse json: " + evt.data);
                    }

                    messageListeners.forEach(function (fn) {
                        try {
                            fn(data);
                        } catch (e) {
                            throw console.log(data), e;
                        }
                    });
                }

                var _ref = options || {},
                    _ref$host = _ref.host,
                    host = void 0 === _ref$host ? "localhost" : _ref$host,
                    _ref$port = _ref.port,
                    port = void 0 === _ref$port ? 8097 : _ref$port,
                    websocket = _ref.websocket,
                    _ref$resolveRNStyle = _ref.resolveRNStyle,
                    resolveRNStyle = void 0 === _ref$resolveRNStyle ? null : _ref$resolveRNStyle,
                    _ref$isAppActive = _ref.isAppActive,
                    isAppActive = void 0 === _ref$isAppActive ? function () {
                    return !0;
                } : _ref$isAppActive;

                if (!isAppActive()) return void scheduleRetry();
                var messageListeners = [],
                    closeListeners = [],
                    uri = "ws://" + host + ":" + port,
                    ws = websocket ? websocket : new window.WebSocket(uri);
                ws.onclose = handleClose, ws.onerror = handleClose, ws.onmessage = handleMessage, ws.onopen = function () {
                    var wall = {
                        listen: function listen(fn) {
                            messageListeners.push(fn);
                        },
                        onClose: function onClose(fn) {
                            closeListeners.push(fn);
                        },
                        send: function send(data) {
                            ws.send(JSON.stringify(data));
                        }
                    };
                    setupBackend(wall, resolveRNStyle);
                };
                var hasClosed = !1;
            }

            function setupBackend(wall, resolveRNStyle) {
                wall.onClose(function () {
                    agent && agent.emit("shutdown"), window.__REACT_DEVTOOLS_GLOBAL_HOOK__.emit("shutdown"), bridge = null, agent = null, console.log("closing devtools");
                });
                var bridge = new Bridge(wall),
                    agent = new Agent(window, {
                    rnStyle: !!resolveRNStyle,
                    rnStyleMeasure: !!resolveRNStyle
                });
                agent.addBridge(bridge), resolveRNStyle && setupRNStyle(bridge, agent, resolveRNStyle), setupRelay(bridge, agent, window.__REACT_DEVTOOLS_GLOBAL_HOOK__);

                var _connectTimeout = setTimeout(function () {
                    console.warn("react-devtools agent got no connection");
                }, 2e4);

                agent.once("connected", function () {
                    agent && (inject(window.__REACT_DEVTOOLS_GLOBAL_HOOK__, agent), clearTimeout(_connectTimeout));
                });
            }

            var Agent = __webpack_require__(1),
                Bridge = __webpack_require__(6),
                installGlobalHook = __webpack_require__(31),
                installRelayHook = __webpack_require__(32),
                inject = __webpack_require__(33),
                setupRNStyle = __webpack_require__(45),
                setupRelay = __webpack_require__(47);

            installGlobalHook(window), installRelayHook(window), window.document && window.__REACT_DEVTOOLS_GLOBAL_HOOK__.on("react-devtools", function (agent) {
                var setupHighlighter = __webpack_require__(48);

                setupHighlighter(agent);
            }), module.exports = {
                connectToDevTools: connectToDevTools
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }

            function _possibleConstructorReturn(self, call) {
                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }

            function _inherits(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }

            var _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
                return typeof obj;
            } : function (obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
            },
                _createClass = function () {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }

                return function (Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
                };
            }(),
                _require = __webpack_require__(2),
                EventEmitter = _require.EventEmitter,
                assign = __webpack_require__(3),
                guid = __webpack_require__(4),
                getIn = __webpack_require__(5),
                Agent = function (_EventEmitter) {
                function Agent(global, capabilities) {
                    _classCallCheck(this, Agent);

                    var _this = _possibleConstructorReturn(this, (Agent.__proto__ || Object.getPrototypeOf(Agent)).call(this));

                    _this.global = global, _this.internalInstancesById = new Map(), _this.idsByInternalInstances = new WeakMap(), _this.renderers = new Map(), _this.elementData = new Map(), _this.roots = new Set(), _this.reactInternals = {};
                    var lastSelected;
                    _this.on("selected", function (id) {
                        var data = _this.elementData.get(id);

                        data && data.publicInstance && _this.global.$r === lastSelected && (_this.global.$r = data.publicInstance, lastSelected = data.publicInstance);
                    }), _this._prevSelected = null, _this._scrollUpdate = !1;
                    var isReactDOM = window.document && "function" == typeof window.document.createElement;
                    return _this.capabilities = assign({
                        scroll: isReactDOM && "function" == typeof window.document.body.scrollIntoView,
                        dom: isReactDOM,
                        editTextContent: !1
                    }, capabilities), isReactDOM && (_this._updateScroll = _this._updateScroll.bind(_this), window.addEventListener("scroll", _this._onScroll.bind(_this), !0), window.addEventListener("click", _this._onClick.bind(_this), !0), window.addEventListener("mouseover", _this._onMouseOver.bind(_this), !0), window.addEventListener("resize", _this._onResize.bind(_this), !0)), _this;
                }

                return _inherits(Agent, _EventEmitter), _createClass(Agent, [{
                    key: "sub",
                    value: function value(ev, fn) {
                        var _this2 = this;

                        return this.on(ev, fn), function () {
                            _this2.removeListener(ev, fn);
                        };
                    }
                }, {
                    key: "setReactInternals",
                    value: function value(renderer, reactInternals) {
                        this.reactInternals[renderer] = reactInternals;
                    }
                }, {
                    key: "addBridge",
                    value: function value(bridge) {
                        var _this3 = this;

                        bridge.on("requestCapabilities", function () {
                            bridge.send("capabilities", _this3.capabilities), _this3.emit("connected");
                        }), bridge.on("setState", this._setState.bind(this)), bridge.on("setProps", this._setProps.bind(this)), bridge.on("setContext", this._setContext.bind(this)), bridge.on("makeGlobal", this._makeGlobal.bind(this)), bridge.on("highlight", function (id) {
                            return _this3.highlight(id);
                        }), bridge.on("highlightMany", function (id) {
                            return _this3.highlightMany(id);
                        }), bridge.on("hideHighlight", function () {
                            return _this3.emit("hideHighlight");
                        }), bridge.on("startInspecting", function () {
                            return _this3.emit("startInspecting");
                        }), bridge.on("stopInspecting", function () {
                            return _this3.emit("stopInspecting");
                        }), bridge.on("selected", function (id) {
                            return _this3.emit("selected", id);
                        }), bridge.on("setInspectEnabled", function (enabled) {
                            _this3._inspectEnabled = enabled, _this3.emit("stopInspecting");
                        }), bridge.on("shutdown", function () {
                            return _this3.emit("shutdown");
                        }), bridge.on("changeTextContent", function (_ref) {
                            var id = _ref.id,
                                text = _ref.text,
                                node = _this3.getNodeForID(id);

                            node && (node.textContent = text);
                        }), bridge.on("putSelectedNode", function (id) {
                            window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$node = _this3.getNodeForID(id);
                        }), bridge.on("putSelectedInstance", function (id) {
                            var node = _this3.elementData.get(id);

                            node ? window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$type = node.type : window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$type = null, node && node.publicInstance ? window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$inst = node.publicInstance : window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$inst = null;
                        }), bridge.on("checkSelection", function () {
                            var newSelected = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;

                            if (newSelected !== _this3._prevSelected) {
                                _this3._prevSelected = newSelected;
                                var sentSelected = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$node;
                                newSelected !== sentSelected && _this3.selectFromDOMNode(newSelected, !0);
                            }
                        }), bridge.on("scrollToNode", function (id) {
                            return _this3.scrollToNode(id);
                        }), bridge.on("traceupdatesstatechange", function (value) {
                            return _this3.emit("traceupdatesstatechange", value);
                        }), bridge.on("colorizerchange", function (value) {
                            return _this3.emit("colorizerchange", value);
                        }), this.on("root", function (id) {
                            return bridge.send("root", id);
                        }), this.on("mount", function (data) {
                            return bridge.send("mount", data);
                        }), this.on("update", function (data) {
                            return bridge.send("update", data);
                        }), this.on("unmount", function (id) {
                            bridge.send("unmount", id), bridge.forget(id);
                        }), this.on("setSelection", function (data) {
                            return bridge.send("select", data);
                        }), this.on("setInspectEnabled", function (data) {
                            return bridge.send("setInspectEnabled", data);
                        });
                    }
                }, {
                    key: "scrollToNode",
                    value: function value(id) {
                        var node = this.getNodeForID(id);
                        if (!node) return void console.warn("unable to get the node for scrolling");
                        var domElement = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
                        return domElement ? ("function" == typeof domElement.scrollIntoViewIfNeeded ? domElement.scrollIntoViewIfNeeded() : "function" == typeof domElement.scrollIntoView && domElement.scrollIntoView(), void this.highlight(id)) : void console.warn("unable to get the domElement for scrolling");
                    }
                }, {
                    key: "highlight",
                    value: function value(id) {
                        var data = this.elementData.get(id),
                            node = this.getNodeForID(id);
                        data && node && this.emit("highlight", {
                            node: node,
                            name: data.name,
                            props: data.props
                        });
                    }
                }, {
                    key: "highlightMany",
                    value: function value(ids) {
                        var _this4 = this,
                            nodes = [];

                        ids.forEach(function (id) {
                            var node = _this4.getNodeForID(id);

                            node && nodes.push(node);
                        }), nodes.length && this.emit("highlightMany", nodes);
                    }
                }, {
                    key: "getNodeForID",
                    value: function value(id) {
                        var component = this.internalInstancesById.get(id);
                        if (!component) return null;
                        var renderer = this.renderers.get(id);
                        return renderer && this.reactInternals[renderer].getNativeFromReactElement ? this.reactInternals[renderer].getNativeFromReactElement(component) : null;
                    }
                }, {
                    key: "selectFromDOMNode",
                    value: function value(node, quiet) {
                        var offsetFromLeaf = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            id = this.getIDForNode(node);
                        id && this.emit("setSelection", {
                            id: id,
                            quiet: quiet,
                            offsetFromLeaf: offsetFromLeaf
                        });
                    }
                }, {
                    key: "selectFromReactInstance",
                    value: function value(instance, quiet) {
                        var id = this.getId(instance);
                        return id ? void this.emit("setSelection", {
                            id: id,
                            quiet: quiet
                        }) : void console.log("no instance id", instance);
                    }
                }, {
                    key: "getIDForNode",
                    value: function value(node) {
                        if (!this.reactInternals) return null;
                        var component;

                        for (var renderer in this.reactInternals) {
                            try {
                                component = this.reactInternals[renderer].getReactElementFromNative(node);
                            } catch (e) {}

                            if (component) return this.getId(component);
                        }

                        return null;
                    }
                }, {
                    key: "_setProps",
                    value: function value(_ref2) {
                        var id = _ref2.id,
                            path = _ref2.path,
                            value = _ref2.value,
                            data = this.elementData.get(id);
                        data && data.updater && data.updater.setInProps ? data.updater.setInProps(path, value) : console.warn("trying to set props on a component that doesn't support it");
                    }
                }, {
                    key: "_setState",
                    value: function value(_ref3) {
                        var id = _ref3.id,
                            path = _ref3.path,
                            value = _ref3.value,
                            data = this.elementData.get(id);
                        data && data.updater && data.updater.setInState ? data.updater.setInState(path, value) : console.warn("trying to set state on a component that doesn't support it");
                    }
                }, {
                    key: "_setContext",
                    value: function value(_ref4) {
                        var id = _ref4.id,
                            path = _ref4.path,
                            value = _ref4.value,
                            data = this.elementData.get(id);
                        data && data.updater && data.updater.setInContext ? data.updater.setInContext(path, value) : console.warn("trying to set context on a component that doesn't support it");
                    }
                }, {
                    key: "_makeGlobal",
                    value: function value(_ref5) {
                        var id = _ref5.id,
                            path = _ref5.path,
                            data = this.elementData.get(id);

                        if (data) {
                            var value;
                            value = "instance" === path ? data.publicInstance : getIn(data, path), this.global.$tmp = value, console.log("$tmp =", value);
                        }
                    }
                }, {
                    key: "getId",
                    value: function value(internalInstance) {
                        return "object" === ("undefined" == typeof internalInstance ? "undefined" : _typeof(internalInstance)) && internalInstance ? (this.idsByInternalInstances.has(internalInstance) || (this.idsByInternalInstances.set(internalInstance, guid()), this.internalInstancesById.set(this.idsByInternalInstances.get(internalInstance), internalInstance)), this.idsByInternalInstances.get(internalInstance)) : internalInstance;
                    }
                }, {
                    key: "addRoot",
                    value: function value(renderer, internalInstance) {
                        var id = this.getId(internalInstance);
                        this.roots.add(id), this.emit("root", id);
                    }
                }, {
                    key: "onMounted",
                    value: function value(renderer, component, data) {
                        var _this5 = this,
                            id = this.getId(component);

                        this.renderers.set(id, renderer), this.elementData.set(id, data);
                        var send = assign({}, data);
                        send.children && send.children.map && (send.children = send.children.map(function (c) {
                            return _this5.getId(c);
                        })), send.id = id, send.canUpdate = send.updater && !!send.updater.forceUpdate, delete send.type, delete send.updater, this.emit("mount", send);
                    }
                }, {
                    key: "onUpdated",
                    value: function value(component, data) {
                        var _this6 = this,
                            id = this.getId(component);

                        this.elementData.set(id, data);
                        var send = assign({}, data);
                        send.children && send.children.map && (send.children = send.children.map(function (c) {
                            return _this6.getId(c);
                        })), send.id = id, send.canUpdate = send.updater && !!send.updater.forceUpdate, delete send.type, delete send.updater, this.emit("update", send);
                    }
                }, {
                    key: "onUnmounted",
                    value: function value(component) {
                        var id = this.getId(component);
                        this.elementData["delete"](id), this.roots["delete"](id), this.renderers["delete"](id), this.emit("unmount", id), this.idsByInternalInstances["delete"](component);
                    }
                }, {
                    key: "_onScroll",
                    value: function value() {
                        this._scrollUpdate || (this._scrollUpdate = !0, window.requestAnimationFrame(this._updateScroll));
                    }
                }, {
                    key: "_updateScroll",
                    value: function value() {
                        this.emit("refreshMultiOverlay"), this.emit("stopInspecting"), this._scrollUpdate = !1;
                    }
                }, {
                    key: "_onClick",
                    value: function value(event) {
                        if (this._inspectEnabled) {
                            var id = this.getIDForNode(event.target);
                            id && (event.stopPropagation(), event.preventDefault(), this.emit("setSelection", {
                                id: id
                            }), this.emit("setInspectEnabled", !1));
                        }
                    }
                }, {
                    key: "_onMouseOver",
                    value: function value(event) {
                        if (this._inspectEnabled) {
                            var id = this.getIDForNode(event.target);
                            if (!id) return;
                            this.highlight(id);
                        }
                    }
                }, {
                    key: "_onResize",
                    value: function value(event) {
                        this.emit("stopInspecting");
                    }
                }]), Agent;
            }(EventEmitter);

            module.exports = Agent;
        }, function (module, exports) {
            function EventEmitter() {
                this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
            }

            function isFunction(arg) {
                return "function" == typeof arg;
            }

            function isNumber(arg) {
                return "number" == typeof arg;
            }

            function isObject(arg) {
                return "object" == typeof arg && null !== arg;
            }

            function isUndefined(arg) {
                return void 0 === arg;
            }

            module.exports = EventEmitter, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, EventEmitter.prototype._maxListeners = void 0, EventEmitter.defaultMaxListeners = 10, EventEmitter.prototype.setMaxListeners = function (n) {
                if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
                return this._maxListeners = n, this;
            }, EventEmitter.prototype.emit = function (type) {
                var er, handler, len, args, i, listeners;

                if (this._events || (this._events = {}), "error" === type && (!this._events.error || isObject(this._events.error) && !this._events.error.length)) {
                    if (er = arguments[1], er instanceof Error) throw er;
                    var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
                    throw err.context = er, err;
                }

                if (handler = this._events[type], isUndefined(handler)) return !1;
                if (isFunction(handler)) switch (arguments.length) {
                    case 1:
                        handler.call(this);
                        break;

                    case 2:
                        handler.call(this, arguments[1]);
                        break;

                    case 3:
                        handler.call(this, arguments[1], arguments[2]);
                        break;

                    default:
                        args = Array.prototype.slice.call(arguments, 1), handler.apply(this, args);
                } else if (isObject(handler)) for (args = Array.prototype.slice.call(arguments, 1), listeners = handler.slice(), len = listeners.length, i = 0; i < len; i++) {
                    listeners[i].apply(this, args);
                }
                return !0;
            }, EventEmitter.prototype.addListener = function (type, listener) {
                var m;
                if (!isFunction(listener)) throw TypeError("listener must be a function");
                return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener), this._events[type] ? isObject(this._events[type]) ? this._events[type].push(listener) : this._events[type] = [this._events[type], listener] : this._events[type] = listener, isObject(this._events[type]) && !this._events[type].warned && (m = isUndefined(this._maxListeners) ? EventEmitter.defaultMaxListeners : this._maxListeners, m && m > 0 && this._events[type].length > m && (this._events[type].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type].length), "function" == typeof console.trace && console.trace())), this;
            }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.once = function (type, listener) {
                function g() {
                    this.removeListener(type, g), fired || (fired = !0, listener.apply(this, arguments));
                }

                if (!isFunction(listener)) throw TypeError("listener must be a function");
                var fired = !1;
                return g.listener = listener, this.on(type, g), this;
            }, EventEmitter.prototype.removeListener = function (type, listener) {
                var list, position, length, i;
                if (!isFunction(listener)) throw TypeError("listener must be a function");
                if (!this._events || !this._events[type]) return this;
                if (list = this._events[type], length = list.length, position = -1, list === listener || isFunction(list.listener) && list.listener === listener) delete this._events[type], this._events.removeListener && this.emit("removeListener", type, listener);else if (isObject(list)) {
                    for (i = length; i-- > 0;) {
                        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                            position = i;
                            break;
                        }
                    }

                    if (position < 0) return this;
                    1 === list.length ? (list.length = 0, delete this._events[type]) : list.splice(position, 1), this._events.removeListener && this.emit("removeListener", type, listener);
                }
                return this;
            }, EventEmitter.prototype.removeAllListeners = function (type) {
                var key, listeners;
                if (!this._events) return this;
                if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[type] && delete this._events[type], this;

                if (0 === arguments.length) {
                    for (key in this._events) {
                        "removeListener" !== key && this.removeAllListeners(key);
                    }

                    return this.removeAllListeners("removeListener"), this._events = {}, this;
                }

                if (listeners = this._events[type], isFunction(listeners)) this.removeListener(type, listeners);else if (listeners) for (; listeners.length;) {
                    this.removeListener(type, listeners[listeners.length - 1]);
                }
                return delete this._events[type], this;
            }, EventEmitter.prototype.listeners = function (type) {
                var ret;
                return ret = this._events && this._events[type] ? isFunction(this._events[type]) ? [this._events[type]] : this._events[type].slice() : [];
            }, EventEmitter.prototype.listenerCount = function (type) {
                if (this._events) {
                    var evlistener = this._events[type];
                    if (isFunction(evlistener)) return 1;
                    if (evlistener) return evlistener.length;
                }

                return 0;
            }, EventEmitter.listenerCount = function (emitter, type) {
                return emitter.listenerCount(type);
            };
        }, function (module, exports) {
            "use strict";

            function toObject(val) {
                if (null === val || void 0 === val) throw new TypeError("Object.assign cannot be called with null or undefined");
                return Object(val);
            }

            var hasOwnProperty = Object.prototype.hasOwnProperty,
                propIsEnumerable = Object.prototype.propertyIsEnumerable;

            module.exports = Object.assign || function (target, source) {
                for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
                    from = Object(arguments[s]);

                    for (var key in from) {
                        hasOwnProperty.call(from, key) && (to[key] = from[key]);
                    }

                    if (Object.getOwnPropertySymbols) {
                        symbols = Object.getOwnPropertySymbols(from);

                        for (var i = 0; i < symbols.length; i++) {
                            propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
                        }
                    }
                }

                return to;
            };
        }, function (module, exports) {
            "use strict";

            function guid() {
                return "g" + Math.random().toString(16).substr(2);
            }

            module.exports = guid;
        }, function (module, exports) {
            "use strict";

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                        arr2[i] = arr[i];
                    }

                    return arr2;
                }

                return Array.from(arr);
            }

            function getIn(base, path) {
                return path.reduce(function (obj, attr) {
                    if (obj) {
                        if (obj.hasOwnProperty(attr)) return obj[attr];
                        if ("function" == typeof obj[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]) return [].concat(_toConsumableArray(obj))[attr];
                    }

                    return null;
                }, base);
            }

            module.exports = getIn;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                        arr2[i] = arr[i];
                    }

                    return arr2;
                }

                return Array.from(arr);
            }

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }

            function getWindowFunction(name, polyfill) {
                return String(window[name]).indexOf("[native code]") === -1 ? polyfill : window[name];
            }

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                    }
                }

                return target;
            },
                _createClass = function () {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }

                return function (Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
                };
            }(),
                consts = __webpack_require__(7),
                hydrate = __webpack_require__(26),
                dehydrate = __webpack_require__(27),
                getIn = __webpack_require__(5),
                performanceNow = __webpack_require__(28),
                lastRunTimeMS = 5,
                cancelIdleCallback = getWindowFunction("cancelIdleCallback", clearTimeout),
                requestIdleCallback = getWindowFunction("requestIdleCallback", function (cb, options) {
                var delayMS = 3e3 * lastRunTimeMS;
                return delayMS > 500 && (delayMS = 500), setTimeout(function () {
                    var startTime = performanceNow();
                    cb({
                        didTimeout: !1,
                        timeRemaining: function timeRemaining() {
                            return 1 / 0;
                        }
                    });
                    var endTime = performanceNow();
                    lastRunTimeMS = (endTime - startTime) / 1e3;
                }, delayMS);
            }),
                Bridge = function () {
                function Bridge(wall) {
                    _classCallCheck(this, Bridge), this._cbs = new Map(), this._inspectables = new Map(), this._cid = 0, this._listeners = {}, this._buffer = [], this._flushHandle = null, this._callers = {}, this._paused = !1, this._wall = wall, wall.listen(this._handleMessage.bind(this));
                }

                return _createClass(Bridge, [{
                    key: "inspect",
                    value: function value(id, path, cb) {
                        var _cid = this._cid++;

                        this._cbs.set(_cid, function (data, cleaned, proto, protoclean) {
                            cleaned.length && hydrate(data, cleaned), proto && protoclean.length && hydrate(proto, protoclean), proto && (data[consts.proto] = proto), cb(data);
                        }), this._wall.send({
                            type: "inspect",
                            callback: _cid,
                            path: path,
                            id: id
                        });
                    }
                }, {
                    key: "call",
                    value: function value(name, args, cb) {
                        var _cid = this._cid++;

                        this._cbs.set(_cid, cb), this._wall.send({
                            type: "call",
                            callback: _cid,
                            args: args,
                            name: name
                        });
                    }
                }, {
                    key: "onCall",
                    value: function value(name, handler) {
                        if (this._callers[name]) throw new Error("only one call handler per call name allowed");
                        this._callers[name] = handler;
                    }
                }, {
                    key: "pause",
                    value: function value() {
                        this._wall.send({
                            type: "pause"
                        });
                    }
                }, {
                    key: "resume",
                    value: function value() {
                        this._wall.send({
                            type: "resume"
                        });
                    }
                }, {
                    key: "setInspectable",
                    value: function value(id, data) {
                        var prev = this._inspectables.get(id);

                        return prev ? void this._inspectables.set(id, _extends({}, prev, data)) : void this._inspectables.set(id, data);
                    }
                }, {
                    key: "send",
                    value: function value(evt, data) {
                        this._buffer.push({
                            evt: evt,
                            data: data
                        }), this.scheduleFlush();
                    }
                }, {
                    key: "scheduleFlush",
                    value: function value() {
                        if (!this._flushHandle && this._buffer.length) {
                            var timeout = this._paused ? 5e3 : 500;
                            this._flushHandle = requestIdleCallback(this.flushBufferWhileIdle.bind(this), {
                                timeout: timeout
                            });
                        }
                    }
                }, {
                    key: "cancelFlush",
                    value: function value() {
                        this._flushHandle && (cancelIdleCallback(this._flushHandle), this._flushHandle = null);
                    }
                }, {
                    key: "flushBufferWhileIdle",
                    value: function value(deadline) {
                        this._flushHandle = null;

                        for (var chunkCount = this._paused ? 20 : 10, chunkSize = Math.round(this._buffer.length / chunkCount), minChunkSize = this._paused ? 50 : 100; this._buffer.length && (deadline.timeRemaining() > 0 || deadline.didTimeout);) {
                            var take = Math.min(this._buffer.length, Math.max(minChunkSize, chunkSize)),
                                currentBuffer = this._buffer.splice(0, take);

                            this.flushBufferSlice(currentBuffer);
                        }

                        this._buffer.length && this.scheduleFlush();
                    }
                }, {
                    key: "flushBufferSlice",
                    value: function value(bufferSlice) {
                        var _this = this,
                            events = bufferSlice.map(function (_ref) {
                            var evt = _ref.evt,
                                data = _ref.data,
                                cleaned = [],
                                san = dehydrate(data, cleaned);
                            return cleaned.length && _this.setInspectable(data.id, data), {
                                type: "event",
                                evt: evt,
                                data: san,
                                cleaned: cleaned
                            };
                        });

                        this._wall.send({
                            type: "many-events",
                            events: events
                        });
                    }
                }, {
                    key: "forget",
                    value: function value(id) {
                        this._inspectables["delete"](id);
                    }
                }, {
                    key: "on",
                    value: function value(evt, fn) {
                        this._listeners[evt] ? this._listeners[evt].push(fn) : this._listeners[evt] = [fn];
                    }
                }, {
                    key: "off",
                    value: function value(evt, fn) {
                        if (this._listeners[evt]) {
                            var ix = this._listeners[evt].indexOf(fn);

                            ix !== -1 && this._listeners[evt].splice(ix, 1);
                        }
                    }
                }, {
                    key: "once",
                    value: function value(evt, fn) {
                        var self = this,
                            listener = function listener() {
                            fn.apply(this, arguments), self.off(evt, listener);
                        };

                        this.on(evt, listener);
                    }
                }, {
                    key: "_handleMessage",
                    value: function value(payload) {
                        var _this2 = this;

                        if ("resume" === payload.type) return this._paused = !1, void this.scheduleFlush();
                        if ("pause" === payload.type) return this._paused = !0, void this.cancelFlush();

                        if ("callback" === payload.type) {
                            var callback = this._cbs.get(payload.id);

                            return void (callback && (callback.apply(void 0, _toConsumableArray(payload.args)), this._cbs["delete"](payload.id)));
                        }

                        if ("call" === payload.type) return void this._handleCall(payload.name, payload.args, payload.callback);
                        if ("inspect" === payload.type) return void this._inspectResponse(payload.id, payload.path, payload.callback);

                        if ("event" === payload.type) {
                            payload.cleaned && hydrate(payload.data, payload.cleaned);
                            var fns = this._listeners[payload.evt],
                                data = payload.data;
                            fns && fns.forEach(function (fn) {
                                return fn(data);
                            });
                        }

                        "many-events" === payload.type && payload.events.forEach(function (event) {
                            event.cleaned && hydrate(event.data, event.cleaned);
                            var handlers = _this2._listeners[event.evt];
                            handlers && handlers.forEach(function (fn) {
                                return fn(event.data);
                            });
                        });
                    }
                }, {
                    key: "_handleCall",
                    value: function value(name, args, callback) {
                        if (!this._callers[name]) return void console.warn('unknown call: "' + name + '"');
                        args = Array.isArray(args) ? args : [args];
                        var result;

                        try {
                            result = this._callers[name].apply(null, args);
                        } catch (e) {
                            return void console.error("Failed to call", e);
                        }

                        this._wall.send({
                            type: "callback",
                            id: callback,
                            args: [result]
                        });
                    }
                }, {
                    key: "_inspectResponse",
                    value: function value(id, path, callback) {
                        var inspectable = this._inspectables.get(id),
                            result = {},
                            cleaned = [],
                            proto = null,
                            protoclean = [];

                        if (inspectable) {
                            var val = getIn(inspectable, path),
                                protod = !1,
                                isFn = "function" == typeof val;

                            if (val && "function" == typeof val[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]) {
                                var iterVal = Object.create({}),
                                    count = 0,
                                    _iteratorNormalCompletion = !0,
                                    _didIteratorError = !1,
                                    _iteratorError = void 0;

                                try {
                                    for (var _step, _iterator = val[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                                        var entry = _step.value;
                                        if (count > 100) break;
                                        iterVal[count] = entry, count++;
                                    }
                                } catch (err) {
                                    _didIteratorError = !0, _iteratorError = err;
                                } finally {
                                    try {
                                        !_iteratorNormalCompletion && _iterator["return"] && _iterator["return"]();
                                    } finally {
                                        if (_didIteratorError) throw _iteratorError;
                                    }
                                }

                                val = iterVal;
                            }

                            if (Object.getOwnPropertyNames(val).forEach(function (name) {
                                "__proto__" === name && (protod = !0), (!isFn || "arguments" !== name && "callee" !== name && "caller" !== name) && (result[name] = dehydrate(val[name], cleaned, [name]));
                            }), !protod && val.__proto__ && "Object" !== val.constructor.name) {
                                var newProto = {},
                                    pIsFn = "function" == typeof val.__proto__;
                                Object.getOwnPropertyNames(val.__proto__).forEach(function (name) {
                                    (!pIsFn || "arguments" !== name && "callee" !== name && "caller" !== name) && (newProto[name] = dehydrate(val.__proto__[name], protoclean, [name]));
                                }), proto = newProto;
                            }
                        }

                        this._wall.send({
                            type: "callback",
                            id: callback,
                            args: [result, cleaned, proto, protoclean]
                        });
                    }
                }]), Bridge;
            }();

            module.exports = Bridge;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var _Symbol = __webpack_require__(8);

            module.exports = {
                name: _Symbol("name"),
                type: _Symbol("type"),
                inspected: _Symbol("inspected"),
                meta: _Symbol("meta"),
                proto: _Symbol("proto")
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            module.exports = __webpack_require__(9)() ? Symbol : __webpack_require__(10);
        }, function (module, exports) {
            "use strict";

            module.exports = function () {
                var symbol;
                if ("function" != typeof Symbol) return !1;
                symbol = Symbol("test symbol");

                try {
                    String(symbol);
                } catch (e) {
                    return !1;
                }

                return "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") || "object" == typeof (typeof Symbol === "function" ? Symbol.isConcatSpreadable : "@@isConcatSpreadable") && "object" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") && "object" == typeof (typeof Symbol === "function" ? Symbol.toPrimitive : "@@toPrimitive") && "object" == typeof (typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag") && "object" == typeof (typeof Symbol === "function" ? Symbol.unscopables : "@@unscopables");
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var NativeSymbol,
                SymbolPolyfill,
                _HiddenSymbol,
                d = __webpack_require__(11),
                validateSymbol = __webpack_require__(24),
                create = Object.create,
                defineProperties = Object.defineProperties,
                defineProperty = Object.defineProperty,
                objPrototype = Object.prototype,
                globalSymbols = create(null);

            "function" == typeof Symbol && (NativeSymbol = Symbol);

            var generateName = function () {
                var created = create(null);
                return function (desc) {
                    for (var name, ie11BugWorkaround, postfix = 0; created[desc + (postfix || "")];) {
                        ++postfix;
                    }

                    return desc += postfix || "", created[desc] = !0, name = "@@" + desc, defineProperty(objPrototype, name, d.gs(null, function (value) {
                        ie11BugWorkaround || (ie11BugWorkaround = !0, defineProperty(this, name, d(value)), ie11BugWorkaround = !1);
                    })), name;
                };
            }();

            _HiddenSymbol = function HiddenSymbol(description) {
                if (this instanceof _HiddenSymbol) throw new TypeError("TypeError: Symbol is not a constructor");
                return SymbolPolyfill(description);
            }, module.exports = SymbolPolyfill = function Symbol(description) {
                var symbol;
                if (this instanceof Symbol) throw new TypeError("TypeError: Symbol is not a constructor");
                return symbol = create(_HiddenSymbol.prototype), description = void 0 === description ? "" : String(description), defineProperties(symbol, {
                    __description__: d("", description),
                    __name__: d("", generateName(description))
                });
            }, defineProperties(SymbolPolyfill, {
                "for": d(function (key) {
                    return globalSymbols[key] ? globalSymbols[key] : globalSymbols[key] = SymbolPolyfill(String(key));
                }),
                keyFor: d(function (s) {
                    var key;
                    validateSymbol(s);

                    for (key in globalSymbols) {
                        if (globalSymbols[key] === s) return key;
                    }
                }),
                hasInstance: d("", NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")),
                isConcatSpreadable: d("", NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")),
                iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
                match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
                replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
                search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
                species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
                split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
                toPrimitive: d("", NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")),
                toStringTag: d("", NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")),
                unscopables: d("", NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables"))
            }), defineProperties(_HiddenSymbol.prototype, {
                constructor: d(SymbolPolyfill),
                toString: d("", function () {
                    return this.__name__;
                })
            }), defineProperties(SymbolPolyfill.prototype, {
                toString: d(function () {
                    return "Symbol (" + validateSymbol(this).__description__ + ")";
                }),
                valueOf: d(function () {
                    return validateSymbol(this);
                })
            }), defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d("", function () {
                return validateSymbol(this);
            })), defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol")), defineProperty(_HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])), defineProperty(_HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var d,
                assign = __webpack_require__(12),
                normalizeOpts = __webpack_require__(19),
                isCallable = __webpack_require__(20),
                contains = __webpack_require__(21);

            d = module.exports = function (dscr, value) {
                var c, e, w, options, desc;
                return arguments.length < 2 || "string" != typeof dscr ? (options = value, value = dscr, dscr = null) : options = arguments[2], null == dscr ? (c = w = !0, e = !1) : (c = contains.call(dscr, "c"), e = contains.call(dscr, "e"), w = contains.call(dscr, "w")), desc = {
                    value: value,
                    configurable: c,
                    enumerable: e,
                    writable: w
                }, options ? assign(normalizeOpts(options), desc) : desc;
            }, d.gs = function (dscr, get, set) {
                var c, e, options, desc;
                return "string" != typeof dscr ? (options = set, set = get, get = dscr, dscr = null) : options = arguments[3], null == get ? get = void 0 : isCallable(get) ? null == set ? set = void 0 : isCallable(set) || (options = set, set = void 0) : (options = get, get = set = void 0), null == dscr ? (c = !0, e = !1) : (c = contains.call(dscr, "c"), e = contains.call(dscr, "e")), desc = {
                    get: get,
                    set: set,
                    configurable: c,
                    enumerable: e
                }, options ? assign(normalizeOpts(options), desc) : desc;
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            module.exports = __webpack_require__(13)() ? Object.assign : __webpack_require__(14);
        }, function (module, exports) {
            "use strict";

            module.exports = function () {
                var obj,
                    assign = Object.assign;
                return "function" == typeof assign && (obj = {
                    foo: "raz"
                }, assign(obj, {
                    bar: "dwa"
                }, {
                    trzy: "trzy"
                }), obj.foo + obj.bar + obj.trzy === "razdwatrzy");
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var keys = __webpack_require__(15),
                value = __webpack_require__(18),
                max = Math.max;

            module.exports = function (dest, src) {
                var error,
                    i,
                    assign,
                    l = max(arguments.length, 2);

                for (dest = Object(value(dest)), assign = function assign(key) {
                    try {
                        dest[key] = src[key];
                    } catch (e) {
                        error || (error = e);
                    }
                }, i = 1; i < l; ++i) {
                    src = arguments[i], keys(src).forEach(assign);
                }

                if (void 0 !== error) throw error;
                return dest;
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            module.exports = __webpack_require__(16)() ? Object.keys : __webpack_require__(17);
        }, function (module, exports) {
            "use strict";

            module.exports = function () {
                try {
                    return Object.keys("primitive"), !0;
                } catch (e) {
                    return !1;
                }
            };
        }, function (module, exports) {
            "use strict";

            var keys = Object.keys;

            module.exports = function (object) {
                return keys(null == object ? object : Object(object));
            };
        }, function (module, exports) {
            "use strict";

            module.exports = function (value) {
                if (null == value) throw new TypeError("Cannot use null or undefined");
                return value;
            };
        }, function (module, exports) {
            "use strict";

            var forEach = Array.prototype.forEach,
                create = Object.create,
                process = function process(src, obj) {
                var key;

                for (key in src) {
                    obj[key] = src[key];
                }
            };

            module.exports = function (options) {
                var result = create(null);
                return forEach.call(arguments, function (options) {
                    null != options && process(Object(options), result);
                }), result;
            };
        }, function (module, exports) {
            "use strict";

            module.exports = function (obj) {
                return "function" == typeof obj;
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            module.exports = __webpack_require__(22)() ? String.prototype.contains : __webpack_require__(23);
        }, function (module, exports) {
            "use strict";

            var str = "razdwatrzy";

            module.exports = function () {
                return "function" == typeof str.contains && str.contains("dwa") === !0 && str.contains("foo") === !1;
            };
        }, function (module, exports) {
            "use strict";

            var indexOf = String.prototype.indexOf;

            module.exports = function (searchString) {
                return indexOf.call(this, searchString, arguments[1]) > -1;
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var isSymbol = __webpack_require__(25);

            module.exports = function (value) {
                if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
                return value;
            };
        }, function (module, exports) {
            "use strict";

            module.exports = function (x) {
                return x && ("symbol" == typeof x || "Symbol" === x["@@toStringTag"]) || !1;
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function hydrate(data, cleaned) {
                cleaned.forEach(function (path) {
                    var last = path.pop(),
                        obj = path.reduce(function (obj_, attr) {
                        return obj_ ? obj_[attr] : null;
                    }, data);

                    if (obj && obj[last]) {
                        var replace = {};
                        replace[consts.name] = obj[last].name, replace[consts.type] = obj[last].type, replace[consts.meta] = obj[last].meta, replace[consts.inspected] = !1, obj[last] = replace;
                    }
                });
            }

            var consts = __webpack_require__(7);

            module.exports = hydrate;
        }, function (module, exports) {
            "use strict";

            function getPropType(data) {
                if (!data) return null;
                var type = "undefined" == typeof data ? "undefined" : _typeof(data);

                if ("object" === type) {
                    if (data._reactFragment) return "react_fragment";
                    if (Array.isArray(data)) return "array";
                    if (ArrayBuffer.isView(data)) return data instanceof DataView ? "data_view" : "typed_array";
                    if (data instanceof ArrayBuffer) return "array_buffer";
                    if ("function" == typeof data[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]) return "iterator";
                    if ("[object Date]" === Object.prototype.toString.call(data)) return "date";
                }

                return type;
            }

            function createDehydrated(type, data, cleaned, path) {
                var meta = {};
                return "array" !== type && "typed_array" !== type || (meta.length = data.length), "iterator" !== type && "typed_array" !== type || (meta.readOnly = !0), cleaned.push(path), {
                    type: type,
                    meta: meta,
                    name: data.constructor && "Object" !== data.constructor.name ? data.constructor.name : ""
                };
            }

            function dehydrate(data, cleaned) {
                var path = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
                    level = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                    type = getPropType(data);

                switch (type) {
                    case "function":
                        return cleaned.push(path), {
                            name: data.name,
                            type: "function"
                        };

                    case "string":
                        return data.length <= 500 ? data : data.slice(0, 500) + "...";

                    case "symbol":
                        return cleaned.push(path), {
                            type: "symbol",
                            name: data.toString()
                        };

                    case "react_fragment":
                        return "A React Fragment";

                    case "array_buffer":
                    case "data_view":
                        return cleaned.push(path), {
                            type: type,
                            name: "data_view" === type ? "DataView" : "ArrayBuffer",
                            meta: {
                                length: data.byteLength,
                                uninspectable: !0
                            }
                        };

                    case "array":
                        return level > 2 ? createDehydrated(type, data, cleaned, path) : data.map(function (item, i) {
                            return dehydrate(item, cleaned, path.concat([i]), level + 1);
                        });

                    case "typed_array":
                    case "iterator":
                        return createDehydrated(type, data, cleaned, path);

                    case "date":
                        return cleaned.push(path), {
                            name: data.toString(),
                            type: "date",
                            meta: {
                                uninspectable: !0
                            }
                        };

                    case "object":
                        if (level > 2 || data.constructor && "function" == typeof data.constructor && "Object" !== data.constructor.name) return createDehydrated(type, data, cleaned, path);
                        var res = {};

                        for (var name in data) {
                            res[name] = dehydrate(data[name], cleaned, path.concat([name]), level + 1);
                        }

                        return res;

                    default:
                        return data;
                }
            }

            var _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
                return typeof obj;
            } : function (obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
            };

            module.exports = dehydrate;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var performanceNow,
                performance = __webpack_require__(29);

            performanceNow = performance.now ? function () {
                return performance.now();
            } : function () {
                return Date.now();
            }, module.exports = performanceNow;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var performance,
                ExecutionEnvironment = __webpack_require__(30);

            ExecutionEnvironment.canUseDOM && (performance = window.performance || window.msPerformance || window.webkitPerformance), module.exports = performance || {};
        }, function (module, exports) {
            "use strict";

            var canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement),
                ExecutionEnvironment = {
                canUseDOM: canUseDOM,
                canUseWorkers: "undefined" != typeof Worker,
                canUseEventListeners: canUseDOM && !(!window.addEventListener && !window.attachEvent),
                canUseViewport: canUseDOM && !!window.screen,
                isInWorker: !canUseDOM
            };
            module.exports = ExecutionEnvironment;
        }, function (module, exports) {
            "use strict";

            function installGlobalHook(window) {
                function detectReactBuildType(renderer) {
                    try {
                        if ("string" == typeof renderer.version) return renderer.bundleType > 0 ? "development" : "production";
                        var toString = Function.prototype.toString;

                        if (renderer.Mount && renderer.Mount._renderNewRootComponent) {
                            var renderRootCode = toString.call(renderer.Mount._renderNewRootComponent);
                            return 0 !== renderRootCode.indexOf("function") ? "production" : renderRootCode.indexOf("storedMeasure") !== -1 ? "development" : renderRootCode.indexOf("should be a pure function") !== -1 ? renderRootCode.indexOf("NODE_ENV") !== -1 ? "development" : renderRootCode.indexOf("development") !== -1 ? "development" : renderRootCode.indexOf("true") !== -1 ? "development" : renderRootCode.indexOf("nextElement") !== -1 || renderRootCode.indexOf("nextComponent") !== -1 ? "unminified" : "development" : renderRootCode.indexOf("nextElement") !== -1 || renderRootCode.indexOf("nextComponent") !== -1 ? "unminified" : renderRootCode.indexOf("._registerComponent") !== -1 ? "outdated" : "production";
                        }
                    } catch (err) {}

                    return "production";
                }

                if (!window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
                    var hasDetectedBadDCE = !1,
                        hook = {
                        _renderers: {},
                        helpers: {},
                        checkDCE: function checkDCE(fn) {
                            try {
                                var toString = Function.prototype.toString,
                                    code = toString.call(fn);
                                code.indexOf("^_^") > -1 && (hasDetectedBadDCE = !0, setTimeout(function () {
                                    throw new Error("React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://fb.me/react-perf-use-the-production-build");
                                }));
                            } catch (err) {}
                        },
                        inject: function inject(renderer) {
                            var id = Math.random().toString(16).slice(2);
                            hook._renderers[id] = renderer;
                            var reactBuildType = hasDetectedBadDCE ? "deadcode" : detectReactBuildType(renderer);
                            return hook.emit("renderer", {
                                id: id,
                                renderer: renderer,
                                reactBuildType: reactBuildType
                            }), id;
                        },
                        _listeners: {},
                        sub: function sub(evt, fn) {
                            return hook.on(evt, fn), function () {
                                return hook.off(evt, fn);
                            };
                        },
                        on: function on(evt, fn) {
                            hook._listeners[evt] || (hook._listeners[evt] = []), hook._listeners[evt].push(fn);
                        },
                        off: function off(evt, fn) {
                            if (hook._listeners[evt]) {
                                var ix = hook._listeners[evt].indexOf(fn);

                                ix !== -1 && hook._listeners[evt].splice(ix, 1), hook._listeners[evt].length || (hook._listeners[evt] = null);
                            }
                        },
                        emit: function emit(evt, data) {
                            hook._listeners[evt] && hook._listeners[evt].map(function (fn) {
                                return fn(data);
                            });
                        },
                        supportsFiber: !0,
                        _fiberRoots: {},
                        getFiberRoots: function getFiberRoots(rendererID) {
                            var roots = hook._fiberRoots;
                            return roots[rendererID] || (roots[rendererID] = new Set()), roots[rendererID];
                        },
                        onCommitFiberUnmount: function onCommitFiberUnmount(rendererID, fiber) {
                            hook.helpers[rendererID] && hook.helpers[rendererID].handleCommitFiberUnmount(fiber);
                        },
                        onCommitFiberRoot: function onCommitFiberRoot(rendererID, root) {
                            var mountedRoots = hook.getFiberRoots(rendererID),
                                current = root.current,
                                isKnownRoot = mountedRoots.has(root),
                                isUnmounting = null == current.memoizedState || null == current.memoizedState.element;
                            isKnownRoot || isUnmounting ? isKnownRoot && isUnmounting && mountedRoots["delete"](root) : mountedRoots.add(root), hook.helpers[rendererID] && hook.helpers[rendererID].handleCommitFiberRoot(root);
                        }
                    };
                    Object.defineProperty(window, "__REACT_DEVTOOLS_GLOBAL_HOOK__", {
                        value: hook
                    });
                }
            }

            module.exports = installGlobalHook;
        }, function (module, exports) {
            "use strict";

            function installRelayHook(window) {
                function decorate(obj, attr, fn) {
                    var old = obj[attr];

                    obj[attr] = function () {
                        var res = old.apply(this, arguments);
                        return fn.apply(this, arguments), res;
                    };
                }

                function emit(name, data) {
                    _eventQueue.push({
                        name: name,
                        data: data
                    }), _listener && _listener(name, data);
                }

                function setRequestListener(listener) {
                    if (_listener) throw new Error("Relay Devtools: Called only call setRequestListener once.");
                    return _listener = listener, _eventQueue.forEach(function (_ref) {
                        var name = _ref.name,
                            data = _ref.data;
                        listener(name, data);
                    }), function () {
                        _listener = null;
                    };
                }

                function recordRequest(type, start, request, requestNumber) {
                    var id = Math.random().toString(16).substr(2);
                    request.then(function (response) {
                        emit("relay:success", {
                            id: id,
                            end: performanceNow(),
                            response: response.response
                        });
                    }, function (error) {
                        emit("relay:failure", {
                            id: id,
                            end: performanceNow(),
                            error: error
                        });
                    });

                    for (var textChunks = [], text = request.getQueryString(); text.length > 0;) {
                        textChunks.push(text.substr(0, TEXT_CHUNK_LENGTH)), text = text.substr(TEXT_CHUNK_LENGTH);
                    }

                    return {
                        id: id,
                        name: request.getDebugName(),
                        requestNumber: requestNumber,
                        start: start,
                        text: textChunks,
                        type: type,
                        variables: request.getVariables()
                    };
                }

                function instrumentRelayRequests(relayInternals) {
                    var NetworkLayer = relayInternals.NetworkLayer;
                    decorate(NetworkLayer, "sendMutation", function (mutation) {
                        requestNumber++, emit("relay:pending", [recordRequest("mutation", performanceNow(), mutation, requestNumber)]);
                    }), decorate(NetworkLayer, "sendQueries", function (queries) {
                        requestNumber++;
                        var start = performanceNow();
                        emit("relay:pending", queries.map(function (query) {
                            return recordRequest("query", start, query, requestNumber);
                        }));
                    });
                    var instrumented = {};

                    for (var key in relayInternals) {
                        relayInternals.hasOwnProperty(key) && (instrumented[key] = relayInternals[key]);
                    }

                    return instrumented.setRequestListener = setRequestListener, instrumented;
                }

                var performanceNow,
                    performance = window.performance;
                performanceNow = performance && "function" == typeof performance.now ? function () {
                    return performance.now();
                } : function () {
                    return Date.now();
                };
                var TEXT_CHUNK_LENGTH = 500,
                    hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;

                if (hook) {
                    var _eventQueue = [],
                        _listener = null,
                        requestNumber = 0,
                        _relayInternals = null;
                    Object.defineProperty(hook, "_relayInternals", {
                        configurable: !0,
                        set: function set(relayInternals) {
                            _relayInternals = instrumentRelayRequests(relayInternals);
                        },
                        get: function get() {
                            return _relayInternals;
                        }
                    });
                }
            }

            module.exports = installRelayHook;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var setupBackend = __webpack_require__(34);

            module.exports = function (hook, agent) {
                var subs = [hook.sub("renderer-attached", function (_ref) {
                    var id = _ref.id,
                        helpers = (_ref.renderer, _ref.helpers);
                    agent.setReactInternals(id, helpers), helpers.walkTree(agent.onMounted.bind(agent, id), agent.addRoot.bind(agent, id));
                }), hook.sub("root", function (_ref2) {
                    var renderer = _ref2.renderer,
                        internalInstance = _ref2.internalInstance;
                    return agent.addRoot(renderer, internalInstance);
                }), hook.sub("mount", function (_ref3) {
                    var renderer = _ref3.renderer,
                        internalInstance = _ref3.internalInstance,
                        data = _ref3.data;
                    return agent.onMounted(renderer, internalInstance, data);
                }), hook.sub("update", function (_ref4) {
                    var internalInstance = (_ref4.renderer, _ref4.internalInstance),
                        data = _ref4.data;
                    return agent.onUpdated(internalInstance, data);
                }), hook.sub("unmount", function (_ref5) {
                    var internalInstance = (_ref5.renderer, _ref5.internalInstance);
                    return agent.onUnmounted(internalInstance);
                })],
                    success = setupBackend(hook);
                success && (hook.emit("react-devtools", agent), hook.reactDevtoolsAgent = agent, agent.on("shutdown", function () {
                    subs.forEach(function (fn) {
                        return fn();
                    }), hook.reactDevtoolsAgent = null;
                }));
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var attachRenderer = __webpack_require__(35);

            module.exports = function (hook) {
                var oldReact = window.React && window.React.__internals;
                oldReact && 0 === Object.keys(hook._renderers).length && hook.inject(oldReact);

                for (var rid in hook._renderers) {
                    hook.helpers[rid] = attachRenderer(hook, rid, hook._renderers[rid]), hook.emit("renderer-attached", {
                        id: rid,
                        renderer: hook._renderers[rid],
                        helpers: hook.helpers[rid]
                    });
                }

                hook.on("renderer", function (_ref) {
                    var id = _ref.id,
                        renderer = _ref.renderer;
                    hook.helpers[id] = attachRenderer(hook, id, renderer), hook.emit("renderer-attached", {
                        id: id,
                        renderer: renderer,
                        helpers: hook.helpers[id]
                    });
                });

                var shutdown = function shutdown() {
                    for (var id in hook.helpers) {
                        hook.helpers[id].cleanup();
                    }

                    hook.off("shutdown", shutdown);
                };

                return hook.on("shutdown", shutdown), !0;
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function attachRenderer(hook, rid, renderer) {
                var rootNodeIDMap = new Map(),
                    extras = {},
                    isPre013 = !renderer.Reconciler;
                if ("function" == typeof renderer.findFiberByHostInstance) return attachRendererFiber(hook, rid, renderer);
                renderer.Mount.findNodeHandle && renderer.Mount.nativeTagToRootNodeID ? (extras.getNativeFromReactElement = function (component) {
                    return renderer.Mount.findNodeHandle(component);
                }, extras.getReactElementFromNative = function (nativeTag) {
                    var id = renderer.Mount.nativeTagToRootNodeID(nativeTag);
                    return rootNodeIDMap.get(id);
                }) : renderer.ComponentTree ? (extras.getNativeFromReactElement = function (component) {
                    return renderer.ComponentTree.getNodeFromInstance(component);
                }, extras.getReactElementFromNative = function (node) {
                    return renderer.ComponentTree.getClosestInstanceFromNode(node);
                }) : renderer.Mount.getID && renderer.Mount.getNode ? (extras.getNativeFromReactElement = function (component) {
                    try {
                        return renderer.Mount.getNode(component._rootNodeID);
                    } catch (e) {
                        return;
                    }
                }, extras.getReactElementFromNative = function (node) {
                    for (var id = renderer.Mount.getID(node); node && node.parentNode && !id;) {
                        node = node.parentNode, id = renderer.Mount.getID(node);
                    }

                    return rootNodeIDMap.get(id);
                }) : console.warn("Unknown react version (does not have getID), probably an unshimmed React Native");
                var oldMethods, oldRenderComponent, oldRenderRoot;
                return renderer.Mount._renderNewRootComponent ? oldRenderRoot = decorateResult(renderer.Mount, "_renderNewRootComponent", function (internalInstance) {
                    hook.emit("root", {
                        renderer: rid,
                        internalInstance: internalInstance
                    });
                }) : renderer.Mount.renderComponent && (oldRenderComponent = decorateResult(renderer.Mount, "renderComponent", function (internalInstance) {
                    hook.emit("root", {
                        renderer: rid,
                        internalInstance: internalInstance._reactInternalInstance
                    });
                })), renderer.Component ? (console.error("You are using a version of React with limited support in this version of the devtools.\nPlease upgrade to use at least 0.13, or you can downgrade to use the old version of the devtools:\ninstructions here https://github.com/facebook/react-devtools/tree/devtools-next#how-do-i-use-this-for-react--013"), oldMethods = decorateMany(renderer.Component.Mixin, {
                    mountComponent: function mountComponent() {
                        var _this = this;

                        rootNodeIDMap.set(this._rootNodeID, this), setTimeout(function () {
                            hook.emit("mount", {
                                internalInstance: _this,
                                data: getData012(_this),
                                renderer: rid
                            });
                        }, 0);
                    },
                    updateComponent: function updateComponent() {
                        var _this2 = this;

                        setTimeout(function () {
                            hook.emit("update", {
                                internalInstance: _this2,
                                data: getData012(_this2),
                                renderer: rid
                            });
                        }, 0);
                    },
                    unmountComponent: function unmountComponent() {
                        hook.emit("unmount", {
                            internalInstance: this,
                            renderer: rid
                        }), rootNodeIDMap["delete"](this._rootNodeID, this);
                    }
                })) : renderer.Reconciler && (oldMethods = decorateMany(renderer.Reconciler, {
                    mountComponent: function mountComponent(internalInstance, rootID, transaction, context) {
                        var data = getData(internalInstance);
                        rootNodeIDMap.set(internalInstance._rootNodeID, internalInstance), hook.emit("mount", {
                            internalInstance: internalInstance,
                            data: data,
                            renderer: rid
                        });
                    },
                    performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, nextChild, transaction, context) {
                        hook.emit("update", {
                            internalInstance: internalInstance,
                            data: getData(internalInstance),
                            renderer: rid
                        });
                    },
                    receiveComponent: function receiveComponent(internalInstance, nextChild, transaction, context) {
                        hook.emit("update", {
                            internalInstance: internalInstance,
                            data: getData(internalInstance),
                            renderer: rid
                        });
                    },
                    unmountComponent: function unmountComponent(internalInstance) {
                        hook.emit("unmount", {
                            internalInstance: internalInstance,
                            renderer: rid
                        }), rootNodeIDMap["delete"](internalInstance._rootNodeID, internalInstance);
                    }
                })), extras.walkTree = function (visit, visitRoot) {
                    var onMount = function onMount(component, data) {
                        rootNodeIDMap.set(component._rootNodeID, component), visit(component, data);
                    };

                    walkRoots(renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID, onMount, visitRoot, isPre013);
                }, extras.cleanup = function () {
                    oldMethods && (renderer.Component ? restoreMany(renderer.Component.Mixin, oldMethods) : restoreMany(renderer.Reconciler, oldMethods)), oldRenderRoot && (renderer.Mount._renderNewRootComponent = oldRenderRoot), oldRenderComponent && (renderer.Mount.renderComponent = oldRenderComponent), oldMethods = null, oldRenderRoot = null, oldRenderComponent = null;
                }, extras;
            }

            function walkRoots(roots, onMount, onRoot, isPre013) {
                for (var name in roots) {
                    walkNode(roots[name], onMount, isPre013), onRoot(roots[name]);
                }
            }

            function walkNode(internalInstance, onMount, isPre013) {
                var data = isPre013 ? getData012(internalInstance) : getData(internalInstance);
                data.children && Array.isArray(data.children) && data.children.forEach(function (child) {
                    return walkNode(child, onMount, isPre013);
                }), onMount(internalInstance, data);
            }

            function decorateResult(obj, attr, fn) {
                var old = obj[attr];
                return obj[attr] = function (instance) {
                    var res = old.apply(this, arguments);
                    return fn(res), res;
                }, old;
            }

            function decorate(obj, attr, fn) {
                var old = obj[attr];
                return obj[attr] = function (instance) {
                    var res = old.apply(this, arguments);
                    return fn.apply(this, arguments), res;
                }, old;
            }

            function decorateMany(source, fns) {
                var olds = {};

                for (var name in fns) {
                    olds[name] = decorate(source, name, fns[name]);
                }

                return olds;
            }

            function restoreMany(source, olds) {
                for (var name in olds) {
                    source[name] = olds[name];
                }
            }

            var getData = __webpack_require__(36),
                getData012 = __webpack_require__(41),
                attachRendererFiber = __webpack_require__(42);

            module.exports = attachRenderer;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function getData(internalInstance) {
                var children = null,
                    props = null,
                    state = null,
                    context = null,
                    updater = null,
                    name = null,
                    type = null,
                    key = null,
                    ref = null,
                    source = null,
                    text = null,
                    publicInstance = null,
                    nodeType = "Native";
                if ("object" !== ("undefined" == typeof internalInstance ? "undefined" : _typeof(internalInstance))) nodeType = "Text", text = internalInstance + "";else if (null === internalInstance._currentElement || internalInstance._currentElement === !1) nodeType = "Empty";else if (internalInstance._renderedComponent) nodeType = "NativeWrapper", children = [internalInstance._renderedComponent], props = internalInstance._instance.props, state = internalInstance._instance.state, context = internalInstance._instance.context, context && 0 === Object.keys(context).length && (context = null);else if (internalInstance._renderedChildren) children = childrenList(internalInstance._renderedChildren);else if (internalInstance._currentElement && internalInstance._currentElement.props) {
                    var unfilteredChildren = internalInstance._currentElement.props.children,
                        filteredChildren = [];
                    traverseAllChildrenImpl(unfilteredChildren, "", function (_traverseContext, child) {
                        var childType = "undefined" == typeof child ? "undefined" : _typeof(child);
                        "string" !== childType && "number" !== childType || filteredChildren.push(child);
                    }), children = filteredChildren.length <= 1 ? filteredChildren.length ? String(filteredChildren[0]) : void 0 : filteredChildren;
                }

                if (!props && internalInstance._currentElement && internalInstance._currentElement.props && (props = internalInstance._currentElement.props), null != internalInstance._currentElement && (type = internalInstance._currentElement.type, internalInstance._currentElement.key && (key = String(internalInstance._currentElement.key)), source = internalInstance._currentElement._source, ref = internalInstance._currentElement.ref, "string" == typeof type ? (name = type, null != internalInstance._nativeNode && (publicInstance = internalInstance._nativeNode), null != internalInstance._hostNode && (publicInstance = internalInstance._hostNode)) : "function" == typeof type ? (nodeType = "Composite", name = getDisplayName(type), internalInstance._renderedComponent && (internalInstance._currentElement.props === internalInstance._renderedComponent._currentElement || internalInstance._currentElement.type.isReactTopLevelWrapper) && (nodeType = "Wrapper"), null === name && (name = "No display name")) : "string" == typeof internalInstance._stringText ? (nodeType = "Text", text = internalInstance._stringText) : name = getDisplayName(type)), internalInstance._instance) {
                    var inst = internalInstance._instance,
                        forceUpdate = inst.forceUpdate || inst.updater && inst.updater.enqueueForceUpdate && function (cb) {
                        inst.updater.enqueueForceUpdate(this, cb, "forceUpdate");
                    };

                    updater = {
                        setState: inst.setState && inst.setState.bind(inst),
                        forceUpdate: forceUpdate && forceUpdate.bind(inst),
                        setInProps: forceUpdate && setInProps.bind(null, internalInstance, forceUpdate),
                        setInState: inst.forceUpdate && setInState.bind(null, inst),
                        setInContext: forceUpdate && setInContext.bind(null, inst, forceUpdate)
                    }, "function" == typeof type && (publicInstance = inst), inst._renderedChildren && (children = childrenList(inst._renderedChildren));
                }

                return "function" == typeof internalInstance.setNativeProps && (updater = {
                    setNativeProps: function setNativeProps(nativeProps) {
                        internalInstance.setNativeProps(nativeProps);
                    }
                }), {
                    nodeType: nodeType,
                    type: type,
                    key: key,
                    ref: ref,
                    source: source,
                    name: name,
                    props: props,
                    state: state,
                    context: context,
                    children: children,
                    text: text,
                    updater: updater,
                    publicInstance: publicInstance
                };
            }

            function setInProps(internalInst, forceUpdate, path, value) {
                var element = internalInst._currentElement;
                internalInst._currentElement = _extends({}, element, {
                    props: copyWithSet(element.props, path, value)
                }), forceUpdate.call(internalInst._instance);
            }

            function setInState(inst, path, value) {
                setIn(inst.state, path, value), inst.forceUpdate();
            }

            function setInContext(inst, forceUpdate, path, value) {
                setIn(inst.context, path, value), forceUpdate.call(inst);
            }

            function setIn(obj, path, value) {
                var last = path.pop(),
                    parent = path.reduce(function (obj_, attr) {
                    return obj_ ? obj_[attr] : null;
                }, obj);
                parent && (parent[last] = value);
            }

            function childrenList(children) {
                var res = [];

                for (var name in children) {
                    res.push(children[name]);
                }

                return res;
            }

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                    }
                }

                return target;
            },
                _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
                return typeof obj;
            } : function (obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
            },
                copyWithSet = __webpack_require__(37),
                getDisplayName = __webpack_require__(38),
                traverseAllChildrenImpl = __webpack_require__(39);

            module.exports = getData;
        }, function (module, exports) {
            "use strict";

            function copyWithSetImpl(obj, path, idx, value) {
                if (idx >= path.length) return value;
                var key = path[idx],
                    updated = Array.isArray(obj) ? obj.slice() : _extends({}, obj);
                return updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value), updated;
            }

            function copyWithSet(obj, path, value) {
                return copyWithSetImpl(obj, path, 0, value);
            }

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                    }
                }

                return target;
            };

            module.exports = copyWithSet;
        }, function (module, exports) {
            "use strict";

            function getDisplayName(type) {
                if (cachedDisplayNames.has(type)) return cachedDisplayNames.get(type);
                var displayName = void 0;
                "string" == typeof type.displayName && (displayName = type.displayName), displayName || (displayName = type.name || "Unknown");
                var match = displayName.match(FB_MODULE_RE);

                if (match) {
                    var componentName = match[1],
                        moduleName = match[2];
                    componentName && moduleName && (moduleName === componentName || moduleName.startsWith(componentName + ".")) && (displayName = componentName);
                }

                return cachedDisplayNames.set(type, displayName), displayName;
            }

            var FB_MODULE_RE = /^(.*) \[from (.*)\]$/,
                cachedDisplayNames = new WeakMap();
            module.exports = getDisplayName;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function escape(key) {
                var escapeRegex = /[=:]/g,
                    escaperLookup = {
                    "=": "=0",
                    ":": "=2"
                },
                    escapedString = ("" + key).replace(escapeRegex, function (match) {
                    return escaperLookup[match];
                });
                return "$" + escapedString;
            }

            function getComponentKey(component, index) {
                return "object" === ("undefined" == typeof component ? "undefined" : _typeof(component)) && null !== component && null != component.key ? escape(component.key) : index.toString(36);
            }

            function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
                var type = "undefined" == typeof children ? "undefined" : _typeof(children);
                if ("undefined" !== type && "boolean" !== type || (children = null), null === children || "string" === type || "number" === type || "object" === type && children.$$typeof === REACT_ELEMENT_TYPE) return callback(traverseContext, children, "" === nameSoFar ? SEPARATOR + getComponentKey(children, 0) : nameSoFar), 1;
                var child,
                    nextName,
                    subtreeCount = 0,
                    nextNamePrefix = "" === nameSoFar ? SEPARATOR : nameSoFar + SUBSEPARATOR;
                if (Array.isArray(children)) for (var i = 0; i < children.length; i++) {
                    child = children[i], nextName = nextNamePrefix + getComponentKey(child, i), subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                } else {
                    var iteratorFn = ITERATOR_SYMBOL && children[ITERATOR_SYMBOL] || children[FAUX_ITERATOR_SYMBOL];
                    if ("function" == typeof iteratorFn) for (var step, iterator = iteratorFn.call(children), ii = 0; !(step = iterator.next()).done;) {
                        child = step.value, nextName = nextNamePrefix + getComponentKey(child, ii++), subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                    } else if ("object" === type) {
                        var addendum = " If you meant to render a collection of children, use an array instead.",
                            childrenString = "" + children;
                        invariant(!1, "The React Devtools cannot render an object as a child. (found: %s).%s", "[object Object]" === childrenString ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString, addendum);
                    }
                }
                return subtreeCount;
            }

            var _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
                return typeof obj;
            } : function (obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
            },
                invariant = __webpack_require__(40),
                SEPARATOR = ".",
                SUBSEPARATOR = ":",
                FAUX_ITERATOR_SYMBOL = "@@iterator",
                ITERATOR_SYMBOL = "function" == typeof Symbol && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator"),
                REACT_ELEMENT_TYPE = "function" == typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103;

            module.exports = traverseAllChildrenImpl;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function invariant(condition, format, a, b, c, d, e, f) {
                if (!condition) {
                    var error;
                    if (void 0 === format) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
                        var args = [a, b, c, d, e, f],
                            argIndex = 0;
                        error = new Error(format.replace(/%s/g, function () {
                            return args[argIndex++];
                        })), error.name = "Invariant Violation";
                    }
                    throw error.framesToPop = 1, error;
                }
            }

            module.exports = invariant;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function getData012(internalInstance) {
                var children = null,
                    props = internalInstance.props,
                    state = internalInstance.state,
                    context = internalInstance.context,
                    updater = null,
                    name = null,
                    type = null,
                    key = null,
                    ref = null,
                    text = null,
                    publicInstance = null,
                    nodeType = "Native";
                return internalInstance._renderedComponent ? (nodeType = "Wrapper", children = [internalInstance._renderedComponent], context && 0 === Object.keys(context).length && (context = null)) : internalInstance._renderedChildren ? (name = internalInstance.constructor.displayName, children = childrenList(internalInstance._renderedChildren)) : "string" == typeof props.children && (name = internalInstance.constructor.displayName, children = props.children, nodeType = "Native"), !props && internalInstance._currentElement && internalInstance._currentElement.props && (props = internalInstance._currentElement.props), internalInstance._currentElement && (type = internalInstance._currentElement.type, internalInstance._currentElement.key && (key = String(internalInstance._currentElement.key)), ref = internalInstance._currentElement.ref, "string" == typeof type ? name = type : (nodeType = "Composite", name = type.displayName, name || (name = "No display name"))), name || (name = internalInstance.constructor.displayName || "No display name", nodeType = "Composite"), "string" == typeof props && (nodeType = "Text", text = props, props = null, name = null), internalInstance.forceUpdate && (updater = {
                    setState: internalInstance.setState.bind(internalInstance),
                    forceUpdate: internalInstance.forceUpdate.bind(internalInstance),
                    setInProps: internalInstance.forceUpdate && setInProps.bind(null, internalInstance),
                    setInState: internalInstance.forceUpdate && setInState.bind(null, internalInstance),
                    setInContext: internalInstance.forceUpdate && setInContext.bind(null, internalInstance)
                }, publicInstance = internalInstance), {
                    nodeType: nodeType,
                    type: type,
                    key: key,
                    ref: ref,
                    source: null,
                    name: name,
                    props: props,
                    state: state,
                    context: context,
                    children: children,
                    text: text,
                    updater: updater,
                    publicInstance: publicInstance
                };
            }

            function setInProps(inst, path, value) {
                inst.props = copyWithSet(inst.props, path, value), inst.forceUpdate();
            }

            function setInState(inst, path, value) {
                setIn(inst.state, path, value), inst.forceUpdate();
            }

            function setInContext(inst, path, value) {
                setIn(inst.context, path, value), inst.forceUpdate();
            }

            function setIn(obj, path, value) {
                var last = path.pop(),
                    parent = path.reduce(function (obj_, attr) {
                    return obj_ ? obj_[attr] : null;
                }, obj);
                parent && (parent[last] = value);
            }

            function childrenList(children) {
                var res = [];

                for (var name in children) {
                    res.push(children[name]);
                }

                return res;
            }

            var copyWithSet = __webpack_require__(37);

            module.exports = getData012;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function attachRendererFiber(hook, rid, renderer) {
                function getOpaqueNode(fiber) {
                    if (opaqueNodes.has(fiber)) return fiber;
                    var alternate = fiber.alternate;
                    return null != alternate && opaqueNodes.has(alternate) ? alternate : (opaqueNodes.add(fiber), fiber);
                }

                function hasDataChanged(prevFiber, nextFiber) {
                    if (prevFiber.tag === ClassComponent) {
                        if ((nextFiber.effectTag & PerformedWork) !== PerformedWork) return !1;
                        if (prevFiber.stateNode.context !== nextFiber.stateNode.context) return !0;
                        if (null != nextFiber.updateQueue && nextFiber.updateQueue.hasForceUpdate) return !0;
                    }

                    return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref || prevFiber._debugSource !== nextFiber._debugSource;
                }

                function flushPendingEvents() {
                    var events = pendingEvents;
                    pendingEvents = [];

                    for (var i = 0; i < events.length; i++) {
                        var event = events[i];
                        hook.emit(event.type, event);
                    }
                }

                function enqueueMount(fiber) {
                    pendingEvents.push({
                        internalInstance: getOpaqueNode(fiber),
                        data: getDataFiber(fiber, getOpaqueNode),
                        renderer: rid,
                        type: "mount"
                    });
                    var isRoot = fiber.tag === HostRoot;
                    isRoot && pendingEvents.push({
                        internalInstance: getOpaqueNode(fiber),
                        renderer: rid,
                        type: "root"
                    });
                }

                function enqueueUpdateIfNecessary(fiber, hasChildOrderChanged) {
                    (hasChildOrderChanged || hasDataChanged(fiber.alternate, fiber)) && pendingEvents.push({
                        internalInstance: getOpaqueNode(fiber),
                        data: getDataFiber(fiber, getOpaqueNode),
                        renderer: rid,
                        type: "update"
                    });
                }

                function enqueueUnmount(fiber) {
                    var isRoot = fiber.tag === HostRoot,
                        opaqueNode = getOpaqueNode(fiber),
                        event = {
                        internalInstance: opaqueNode,
                        renderer: rid,
                        type: "unmount"
                    };
                    isRoot ? pendingEvents.push(event) : pendingEvents.unshift(event), opaqueNodes["delete"](opaqueNode);
                }

                function mountFiber(fiber) {
                    var node = fiber;

                    outer: for (;;) {
                        if (node.child) node.child["return"] = node, node = node.child;else {
                            if (enqueueMount(node), node == fiber) return;

                            if (!node.sibling) {
                                for (; node["return"];) {
                                    if (node = node["return"], enqueueMount(node), node == fiber) return;

                                    if (node.sibling) {
                                        node.sibling["return"] = node["return"], node = node.sibling;
                                        continue outer;
                                    }
                                }

                                return;
                            }

                            node.sibling["return"] = node["return"], node = node.sibling;
                        }
                    }
                }

                function updateFiber(nextFiber, prevFiber) {
                    var hasChildOrderChanged = !1;

                    if (nextFiber.child !== prevFiber.child) {
                        for (var nextChild = nextFiber.child, prevChildAtSameIndex = prevFiber.child; nextChild;) {
                            if (nextChild.alternate) {
                                var prevChild = nextChild.alternate;
                                updateFiber(nextChild, prevChild), hasChildOrderChanged || prevChild === prevChildAtSameIndex || (hasChildOrderChanged = !0);
                            } else mountFiber(nextChild), hasChildOrderChanged || (hasChildOrderChanged = !0);

                            nextChild = nextChild.sibling, hasChildOrderChanged || null == prevChildAtSameIndex || (prevChildAtSameIndex = prevChildAtSameIndex.sibling);
                        }

                        hasChildOrderChanged || null == prevChildAtSameIndex || (hasChildOrderChanged = !0);
                    }

                    enqueueUpdateIfNecessary(nextFiber, hasChildOrderChanged);
                }

                function walkTree() {
                    hook.getFiberRoots(rid).forEach(function (root) {
                        mountFiber(root.current);
                    }), flushPendingEvents();
                }

                function cleanup() {}

                function handleCommitFiberUnmount(fiber) {
                    enqueueUnmount(fiber);
                }

                function handleCommitFiberRoot(root) {
                    var current = root.current,
                        alternate = current.alternate;

                    if (alternate) {
                        var wasMounted = null != alternate.memoizedState && null != alternate.memoizedState.element,
                            isMounted = null != current.memoizedState && null != current.memoizedState.element;
                        !wasMounted && isMounted ? mountFiber(current) : wasMounted && isMounted ? updateFiber(current, alternate) : wasMounted && !isMounted && enqueueUnmount(current);
                    } else mountFiber(current);

                    flushPendingEvents();
                }

                function getNativeFromReactElement(fiber) {
                    try {
                        var opaqueNode = fiber,
                            hostInstance = renderer.findHostInstanceByFiber(opaqueNode);
                        return hostInstance;
                    } catch (err) {
                        return null;
                    }
                }

                function getReactElementFromNative(hostInstance) {
                    var fiber = renderer.findFiberByHostInstance(hostInstance);

                    if (null != fiber) {
                        var opaqueNode = getOpaqueNode(fiber);
                        return opaqueNode;
                    }

                    return null;
                }

                var opaqueNodes = new Set(),
                    pendingEvents = [];
                return {
                    getNativeFromReactElement: getNativeFromReactElement,
                    getReactElementFromNative: getReactElementFromNative,
                    handleCommitFiberRoot: handleCommitFiberRoot,
                    handleCommitFiberUnmount: handleCommitFiberUnmount,
                    cleanup: cleanup,
                    walkTree: walkTree
                };
            }

            var getDataFiber = __webpack_require__(43),
                _require = __webpack_require__(44),
                ClassComponent = _require.ClassComponent,
                HostRoot = _require.HostRoot,
                PerformedWork = 1;

            module.exports = attachRendererFiber;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function getDataFiber(fiber, getOpaqueNode) {
                var type = fiber.type,
                    key = fiber.key,
                    ref = fiber.ref,
                    source = fiber._debugSource,
                    publicInstance = null,
                    props = null,
                    state = null,
                    children = null,
                    context = null,
                    updater = null,
                    nodeType = null,
                    name = null,
                    text = null;

                switch (fiber.tag) {
                    case FunctionalComponent:
                    case ClassComponent:
                        nodeType = "Composite", name = getDisplayName(fiber.type), publicInstance = fiber.stateNode, props = fiber.memoizedProps, state = fiber.memoizedState, null != publicInstance && (context = publicInstance.context, context && 0 === Object.keys(context).length && (context = null));
                        var inst = publicInstance;
                        inst && (updater = {
                            setState: inst.setState && inst.setState.bind(inst),
                            forceUpdate: inst.forceUpdate && inst.forceUpdate.bind(inst),
                            setInProps: inst.forceUpdate && setInProps.bind(null, fiber),
                            setInState: inst.forceUpdate && setInState.bind(null, inst),
                            setInContext: inst.forceUpdate && setInContext.bind(null, inst)
                        }), children = [];
                        break;

                    case HostRoot:
                        nodeType = "Wrapper", children = [];
                        break;

                    case HostPortal:
                        nodeType = "Portal", name = "ReactPortal", props = {
                            target: fiber.stateNode.containerInfo
                        }, children = [];
                        break;

                    case HostComponent:
                        nodeType = "Native", name = fiber.type, name = name.replace("topsecret-", ""), publicInstance = fiber.stateNode, props = fiber.memoizedProps, children = "string" == typeof props.children || "number" == typeof props.children ? props.children.toString() : [], "function" == typeof fiber.stateNode.setNativeProps && (updater = {
                            setNativeProps: function setNativeProps(nativeProps) {
                                fiber.stateNode.setNativeProps(nativeProps);
                            }
                        });
                        break;

                    case HostText:
                        nodeType = "Text", text = fiber.memoizedProps;
                        break;

                    case Fragment:
                        nodeType = "Wrapper", children = [];
                        break;

                    default:
                        nodeType = "Native", props = fiber.memoizedProps, name = "TODO_NOT_IMPLEMENTED_YET", children = [];
                }

                if (Array.isArray(children)) for (var child = fiber.child; child;) {
                    children.push(getOpaqueNode(child)), child = child.sibling;
                }
                return {
                    nodeType: nodeType,
                    type: type,
                    key: key,
                    ref: ref,
                    source: source,
                    name: name,
                    props: props,
                    state: state,
                    context: context,
                    children: children,
                    text: text,
                    updater: updater,
                    publicInstance: publicInstance
                };
            }

            function setInProps(fiber, path, value) {
                var inst = fiber.stateNode;
                fiber.pendingProps = copyWithSet(inst.props, path, value), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps), fiber.stateNode.forceUpdate();
            }

            function setInState(inst, path, value) {
                setIn(inst.state, path, value), inst.forceUpdate();
            }

            function setInContext(inst, path, value) {
                setIn(inst.context, path, value), inst.forceUpdate();
            }

            function setIn(obj, path, value) {
                var last = path.pop(),
                    parent = path.reduce(function (obj_, attr) {
                    return obj_ ? obj_[attr] : null;
                }, obj);
                parent && (parent[last] = value);
            }

            var copyWithSet = __webpack_require__(37),
                getDisplayName = __webpack_require__(38),
                _require = __webpack_require__(44),
                FunctionalComponent = _require.FunctionalComponent,
                ClassComponent = _require.ClassComponent,
                HostRoot = _require.HostRoot,
                HostPortal = _require.HostPortal,
                HostComponent = _require.HostComponent,
                HostText = _require.HostText,
                Fragment = _require.Fragment;

            module.exports = getDataFiber;
        }, function (module, exports) {
            "use strict";

            module.exports = {
                IndeterminateComponent: 0,
                FunctionalComponent: 1,
                ClassComponent: 2,
                HostRoot: 3,
                HostPortal: 4,
                HostComponent: 5,
                HostText: 6,
                CoroutineComponent: 7,
                CoroutineHandlerPhase: 8,
                YieldComponent: 9,
                Fragment: 10
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function _defineProperty(obj, key, value) {
                return key in obj ? Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : obj[key] = value, obj;
            }

            function measureStyle(agent, bridge, resolveRNStyle, id) {
                var node = agent.elementData.get(id);
                if (!node || !node.props) return void bridge.send("rn-style:measure", {});
                var style = resolveRNStyle(node.props.style);
                styleOverridesByHostComponentId[id] && (style = babelHelpers.extends({}, style, styleOverridesByHostComponentId[id]));
                var instance = node.publicInstance;
                return instance && instance.measure ? void instance.measure(function (x, y, width, height, left, top) {
                    if ("number" != typeof x) return void bridge.send("rn-style:measure", {
                        style: style
                    });
                    var margin = style && resolveBoxStyle("margin", style) || blank,
                        padding = style && resolveBoxStyle("padding", style) || blank;
                    bridge.send("rn-style:measure", {
                        style: style,
                        measuredLayout: {
                            x: x,
                            y: y,
                            width: width,
                            height: height,
                            left: left,
                            top: top,
                            margin: margin,
                            padding: padding
                        }
                    });
                }) : void bridge.send("rn-style:measure", {
                    style: style
                });
            }

            function shallowClone(obj) {
                var nobj = {};

                for (var n in obj) {
                    nobj[n] = obj[n];
                }

                return nobj;
            }

            function renameStyle(agent, id, oldName, newName, val) {
                var _ref3,
                    data = agent.elementData.get(id),
                    newStyle = newName ? (_ref3 = {}, _defineProperty(_ref3, oldName, void 0), _defineProperty(_ref3, newName, val), _ref3) : _defineProperty({}, oldName, void 0);

                if (data && data.updater && data.updater.setInProps) {
                    var customStyle,
                        style = data && data.props && data.props.style;

                    if (Array.isArray(style)) {
                        var lastLength = style.length - 1;
                        "object" !== _typeof(style[lastLength]) || Array.isArray(style[lastLength]) ? (style = style.concat([newStyle]), data.updater.setInProps(["style"], style)) : (customStyle = shallowClone(style[lastLength]), delete customStyle[oldName], newName ? customStyle[newName] = val : customStyle[oldName] = void 0, data.updater.setInProps(["style", lastLength], customStyle));
                    } else "object" === ("undefined" == typeof style ? "undefined" : _typeof(style)) ? (customStyle = shallowClone(style), delete customStyle[oldName], newName ? customStyle[newName] = val : customStyle[oldName] = void 0, data.updater.setInProps(["style"], customStyle)) : (style = [style, newStyle], data.updater.setInProps(["style"], style));
                } else {
                    if (!(data && data.updater && data.updater.setNativeProps)) return;
                    styleOverridesByHostComponentId[id] ? babelHelpers.extends(styleOverridesByHostComponentId[id], newStyle) : styleOverridesByHostComponentId[id] = newStyle, data.updater.setNativeProps({
                        style: newStyle
                    });
                }

                agent.emit("hideHighlight");
            }

            function setStyle(agent, id, attr, val) {
                var data = agent.elementData.get(id),
                    newStyle = _defineProperty({}, attr, val);

                if (data && data.updater && data.updater.setInProps) {
                    var style = data.props && data.props.style;

                    if (Array.isArray(style)) {
                        var lastLength = style.length - 1;
                        "object" !== _typeof(style[lastLength]) || Array.isArray(style[lastLength]) ? (style = style.concat([newStyle]), data.updater.setInProps(["style"], style)) : data.updater.setInProps(["style", lastLength, attr], val);
                    } else style = [style, newStyle], data.updater.setInProps(["style"], style);
                } else {
                    if (!(data && data.updater && data.updater.setNativeProps)) return;
                    styleOverridesByHostComponentId[id] ? babelHelpers.extends(styleOverridesByHostComponentId[id], newStyle) : styleOverridesByHostComponentId[id] = newStyle, data.updater.setNativeProps({
                        style: newStyle
                    });
                }

                agent.emit("hideHighlight");
            }

            var _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
                return typeof obj;
            } : function (obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
            },
                resolveBoxStyle = __webpack_require__(46),
                styleOverridesByHostComponentId = {};

            module.exports = function (bridge, agent, resolveRNStyle) {
                bridge.onCall("rn-style:get", function (id) {
                    var node = agent.elementData.get(id);
                    return node && node.props ? resolveRNStyle(node.props.style) : null;
                }), bridge.on("rn-style:measure", function (id) {
                    measureStyle(agent, bridge, resolveRNStyle, id);
                }), bridge.on("rn-style:rename", function (_ref) {
                    var id = _ref.id,
                        oldName = _ref.oldName,
                        newName = _ref.newName,
                        val = _ref.val;
                    renameStyle(agent, id, oldName, newName, val), setTimeout(function () {
                        return measureStyle(agent, bridge, resolveRNStyle, id);
                    });
                }), bridge.on("rn-style:set", function (_ref2) {
                    var id = _ref2.id,
                        attr = _ref2.attr,
                        val = _ref2.val;
                    setStyle(agent, id, attr, val), setTimeout(function () {
                        return measureStyle(agent, bridge, resolveRNStyle, id);
                    });
                });
            };

            var blank = {
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            };
        }, function (module, exports) {
            "use strict";

            function resolveBoxStyle(prefix, style) {
                var res = {},
                    subs = ["top", "left", "bottom", "right"],
                    set = !1;
                return subs.forEach(function (sub) {
                    res[sub] = style[prefix] || 0;
                }), style[prefix] && (set = !0), style[prefix + "Vertical"] && (res.top = res.bottom = style[prefix + "Vertical"], set = !0), style[prefix + "Horizontal"] && (res.left = res.right = style[prefix + "Horizontal"], set = !0), subs.forEach(function (sub) {
                    var val = style[prefix + capFirst(sub)];
                    val && (res[sub] = val, set = !0);
                }), set ? res : null;
            }

            function capFirst(text) {
                return text[0].toUpperCase() + text.slice(1);
            }

            module.exports = resolveBoxStyle;
        }, function (module, exports) {
            "use strict";

            function decorate(obj, attr, fn) {
                var old = obj[attr];
                return obj[attr] = function () {
                    var res = old.apply(this, arguments);
                    return fn.apply(this, arguments), res;
                }, function () {
                    obj[attr] = old;
                };
            }

            var subscriptionEnabled = !1;

            module.exports = function (bridge, agent, hook) {
                function sendStoreData() {
                    subscriptionEnabled && bridge.send("relay:store", {
                        id: "relay:store",
                        nodes: DefaultStoreData.getNodeData()
                    });
                }

                var shouldEnable = !!hook._relayInternals;

                if (bridge.onCall("relay:check", function () {
                    return shouldEnable;
                }), shouldEnable) {
                    var _hook$_relayInternals = hook._relayInternals,
                        DefaultStoreData = _hook$_relayInternals.DefaultStoreData,
                        setRequestListener = _hook$_relayInternals.setRequestListener;
                    bridge.onCall("relay:store:enable", function () {
                        subscriptionEnabled = !0, sendStoreData();
                    }), bridge.onCall("relay:store:disable", function () {
                        subscriptionEnabled = !1;
                    }), sendStoreData(), decorate(DefaultStoreData, "handleUpdatePayload", sendStoreData), decorate(DefaultStoreData, "handleQueryPayload", sendStoreData);
                    var removeListener = setRequestListener(function (event, data) {
                        bridge.send(event, data);
                    });
                    hook.on("shutdown", removeListener);
                }
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            var Highlighter = __webpack_require__(49);

            module.exports = function (agent) {
                var hl = new Highlighter(window, function (node) {
                    agent.selectFromDOMNode(node);
                });
                agent.on("highlight", function (data) {
                    return hl.highlight(data.node, data.name);
                }), agent.on("highlightMany", function (nodes) {
                    return hl.highlightMany(nodes);
                }), agent.on("hideHighlight", function () {
                    return hl.hideHighlight();
                }), agent.on("refreshMultiOverlay", function () {
                    return hl.refreshMultiOverlay();
                }), agent.on("startInspecting", function () {
                    return hl.startInspecting();
                }), agent.on("stopInspecting", function () {
                    return hl.stopInspecting();
                }), agent.on("shutdown", function () {
                    hl.remove();
                });
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }

            function captureSubscription(obj, evt, cb) {
                return obj.addEventListener(evt, cb, !0), function () {
                    return obj.removeEventListener(evt, cb, !0);
                };
            }

            function makeMagnifier() {
                var button = window.document.createElement("button");
                return button.innerHTML = "&#128269;", button.style.backgroundColor = "transparent", button.style.border = "none", button.style.outline = "none", button.style.cursor = "pointer", button.style.position = "fixed", button.style.bottom = "10px", button.style.right = "10px", button.style.fontSize = "30px", button.style.zIndex = 1e7, button;
            }

            var _createClass = function () {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }

                return function (Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
                };
            }(),
                Overlay = __webpack_require__(50),
                MultiOverlay = __webpack_require__(52),
                Highlighter = function () {
                function Highlighter(win, onSelect) {
                    _classCallCheck(this, Highlighter), this._win = win, this._onSelect = onSelect, this._overlay = null, this._multiOverlay = null, this._subs = [];
                }

                return _createClass(Highlighter, [{
                    key: "startInspecting",
                    value: function value() {
                        this._inspecting = !0, this._subs = [captureSubscription(this._win, "mouseover", this.onHover.bind(this)), captureSubscription(this._win, "mousedown", this.onMouseDown.bind(this)), captureSubscription(this._win, "click", this.onClick.bind(this))];
                    }
                }, {
                    key: "stopInspecting",
                    value: function value() {
                        this._subs.forEach(function (unsub) {
                            return unsub();
                        }), this.hideHighlight();
                    }
                }, {
                    key: "remove",
                    value: function value() {
                        this.stopInspecting(), this._button && this._button.parentNode && this._button.parentNode.removeChild(this._button);
                    }
                }, {
                    key: "highlight",
                    value: function value(node, name) {
                        this.removeMultiOverlay(), node.nodeType !== Node.COMMENT_NODE && (this._overlay || (this._overlay = new Overlay(this._win)), this._overlay.inspect(node, name));
                    }
                }, {
                    key: "highlightMany",
                    value: function value(nodes) {
                        this.removeOverlay(), this._multiOverlay || (this._multiOverlay = new MultiOverlay(this._win)), this._multiOverlay.highlightMany(nodes);
                    }
                }, {
                    key: "hideHighlight",
                    value: function value() {
                        this._inspecting = !1, this.removeOverlay(), this.removeMultiOverlay();
                    }
                }, {
                    key: "refreshMultiOverlay",
                    value: function value() {
                        this._multiOverlay && this._multiOverlay.refresh();
                    }
                }, {
                    key: "removeOverlay",
                    value: function value() {
                        this._overlay && (this._overlay.remove(), this._overlay = null);
                    }
                }, {
                    key: "removeMultiOverlay",
                    value: function value() {
                        this._multiOverlay && (this._multiOverlay.remove(), this._multiOverlay = null);
                    }
                }, {
                    key: "onMouseDown",
                    value: function value(evt) {
                        this._inspecting && (evt.preventDefault(), evt.stopPropagation(), evt.cancelBubble = !0, this._onSelect(evt.target));
                    }
                }, {
                    key: "onClick",
                    value: function value(evt) {
                        this._inspecting && (this._subs.forEach(function (unsub) {
                            return unsub();
                        }), evt.preventDefault(), evt.stopPropagation(), evt.cancelBubble = !0, this.hideHighlight());
                    }
                }, {
                    key: "onHover",
                    value: function value(evt) {
                        this._inspecting && (evt.preventDefault(), evt.stopPropagation(), evt.cancelBubble = !0, this.highlight(evt.target));
                    }
                }, {
                    key: "injectButton",
                    value: function value() {
                        this._button = makeMagnifier(), this._button.onclick = this.startInspecting.bind(this), this._win.document.body.appendChild(this._button);
                    }
                }]), Highlighter;
            }();

            module.exports = Highlighter;
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }

            function findTipPos(dims, win) {
                var top,
                    tipHeight = 20,
                    margin = 5;
                return top = dims.top + dims.height + tipHeight <= win.innerHeight ? dims.top + dims.height < 0 ? margin : dims.top + dims.height + margin : dims.top - tipHeight <= win.innerHeight ? dims.top - tipHeight - margin < margin ? margin : dims.top - tipHeight - margin : win.innerHeight - tipHeight - margin, top += "px", dims.left < 0 ? {
                    top: top,
                    left: margin
                } : dims.left + 200 > win.innerWidth ? {
                    top: top,
                    right: margin
                } : {
                    top: top,
                    left: dims.left + margin + "px"
                };
            }

            function getElementDimensions(domElement) {
                var calculatedStyle = window.getComputedStyle(domElement);
                return {
                    borderLeft: +calculatedStyle.borderLeftWidth.match(/[0-9]*/)[0],
                    borderRight: +calculatedStyle.borderRightWidth.match(/[0-9]*/)[0],
                    borderTop: +calculatedStyle.borderTopWidth.match(/[0-9]*/)[0],
                    borderBottom: +calculatedStyle.borderBottomWidth.match(/[0-9]*/)[0],
                    marginLeft: +calculatedStyle.marginLeft.match(/[0-9]*/)[0],
                    marginRight: +calculatedStyle.marginRight.match(/[0-9]*/)[0],
                    marginTop: +calculatedStyle.marginTop.match(/[0-9]*/)[0],
                    marginBottom: +calculatedStyle.marginBottom.match(/[0-9]*/)[0],
                    paddingLeft: +calculatedStyle.paddingLeft.match(/[0-9]*/)[0],
                    paddingRight: +calculatedStyle.paddingRight.match(/[0-9]*/)[0],
                    paddingTop: +calculatedStyle.paddingTop.match(/[0-9]*/)[0],
                    paddingBottom: +calculatedStyle.paddingBottom.match(/[0-9]*/)[0]
                };
            }

            function getOwnerWindow(node) {
                return node.ownerDocument ? node.ownerDocument.defaultView : null;
            }

            function getOwnerIframe(node) {
                var nodeWindow = getOwnerWindow(node);
                return nodeWindow ? nodeWindow.frameElement : null;
            }

            function getBoundingClientRectWithBorderOffset(node) {
                var dimensions = getElementDimensions(node);
                return mergeRectOffsets([node.getBoundingClientRect(), {
                    top: dimensions.borderTop,
                    left: dimensions.borderLeft,
                    bottom: dimensions.borderBottom,
                    right: dimensions.borderRight,
                    width: 0,
                    height: 0
                }]);
            }

            function mergeRectOffsets(rects) {
                return rects.reduce(function (previousRect, rect) {
                    return null == previousRect ? rect : {
                        top: previousRect.top + rect.top,
                        left: previousRect.left + rect.left,
                        width: previousRect.width,
                        height: previousRect.height,
                        bottom: previousRect.bottom + rect.bottom,
                        right: previousRect.right + rect.right
                    };
                });
            }

            function getNestedBoundingClientRect(node, boundaryWindow) {
                var ownerIframe = getOwnerIframe(node);

                if (ownerIframe && ownerIframe !== boundaryWindow) {
                    for (var rects = [node.getBoundingClientRect()], currentIframe = ownerIframe, onlyOneMore = !1; currentIframe;) {
                        var rect = getBoundingClientRectWithBorderOffset(currentIframe);
                        if (rects.push(rect), currentIframe = getOwnerIframe(currentIframe), onlyOneMore) break;
                        currentIframe && getOwnerWindow(currentIframe) === boundaryWindow && (onlyOneMore = !0);
                    }

                    return mergeRectOffsets(rects);
                }

                return node.getBoundingClientRect();
            }

            function boxWrap(dims, what, node) {
                assign(node.style, {
                    borderTopWidth: dims[what + "Top"] + "px",
                    borderLeftWidth: dims[what + "Left"] + "px",
                    borderRightWidth: dims[what + "Right"] + "px",
                    borderBottomWidth: dims[what + "Bottom"] + "px",
                    borderStyle: "solid"
                });
            }

            var _createClass = function () {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }

                return function (Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
                };
            }(),
                assign = __webpack_require__(3),
                _require = __webpack_require__(51),
                monospace = _require.monospace,
                Overlay = function () {
                function Overlay(window) {
                    _classCallCheck(this, Overlay);

                    var doc = window.document;
                    this.win = window, this.container = doc.createElement("div"), this.node = doc.createElement("div"), this.border = doc.createElement("div"), this.padding = doc.createElement("div"), this.content = doc.createElement("div"), this.border.style.borderColor = overlayStyles.border, this.padding.style.borderColor = overlayStyles.padding, this.content.style.backgroundColor = overlayStyles.background, assign(this.node.style, {
                        borderColor: overlayStyles.margin,
                        pointerEvents: "none",
                        position: "fixed"
                    }), this.tip = doc.createElement("div"), assign(this.tip.style, {
                        backgroundColor: "#333740",
                        borderRadius: "2px",
                        fontFamily: monospace.family,
                        fontWeight: "bold",
                        padding: "3px 5px",
                        position: "fixed",
                        fontSize: monospace.sizes.normal
                    }), this.nameSpan = doc.createElement("span"), this.tip.appendChild(this.nameSpan), assign(this.nameSpan.style, {
                        color: "#ee78e6",
                        borderRight: "1px solid #aaaaaa",
                        paddingRight: "0.5rem",
                        marginRight: "0.5rem"
                    }), this.dimSpan = doc.createElement("span"), this.tip.appendChild(this.dimSpan), assign(this.dimSpan.style, {
                        color: "#d7d7d7"
                    }), this.container.style.zIndex = 1e7, this.node.style.zIndex = 1e7, this.tip.style.zIndex = 1e7, this.container.appendChild(this.node), this.container.appendChild(this.tip), this.node.appendChild(this.border), this.border.appendChild(this.padding), this.padding.appendChild(this.content), doc.body.appendChild(this.container);
                }

                return _createClass(Overlay, [{
                    key: "remove",
                    value: function value() {
                        this.container.parentNode && this.container.parentNode.removeChild(this.container);
                    }
                }, {
                    key: "inspect",
                    value: function value(node, name) {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            var box = getNestedBoundingClientRect(node, this.win),
                                dims = getElementDimensions(node);
                            boxWrap(dims, "margin", this.node), boxWrap(dims, "border", this.border), boxWrap(dims, "padding", this.padding), assign(this.content.style, {
                                height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + "px",
                                width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + "px"
                            }), assign(this.node.style, {
                                top: box.top - dims.marginTop + "px",
                                left: box.left - dims.marginLeft + "px"
                            }), this.nameSpan.textContent = name || node.nodeName.toLowerCase(), this.dimSpan.textContent = box.width + "px  " + box.height + "px";
                            var tipPos = findTipPos({
                                top: box.top - dims.marginTop,
                                left: box.left - dims.marginLeft,
                                height: box.height + dims.marginTop + dims.marginBottom,
                                width: box.width + dims.marginLeft + dims.marginRight
                            }, this.win);
                            assign(this.tip.style, tipPos);
                        }
                    }
                }]), Overlay;
            }(),
                overlayStyles = {
                background: "rgba(120, 170, 210, 0.7)",
                padding: "rgba(77, 200, 0, 0.3)",
                margin: "rgba(255, 155, 0, 0.3)",
                border: "rgba(255, 200, 50, 0.3)"
            };

            module.exports = Overlay;
        }, function (module, exports) {
            "use strict";

            module.exports = {
                monospace: {
                    family: "Menlo, Consolas, monospace",
                    sizes: {
                        normal: 11,
                        large: 14
                    }
                },
                sansSerif: {
                    family: '"Helvetica Neue", "Lucida Grande", -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, sans-serif',
                    sizes: {
                        small: 10,
                        normal: 12,
                        large: 14
                    }
                }
            };
        }, function (module, exports, __webpack_require__) {
            "use strict";

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }

            var _createClass = function () {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }

                return function (Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
                };
            }(),
                assign = __webpack_require__(3),
                MultiOverlay = function () {
                function MultiOverlay(window) {
                    _classCallCheck(this, MultiOverlay), this.win = window;
                    var doc = window.document;
                    this.container = doc.createElement("div"), doc.body.appendChild(this.container), this._currentNodes = null;
                }

                return _createClass(MultiOverlay, [{
                    key: "highlightMany",
                    value: function value(nodes) {
                        var _this = this;

                        this._currentNodes = nodes, this.container.innerHTML = "", nodes.forEach(function (node) {
                            var div = _this.win.document.createElement("div");

                            if ("function" == typeof node.getBoundingClientRect) {
                                var box = node.getBoundingClientRect();
                                box.bottom < 0 || box.top > window.innerHeight || (assign(div.style, {
                                    top: box.top + "px",
                                    left: box.left + "px",
                                    width: box.width + "px",
                                    height: box.height + "px",
                                    border: "2px dotted rgba(200, 100, 100, .8)",
                                    boxSizing: "border-box",
                                    backgroundColor: "rgba(200, 100, 100, .2)",
                                    position: "fixed",
                                    zIndex: 1e7,
                                    pointerEvents: "none"
                                }), _this.container.appendChild(div));
                            }
                        });
                    }
                }, {
                    key: "refresh",
                    value: function value() {
                        this._currentNodes && this.highlightMany(this._currentNodes);
                    }
                }, {
                    key: "remove",
                    value: function value() {
                        this.container.parentNode && (this.container.parentNode.removeChild(this.container), this._currentNodes = null);
                    }
                }]), MultiOverlay;
            }();

            module.exports = MultiOverlay;
        }]);
    });
},151,[],"react-devtools-core/build/backend.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var ReactNativePropRegistry;

  function getStyle(style) {
    if (ReactNativePropRegistry === undefined) {
      ReactNativePropRegistry = require(_dependencyMap[1], 'ReactNativePropRegistry');
    }

    if (typeof style === 'number') {
      return ReactNativePropRegistry.getByID(style);
    }

    return style;
  }

  function flattenStyle(style) {
    if (!style) {
      return undefined;
    }

    invariant(style !== true, 'style may be false but not true');

    if (!Array.isArray(style)) {
      return getStyle(style);
    }

    var result = {};

    for (var i = 0, styleLength = style.length; i < styleLength; ++i) {
      var computedStyle = flattenStyle(style[i]);

      if (computedStyle) {
        for (var key in computedStyle) {
          result[key] = computedStyle[key];
        }
      }
    }

    return result;
  }

  module.exports = flattenStyle;
},152,[18,153],"flattenStyle");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'ReactNative'),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  module.exports = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactNativePropRegistry;
},153,[74],"ReactNativePropRegistry");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var JSInspector = {
    registerAgent: function registerAgent(type) {
      if (global.__registerInspectorAgent) {
        global.__registerInspectorAgent(type);
      }
    },
    getTimestamp: function getTimestamp() {
      return global.__inspectorTimestamp();
    }
  };
  module.exports = JSInspector;
},154,[],"JSInspector");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var InspectorAgent = require(_dependencyMap[0], 'InspectorAgent');

  var JSInspector = require(_dependencyMap[1], 'JSInspector');

  var Map = require(_dependencyMap[2], 'Map');

  var XMLHttpRequest = require(_dependencyMap[3], 'XMLHttpRequest');

  var Interceptor = function () {
    function Interceptor(agent) {
      babelHelpers.classCallCheck(this, Interceptor);
      this._agent = agent;
      this._requests = new Map();
    }

    babelHelpers.createClass(Interceptor, [{
      key: "getData",
      value: function getData(requestId) {
        return this._requests.get(requestId);
      }
    }, {
      key: "requestSent",
      value: function requestSent(id, url, method, headers) {
        var requestId = String(id);

        this._requests.set(requestId, '');

        var request = {
          url: url,
          method: method,
          headers: headers,
          initialPriority: 'Medium'
        };
        var event = {
          requestId: requestId,
          documentURL: '',
          frameId: '1',
          loaderId: '1',
          request: request,
          timestamp: JSInspector.getTimestamp(),
          initiator: {
            type: 'other'
          },
          type: 'Other'
        };

        this._agent.sendEvent('requestWillBeSent', event);
      }
    }, {
      key: "responseReceived",
      value: function responseReceived(id, url, status, headers) {
        var requestId = String(id);
        var response = {
          url: url,
          status: status,
          statusText: String(status),
          headers: headers,
          requestHeaders: {},
          mimeType: this._getMimeType(headers),
          connectionReused: false,
          connectionId: -1,
          encodedDataLength: 0,
          securityState: 'unknown'
        };
        var event = {
          requestId: requestId,
          frameId: '1',
          loaderId: '1',
          timestamp: JSInspector.getTimestamp(),
          type: 'Other',
          response: response
        };

        this._agent.sendEvent('responseReceived', event);
      }
    }, {
      key: "dataReceived",
      value: function dataReceived(id, data) {
        var requestId = String(id);
        var existingData = this._requests.get(requestId) || '';

        this._requests.set(requestId, existingData.concat(data));

        var event = {
          requestId: requestId,
          timestamp: JSInspector.getTimestamp(),
          dataLength: data.length,
          encodedDataLength: data.length
        };

        this._agent.sendEvent('dataReceived', event);
      }
    }, {
      key: "loadingFinished",
      value: function loadingFinished(id, encodedDataLength) {
        var event = {
          requestId: String(id),
          timestamp: JSInspector.getTimestamp(),
          encodedDataLength: encodedDataLength
        };

        this._agent.sendEvent('loadingFinished', event);
      }
    }, {
      key: "loadingFailed",
      value: function loadingFailed(id, error) {
        var event = {
          requestId: String(id),
          timestamp: JSInspector.getTimestamp(),
          type: 'Other',
          errorText: error
        };

        this._agent.sendEvent('loadingFailed', event);
      }
    }, {
      key: "_getMimeType",
      value: function _getMimeType(headers) {
        var contentType = headers['Content-Type'] || '';
        return contentType.split(';')[0];
      }
    }]);
    return Interceptor;
  }();

  var NetworkAgent = function (_InspectorAgent) {
    babelHelpers.inherits(NetworkAgent, _InspectorAgent);

    function NetworkAgent() {
      babelHelpers.classCallCheck(this, NetworkAgent);
      return babelHelpers.possibleConstructorReturn(this, (NetworkAgent.__proto__ || Object.getPrototypeOf(NetworkAgent)).apply(this, arguments));
    }

    babelHelpers.createClass(NetworkAgent, [{
      key: "enable",
      value: function enable(_ref) {
        var maxResourceBufferSize = _ref.maxResourceBufferSize,
            maxTotalBufferSize = _ref.maxTotalBufferSize;
        this._interceptor = new Interceptor(this);
        XMLHttpRequest.setInterceptor(this._interceptor);
      }
    }, {
      key: "disable",
      value: function disable() {
        XMLHttpRequest.setInterceptor(null);
        this._interceptor = null;
      }
    }, {
      key: "getResponseBody",
      value: function getResponseBody(_ref2) {
        var requestId = _ref2.requestId;
        return {
          body: this.interceptor().getData(requestId),
          base64Encoded: false
        };
      }
    }, {
      key: "interceptor",
      value: function interceptor() {
        if (this._interceptor) {
          return this._interceptor;
        } else {
          throw Error('_interceptor can not be null');
        }
      }
    }]);
    return NetworkAgent;
  }(InspectorAgent);

  NetworkAgent.DOMAIN = 'Network';
  module.exports = NetworkAgent;
},155,[156,154,79,109],"NetworkAgent");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var InspectorAgent = function () {
    function InspectorAgent(eventSender) {
      babelHelpers.classCallCheck(this, InspectorAgent);
      this._eventSender = eventSender;
    }

    babelHelpers.createClass(InspectorAgent, [{
      key: "sendEvent",
      value: function sendEvent(name, params) {
        this._eventSender(name, params);
      }
    }]);
    return InspectorAgent;
  }();

  module.exports = InspectorAgent;
},156,[],"InspectorAgent");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var BatchedBridge = require(_dependencyMap[0], 'BatchedBridge');

  var RCTEventEmitter = {
    register: function register(eventEmitter) {
      BatchedBridge.registerCallableModule('RCTEventEmitter', eventEmitter);
    }
  };
  module.exports = RCTEventEmitter;
},157,[69],"RCTEventEmitter");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = require(_dependencyMap[0], 'NativeModules');

  var Platform = require(_dependencyMap[1], 'Platform');

  var defineLazyObjectProperty = require(_dependencyMap[2], 'defineLazyObjectProperty');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var UIManager = NativeModules.UIManager;
  invariant(UIManager, 'UIManager is undefined. The native module config is probably incorrect.');
  UIManager.__takeSnapshot = UIManager.takeSnapshot;

  UIManager.takeSnapshot = function () {
    invariant(false, 'UIManager.takeSnapshot should not be called directly. ' + 'Use ReactNative.takeSnapshot instead.');
  };

  if (Platform.OS === 'ios') {
    Object.keys(UIManager).forEach(function (viewName) {
      var viewConfig = UIManager[viewName];

      if (viewConfig.Manager) {
        defineLazyObjectProperty(viewConfig, 'Constants', {
          get: function get() {
            var viewManager = NativeModules[viewConfig.Manager];
            var constants = {};
            viewManager && Object.keys(viewManager).forEach(function (key) {
              var value = viewManager[key];

              if (typeof value !== 'function') {
                constants[key] = value;
              }
            });
            return constants;
          }
        });
        defineLazyObjectProperty(viewConfig, 'Commands', {
          get: function get() {
            var viewManager = NativeModules[viewConfig.Manager];
            var commands = {};
            var index = 0;
            viewManager && Object.keys(viewManager).forEach(function (key) {
              var value = viewManager[key];

              if (typeof value === 'function') {
                commands[key] = index++;
              }
            });
            return commands;
          }
        });
      }
    });
  } else if (Platform.OS === 'android' && UIManager.ViewManagerNames) {
    UIManager.ViewManagerNames.forEach(function (viewManagerName) {
      defineLazyObjectProperty(UIManager, viewManagerName, {
        get: function get() {
          return UIManager.getConstantsForViewManager(viewManagerName);
        }
      });
    });
  }

  module.exports = UIManager;
},158,[68,105,77,18],"UIManager");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Platform = require(_dependencyMap[0], 'Platform');

  var UIManager = require(_dependencyMap[1], 'UIManager');

  var TextInputState = {
    _currentlyFocusedID: null,
    currentlyFocusedField: function currentlyFocusedField() {
      return this._currentlyFocusedID;
    },
    focusTextInput: function focusTextInput(textFieldID) {
      if (this._currentlyFocusedID !== textFieldID && textFieldID !== null) {
        this._currentlyFocusedID = textFieldID;

        if (Platform.OS === 'ios') {
          UIManager.focus(textFieldID);
        } else if (Platform.OS === 'android') {
          UIManager.dispatchViewManagerCommand(textFieldID, UIManager.AndroidTextInput.Commands.focusTextInput, null);
        }
      }
    },
    blurTextInput: function blurTextInput(textFieldID) {
      if (this._currentlyFocusedID === textFieldID && textFieldID !== null) {
        this._currentlyFocusedID = null;

        if (Platform.OS === 'ios') {
          UIManager.blur(textFieldID);
        } else if (Platform.OS === 'android') {
          UIManager.dispatchViewManagerCommand(textFieldID, UIManager.AndroidTextInput.Commands.blurTextInput, null);
        }
      }
    }
  };
  module.exports = TextInputState;
},159,[105,158],"TextInputState");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var deepDiffer = function deepDiffer(one, two) {
    if (one === two) {
      return false;
    }

    if (typeof one === 'function' && typeof two === 'function') {
      return false;
    }

    if (typeof one !== 'object' || one === null) {
      return one !== two;
    }

    if (typeof two !== 'object' || two === null) {
      return true;
    }

    if (one.constructor !== two.constructor) {
      return true;
    }

    if (Array.isArray(one)) {
      var len = one.length;

      if (two.length !== len) {
        return true;
      }

      for (var ii = 0; ii < len; ii++) {
        if (deepDiffer(one[ii], two[ii])) {
          return true;
        }
      }
    } else {
      for (var key in one) {
        if (deepDiffer(one[key], two[key])) {
          return true;
        }
      }

      for (var twoKey in two) {
        if (one[twoKey] === undefined && two[twoKey] !== undefined) {
          return true;
        }
      }
    }

    return false;
  };

  module.exports = deepDiffer;
},160,[],"deepDiffer");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function is(x, y) {
    if (x === y) {
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }

  function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
      return true;
    }

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  }

  module.exports = shallowEqual;
},161,[],"fbjs/lib/shallowEqual.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function deepFreezeAndThrowOnMutationInDev(object) {
    if (__DEV__) {
      if (typeof object !== 'object' || object === null || Object.isFrozen(object) || Object.isSealed(object)) {
        return;
      }

      var keys = Object.keys(object);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (object.hasOwnProperty(key)) {
          object.__defineGetter__(key, identity.bind(null, object[key]));

          object.__defineSetter__(key, throwOnImmutableMutation.bind(null, key));
        }
      }

      Object.freeze(object);
      Object.seal(object);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (object.hasOwnProperty(key)) {
          deepFreezeAndThrowOnMutationInDev(object[key]);
        }
      }
    }
  }

  function throwOnImmutableMutation(key, value) {
    throw Error('You attempted to set the key `' + key + '` with the value `' + JSON.stringify(value) + '` on an object that is meant to be immutable ' + 'and has been frozen.');
  }

  function identity(value) {
    return value;
  }

  module.exports = deepFreezeAndThrowOnMutationInDev;
},162,[],"deepFreezeAndThrowOnMutationInDev");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ReactFeatureFlags = {
    debugRenderPhaseSideEffects: false
  };
  module.exports = ReactFeatureFlags;
},163,[],"ReactFeatureFlags");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0], "InitializeCore");

  var invariant = require(_dependencyMap[1], "fbjs/lib/invariant"),
      emptyFunction = require(_dependencyMap[2], "fbjs/lib/emptyFunction"),
      RCTEventEmitter = require(_dependencyMap[3], "RCTEventEmitter"),
      UIManager = require(_dependencyMap[4], "UIManager"),
      React = require(_dependencyMap[5], "react"),
      ExceptionsManager = require(_dependencyMap[6], "ExceptionsManager"),
      TextInputState = require(_dependencyMap[7], "TextInputState"),
      deepDiffer = require(_dependencyMap[8], "deepDiffer"),
      flattenStyle = require(_dependencyMap[9], "flattenStyle"),
      emptyObject = require(_dependencyMap[10], "fbjs/lib/emptyObject"),
      shallowEqual = require(_dependencyMap[11], "fbjs/lib/shallowEqual"),
      ReactErrorUtils = {
    _caughtError: null,
    _hasCaughtError: !1,
    _rethrowError: null,
    _hasRethrowError: !1,
    injection: {
      injectErrorUtils: function injectErrorUtils(injectedErrorUtils) {
        invariant("function" === typeof injectedErrorUtils.invokeGuardedCallback, "Injected invokeGuardedCallback() must be a function.");
        _invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
      }
    },
    invokeGuardedCallback: function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
      _invokeGuardedCallback.apply(ReactErrorUtils, arguments);
    },
    invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
      ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);

      if (ReactErrorUtils.hasCaughtError()) {
        var error = ReactErrorUtils.clearCaughtError();
        ReactErrorUtils._hasRethrowError || (ReactErrorUtils._hasRethrowError = !0, ReactErrorUtils._rethrowError = error);
      }
    },
    rethrowCaughtError: function rethrowCaughtError() {
      return _rethrowCaughtError.apply(ReactErrorUtils, arguments);
    },
    hasCaughtError: function hasCaughtError() {
      return ReactErrorUtils._hasCaughtError;
    },
    clearCaughtError: function clearCaughtError() {
      if (ReactErrorUtils._hasCaughtError) {
        var error = ReactErrorUtils._caughtError;
        ReactErrorUtils._caughtError = null;
        ReactErrorUtils._hasCaughtError = !1;
        return error;
      }

      invariant(!1, "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
  };

  function _invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
    ReactErrorUtils._hasCaughtError = !1;
    ReactErrorUtils._caughtError = null;
    var funcArgs = Array.prototype.slice.call(arguments, 3);

    try {
      func.apply(context, funcArgs);
    } catch (error) {
      ReactErrorUtils._caughtError = error, ReactErrorUtils._hasCaughtError = !0;
    }
  }

  function _rethrowCaughtError() {
    if (ReactErrorUtils._hasRethrowError) {
      var error = ReactErrorUtils._rethrowError;
      ReactErrorUtils._rethrowError = null;
      ReactErrorUtils._hasRethrowError = !1;
      throw error;
    }
  }

  var eventPluginOrder = null,
      namesToPlugins = {};

  function recomputePluginOrdering() {
    if (eventPluginOrder) for (var pluginName in namesToPlugins) {
      var pluginModule = namesToPlugins[pluginName],
          pluginIndex = eventPluginOrder.indexOf(pluginName);
      invariant(-1 < pluginIndex, "EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.", pluginName);

      if (!plugins[pluginIndex]) {
        invariant(pluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.", pluginName);
        plugins[pluginIndex] = pluginModule;
        pluginIndex = pluginModule.eventTypes;

        for (var eventName in pluginIndex) {
          var JSCompiler_inline_result = void 0;
          var dispatchConfig = pluginIndex[eventName],
              pluginModule$jscomp$0 = pluginModule,
              eventName$jscomp$0 = eventName;
          invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0), "EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.", eventName$jscomp$0);
          eventNameDispatchConfigs[eventName$jscomp$0] = dispatchConfig;
          var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

          if (phasedRegistrationNames) {
            for (JSCompiler_inline_result in phasedRegistrationNames) {
              phasedRegistrationNames.hasOwnProperty(JSCompiler_inline_result) && publishRegistrationName(phasedRegistrationNames[JSCompiler_inline_result], pluginModule$jscomp$0, eventName$jscomp$0);
            }

            JSCompiler_inline_result = !0;
          } else dispatchConfig.registrationName ? (publishRegistrationName(dispatchConfig.registrationName, pluginModule$jscomp$0, eventName$jscomp$0), JSCompiler_inline_result = !0) : JSCompiler_inline_result = !1;

          invariant(JSCompiler_inline_result, "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName);
        }
      }
    }
  }

  function publishRegistrationName(registrationName, pluginModule) {
    invariant(!registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
    registrationNameModules[registrationName] = pluginModule;
  }

  var plugins = [],
      eventNameDispatchConfigs = {},
      registrationNameModules = {},
      getFiberCurrentPropsFromNode = null,
      getInstanceFromNode = null,
      getNodeFromInstance = null;

  function isEndish(topLevelType) {
    return "topMouseUp" === topLevelType || "topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType;
  }

  function isMoveish(topLevelType) {
    return "topMouseMove" === topLevelType || "topTouchMove" === topLevelType;
  }

  function isStartish(topLevelType) {
    return "topMouseDown" === topLevelType || "topTouchStart" === topLevelType;
  }

  function executeDispatch(event, simulated, listener, inst) {
    simulated = event.type || "unknown-event";
    event.currentTarget = getNodeFromInstance(inst);
    ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(simulated, listener, void 0, event);
    event.currentTarget = null;
  }

  function executeDirectDispatch(event) {
    var dispatchListener = event._dispatchListeners,
        dispatchInstance = event._dispatchInstances;
    invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
    event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
    dispatchListener = dispatchListener ? dispatchListener(event) : null;
    event.currentTarget = null;
    event._dispatchListeners = null;
    event._dispatchInstances = null;
    return dispatchListener;
  }

  function accumulateInto(current, next) {
    invariant(null != next, "accumulateInto(...): Accumulated items must not be null or undefined.");
    if (null == current) return next;

    if (Array.isArray(current)) {
      if (Array.isArray(next)) return current.push.apply(current, next), current;
      current.push(next);
      return current;
    }

    return Array.isArray(next) ? [current].concat(next) : [current, next];
  }

  function forEachAccumulated(arr, cb, scope) {
    Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
  }

  var eventQueue = null;

  function executeDispatchesAndReleaseTopLevel(e) {
    if (e) {
      var dispatchListeners = e._dispatchListeners,
          dispatchInstances = e._dispatchInstances;
      if (Array.isArray(dispatchListeners)) for (var i = 0; i < dispatchListeners.length && !e.isPropagationStopped(); i++) {
        executeDispatch(e, !1, dispatchListeners[i], dispatchInstances[i]);
      } else dispatchListeners && executeDispatch(e, !1, dispatchListeners, dispatchInstances);
      e._dispatchListeners = null;
      e._dispatchInstances = null;
      e.isPersistent() || e.constructor.release(e);
    }
  }

  var injection = {
    injectEventPluginOrder: function injectEventPluginOrder(injectedEventPluginOrder) {
      invariant(!eventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.");
      eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
      recomputePluginOrdering();
    },
    injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
      var isOrderingDirty = !1,
          pluginName;

      for (pluginName in injectedNamesToPlugins) {
        if (injectedNamesToPlugins.hasOwnProperty(pluginName)) {
          var pluginModule = injectedNamesToPlugins[pluginName];
          namesToPlugins.hasOwnProperty(pluginName) && namesToPlugins[pluginName] === pluginModule || (invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.", pluginName), namesToPlugins[pluginName] = pluginModule, isOrderingDirty = !0);
        }
      }

      isOrderingDirty && recomputePluginOrdering();
    }
  };

  function getListener(inst, registrationName) {
    var listener = inst.stateNode;
    if (!listener) return null;
    var props = getFiberCurrentPropsFromNode(listener);
    if (!props) return null;
    listener = props[registrationName];

    a: switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
        (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
        inst = !props;
        break a;

      default:
        inst = !1;
    }

    if (inst) return null;
    invariant(!listener || "function" === typeof listener, "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
    return listener;
  }

  function getParent(inst) {
    do {
      inst = inst["return"];
    } while (inst && 5 !== inst.tag);

    return inst ? inst : null;
  }

  function traverseTwoPhase(inst, fn, arg) {
    for (var path = []; inst;) {
      path.push(inst), inst = getParent(inst);
    }

    for (inst = path.length; 0 < inst--;) {
      fn(path[inst], "captured", arg);
    }

    for (inst = 0; inst < path.length; inst++) {
      fn(path[inst], "bubbled", arg);
    }
  }

  function accumulateDirectionalDispatches(inst, phase, event) {
    if (phase = getListener(inst, event.dispatchConfig.phasedRegistrationNames[phase])) event._dispatchListeners = accumulateInto(event._dispatchListeners, phase), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }

  function accumulateTwoPhaseDispatchesSingle(event) {
    event && event.dispatchConfig.phasedRegistrationNames && traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }

  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var targetInst = event._targetInst;
      targetInst = targetInst ? getParent(targetInst) : null;
      traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
    }
  }

  function accumulateDirectDispatchesSingle(event) {
    if (event && event.dispatchConfig.registrationName) {
      var inst = event._targetInst;

      if (inst && event && event.dispatchConfig.registrationName) {
        var listener = getListener(inst, event.dispatchConfig.registrationName);
        listener && (event._dispatchListeners = accumulateInto(event._dispatchListeners, listener), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst));
      }
    }
  }

  var shouldBeReleasedProperties = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
      EventInterface = {
    type: null,
    target: null,
    currentTarget: emptyFunction.thatReturnsNull,
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function timeStamp(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };

  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;
    dispatchConfig = this.constructor.Interface;

    for (var propName in dispatchConfig) {
      dispatchConfig.hasOwnProperty(propName) && ((targetInst = dispatchConfig[propName]) ? this[propName] = targetInst(nativeEvent) : "target" === propName ? this.target = nativeEventTarget : this[propName] = nativeEvent[propName]);
    }

    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? emptyFunction.thatReturnsTrue : emptyFunction.thatReturnsFalse;
    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
    return this;
  }

  babelHelpers.extends(SyntheticEvent.prototype, {
    preventDefault: function preventDefault() {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = emptyFunction.thatReturnsTrue);
    },
    stopPropagation: function stopPropagation() {
      var event = this.nativeEvent;
      event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = emptyFunction.thatReturnsTrue);
    },
    persist: function persist() {
      this.isPersistent = emptyFunction.thatReturnsTrue;
    },
    isPersistent: emptyFunction.thatReturnsFalse,
    destructor: function destructor() {
      var Interface = this.constructor.Interface,
          propName;

      for (propName in Interface) {
        this[propName] = null;
      }

      for (Interface = 0; Interface < shouldBeReleasedProperties.length; Interface++) {
        this[shouldBeReleasedProperties[Interface]] = null;
      }
    }
  });
  SyntheticEvent.Interface = EventInterface;

  SyntheticEvent.augmentClass = function (Class, Interface) {
    function E() {}

    E.prototype = this.prototype;
    var prototype = new E();
    babelHelpers.extends(prototype, Class.prototype);
    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = babelHelpers.extends({}, this.Interface, Interface);
    Class.augmentClass = this.augmentClass;
    addEventPoolingTo(Class);
  };

  addEventPoolingTo(SyntheticEvent);

  function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
    if (this.eventPool.length) {
      var instance = this.eventPool.pop();
      this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
      return instance;
    }

    return new this(dispatchConfig, targetInst, nativeEvent, nativeInst);
  }

  function releasePooledEvent(event) {
    invariant(event instanceof this, "Trying to release an event instance  into a pool of a different type.");
    event.destructor();
    10 > this.eventPool.length && this.eventPool.push(event);
  }

  function addEventPoolingTo(EventConstructor) {
    EventConstructor.eventPool = [];
    EventConstructor.getPooled = getPooledEvent;
    EventConstructor.release = releasePooledEvent;
  }

  function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent.augmentClass(ResponderSyntheticEvent, {
    touchHistory: function touchHistory() {
      return null;
    }
  });
  var touchBank = [],
      touchHistory = {
    touchBank: touchBank,
    numberActiveTouches: 0,
    indexOfSingleActiveTouch: -1,
    mostRecentTimeStamp: 0
  };

  function timestampForTouch(touch) {
    return touch.timeStamp || touch.timestamp;
  }

  function getTouchIdentifier(_ref) {
    _ref = _ref.identifier;
    invariant(null != _ref, "Touch object is missing identifier.");
    return _ref;
  }

  function recordTouchStart(touch) {
    var identifier = getTouchIdentifier(touch),
        touchRecord = touchBank[identifier];
    touchRecord ? (touchRecord.touchActive = !0, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch)) : (touchRecord = {
      touchActive: !0,
      startPageX: touch.pageX,
      startPageY: touch.pageY,
      startTimeStamp: timestampForTouch(touch),
      currentPageX: touch.pageX,
      currentPageY: touch.pageY,
      currentTimeStamp: timestampForTouch(touch),
      previousPageX: touch.pageX,
      previousPageY: touch.pageY,
      previousTimeStamp: timestampForTouch(touch)
    }, touchBank[identifier] = touchRecord);
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  }

  function recordTouchMove(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord ? (touchRecord.touchActive = !0, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.error("Cannot record touch move without a touch start.\nTouch Move: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
  }

  function recordTouchEnd(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord ? (touchRecord.touchActive = !1, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.error("Cannot record touch end without a touch start.\nTouch End: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
  }

  function printTouch(touch) {
    return JSON.stringify({
      identifier: touch.identifier,
      pageX: touch.pageX,
      pageY: touch.pageY,
      timestamp: timestampForTouch(touch)
    });
  }

  function printTouchBank() {
    var printed = JSON.stringify(touchBank.slice(0, 20));
    20 < touchBank.length && (printed += " (original size: " + touchBank.length + ")");
    return printed;
  }

  var ResponderTouchHistoryStore = {
    recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
      if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchMove);else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchStart), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);else if (isEndish(topLevelType) && (nativeEvent.changedTouches.forEach(recordTouchEnd), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches)) for (topLevelType = 0; topLevelType < touchBank.length; topLevelType++) {
        if (nativeEvent = touchBank[topLevelType], null != nativeEvent && nativeEvent.touchActive) {
          touchHistory.indexOfSingleActiveTouch = topLevelType;
          break;
        }
      }
    },
    touchHistory: touchHistory
  };

  function accumulate(current, next) {
    invariant(null != next, "accumulate(...): Accumulated items must be not be null or undefined.");
    return null == current ? next : Array.isArray(current) ? current.concat(next) : Array.isArray(next) ? [current].concat(next) : [current, next];
  }

  var responderInst = null,
      trackedTouchCount = 0,
      previousActiveTouches = 0;

  function changeResponder(nextResponderInst, blockHostResponder) {
    var oldResponderInst = responderInst;
    responderInst = nextResponderInst;
    if (null !== ResponderEventPlugin.GlobalResponderHandler) ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
  }

  var eventTypes = {
    startShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onStartShouldSetResponder",
        captured: "onStartShouldSetResponderCapture"
      }
    },
    scrollShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onScrollShouldSetResponder",
        captured: "onScrollShouldSetResponderCapture"
      }
    },
    selectionChangeShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onSelectionChangeShouldSetResponder",
        captured: "onSelectionChangeShouldSetResponderCapture"
      }
    },
    moveShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onMoveShouldSetResponder",
        captured: "onMoveShouldSetResponderCapture"
      }
    },
    responderStart: {
      registrationName: "onResponderStart"
    },
    responderMove: {
      registrationName: "onResponderMove"
    },
    responderEnd: {
      registrationName: "onResponderEnd"
    },
    responderRelease: {
      registrationName: "onResponderRelease"
    },
    responderTerminationRequest: {
      registrationName: "onResponderTerminationRequest"
    },
    responderGrant: {
      registrationName: "onResponderGrant"
    },
    responderReject: {
      registrationName: "onResponderReject"
    },
    responderTerminate: {
      registrationName: "onResponderTerminate"
    }
  },
      ResponderEventPlugin = {
    _getResponder: function _getResponder() {
      return responderInst;
    },
    eventTypes: eventTypes,
    extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (isStartish(topLevelType)) trackedTouchCount += 1;else if (isEndish(topLevelType)) if (0 <= trackedTouchCount) --trackedTouchCount;else return console.error("Ended a touch event which was not counted in `trackedTouchCount`."), null;
      ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

      if (targetInst && ("topScroll" === topLevelType && !nativeEvent.responderIgnoreScroll || 0 < trackedTouchCount && "topSelectionChange" === topLevelType || isStartish(topLevelType) || isMoveish(topLevelType))) {
        var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : "topSelectionChange" === topLevelType ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;
        if (responderInst) b: {
          var JSCompiler_temp = responderInst;

          for (var depthA = 0, tempA = JSCompiler_temp; tempA; tempA = getParent(tempA)) {
            depthA++;
          }

          tempA = 0;

          for (var tempB = targetInst; tempB; tempB = getParent(tempB)) {
            tempA++;
          }

          for (; 0 < depthA - tempA;) {
            JSCompiler_temp = getParent(JSCompiler_temp), depthA--;
          }

          for (; 0 < tempA - depthA;) {
            targetInst = getParent(targetInst), tempA--;
          }

          for (; depthA--;) {
            if (JSCompiler_temp === targetInst || JSCompiler_temp === targetInst.alternate) break b;
            JSCompiler_temp = getParent(JSCompiler_temp);
            targetInst = getParent(targetInst);
          }

          JSCompiler_temp = null;
        } else JSCompiler_temp = targetInst;
        targetInst = JSCompiler_temp === responderInst;
        JSCompiler_temp = ResponderSyntheticEvent.getPooled(shouldSetEventType, JSCompiler_temp, nativeEvent, nativeEventTarget);
        JSCompiler_temp.touchHistory = ResponderTouchHistoryStore.touchHistory;
        targetInst ? forEachAccumulated(JSCompiler_temp, accumulateTwoPhaseDispatchesSingleSkipTarget) : forEachAccumulated(JSCompiler_temp, accumulateTwoPhaseDispatchesSingle);

        b: {
          shouldSetEventType = JSCompiler_temp._dispatchListeners;
          targetInst = JSCompiler_temp._dispatchInstances;
          if (Array.isArray(shouldSetEventType)) for (depthA = 0; depthA < shouldSetEventType.length && !JSCompiler_temp.isPropagationStopped(); depthA++) {
            if (shouldSetEventType[depthA](JSCompiler_temp, targetInst[depthA])) {
              shouldSetEventType = targetInst[depthA];
              break b;
            }
          } else if (shouldSetEventType && shouldSetEventType(JSCompiler_temp, targetInst)) {
            shouldSetEventType = targetInst;
            break b;
          }
          shouldSetEventType = null;
        }

        JSCompiler_temp._dispatchInstances = null;
        JSCompiler_temp._dispatchListeners = null;
        JSCompiler_temp.isPersistent() || JSCompiler_temp.constructor.release(JSCompiler_temp);
        if (shouldSetEventType && shouldSetEventType !== responderInst) {
          if (JSCompiler_temp = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, shouldSetEventType, nativeEvent, nativeEventTarget), JSCompiler_temp.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(JSCompiler_temp, accumulateDirectDispatchesSingle), targetInst = !0 === executeDirectDispatch(JSCompiler_temp), responderInst) {
            if (depthA = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget), depthA.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(depthA, accumulateDirectDispatchesSingle), tempA = !depthA._dispatchListeners || executeDirectDispatch(depthA), depthA.isPersistent() || depthA.constructor.release(depthA), tempA) {
              depthA = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
              depthA.touchHistory = ResponderTouchHistoryStore.touchHistory;
              forEachAccumulated(depthA, accumulateDirectDispatchesSingle);
              var JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, [JSCompiler_temp, depthA]);
              changeResponder(shouldSetEventType, targetInst);
            } else shouldSetEventType = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, shouldSetEventType, nativeEvent, nativeEventTarget), shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(shouldSetEventType, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, shouldSetEventType);
          } else JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, JSCompiler_temp), changeResponder(shouldSetEventType, targetInst);
        } else JSCompiler_temp$jscomp$0 = null;
      } else JSCompiler_temp$jscomp$0 = null;

      shouldSetEventType = responderInst && isStartish(topLevelType);
      JSCompiler_temp = responderInst && isMoveish(topLevelType);
      targetInst = responderInst && isEndish(topLevelType);
      if (shouldSetEventType = shouldSetEventType ? eventTypes.responderStart : JSCompiler_temp ? eventTypes.responderMove : targetInst ? eventTypes.responderEnd : null) shouldSetEventType = ResponderSyntheticEvent.getPooled(shouldSetEventType, responderInst, nativeEvent, nativeEventTarget), shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(shouldSetEventType, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, shouldSetEventType);
      shouldSetEventType = responderInst && "topTouchCancel" === topLevelType;
      if (topLevelType = responderInst && !shouldSetEventType && isEndish(topLevelType)) a: {
        if ((topLevelType = nativeEvent.touches) && 0 !== topLevelType.length) for (JSCompiler_temp = 0; JSCompiler_temp < topLevelType.length; JSCompiler_temp++) {
          if (targetInst = topLevelType[JSCompiler_temp].target, null !== targetInst && void 0 !== targetInst && 0 !== targetInst) {
            depthA = getInstanceFromNode(targetInst);

            b: {
              for (targetInst = responderInst; depthA;) {
                if (targetInst === depthA || targetInst === depthA.alternate) {
                  targetInst = !0;
                  break b;
                }

                depthA = getParent(depthA);
              }

              targetInst = !1;
            }

            if (targetInst) {
              topLevelType = !1;
              break a;
            }
          }
        }
        topLevelType = !0;
      }
      if (topLevelType = shouldSetEventType ? eventTypes.responderTerminate : topLevelType ? eventTypes.responderRelease : null) nativeEvent = ResponderSyntheticEvent.getPooled(topLevelType, responderInst, nativeEvent, nativeEventTarget), nativeEvent.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(nativeEvent, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, nativeEvent), changeResponder(null);
      nativeEvent = ResponderTouchHistoryStore.touchHistory.numberActiveTouches;
      if (ResponderEventPlugin.GlobalInteractionHandler && nativeEvent !== previousActiveTouches) ResponderEventPlugin.GlobalInteractionHandler.onChange(nativeEvent);
      previousActiveTouches = nativeEvent;
      return JSCompiler_temp$jscomp$0;
    },
    GlobalResponderHandler: null,
    GlobalInteractionHandler: null,
    injection: {
      injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
        ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
      },
      injectGlobalInteractionHandler: function injectGlobalInteractionHandler(GlobalInteractionHandler) {
        ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;
      }
    }
  },
      customBubblingEventTypes = {},
      customDirectEventTypes = {},
      ReactNativeBridgeEventPlugin = {
    eventTypes: {},
    extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var bubbleDispatchConfig = customBubblingEventTypes[topLevelType],
          directDispatchConfig = customDirectEventTypes[topLevelType];
      invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type "%s" dispatched', topLevelType);
      topLevelType = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);
      if (bubbleDispatchConfig) forEachAccumulated(topLevelType, accumulateTwoPhaseDispatchesSingle);else if (directDispatchConfig) forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle);else return null;
      return topLevelType;
    },
    processEventTypes: function processEventTypes(viewConfig) {
      var bubblingEventTypes = viewConfig.bubblingEventTypes;
      viewConfig = viewConfig.directEventTypes;
      if (null != bubblingEventTypes) for (var _topLevelType in bubblingEventTypes) {
        null == customBubblingEventTypes[_topLevelType] && (ReactNativeBridgeEventPlugin.eventTypes[_topLevelType] = customBubblingEventTypes[_topLevelType] = bubblingEventTypes[_topLevelType]);
      }
      if (null != viewConfig) for (var _topLevelType2 in viewConfig) {
        null == customDirectEventTypes[_topLevelType2] && (ReactNativeBridgeEventPlugin.eventTypes[_topLevelType2] = customDirectEventTypes[_topLevelType2] = viewConfig[_topLevelType2]);
      }
    }
  },
      instanceCache = {},
      instanceProps = {};

  function uncacheFiberNode(tag) {
    delete instanceCache[tag];
    delete instanceProps[tag];
  }

  function getInstanceFromTag(tag) {
    return instanceCache[tag] || null;
  }

  var ReactNativeComponentTree = Object.freeze({
    precacheFiberNode: function precacheFiberNode(hostInst, tag) {
      instanceCache[tag] = hostInst;
    },
    uncacheFiberNode: uncacheFiberNode,
    getClosestInstanceFromNode: getInstanceFromTag,
    getInstanceFromNode: getInstanceFromTag,
    getNodeFromInstance: function getNodeFromInstance(inst) {
      inst = inst.stateNode._nativeTag;
      invariant(inst, "All native instances should have a tag.");
      return inst;
    },
    getFiberCurrentPropsFromNode: function getFiberCurrentPropsFromNode(stateNode) {
      return instanceProps[stateNode._nativeTag] || null;
    },
    updateFiberProps: function updateFiberProps(tag, props) {
      instanceProps[tag] = props;
    }
  }),
      restoreTarget = null,
      restoreQueue = null;

  function restoreStateOfTarget(target) {
    if (target = getInstanceFromNode(target)) {
      invariant(null, "Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
      var props = getFiberCurrentPropsFromNode(target.stateNode);
      null.restoreControlledState(target.stateNode, target.type, props);
    }
  }

  function fiberBatchedUpdates(fn, bookkeeping) {
    return fn(bookkeeping);
  }

  var isNestingBatched = !1;

  function batchedUpdates(fn, bookkeeping) {
    if (isNestingBatched) return fiberBatchedUpdates(fn, bookkeeping);
    isNestingBatched = !0;

    try {
      return fiberBatchedUpdates(fn, bookkeeping);
    } finally {
      if (isNestingBatched = !1, restoreTarget && (bookkeeping = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(bookkeeping), fn)) for (bookkeeping = 0; bookkeeping < fn.length; bookkeeping++) {
        restoreStateOfTarget(fn[bookkeeping]);
      }
    }
  }

  function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    for (var events, i = 0; i < plugins.length; i++) {
      var possiblePlugin = plugins[i];
      possiblePlugin && (possiblePlugin = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget)) && (events = accumulateInto(events, possiblePlugin));
    }

    events && (eventQueue = accumulateInto(eventQueue, events));
    topLevelType = eventQueue;
    eventQueue = null;
    topLevelType && (forEachAccumulated(topLevelType, executeDispatchesAndReleaseTopLevel), invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."), ReactErrorUtils.rethrowCaughtError());
  }

  var ReactNativeTagHandles = {
    tagsStartAt: 1,
    tagCount: 1,
    allocateTag: function allocateTag() {
      for (; this.reactTagIsNativeTopRootID(ReactNativeTagHandles.tagCount);) {
        ReactNativeTagHandles.tagCount++;
      }

      var tag = ReactNativeTagHandles.tagCount;
      ReactNativeTagHandles.tagCount++;
      return tag;
    },
    assertRootTag: function assertRootTag(tag) {
      invariant(this.reactTagIsNativeTopRootID(tag), "Expect a native root tag, instead got %s", tag);
    },
    reactTagIsNativeTopRootID: function reactTagIsNativeTopRootID(reactTag) {
      return 1 === reactTag % 10;
    }
  },
      EMPTY_NATIVE_EVENT = {};

  function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
    var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT,
        inst = getInstanceFromTag(rootNodeID);
    batchedUpdates(function () {
      handleTopLevel(topLevelType, inst, nativeEvent, nativeEvent.target);
    });
  }

  var ReactNativeEventEmitter = Object.freeze({
    getListener: getListener,
    registrationNames: registrationNameModules,
    _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,
    receiveEvent: function receiveEvent(rootNodeID, topLevelType, nativeEventParam) {
      _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);
    },
    receiveTouches: function receiveTouches(eventTopLevelType, touches, changedIndices) {
      if ("topTouchEnd" === eventTopLevelType || "topTouchCancel" === eventTopLevelType) {
        var JSCompiler_temp = [];

        for (var i = 0; i < changedIndices.length; i++) {
          var index = changedIndices[i];
          JSCompiler_temp.push(touches[index]);
          touches[index] = null;
        }

        for (i = changedIndices = 0; i < touches.length; i++) {
          index = touches[i], null !== index && (touches[changedIndices++] = index);
        }

        touches.length = changedIndices;
      } else for (JSCompiler_temp = [], i = 0; i < changedIndices.length; i++) {
        JSCompiler_temp.push(touches[changedIndices[i]]);
      }

      for (changedIndices = 0; changedIndices < JSCompiler_temp.length; changedIndices++) {
        i = JSCompiler_temp[changedIndices];
        i.changedTouches = JSCompiler_temp;
        i.touches = touches;
        index = null;
        var target = i.target;
        null === target || void 0 === target || target < ReactNativeTagHandles.tagsStartAt || (index = target);

        _receiveRootNodeIDEvent(index, eventTopLevelType, i);
      }
    },
    handleTopLevel: handleTopLevel
  });
  RCTEventEmitter.register(ReactNativeEventEmitter);
  injection.injectEventPluginOrder(["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"]);
  getFiberCurrentPropsFromNode = ReactNativeComponentTree.getFiberCurrentPropsFromNode;
  getInstanceFromNode = ReactNativeComponentTree.getInstanceFromNode;
  getNodeFromInstance = ReactNativeComponentTree.getNodeFromInstance;
  ResponderEventPlugin.injection.injectGlobalResponderHandler({
    onChange: function onChange(from, to, blockNativeResponder) {
      null !== to ? UIManager.setJSResponder(to.stateNode._nativeTag, blockNativeResponder) : UIManager.clearJSResponder();
    }
  });
  injection.injectEventPluginsByName({
    ResponderEventPlugin: ResponderEventPlugin,
    ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin
  });

  function defaultShowDialog() {
    return !0;
  }

  var showDialog = defaultShowDialog,
      hasSymbol = "function" === typeof Symbol && Symbol["for"],
      REACT_ELEMENT_TYPE = hasSymbol ? Symbol["for"]("react.element") : 60103,
      REACT_CALL_TYPE = hasSymbol ? Symbol["for"]("react.call") : 60104,
      REACT_RETURN_TYPE = hasSymbol ? Symbol["for"]("react.return") : 60105,
      REACT_PORTAL_TYPE = hasSymbol ? Symbol["for"]("react.portal") : 60106,
      REACT_FRAGMENT_TYPE = hasSymbol ? Symbol["for"]("react.fragment") : 60107,
      MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");

  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "undefined" === typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }

  function _createPortal(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children: children,
      containerInfo: containerInfo,
      implementation: implementation
    };
  }

  var TouchHistoryMath = {
    centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
      var touchBank = touchHistory.touchBank,
          total = 0,
          count = 0;
      touchHistory = 1 === touchHistory.numberActiveTouches ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;
      if (null !== touchHistory) touchHistory.touchActive && touchHistory.currentTimeStamp > touchesChangedAfter && (total += ofCurrent && isXAxis ? touchHistory.currentPageX : ofCurrent && !isXAxis ? touchHistory.currentPageY : !ofCurrent && isXAxis ? touchHistory.previousPageX : touchHistory.previousPageY, count = 1);else for (touchHistory = 0; touchHistory < touchBank.length; touchHistory++) {
        var touchTrack = touchBank[touchHistory];
        null !== touchTrack && void 0 !== touchTrack && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter && (total += ofCurrent && isXAxis ? touchTrack.currentPageX : ofCurrent && !isXAxis ? touchTrack.currentPageY : !ofCurrent && isXAxis ? touchTrack.previousPageX : touchTrack.previousPageY, count++);
      }
      return 0 < count ? total / count : TouchHistoryMath.noCentroid;
    },
    currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, !0, !0);
    },
    currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, !1, !0);
    },
    previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, !0, !1);
    },
    previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, !1, !1);
    },
    currentCentroidX: function currentCentroidX(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0, !0, !0);
    },
    currentCentroidY: function currentCentroidY(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0, !1, !0);
    },
    noCentroid: -1
  },
      ReactCurrentOwner = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
      ReactGlobalSharedState = Object.freeze({
    ReactCurrentOwner: ReactCurrentOwner,
    ReactDebugCurrentFrame: null
  }),
      objects = {},
      uniqueID = 1,
      emptyObject$2 = {},
      ReactNativePropRegistry = function () {
    function ReactNativePropRegistry() {
      if (!(this instanceof ReactNativePropRegistry)) throw new TypeError("Cannot call a class as a function");
    }

    ReactNativePropRegistry.register = function (object) {
      var id = ++uniqueID;
      objects[id] = object;
      return id;
    };

    ReactNativePropRegistry.getByID = function (id) {
      if (!id) return emptyObject$2;
      var object = objects[id];
      return object ? object : (console.warn("Invalid style with id `" + id + "`. Skipping ..."), emptyObject$2);
    };

    return ReactNativePropRegistry;
  }(),
      emptyObject$1 = {},
      removedKeys = null,
      removedKeyCount = 0;

  function resolveObject(idOrObject) {
    return "number" === typeof idOrObject ? ReactNativePropRegistry.getByID(idOrObject) : idOrObject;
  }

  function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
    if (Array.isArray(node)) for (var i = node.length; i-- && 0 < removedKeyCount;) {
      restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
    } else if (node && 0 < removedKeyCount) for (i in node = resolveObject(node), removedKeys) {
      if (removedKeys[i]) {
        var nextProp = node[i];

        if (void 0 !== nextProp) {
          var attributeConfig = validAttributes[i];

          if (attributeConfig) {
            "function" === typeof nextProp && (nextProp = !0);
            "undefined" === typeof nextProp && (nextProp = null);
            if ("object" !== typeof attributeConfig) updatePayload[i] = nextProp;else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) nextProp = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[i] = nextProp;
            removedKeys[i] = !1;
            removedKeyCount--;
          }
        }
      }
    }
  }

  function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
    if (!updatePayload && prevProp === nextProp) return updatePayload;
    if (!prevProp || !nextProp) return nextProp ? addNestedProperty(updatePayload, nextProp, validAttributes) : prevProp ? clearNestedProperty(updatePayload, prevProp, validAttributes) : updatePayload;
    if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) return diffProperties(updatePayload, resolveObject(prevProp), resolveObject(nextProp), validAttributes);

    if (Array.isArray(prevProp) && Array.isArray(nextProp)) {
      var minLength = prevProp.length < nextProp.length ? prevProp.length : nextProp.length,
          i;

      for (i = 0; i < minLength; i++) {
        updatePayload = diffNestedProperty(updatePayload, prevProp[i], nextProp[i], validAttributes);
      }

      for (; i < prevProp.length; i++) {
        updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
      }

      for (; i < nextProp.length; i++) {
        updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
      }

      return updatePayload;
    }

    return Array.isArray(prevProp) ? diffProperties(updatePayload, flattenStyle(prevProp), resolveObject(nextProp), validAttributes) : diffProperties(updatePayload, resolveObject(prevProp), flattenStyle(nextProp), validAttributes);
  }

  function addNestedProperty(updatePayload, nextProp, validAttributes) {
    if (!nextProp) return updatePayload;
    if (!Array.isArray(nextProp)) return nextProp = resolveObject(nextProp), diffProperties(updatePayload, emptyObject$1, nextProp, validAttributes);

    for (var i = 0; i < nextProp.length; i++) {
      updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
    }

    return updatePayload;
  }

  function clearNestedProperty(updatePayload, prevProp, validAttributes) {
    if (!prevProp) return updatePayload;
    if (!Array.isArray(prevProp)) return prevProp = resolveObject(prevProp), diffProperties(updatePayload, prevProp, emptyObject$1, validAttributes);

    for (var i = 0; i < prevProp.length; i++) {
      updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
    }

    return updatePayload;
  }

  function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
    var attributeConfig, propKey;

    for (propKey in nextProps) {
      if (attributeConfig = validAttributes[propKey]) {
        var prevProp = prevProps[propKey];
        var nextProp = nextProps[propKey];
        "function" === typeof nextProp && (nextProp = !0, "function" === typeof prevProp && (prevProp = !0));
        "undefined" === typeof nextProp && (nextProp = null, "undefined" === typeof prevProp && (prevProp = null));
        removedKeys && (removedKeys[propKey] = !1);
        if (updatePayload && void 0 !== updatePayload[propKey]) {
          if ("object" !== typeof attributeConfig) updatePayload[propKey] = nextProp;else {
            if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[propKey] = attributeConfig;
          }
        } else if (prevProp !== nextProp) if ("object" !== typeof attributeConfig) ("object" !== typeof nextProp || null === nextProp || deepDiffer(prevProp, nextProp)) && ((updatePayload || (updatePayload = {}))[propKey] = nextProp);else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) {
          if (void 0 === prevProp || ("function" === typeof attributeConfig.diff ? attributeConfig.diff(prevProp, nextProp) : "object" !== typeof nextProp || null === nextProp || deepDiffer(prevProp, nextProp))) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, (updatePayload || (updatePayload = {}))[propKey] = attributeConfig;
        } else removedKeys = null, removedKeyCount = 0, updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig), 0 < removedKeyCount && updatePayload && (restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig), removedKeys = null);
      }
    }

    for (propKey in prevProps) {
      void 0 === nextProps[propKey] && (!(attributeConfig = validAttributes[propKey]) || updatePayload && void 0 !== updatePayload[propKey] || (prevProp = prevProps[propKey], void 0 !== prevProp && ("object" !== typeof attributeConfig || "function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process ? ((updatePayload || (updatePayload = {}))[propKey] = null, removedKeys || (removedKeys = {}), removedKeys[propKey] || (removedKeys[propKey] = !0, removedKeyCount++)) : updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig))));
    }

    return updatePayload;
  }

  function mountSafeCallback(context, callback) {
    return function () {
      if (callback) {
        if ("boolean" === typeof context.__isMounted) {
          if (!context.__isMounted) return;
        } else if ("function" === typeof context.isMounted && !context.isMounted()) return;

        return callback.apply(context, arguments);
      }
    };
  }

  function getComponentName(fiber) {
    fiber = fiber.type;
    return "string" === typeof fiber ? fiber : "function" === typeof fiber ? fiber.displayName || fiber.name : null;
  }

  var debugRenderPhaseSideEffects = require(_dependencyMap[12], "ReactFeatureFlags").debugRenderPhaseSideEffects;

  function isFiberMountedImpl(fiber) {
    var node = fiber;
    if (fiber.alternate) for (; node["return"];) {
      node = node["return"];
    } else {
      if (0 !== (node.effectTag & 2)) return 1;

      for (; node["return"];) {
        if (node = node["return"], 0 !== (node.effectTag & 2)) return 1;
      }
    }
    return 3 === node.tag ? 2 : 3;
  }

  function isMounted(component) {
    return (component = component._reactInternalFiber) ? 2 === isFiberMountedImpl(component) : !1;
  }

  function assertIsMounted(fiber) {
    invariant(2 === isFiberMountedImpl(fiber), "Unable to find node on an unmounted component.");
  }

  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) return alternate = isFiberMountedImpl(fiber), invariant(3 !== alternate, "Unable to find node on an unmounted component."), 1 === alternate ? null : fiber;

    for (var a = fiber, b = alternate;;) {
      var parentA = a["return"],
          parentB = parentA ? parentA.alternate : null;
      if (!parentA || !parentB) break;

      if (parentA.child === parentB.child) {
        for (var child = parentA.child; child;) {
          if (child === a) return assertIsMounted(parentA), fiber;
          if (child === b) return assertIsMounted(parentA), alternate;
          child = child.sibling;
        }

        invariant(!1, "Unable to find node on an unmounted component.");
      }

      if (a["return"] !== b["return"]) a = parentA, b = parentB;else {
        child = !1;

        for (var _child = parentA.child; _child;) {
          if (_child === a) {
            child = !0;
            a = parentA;
            b = parentB;
            break;
          }

          if (_child === b) {
            child = !0;
            b = parentA;
            a = parentB;
            break;
          }

          _child = _child.sibling;
        }

        if (!child) {
          for (_child = parentB.child; _child;) {
            if (_child === a) {
              child = !0;
              a = parentB;
              b = parentA;
              break;
            }

            if (_child === b) {
              child = !0;
              b = parentB;
              a = parentA;
              break;
            }

            _child = _child.sibling;
          }

          invariant(child, "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
        }
      }
      invariant(a.alternate === b, "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
    }

    invariant(3 === a.tag, "Unable to find node on an unmounted component.");
    return a.stateNode.current === a ? fiber : alternate;
  }

  function findCurrentHostFiber(parent) {
    parent = findCurrentFiberUsingSlowPath(parent);
    if (!parent) return null;

    for (var node = parent;;) {
      if (5 === node.tag || 6 === node.tag) return node;
      if (node.child) node.child["return"] = node, node = node.child;else {
        if (node === parent) break;

        for (; !node.sibling;) {
          if (!node["return"] || node["return"] === parent) return null;
          node = node["return"];
        }

        node.sibling["return"] = node["return"];
        node = node.sibling;
      }
    }

    return null;
  }

  function findCurrentHostFiberWithNoPortals(parent) {
    parent = findCurrentFiberUsingSlowPath(parent);
    if (!parent) return null;

    for (var node = parent;;) {
      if (5 === node.tag || 6 === node.tag) return node;
      if (node.child && 4 !== node.tag) node.child["return"] = node, node = node.child;else {
        if (node === parent) break;

        for (; !node.sibling;) {
          if (!node["return"] || node["return"] === parent) return null;
          node = node["return"];
        }

        node.sibling["return"] = node["return"];
        node = node.sibling;
      }
    }

    return null;
  }

  var valueStack = [],
      index = -1;

  function pop(cursor) {
    0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
  }

  function push(cursor, value) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }

  new Set();
  var contextStackCursor = {
    current: emptyObject
  },
      didPerformWorkStackCursor = {
    current: !1
  },
      previousContext = emptyObject;

  function getUnmaskedContext(workInProgress) {
    return isContextProvider(workInProgress) ? previousContext : contextStackCursor.current;
  }

  function getMaskedContext(workInProgress, unmaskedContext) {
    var contextTypes = workInProgress.type.contextTypes;
    if (!contextTypes) return emptyObject;
    var instance = workInProgress.stateNode;
    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) return instance.__reactInternalMemoizedMaskedChildContext;
    var context = {},
        key;

    for (key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    instance && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
    return context;
  }

  function isContextProvider(fiber) {
    return 2 === fiber.tag && null != fiber.type.childContextTypes;
  }

  function popContextProvider(fiber) {
    isContextProvider(fiber) && (pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber));
  }

  function pushTopLevelContextObject(fiber, context, didChange) {
    invariant(null == contextStackCursor.cursor, "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }

  function processChildContext(fiber, parentContext) {
    var instance = fiber.stateNode,
        childContextTypes = fiber.type.childContextTypes;
    if ("function" !== typeof instance.getChildContext) return parentContext;
    instance = instance.getChildContext();

    for (var contextKey in instance) {
      invariant(contextKey in childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || "Unknown", contextKey);
    }

    return babelHelpers.extends({}, parentContext, instance);
  }

  function pushContextProvider(workInProgress) {
    if (!isContextProvider(workInProgress)) return !1;
    var instance = workInProgress.stateNode;
    instance = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;
    previousContext = contextStackCursor.current;
    push(contextStackCursor, instance, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
    return !0;
  }

  function invalidateContextProvider(workInProgress, didChange) {
    var instance = workInProgress.stateNode;
    invariant(instance, "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");

    if (didChange) {
      var mergedContext = processChildContext(workInProgress, previousContext);
      instance.__reactInternalMemoizedMergedChildContext = mergedContext;
      pop(didPerformWorkStackCursor, workInProgress);
      pop(contextStackCursor, workInProgress);
      push(contextStackCursor, mergedContext, workInProgress);
    } else pop(didPerformWorkStackCursor, workInProgress);

    push(didPerformWorkStackCursor, didChange, workInProgress);
  }

  function FiberNode(tag, pendingProps, key, internalContextTag) {
    this.tag = tag;
    this.key = key;
    this.stateNode = this.type = null;
    this.sibling = this.child = this["return"] = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.internalContextTag = internalContextTag;
    this.effectTag = 0;
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    this.expirationTime = 0;
    this.alternate = null;
  }

  function createFiber(tag, pendingProps, key, internalContextTag) {
    return new FiberNode(tag, pendingProps, key, internalContextTag);
  }

  function createWorkInProgress(current, pendingProps, expirationTime) {
    var workInProgress = current.alternate;
    null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.internalContextTag), workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.effectTag = 0, workInProgress.nextEffect = null, workInProgress.firstEffect = null, workInProgress.lastEffect = null);
    workInProgress.expirationTime = expirationTime;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;
    return workInProgress;
  }

  function createFiberFromElement(element, internalContextTag, expirationTime) {
    var fiber = void 0,
        type = element.type,
        key = element.key;
    element = element.props;
    "function" === typeof type ? (fiber = type.prototype && type.prototype.isReactComponent ? createFiber(2, element, key, internalContextTag) : createFiber(0, element, key, internalContextTag), fiber.type = type) : "string" === typeof type ? (fiber = createFiber(5, element, key, internalContextTag), fiber.type = type) : "object" === typeof type && null !== type && "number" === typeof type.tag ? (fiber = type, fiber.pendingProps = element) : invariant(!1, "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", null == type ? type : typeof type, "");
    fiber.expirationTime = expirationTime;
    return fiber;
  }

  function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
    elements = createFiber(10, elements, key, internalContextTag);
    elements.expirationTime = expirationTime;
    return elements;
  }

  function createFiberFromText(content, internalContextTag, expirationTime) {
    content = createFiber(6, content, null, internalContextTag);
    content.expirationTime = expirationTime;
    return content;
  }

  function createFiberFromCall(call, internalContextTag, expirationTime) {
    internalContextTag = createFiber(7, call, call.key, internalContextTag);
    internalContextTag.type = call.handler;
    internalContextTag.expirationTime = expirationTime;
    return internalContextTag;
  }

  function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
    returnNode = createFiber(9, null, null, internalContextTag);
    returnNode.expirationTime = expirationTime;
    return returnNode;
  }

  function createFiberFromPortal(portal, internalContextTag, expirationTime) {
    internalContextTag = createFiber(4, null !== portal.children ? portal.children : [], portal.key, internalContextTag);
    internalContextTag.expirationTime = expirationTime;
    internalContextTag.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return internalContextTag;
  }

  var onCommitFiberRoot = null,
      onCommitFiberUnmount = null;

  function catchErrors(fn) {
    return function (arg) {
      try {
        return fn(arg);
      } catch (err) {}
    };
  }

  function injectInternals(internals) {
    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (hook.isDisabled || !hook.supportsFiber) return !0;

    try {
      var rendererID = hook.inject(internals);
      onCommitFiberRoot = catchErrors(function (root) {
        return hook.onCommitFiberRoot(rendererID, root);
      });
      onCommitFiberUnmount = catchErrors(function (fiber) {
        return hook.onCommitFiberUnmount(rendererID, fiber);
      });
    } catch (err) {}

    return !0;
  }

  function onCommitRoot(root) {
    "function" === typeof onCommitFiberRoot && onCommitFiberRoot(root);
  }

  function onCommitUnmount(fiber) {
    "function" === typeof onCommitFiberUnmount && onCommitFiberUnmount(fiber);
  }

  function createUpdateQueue(baseState) {
    return {
      baseState: baseState,
      expirationTime: 0,
      first: null,
      last: null,
      callbackList: null,
      hasForceUpdate: !1,
      isInitialized: !1
    };
  }

  function insertUpdateIntoQueue(queue, update) {
    null === queue.last ? queue.first = queue.last = update : (queue.last.next = update, queue.last = update);
    if (0 === queue.expirationTime || queue.expirationTime > update.expirationTime) queue.expirationTime = update.expirationTime;
  }

  function insertUpdateIntoFiber(fiber, update) {
    var alternateFiber = fiber.alternate,
        queue1 = fiber.updateQueue;
    null === queue1 && (queue1 = fiber.updateQueue = createUpdateQueue(null));
    null !== alternateFiber ? (fiber = alternateFiber.updateQueue, null === fiber && (fiber = alternateFiber.updateQueue = createUpdateQueue(null))) : fiber = null;
    fiber = fiber !== queue1 ? fiber : null;
    null === fiber ? insertUpdateIntoQueue(queue1, update) : null === queue1.last || null === fiber.last ? (insertUpdateIntoQueue(queue1, update), insertUpdateIntoQueue(fiber, update)) : (insertUpdateIntoQueue(queue1, update), fiber.last = update);
  }

  function getStateFromUpdate(update, instance, prevState, props) {
    update = update.partialState;
    return "function" === typeof update ? (debugRenderPhaseSideEffects && update.call(instance, prevState, props), update.call(instance, prevState, props)) : update;
  }

  function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
    null !== current && current.updateQueue === queue && (queue = workInProgress.updateQueue = {
      baseState: queue.baseState,
      expirationTime: queue.expirationTime,
      first: queue.first,
      last: queue.last,
      isInitialized: queue.isInitialized,
      callbackList: null,
      hasForceUpdate: !1
    });
    queue.expirationTime = 0;
    queue.isInitialized ? current = queue.baseState : (current = queue.baseState = workInProgress.memoizedState, queue.isInitialized = !0);

    for (var dontMutatePrevState = !0, update = queue.first, didSkip = !1; null !== update;) {
      var updateExpirationTime = update.expirationTime;

      if (updateExpirationTime > renderExpirationTime) {
        var remainingExpirationTime = queue.expirationTime;
        if (0 === remainingExpirationTime || remainingExpirationTime > updateExpirationTime) queue.expirationTime = updateExpirationTime;
        didSkip || (didSkip = !0, queue.baseState = current);
      } else {
        didSkip || (queue.first = update.next, null === queue.first && (queue.last = null));
        if (update.isReplace) current = getStateFromUpdate(update, instance, current, props), dontMutatePrevState = !0;else if (updateExpirationTime = getStateFromUpdate(update, instance, current, props)) current = dontMutatePrevState ? babelHelpers.extends({}, current, updateExpirationTime) : babelHelpers.extends(current, updateExpirationTime), dontMutatePrevState = !1;
        update.isForced && (queue.hasForceUpdate = !0);
        null !== update.callback && (updateExpirationTime = queue.callbackList, null === updateExpirationTime && (updateExpirationTime = queue.callbackList = []), updateExpirationTime.push(update));
      }

      update = update.next;
    }

    null !== queue.callbackList ? workInProgress.effectTag |= 32 : null !== queue.first || queue.hasForceUpdate || (workInProgress.updateQueue = null);
    didSkip || (queue.baseState = current);
    return current;
  }

  function commitCallbacks(queue, context) {
    var callbackList = queue.callbackList;
    if (null !== callbackList) for (queue.callbackList = null, queue = 0; queue < callbackList.length; queue++) {
      var update = callbackList[queue],
          _callback = update.callback;
      update.callback = null;
      invariant("function" === typeof _callback, "Invalid argument passed as callback. Expected a function. Instead received: %s", _callback);

      _callback.call(context);
    }
  }

  function ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
    function adoptClassInstance(workInProgress, instance) {
      instance.updater = updater;
      workInProgress.stateNode = instance;
      instance._reactInternalFiber = workInProgress;
    }

    var updater = {
      isMounted: isMounted,
      enqueueSetState: function enqueueSetState(instance, partialState, callback) {
        instance = instance._reactInternalFiber;
        callback = void 0 === callback ? null : callback;
        var expirationTime = computeExpirationForFiber(instance);
        insertUpdateIntoFiber(instance, {
          expirationTime: expirationTime,
          partialState: partialState,
          callback: callback,
          isReplace: !1,
          isForced: !1,
          nextCallback: null,
          next: null
        });
        scheduleWork(instance, expirationTime);
      },
      enqueueReplaceState: function enqueueReplaceState(instance, state, callback) {
        instance = instance._reactInternalFiber;
        callback = void 0 === callback ? null : callback;
        var expirationTime = computeExpirationForFiber(instance);
        insertUpdateIntoFiber(instance, {
          expirationTime: expirationTime,
          partialState: state,
          callback: callback,
          isReplace: !0,
          isForced: !1,
          nextCallback: null,
          next: null
        });
        scheduleWork(instance, expirationTime);
      },
      enqueueForceUpdate: function enqueueForceUpdate(instance, callback) {
        instance = instance._reactInternalFiber;
        callback = void 0 === callback ? null : callback;
        var expirationTime = computeExpirationForFiber(instance);
        insertUpdateIntoFiber(instance, {
          expirationTime: expirationTime,
          partialState: null,
          callback: callback,
          isReplace: !1,
          isForced: !0,
          nextCallback: null,
          next: null
        });
        scheduleWork(instance, expirationTime);
      }
    };
    return {
      adoptClassInstance: adoptClassInstance,
      constructClassInstance: function constructClassInstance(workInProgress, props) {
        var ctor = workInProgress.type,
            unmaskedContext = getUnmaskedContext(workInProgress),
            needsContext = 2 === workInProgress.tag && null != workInProgress.type.contextTypes,
            context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
        props = new ctor(props, context);
        adoptClassInstance(workInProgress, props);
        needsContext && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
        return props;
      },
      mountClassInstance: function mountClassInstance(workInProgress, renderExpirationTime) {
        var current = workInProgress.alternate,
            instance = workInProgress.stateNode,
            state = instance.state || null,
            props = workInProgress.pendingProps,
            unmaskedContext = getUnmaskedContext(workInProgress);
        instance.props = props;
        instance.state = workInProgress.memoizedState = state;
        instance.refs = emptyObject;
        instance.context = getMaskedContext(workInProgress, unmaskedContext);
        null != workInProgress.type && null != workInProgress.type.prototype && !0 === workInProgress.type.prototype.unstable_isAsyncReactComponent && (workInProgress.internalContextTag |= 1);
        "function" === typeof instance.componentWillMount && (state = instance.state, instance.componentWillMount(), debugRenderPhaseSideEffects && instance.componentWillMount(), state !== instance.state && updater.enqueueReplaceState(instance, instance.state, null), state = workInProgress.updateQueue, null !== state && (instance.state = processUpdateQueue(current, workInProgress, state, instance, props, renderExpirationTime)));
        "function" === typeof instance.componentDidMount && (workInProgress.effectTag |= 4);
      },
      updateClassInstance: function updateClassInstance(current, workInProgress, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        instance.props = workInProgress.memoizedProps;
        instance.state = workInProgress.memoizedState;
        var oldProps = workInProgress.memoizedProps,
            newProps = workInProgress.pendingProps,
            oldContext = instance.context,
            newUnmaskedContext = getUnmaskedContext(workInProgress);
        newUnmaskedContext = getMaskedContext(workInProgress, newUnmaskedContext);
        "function" !== typeof instance.componentWillReceiveProps || oldProps === newProps && oldContext === newUnmaskedContext || (oldContext = instance.state, instance.componentWillReceiveProps(newProps, newUnmaskedContext), debugRenderPhaseSideEffects && instance.componentWillReceiveProps(newProps, newUnmaskedContext), instance.state !== oldContext && updater.enqueueReplaceState(instance, instance.state, null));
        oldContext = workInProgress.memoizedState;
        renderExpirationTime = null !== workInProgress.updateQueue ? processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime) : oldContext;
        if (!(oldProps !== newProps || oldContext !== renderExpirationTime || didPerformWorkStackCursor.current || null !== workInProgress.updateQueue && workInProgress.updateQueue.hasForceUpdate)) return "function" !== typeof instance.componentDidUpdate || oldProps === current.memoizedProps && oldContext === current.memoizedState || (workInProgress.effectTag |= 4), !1;
        if (null === oldProps || null !== workInProgress.updateQueue && workInProgress.updateQueue.hasForceUpdate) var shouldUpdate = !0;else {
          shouldUpdate = workInProgress.stateNode;
          var type = workInProgress.type;
          "function" === typeof shouldUpdate.shouldComponentUpdate ? (type = shouldUpdate.shouldComponentUpdate(newProps, renderExpirationTime, newUnmaskedContext), debugRenderPhaseSideEffects && shouldUpdate.shouldComponentUpdate(newProps, renderExpirationTime, newUnmaskedContext), shouldUpdate = type) : shouldUpdate = type.prototype && type.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldContext, renderExpirationTime) : !0;
        }
        shouldUpdate ? ("function" === typeof instance.componentWillUpdate && (instance.componentWillUpdate(newProps, renderExpirationTime, newUnmaskedContext), debugRenderPhaseSideEffects && instance.componentWillUpdate(newProps, renderExpirationTime, newUnmaskedContext)), "function" === typeof instance.componentDidUpdate && (workInProgress.effectTag |= 4)) : ("function" !== typeof instance.componentDidUpdate || oldProps === current.memoizedProps && oldContext === current.memoizedState || (workInProgress.effectTag |= 4), memoizeProps(workInProgress, newProps), memoizeState(workInProgress, renderExpirationTime));
        instance.props = newProps;
        instance.state = renderExpirationTime;
        instance.context = newUnmaskedContext;
        return shouldUpdate;
      }
    };
  }

  var isArray$1 = Array.isArray;

  function coerceRef(current, element) {
    var mixedRef = element.ref;

    if (null !== mixedRef && "function" !== typeof mixedRef) {
      if (element._owner) {
        element = element._owner;
        var inst = void 0;
        element && (invariant(2 === element.tag, "Stateless function components cannot have refs."), inst = element.stateNode);
        invariant(inst, "Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.", mixedRef);
        var stringRef = "" + mixedRef;
        if (null !== current && null !== current.ref && current.ref._stringRef === stringRef) return current.ref;

        current = function current(value) {
          var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
          null === value ? delete refs[stringRef] : refs[stringRef] = value;
        };

        current._stringRef = stringRef;
        return current;
      }

      invariant("string" === typeof mixedRef, "Expected ref to be a function or a string.");
      invariant(element._owner, "Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).", mixedRef);
    }

    return mixedRef;
  }

  function throwOnInvalidObjectType(returnFiber, newChild) {
    "textarea" !== returnFiber.type && invariant(!1, "Objects are not valid as a React child (found: %s).%s", "[object Object]" === Object.prototype.toString.call(newChild) ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, "");
  }

  function ChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var last = returnFiber.lastEffect;
        null !== last ? (last.nextEffect = childToDelete, returnFiber.lastEffect = childToDelete) : returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        childToDelete.nextEffect = null;
        childToDelete.effectTag = 8;
      }
    }

    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;

      for (; null !== currentFirstChild;) {
        deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return null;
    }

    function mapRemainingChildren(returnFiber, currentFirstChild) {
      for (returnFiber = new Map(); null !== currentFirstChild;) {
        null !== currentFirstChild.key ? returnFiber.set(currentFirstChild.key, currentFirstChild) : returnFiber.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return returnFiber;
    }

    function useFiber(fiber, pendingProps, expirationTime) {
      fiber = createWorkInProgress(fiber, pendingProps, expirationTime);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }

    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) return lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.effectTag = 2, lastPlacedIndex) : newIndex;
      newFiber.effectTag = 2;
      return lastPlacedIndex;
    }

    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.effectTag = 2);
      return newFiber;
    }

    function updateTextNode(returnFiber, current, textContent, expirationTime) {
      if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime), current["return"] = returnFiber, current;
      current = useFiber(current, textContent, expirationTime);
      current["return"] = returnFiber;
      return current;
    }

    function updateElement(returnFiber, current, element, expirationTime) {
      if (null !== current && current.type === element.type) return expirationTime = useFiber(current, element.props, expirationTime), expirationTime.ref = coerceRef(current, element), expirationTime["return"] = returnFiber, expirationTime;
      expirationTime = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      expirationTime.ref = coerceRef(current, element);
      expirationTime["return"] = returnFiber;
      return expirationTime;
    }

    function updateCall(returnFiber, current, call, expirationTime) {
      if (null === current || 7 !== current.tag) return current = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime), current["return"] = returnFiber, current;
      current = useFiber(current, call, expirationTime);
      current["return"] = returnFiber;
      return current;
    }

    function updateReturn(returnFiber, current, returnNode, expirationTime) {
      if (null === current || 9 !== current.tag) return current = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime), current.type = returnNode.value, current["return"] = returnFiber, current;
      current = useFiber(current, null, expirationTime);
      current.type = returnNode.value;
      current["return"] = returnFiber;
      return current;
    }

    function updatePortal(returnFiber, current, portal, expirationTime) {
      if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime), current["return"] = returnFiber, current;
      current = useFiber(current, portal.children || [], expirationTime);
      current["return"] = returnFiber;
      return current;
    }

    function updateFragment(returnFiber, current, fragment, expirationTime, key) {
      if (null === current || 10 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key), current["return"] = returnFiber, current;
      current = useFiber(current, fragment, expirationTime);
      current["return"] = returnFiber;
      return current;
    }

    function createChild(returnFiber, newChild, expirationTime) {
      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.internalContextTag, expirationTime), newChild["return"] = returnFiber, newChild;

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            if (newChild.type === REACT_FRAGMENT_TYPE) return newChild = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key), newChild["return"] = returnFiber, newChild;
            expirationTime = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
            expirationTime.ref = coerceRef(null, newChild);
            expirationTime["return"] = returnFiber;
            return expirationTime;

          case REACT_CALL_TYPE:
            return newChild = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime), newChild["return"] = returnFiber, newChild;

          case REACT_RETURN_TYPE:
            return expirationTime = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime), expirationTime.type = newChild.value, expirationTime["return"] = returnFiber, expirationTime;

          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime), newChild["return"] = returnFiber, newChild;
        }

        if (isArray$1(newChild) || getIteratorFn(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null), newChild["return"] = returnFiber, newChild;
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild || "number" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? newChild.type === REACT_FRAGMENT_TYPE ? updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key) : updateElement(returnFiber, oldFiber, newChild, expirationTime) : null;

          case REACT_CALL_TYPE:
            return newChild.key === key ? updateCall(returnFiber, oldFiber, newChild, expirationTime) : null;

          case REACT_RETURN_TYPE:
            return null === key ? updateReturn(returnFiber, oldFiber, newChild, expirationTime) : null;

          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, expirationTime) : null;
        }

        if (isArray$1(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
      if ("string" === typeof newChild || "number" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, expirationTime);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, newChild.type === REACT_FRAGMENT_TYPE ? updateFragment(returnFiber, existingChildren, newChild.props.children, expirationTime, newChild.key) : updateElement(returnFiber, existingChildren, newChild, expirationTime);

          case REACT_CALL_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updateCall(returnFiber, existingChildren, newChild, expirationTime);

          case REACT_RETURN_TYPE:
            return existingChildren = existingChildren.get(newIdx) || null, updateReturn(returnFiber, existingChildren, newChild, expirationTime);

          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, expirationTime);
        }

        if (isArray$1(newChild) || getIteratorFn(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, expirationTime, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild;

      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++) {
          if (oldFiber = createChild(returnFiber, newChildren[newIdx], expirationTime)) currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber;
        }

        return resultingFirstChild;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); newIdx < newChildren.length; newIdx++) {
        if (nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], expirationTime)) {
          if (shouldTrackSideEffects && null !== nextOldFiber.alternate) oldFiber["delete"](null === nextOldFiber.key ? newIdx : nextOldFiber.key);
          currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber;
          previousNewFiber = nextOldFiber;
        }
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return resultingFirstChild;
    }

    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
      var iteratorFn = getIteratorFn(newChildrenIterable);
      invariant("function" === typeof iteratorFn, "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
      newChildrenIterable = iteratorFn.call(newChildrenIterable);
      invariant(null != newChildrenIterable, "An iterable object provided no iterator.");

      for (var previousNewFiber = iteratorFn = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildrenIterable.next(); null !== oldFiber && !step.done; newIdx++, step = newChildrenIterable.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

        if (null === newFiber) {
          oldFiber || (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? iteratorFn = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;

      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildrenIterable.next()) {
          step = createChild(returnFiber, step.value, expirationTime), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step, previousNewFiber = step);
        }

        return iteratorFn;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); !step.done; newIdx++, step = newChildrenIterable.next()) {
        if (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, expirationTime), null !== step) {
          if (shouldTrackSideEffects && null !== step.alternate) oldFiber["delete"](null === step.key ? newIdx : step.key);
          currentFirstChild = placeChild(step, currentFirstChild, newIdx);
          null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step;
          previousNewFiber = step;
        }
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return iteratorFn;
    }

    return function (returnFiber, currentFirstChild, newChild, expirationTime) {
      "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
      var isObject = "object" === typeof newChild && null !== newChild;
      if (isObject) switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            var key = newChild.key;

            for (isObject = currentFirstChild; null !== isObject;) {
              if (isObject.key === key) {
                if (10 === isObject.tag ? newChild.type === REACT_FRAGMENT_TYPE : isObject.type === newChild.type) {
                  deleteRemainingChildren(returnFiber, isObject.sibling);
                  currentFirstChild = useFiber(isObject, newChild.type === REACT_FRAGMENT_TYPE ? newChild.props.children : newChild.props, expirationTime);
                  currentFirstChild.ref = coerceRef(isObject, newChild);
                  currentFirstChild["return"] = returnFiber;
                  returnFiber = currentFirstChild;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, isObject);
                  break;
                }
              } else deleteChild(returnFiber, isObject);
              isObject = isObject.sibling;
            }

            newChild.type === REACT_FRAGMENT_TYPE ? (currentFirstChild = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key), currentFirstChild["return"] = returnFiber, returnFiber = currentFirstChild) : (expirationTime = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime), expirationTime.ref = coerceRef(currentFirstChild, newChild), expirationTime["return"] = returnFiber, returnFiber = expirationTime);
          }

          return placeSingleChild(returnFiber);

        case REACT_CALL_TYPE:
          a: {
            for (isObject = newChild.key; null !== currentFirstChild;) {
              if (currentFirstChild.key === isObject) {
                if (7 === currentFirstChild.tag) {
                  deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                  currentFirstChild = useFiber(currentFirstChild, newChild, expirationTime);
                  currentFirstChild["return"] = returnFiber;
                  returnFiber = currentFirstChild;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }

            currentFirstChild = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
            currentFirstChild["return"] = returnFiber;
            returnFiber = currentFirstChild;
          }

          return placeSingleChild(returnFiber);

        case REACT_RETURN_TYPE:
          a: {
            if (null !== currentFirstChild) if (9 === currentFirstChild.tag) {
              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
              currentFirstChild = useFiber(currentFirstChild, null, expirationTime);
              currentFirstChild.type = newChild.value;
              currentFirstChild["return"] = returnFiber;
              returnFiber = currentFirstChild;
              break a;
            } else deleteRemainingChildren(returnFiber, currentFirstChild);
            currentFirstChild = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
            currentFirstChild.type = newChild.value;
            currentFirstChild["return"] = returnFiber;
            returnFiber = currentFirstChild;
          }

          return placeSingleChild(returnFiber);

        case REACT_PORTAL_TYPE:
          a: {
            for (isObject = newChild.key; null !== currentFirstChild;) {
              if (currentFirstChild.key === isObject) {
                if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                  deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                  currentFirstChild = useFiber(currentFirstChild, newChild.children || [], expirationTime);
                  currentFirstChild["return"] = returnFiber;
                  returnFiber = currentFirstChild;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }

            currentFirstChild = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
            currentFirstChild["return"] = returnFiber;
            returnFiber = currentFirstChild;
          }

          return placeSingleChild(returnFiber);
      }
      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), currentFirstChild = useFiber(currentFirstChild, newChild, expirationTime)) : (deleteRemainingChildren(returnFiber, currentFirstChild), currentFirstChild = createFiberFromText(newChild, returnFiber.internalContextTag, expirationTime)), currentFirstChild["return"] = returnFiber, returnFiber = currentFirstChild, placeSingleChild(returnFiber);
      if (isArray$1(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
      if (getIteratorFn(newChild)) return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
      isObject && throwOnInvalidObjectType(returnFiber, newChild);
      if ("undefined" === typeof newChild) switch (returnFiber.tag) {
        case 2:
        case 1:
          expirationTime = returnFiber.type, invariant(!1, "%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.", expirationTime.displayName || expirationTime.name || "Component");
      }
      return deleteRemainingChildren(returnFiber, currentFirstChild);
    };
  }

  var reconcileChildFibers = ChildReconciler(!0),
      mountChildFibers = ChildReconciler(!1);

  function ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
    function reconcileChildren(current, workInProgress, nextChildren) {
      var renderExpirationTime = workInProgress.expirationTime;
      workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
    }

    function markRef(current, workInProgress) {
      var ref = workInProgress.ref;
      null === ref || current && current.ref === ref || (workInProgress.effectTag |= 128);
    }

    function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
      markRef(current, workInProgress);
      if (!shouldUpdate) return hasContext && invalidateContextProvider(workInProgress, !1), bailoutOnAlreadyFinishedWork(current, workInProgress);
      shouldUpdate = workInProgress.stateNode;
      ReactCurrentOwner.current = workInProgress;
      debugRenderPhaseSideEffects && shouldUpdate.render();
      var nextChildren = shouldUpdate.render();
      workInProgress.effectTag |= 1;
      reconcileChildren(current, workInProgress, nextChildren);
      workInProgress.memoizedState = shouldUpdate.state;
      workInProgress.memoizedProps = shouldUpdate.props;
      hasContext && invalidateContextProvider(workInProgress, !0);
      return workInProgress.child;
    }

    function pushHostRootContext(workInProgress) {
      var root = workInProgress.stateNode;
      root.pendingContext ? pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context) : root.context && pushTopLevelContextObject(workInProgress, root.context, !1);
      pushHostContainer(workInProgress, root.containerInfo);
    }

    function bailoutOnAlreadyFinishedWork(current, workInProgress) {
      invariant(null === current || workInProgress.child === current.child, "Resuming work not yet implemented.");

      if (null !== workInProgress.child) {
        current = workInProgress.child;
        var newChild = createWorkInProgress(current, current.pendingProps, current.expirationTime);
        workInProgress.child = newChild;

        for (newChild["return"] = workInProgress; null !== current.sibling;) {
          current = current.sibling, newChild = newChild.sibling = createWorkInProgress(current, current.pendingProps, current.expirationTime), newChild["return"] = workInProgress;
        }

        newChild.sibling = null;
      }

      return workInProgress.child;
    }

    function bailoutOnLowPriority(current, workInProgress) {
      switch (workInProgress.tag) {
        case 3:
          pushHostRootContext(workInProgress);
          break;

        case 2:
          pushContextProvider(workInProgress);
          break;

        case 4:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      }

      return null;
    }

    var shouldSetTextContent = config.shouldSetTextContent,
        useSyncScheduling = config.useSyncScheduling,
        shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree,
        pushHostContext = hostContext.pushHostContext,
        pushHostContainer = hostContext.pushHostContainer,
        enterHydrationState = hydrationContext.enterHydrationState,
        resetHydrationState = hydrationContext.resetHydrationState,
        tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;
    config = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, function (workInProgress, nextProps) {
      workInProgress.memoizedProps = nextProps;
    }, function (workInProgress, nextState) {
      workInProgress.memoizedState = nextState;
    });
    var adoptClassInstance = config.adoptClassInstance,
        constructClassInstance = config.constructClassInstance,
        mountClassInstance = config.mountClassInstance,
        updateClassInstance = config.updateClassInstance;
    return {
      beginWork: function beginWork(current, workInProgress, renderExpirationTime) {
        if (0 === workInProgress.expirationTime || workInProgress.expirationTime > renderExpirationTime) return bailoutOnLowPriority(current, workInProgress);

        switch (workInProgress.tag) {
          case 0:
            invariant(null === current, "An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.");
            var fn = workInProgress.type,
                props = workInProgress.pendingProps,
                unmaskedContext = getUnmaskedContext(workInProgress);
            unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
            fn = fn(props, unmaskedContext);
            workInProgress.effectTag |= 1;
            "object" === typeof fn && null !== fn && "function" === typeof fn.render ? (workInProgress.tag = 2, props = pushContextProvider(workInProgress), adoptClassInstance(workInProgress, fn), mountClassInstance(workInProgress, renderExpirationTime), current = finishClassComponent(current, workInProgress, !0, props)) : (workInProgress.tag = 1, reconcileChildren(current, workInProgress, fn), workInProgress.memoizedProps = props, current = workInProgress.child);
            return current;

          case 1:
            return props = workInProgress.type, renderExpirationTime = workInProgress.pendingProps, didPerformWorkStackCursor.current || workInProgress.memoizedProps !== renderExpirationTime ? (fn = getUnmaskedContext(workInProgress), fn = getMaskedContext(workInProgress, fn), props = props(renderExpirationTime, fn), workInProgress.effectTag |= 1, reconcileChildren(current, workInProgress, props), workInProgress.memoizedProps = renderExpirationTime, current = workInProgress.child) : current = bailoutOnAlreadyFinishedWork(current, workInProgress), current;

          case 2:
            return props = pushContextProvider(workInProgress), fn = void 0, null === current ? workInProgress.stateNode ? invariant(!1, "Resuming work not yet implemented.") : (constructClassInstance(workInProgress, workInProgress.pendingProps), mountClassInstance(workInProgress, renderExpirationTime), fn = !0) : fn = updateClassInstance(current, workInProgress, renderExpirationTime), finishClassComponent(current, workInProgress, fn, props);

          case 3:
            return pushHostRootContext(workInProgress), props = workInProgress.updateQueue, null !== props ? (fn = workInProgress.memoizedState, props = processUpdateQueue(current, workInProgress, props, null, null, renderExpirationTime), fn === props ? (resetHydrationState(), current = bailoutOnAlreadyFinishedWork(current, workInProgress)) : (fn = props.element, unmaskedContext = workInProgress.stateNode, (null === current || null === current.child) && unmaskedContext.hydrate && enterHydrationState(workInProgress) ? (workInProgress.effectTag |= 2, workInProgress.child = mountChildFibers(workInProgress, null, fn, renderExpirationTime)) : (resetHydrationState(), reconcileChildren(current, workInProgress, fn)), workInProgress.memoizedState = props, current = workInProgress.child)) : (resetHydrationState(), current = bailoutOnAlreadyFinishedWork(current, workInProgress)), current;

          case 5:
            pushHostContext(workInProgress);
            null === current && tryToClaimNextHydratableInstance(workInProgress);
            props = workInProgress.type;
            var memoizedProps = workInProgress.memoizedProps;
            fn = workInProgress.pendingProps;
            unmaskedContext = null !== current ? current.memoizedProps : null;
            didPerformWorkStackCursor.current || memoizedProps !== fn ? (memoizedProps = fn.children, shouldSetTextContent(props, fn) ? memoizedProps = null : unmaskedContext && shouldSetTextContent(props, unmaskedContext) && (workInProgress.effectTag |= 16), markRef(current, workInProgress), 2147483647 !== renderExpirationTime && !useSyncScheduling && shouldDeprioritizeSubtree(props, fn) ? (workInProgress.expirationTime = 2147483647, current = null) : (reconcileChildren(current, workInProgress, memoizedProps), workInProgress.memoizedProps = fn, current = workInProgress.child)) : current = bailoutOnAlreadyFinishedWork(current, workInProgress);
            return current;

          case 6:
            return null === current && tryToClaimNextHydratableInstance(workInProgress), workInProgress.memoizedProps = workInProgress.pendingProps, null;

          case 8:
            workInProgress.tag = 7;

          case 7:
            return props = workInProgress.pendingProps, didPerformWorkStackCursor.current || workInProgress.memoizedProps !== props || (props = workInProgress.memoizedProps), fn = props.children, workInProgress.stateNode = null === current ? mountChildFibers(workInProgress, workInProgress.stateNode, fn, renderExpirationTime) : reconcileChildFibers(workInProgress, workInProgress.stateNode, fn, renderExpirationTime), workInProgress.memoizedProps = props, workInProgress.stateNode;

          case 9:
            return null;

          case 4:
            return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), props = workInProgress.pendingProps, didPerformWorkStackCursor.current || workInProgress.memoizedProps !== props ? (null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, props, renderExpirationTime) : reconcileChildren(current, workInProgress, props), workInProgress.memoizedProps = props, current = workInProgress.child) : current = bailoutOnAlreadyFinishedWork(current, workInProgress), current;

          case 10:
            return renderExpirationTime = workInProgress.pendingProps, didPerformWorkStackCursor.current || null !== renderExpirationTime && workInProgress.memoizedProps !== renderExpirationTime ? (reconcileChildren(current, workInProgress, renderExpirationTime), workInProgress.memoizedProps = renderExpirationTime, current = workInProgress.child) : current = bailoutOnAlreadyFinishedWork(current, workInProgress), current;

          default:
            invariant(!1, "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.");
        }
      },
      beginFailedWork: function beginFailedWork(current, workInProgress, renderExpirationTime) {
        switch (workInProgress.tag) {
          case 2:
            pushContextProvider(workInProgress);
            break;

          case 3:
            pushHostRootContext(workInProgress);
            break;

          default:
            invariant(!1, "Invalid type of work. This error is likely caused by a bug in React. Please file an issue.");
        }

        workInProgress.effectTag |= 64;
        null === current ? workInProgress.child = null : workInProgress.child !== current.child && (workInProgress.child = current.child);
        if (0 === workInProgress.expirationTime || workInProgress.expirationTime > renderExpirationTime) return bailoutOnLowPriority(current, workInProgress);
        workInProgress.firstEffect = null;
        workInProgress.lastEffect = null;
        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, null, renderExpirationTime) : reconcileChildFibers(workInProgress, current.child, null, renderExpirationTime);
        2 === workInProgress.tag && (current = workInProgress.stateNode, workInProgress.memoizedProps = current.props, workInProgress.memoizedState = current.state);
        return workInProgress.child;
      }
    };
  }

  function ReactFiberCompleteWork(config, hostContext, hydrationContext) {
    function markUpdate(workInProgress) {
      workInProgress.effectTag |= 4;
    }

    var createInstance = config.createInstance,
        createTextInstance = config.createTextInstance,
        appendInitialChild = config.appendInitialChild,
        finalizeInitialChildren = config.finalizeInitialChildren,
        prepareUpdate = config.prepareUpdate,
        persistence = config.persistence,
        getRootHostContainer = hostContext.getRootHostContainer,
        popHostContext = hostContext.popHostContext,
        getHostContext = hostContext.getHostContext,
        popHostContainer = hostContext.popHostContainer,
        prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
        prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
        popHydrationState = hydrationContext.popHydrationState,
        updateHostContainer = void 0,
        updateHostComponent = void 0,
        updateHostText = void 0;
    config.mutation ? (updateHostContainer = function updateHostContainer() {}, updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload) {
      (workInProgress.updateQueue = updatePayload) && markUpdate(workInProgress);
    }, updateHostText = function updateHostText(current, workInProgress, oldText, newText) {
      oldText !== newText && markUpdate(workInProgress);
    }) : persistence ? invariant(!1, "Persistent reconciler is disabled.") : invariant(!1, "Noop reconciler is disabled.");
    return {
      completeWork: function completeWork(current, workInProgress, renderExpirationTime) {
        var newProps = workInProgress.pendingProps;

        switch (workInProgress.tag) {
          case 1:
            return null;

          case 2:
            return popContextProvider(workInProgress), null;

          case 3:
            popHostContainer(workInProgress);
            pop(didPerformWorkStackCursor, workInProgress);
            pop(contextStackCursor, workInProgress);
            newProps = workInProgress.stateNode;
            newProps.pendingContext && (newProps.context = newProps.pendingContext, newProps.pendingContext = null);
            if (null === current || null === current.child) popHydrationState(workInProgress), workInProgress.effectTag &= -3;
            updateHostContainer(workInProgress);
            return null;

          case 5:
            popHostContext(workInProgress);
            renderExpirationTime = getRootHostContainer();
            var type = workInProgress.type;

            if (null !== current && null != workInProgress.stateNode) {
              var oldProps = current.memoizedProps,
                  instance = workInProgress.stateNode,
                  currentHostContext = getHostContext();
              instance = prepareUpdate(instance, type, oldProps, newProps, renderExpirationTime, currentHostContext);
              updateHostComponent(current, workInProgress, instance, type, oldProps, newProps, renderExpirationTime);
              current.ref !== workInProgress.ref && (workInProgress.effectTag |= 128);
            } else {
              if (!newProps) return invariant(null !== workInProgress.stateNode, "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."), null;
              current = getHostContext();
              if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress, renderExpirationTime, current) && markUpdate(workInProgress);else {
                current = createInstance(type, newProps, renderExpirationTime, current, workInProgress);

                a: for (oldProps = workInProgress.child; null !== oldProps;) {
                  if (5 === oldProps.tag || 6 === oldProps.tag) appendInitialChild(current, oldProps.stateNode);else if (4 !== oldProps.tag && null !== oldProps.child) {
                    oldProps.child["return"] = oldProps;
                    oldProps = oldProps.child;
                    continue;
                  }
                  if (oldProps === workInProgress) break;

                  for (; null === oldProps.sibling;) {
                    if (null === oldProps["return"] || oldProps["return"] === workInProgress) break a;
                    oldProps = oldProps["return"];
                  }

                  oldProps.sibling["return"] = oldProps["return"];
                  oldProps = oldProps.sibling;
                }

                finalizeInitialChildren(current, type, newProps, renderExpirationTime) && markUpdate(workInProgress);
                workInProgress.stateNode = current;
              }
              null !== workInProgress.ref && (workInProgress.effectTag |= 128);
            }

            return null;

          case 6:
            if (current && null != workInProgress.stateNode) updateHostText(current, workInProgress, current.memoizedProps, newProps);else {
              if ("string" !== typeof newProps) return invariant(null !== workInProgress.stateNode, "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."), null;
              current = getRootHostContainer();
              renderExpirationTime = getHostContext();
              popHydrationState(workInProgress) ? prepareToHydrateHostTextInstance(workInProgress) && markUpdate(workInProgress) : workInProgress.stateNode = createTextInstance(newProps, current, renderExpirationTime, workInProgress);
            }
            return null;

          case 7:
            newProps = workInProgress.memoizedProps;
            invariant(newProps, "Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.");
            workInProgress.tag = 8;
            type = [];

            a: for ((oldProps = workInProgress.stateNode) && (oldProps["return"] = workInProgress); null !== oldProps;) {
              if (5 === oldProps.tag || 6 === oldProps.tag || 4 === oldProps.tag) invariant(!1, "A call cannot have host component children.");else if (9 === oldProps.tag) type.push(oldProps.type);else if (null !== oldProps.child) {
                oldProps.child["return"] = oldProps;
                oldProps = oldProps.child;
                continue;
              }

              for (; null === oldProps.sibling;) {
                if (null === oldProps["return"] || oldProps["return"] === workInProgress) break a;
                oldProps = oldProps["return"];
              }

              oldProps.sibling["return"] = oldProps["return"];
              oldProps = oldProps.sibling;
            }

            oldProps = newProps.handler;
            newProps = oldProps(newProps.props, type);
            workInProgress.child = reconcileChildFibers(workInProgress, null !== current ? current.child : null, newProps, renderExpirationTime);
            return workInProgress.child;

          case 8:
            return workInProgress.tag = 7, null;

          case 9:
            return null;

          case 10:
            return null;

          case 4:
            return popHostContainer(workInProgress), updateHostContainer(workInProgress), null;

          case 0:
            invariant(!1, "An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.");

          default:
            invariant(!1, "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    };
  }

  function ReactFiberCommitWork(config, captureError) {
    function safelyDetachRef(current) {
      var ref = current.ref;
      if (null !== ref) try {
        ref(null);
      } catch (refError) {
        captureError(current, refError);
      }
    }

    function commitUnmount(current) {
      "function" === typeof onCommitUnmount && onCommitUnmount(current);

      switch (current.tag) {
        case 2:
          safelyDetachRef(current);
          var instance = current.stateNode;
          if ("function" === typeof instance.componentWillUnmount) try {
            instance.props = current.memoizedProps, instance.state = current.memoizedState, instance.componentWillUnmount();
          } catch (unmountError) {
            captureError(current, unmountError);
          }
          break;

        case 5:
          safelyDetachRef(current);
          break;

        case 7:
          commitNestedUnmounts(current.stateNode);
          break;

        case 4:
          mutation && unmountHostComponents(current);
      }
    }

    function commitNestedUnmounts(root) {
      for (var node = root;;) {
        if (commitUnmount(node), null === node.child || mutation && 4 === node.tag) {
          if (node === root) break;

          for (; null === node.sibling;) {
            if (null === node["return"] || node["return"] === root) return;
            node = node["return"];
          }

          node.sibling["return"] = node["return"];
          node = node.sibling;
        } else node.child["return"] = node, node = node.child;
      }
    }

    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
    }

    function unmountHostComponents(current) {
      for (var node = current, currentParentIsValid = !1, currentParent = void 0, currentParentIsContainer = void 0;;) {
        if (!currentParentIsValid) {
          currentParentIsValid = node["return"];

          a: for (;;) {
            invariant(null !== currentParentIsValid, "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");

            switch (currentParentIsValid.tag) {
              case 5:
                currentParent = currentParentIsValid.stateNode;
                currentParentIsContainer = !1;
                break a;

              case 3:
                currentParent = currentParentIsValid.stateNode.containerInfo;
                currentParentIsContainer = !0;
                break a;

              case 4:
                currentParent = currentParentIsValid.stateNode.containerInfo;
                currentParentIsContainer = !0;
                break a;
            }

            currentParentIsValid = currentParentIsValid["return"];
          }

          currentParentIsValid = !0;
        }

        if (5 === node.tag || 6 === node.tag) commitNestedUnmounts(node), currentParentIsContainer ? removeChildFromContainer(currentParent, node.stateNode) : removeChild(currentParent, node.stateNode);else if (4 === node.tag ? currentParent = node.stateNode.containerInfo : commitUnmount(node), null !== node.child) {
          node.child["return"] = node;
          node = node.child;
          continue;
        }
        if (node === current) break;

        for (; null === node.sibling;) {
          if (null === node["return"] || node["return"] === current) return;
          node = node["return"];
          4 === node.tag && (currentParentIsValid = !1);
        }

        node.sibling["return"] = node["return"];
        node = node.sibling;
      }
    }

    var getPublicInstance = config.getPublicInstance,
        mutation = config.mutation;
    config = config.persistence;
    mutation || (config ? invariant(!1, "Persistent reconciler is disabled.") : invariant(!1, "Noop reconciler is disabled."));
    var commitMount = mutation.commitMount,
        commitUpdate = mutation.commitUpdate,
        resetTextContent = mutation.resetTextContent,
        commitTextUpdate = mutation.commitTextUpdate,
        appendChild = mutation.appendChild,
        appendChildToContainer = mutation.appendChildToContainer,
        insertBefore = mutation.insertBefore,
        insertInContainerBefore = mutation.insertInContainerBefore,
        removeChild = mutation.removeChild,
        removeChildFromContainer = mutation.removeChildFromContainer;
    return {
      commitResetTextContent: function commitResetTextContent(current) {
        resetTextContent(current.stateNode);
      },
      commitPlacement: function commitPlacement(finishedWork) {
        a: {
          for (var parent = finishedWork["return"]; null !== parent;) {
            if (isHostParent(parent)) {
              var parentFiber = parent;
              break a;
            }

            parent = parent["return"];
          }

          invariant(!1, "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          parentFiber = void 0;
        }

        var isContainer = parent = void 0;

        switch (parentFiber.tag) {
          case 5:
            parent = parentFiber.stateNode;
            isContainer = !1;
            break;

          case 3:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = !0;
            break;

          case 4:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = !0;
            break;

          default:
            invariant(!1, "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }

        parentFiber.effectTag & 16 && (resetTextContent(parent), parentFiber.effectTag &= -17);

        a: b: for (parentFiber = finishedWork;;) {
          for (; null === parentFiber.sibling;) {
            if (null === parentFiber["return"] || isHostParent(parentFiber["return"])) {
              parentFiber = null;
              break a;
            }

            parentFiber = parentFiber["return"];
          }

          parentFiber.sibling["return"] = parentFiber["return"];

          for (parentFiber = parentFiber.sibling; 5 !== parentFiber.tag && 6 !== parentFiber.tag;) {
            if (parentFiber.effectTag & 2) continue b;
            if (null === parentFiber.child || 4 === parentFiber.tag) continue b;else parentFiber.child["return"] = parentFiber, parentFiber = parentFiber.child;
          }

          if (!(parentFiber.effectTag & 2)) {
            parentFiber = parentFiber.stateNode;
            break a;
          }
        }

        for (var node = finishedWork;;) {
          if (5 === node.tag || 6 === node.tag) parentFiber ? isContainer ? insertInContainerBefore(parent, node.stateNode, parentFiber) : insertBefore(parent, node.stateNode, parentFiber) : isContainer ? appendChildToContainer(parent, node.stateNode) : appendChild(parent, node.stateNode);else if (4 !== node.tag && null !== node.child) {
            node.child["return"] = node;
            node = node.child;
            continue;
          }
          if (node === finishedWork) break;

          for (; null === node.sibling;) {
            if (null === node["return"] || node["return"] === finishedWork) return;
            node = node["return"];
          }

          node.sibling["return"] = node["return"];
          node = node.sibling;
        }
      },
      commitDeletion: function commitDeletion(current) {
        unmountHostComponents(current);
        current["return"] = null;
        current.child = null;
        current.alternate && (current.alternate.child = null, current.alternate["return"] = null);
      },
      commitWork: function commitWork(current, finishedWork) {
        switch (finishedWork.tag) {
          case 2:
            break;

          case 5:
            var instance = finishedWork.stateNode;

            if (null != instance) {
              var newProps = finishedWork.memoizedProps;
              current = null !== current ? current.memoizedProps : newProps;
              var type = finishedWork.type,
                  updatePayload = finishedWork.updateQueue;
              finishedWork.updateQueue = null;
              null !== updatePayload && commitUpdate(instance, updatePayload, type, current, newProps, finishedWork);
            }

            break;

          case 6:
            invariant(null !== finishedWork.stateNode, "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            instance = finishedWork.memoizedProps;
            commitTextUpdate(finishedWork.stateNode, null !== current ? current.memoizedProps : instance, instance);
            break;

          case 3:
            break;

          default:
            invariant(!1, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      },
      commitLifeCycles: function commitLifeCycles(current, finishedWork) {
        switch (finishedWork.tag) {
          case 2:
            var instance = finishedWork.stateNode;
            if (finishedWork.effectTag & 4) if (null === current) instance.props = finishedWork.memoizedProps, instance.state = finishedWork.memoizedState, instance.componentDidMount();else {
              var prevProps = current.memoizedProps;
              current = current.memoizedState;
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidUpdate(prevProps, current);
            }
            finishedWork = finishedWork.updateQueue;
            null !== finishedWork && commitCallbacks(finishedWork, instance);
            break;

          case 3:
            instance = finishedWork.updateQueue;
            null !== instance && commitCallbacks(instance, null !== finishedWork.child ? finishedWork.child.stateNode : null);
            break;

          case 5:
            instance = finishedWork.stateNode;
            null === current && finishedWork.effectTag & 4 && commitMount(instance, finishedWork.type, finishedWork.memoizedProps, finishedWork);
            break;

          case 6:
            break;

          case 4:
            break;

          default:
            invariant(!1, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      },
      commitAttachRef: function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;

        if (null !== ref) {
          var instance = finishedWork.stateNode;

          switch (finishedWork.tag) {
            case 5:
              ref(getPublicInstance(instance));
              break;

            default:
              ref(instance);
          }
        }
      },
      commitDetachRef: function commitDetachRef(current) {
        current = current.ref;
        null !== current && current(null);
      }
    };
  }

  var NO_CONTEXT = {};

  function ReactFiberHostContext(config) {
    function requiredContext(c) {
      invariant(c !== NO_CONTEXT, "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }

    var getChildHostContext = config.getChildHostContext,
        getRootHostContext = config.getRootHostContext,
        contextStackCursor = {
      current: NO_CONTEXT
    },
        contextFiberStackCursor = {
      current: NO_CONTEXT
    },
        rootInstanceStackCursor = {
      current: NO_CONTEXT
    };
    return {
      getHostContext: function getHostContext() {
        return requiredContext(contextStackCursor.current);
      },
      getRootHostContainer: function getRootHostContainer() {
        return requiredContext(rootInstanceStackCursor.current);
      },
      popHostContainer: function popHostContainer(fiber) {
        pop(contextStackCursor, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      },
      popHostContext: function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      },
      pushHostContainer: function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        nextRootInstance = getRootHostContext(nextRootInstance);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor, nextRootInstance, fiber);
      },
      pushHostContext: function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current),
            context = requiredContext(contextStackCursor.current);
        rootInstance = getChildHostContext(context, fiber.type, rootInstance);
        context !== rootInstance && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, rootInstance, fiber));
      },
      resetHostContainer: function resetHostContainer() {
        contextStackCursor.current = NO_CONTEXT;
        rootInstanceStackCursor.current = NO_CONTEXT;
      }
    };
  }

  function ReactFiberHydrationContext(config) {
    function deleteHydratableInstance(returnFiber, instance) {
      var fiber = createFiber(5, null, null, 0);
      fiber.type = "DELETED";
      fiber.stateNode = instance;
      fiber["return"] = returnFiber;
      fiber.effectTag = 8;
      null !== returnFiber.lastEffect ? (returnFiber.lastEffect.nextEffect = fiber, returnFiber.lastEffect = fiber) : returnFiber.firstEffect = returnFiber.lastEffect = fiber;
    }

    function tryHydrate(fiber, nextInstance) {
      switch (fiber.tag) {
        case 5:
          return nextInstance = canHydrateInstance(nextInstance, fiber.type, fiber.pendingProps), null !== nextInstance ? (fiber.stateNode = nextInstance, !0) : !1;

        case 6:
          return nextInstance = canHydrateTextInstance(nextInstance, fiber.pendingProps), null !== nextInstance ? (fiber.stateNode = nextInstance, !0) : !1;

        default:
          return !1;
      }
    }

    function popToNextHostParent(fiber) {
      for (fiber = fiber["return"]; null !== fiber && 5 !== fiber.tag && 3 !== fiber.tag;) {
        fiber = fiber["return"];
      }

      hydrationParentFiber = fiber;
    }

    var shouldSetTextContent = config.shouldSetTextContent;
    config = config.hydration;
    if (!config) return {
      enterHydrationState: function enterHydrationState() {
        return !1;
      },
      resetHydrationState: function resetHydrationState() {},
      tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {},
      prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
        invariant(!1, "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      },
      prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
        invariant(!1, "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      },
      popHydrationState: function popHydrationState() {
        return !1;
      }
    };
    var canHydrateInstance = config.canHydrateInstance,
        canHydrateTextInstance = config.canHydrateTextInstance,
        getNextHydratableSibling = config.getNextHydratableSibling,
        getFirstHydratableChild = config.getFirstHydratableChild,
        hydrateInstance = config.hydrateInstance,
        hydrateTextInstance = config.hydrateTextInstance,
        hydrationParentFiber = null,
        nextHydratableInstance = null,
        isHydrating = !1;
    return {
      enterHydrationState: function enterHydrationState(fiber) {
        nextHydratableInstance = getFirstHydratableChild(fiber.stateNode.containerInfo);
        hydrationParentFiber = fiber;
        return isHydrating = !0;
      },
      resetHydrationState: function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = !1;
      },
      tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance(fiber) {
        if (isHydrating) {
          var nextInstance = nextHydratableInstance;

          if (nextInstance) {
            if (!tryHydrate(fiber, nextInstance)) {
              nextInstance = getNextHydratableSibling(nextInstance);

              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                fiber.effectTag |= 2;
                isHydrating = !1;
                hydrationParentFiber = fiber;
                return;
              }

              deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
            }

            hydrationParentFiber = fiber;
            nextHydratableInstance = getFirstHydratableChild(nextInstance);
          } else fiber.effectTag |= 2, isHydrating = !1, hydrationParentFiber = fiber;
        }
      },
      prepareToHydrateHostInstance: function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        rootContainerInstance = hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
        fiber.updateQueue = rootContainerInstance;
        return null !== rootContainerInstance ? !0 : !1;
      },
      prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance(fiber) {
        return hydrateTextInstance(fiber.stateNode, fiber.memoizedProps, fiber);
      },
      popHydrationState: function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return !1;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;
        var type = fiber.type;
        if (5 !== fiber.tag || "head" !== type && "body" !== type && !shouldSetTextContent(type, fiber.memoizedProps)) for (type = nextHydratableInstance; type;) {
          deleteHydratableInstance(fiber, type), type = getNextHydratableSibling(type);
        }
        popToNextHostParent(fiber);
        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return !0;
      }
    };
  }

  function ReactFiberScheduler(config) {
    function completeUnitOfWork(workInProgress$jscomp$0) {
      for (;;) {
        var next = completeWork(workInProgress$jscomp$0.alternate, workInProgress$jscomp$0, nextRenderExpirationTime),
            returnFiber = workInProgress$jscomp$0["return"],
            siblingFiber = workInProgress$jscomp$0.sibling;
        var workInProgress = workInProgress$jscomp$0;

        if (2147483647 === nextRenderExpirationTime || 2147483647 !== workInProgress.expirationTime) {
          if (2 !== workInProgress.tag && 3 !== workInProgress.tag) var newExpirationTime = 0;else newExpirationTime = workInProgress.updateQueue, newExpirationTime = null === newExpirationTime ? 0 : newExpirationTime.expirationTime;

          for (var child = workInProgress.child; null !== child;) {
            0 !== child.expirationTime && (0 === newExpirationTime || newExpirationTime > child.expirationTime) && (newExpirationTime = child.expirationTime), child = child.sibling;
          }

          workInProgress.expirationTime = newExpirationTime;
        }

        if (null !== next) return next;
        null !== returnFiber && (null === returnFiber.firstEffect && (returnFiber.firstEffect = workInProgress$jscomp$0.firstEffect), null !== workInProgress$jscomp$0.lastEffect && (null !== returnFiber.lastEffect && (returnFiber.lastEffect.nextEffect = workInProgress$jscomp$0.firstEffect), returnFiber.lastEffect = workInProgress$jscomp$0.lastEffect), 1 < workInProgress$jscomp$0.effectTag && (null !== returnFiber.lastEffect ? returnFiber.lastEffect.nextEffect = workInProgress$jscomp$0 : returnFiber.firstEffect = workInProgress$jscomp$0, returnFiber.lastEffect = workInProgress$jscomp$0));
        if (null !== siblingFiber) return siblingFiber;
        if (null !== returnFiber) workInProgress$jscomp$0 = returnFiber;else {
          workInProgress$jscomp$0.stateNode.isReadyForCommit = !0;
          break;
        }
      }

      return null;
    }

    function performUnitOfWork(workInProgress) {
      var next = beginWork(workInProgress.alternate, workInProgress, nextRenderExpirationTime);
      null === next && (next = completeUnitOfWork(workInProgress));
      ReactCurrentOwner.current = null;
      return next;
    }

    function performFailedUnitOfWork(workInProgress) {
      var next = beginFailedWork(workInProgress.alternate, workInProgress, nextRenderExpirationTime);
      null === next && (next = completeUnitOfWork(workInProgress));
      ReactCurrentOwner.current = null;
      return next;
    }

    function workLoop(expirationTime) {
      if (null !== capturedErrors) {
        if (!(0 === nextRenderExpirationTime || nextRenderExpirationTime > expirationTime)) if (nextRenderExpirationTime <= mostRecentCurrentTime) for (; null !== nextUnitOfWork;) {
          nextUnitOfWork = hasCapturedError(nextUnitOfWork) ? performFailedUnitOfWork(nextUnitOfWork) : performUnitOfWork(nextUnitOfWork);
        } else for (; null !== nextUnitOfWork && !shouldYield();) {
          nextUnitOfWork = hasCapturedError(nextUnitOfWork) ? performFailedUnitOfWork(nextUnitOfWork) : performUnitOfWork(nextUnitOfWork);
        }
      } else if (!(0 === nextRenderExpirationTime || nextRenderExpirationTime > expirationTime)) if (nextRenderExpirationTime <= mostRecentCurrentTime) for (; null !== nextUnitOfWork;) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      } else for (; null !== nextUnitOfWork && !shouldYield();) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    }

    function renderRoot(root, expirationTime) {
      invariant(!isWorking, "renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.");
      isWorking = !0;
      root.isReadyForCommit = !1;

      if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || null === nextUnitOfWork) {
        for (; -1 < index;) {
          valueStack[index] = null, index--;
        }

        previousContext = emptyObject;
        contextStackCursor.current = emptyObject;
        didPerformWorkStackCursor.current = !1;
        resetHostContainer();
        nextRoot = root;
        nextRenderExpirationTime = expirationTime;
        nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
      }

      var didError = !1,
          error = null;

      try {
        workLoop(expirationTime);
      } catch (e) {
        didError = !0, error = e;
      }

      for (; didError;) {
        if (didFatal) {
          firstUncaughtError = error;
          break;
        }

        var failedWork = nextUnitOfWork;
        if (null === failedWork) didFatal = !0;else {
          var boundary = captureError(failedWork, error);
          invariant(null !== boundary, "Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.");

          if (!didFatal) {
            try {
              didError = boundary;
              error = expirationTime;

              for (boundary = didError; null !== failedWork;) {
                switch (failedWork.tag) {
                  case 2:
                    popContextProvider(failedWork);
                    break;

                  case 5:
                    popHostContext(failedWork);
                    break;

                  case 3:
                    popHostContainer(failedWork);
                    break;

                  case 4:
                    popHostContainer(failedWork);
                }

                if (failedWork === boundary || failedWork.alternate === boundary) break;
                failedWork = failedWork["return"];
              }

              nextUnitOfWork = performFailedUnitOfWork(didError);
              workLoop(error);
            } catch (e) {
              didError = !0;
              error = e;
              continue;
            }

            break;
          }
        }
      }

      expirationTime = firstUncaughtError;
      didFatal = isWorking = !1;
      firstUncaughtError = null;
      null !== expirationTime && onUncaughtError(expirationTime);
      return root.isReadyForCommit ? root.current.alternate : null;
    }

    function captureError(failedWork, error$jscomp$0) {
      var boundary = ReactCurrentOwner.current = null,
          errorBoundaryFound = !1,
          willRetry = !1,
          errorBoundaryName = null;
      if (3 === failedWork.tag) boundary = failedWork, isFailedBoundary(failedWork) && (didFatal = !0);else for (var node = failedWork["return"]; null !== node && null === boundary;) {
        2 === node.tag ? "function" === typeof node.stateNode.componentDidCatch && (errorBoundaryFound = !0, errorBoundaryName = getComponentName(node), boundary = node, willRetry = !0) : 3 === node.tag && (boundary = node);

        if (isFailedBoundary(node)) {
          if (isUnmounting || null !== commitPhaseBoundaries && (commitPhaseBoundaries.has(node) || null !== node.alternate && commitPhaseBoundaries.has(node.alternate))) return null;
          boundary = null;
          willRetry = !1;
        }

        node = node["return"];
      }

      if (null !== boundary) {
        null === failedBoundaries && (failedBoundaries = new Set());
        failedBoundaries.add(boundary);
        var info = "";
        node = failedWork;

        do {
          a: switch (node.tag) {
            case 0:
            case 1:
            case 2:
            case 5:
              var owner = node._debugOwner,
                  source = node._debugSource;
              var JSCompiler_inline_result = getComponentName(node);
              var ownerName = null;
              owner && (ownerName = getComponentName(owner));
              owner = source;
              JSCompiler_inline_result = "\n    in " + (JSCompiler_inline_result || "Unknown") + (owner ? " (at " + owner.fileName.replace(/^.*[\\\/]/, "") + ":" + owner.lineNumber + ")" : ownerName ? " (created by " + ownerName + ")" : "");
              break a;

            default:
              JSCompiler_inline_result = "";
          }

          info += JSCompiler_inline_result;
          node = node["return"];
        } while (node);

        node = info;
        failedWork = getComponentName(failedWork);
        null === capturedErrors && (capturedErrors = new Map());
        error$jscomp$0 = {
          componentName: failedWork,
          componentStack: node,
          error: error$jscomp$0,
          errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
          errorBoundaryFound: errorBoundaryFound,
          errorBoundaryName: errorBoundaryName,
          willRetry: willRetry
        };
        capturedErrors.set(boundary, error$jscomp$0);

        try {
          if (!1 !== showDialog(error$jscomp$0)) {
            var error = error$jscomp$0.error;
            error && error.suppressReactErrorLogging || console.error(error);
          }
        } catch (e) {
          e && e.suppressReactErrorLogging || console.error(e);
        }

        isCommitting ? (null === commitPhaseBoundaries && (commitPhaseBoundaries = new Set()), commitPhaseBoundaries.add(boundary)) : scheduleErrorRecovery(boundary);
        return boundary;
      }

      null === firstUncaughtError && (firstUncaughtError = error$jscomp$0);
      return null;
    }

    function hasCapturedError(fiber) {
      return null !== capturedErrors && (capturedErrors.has(fiber) || null !== fiber.alternate && capturedErrors.has(fiber.alternate));
    }

    function isFailedBoundary(fiber) {
      return null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== fiber.alternate && failedBoundaries.has(fiber.alternate));
    }

    function computeAsyncExpiration() {
      return 20 * (((recalculateCurrentTime() + 100) / 20 | 0) + 1);
    }

    function computeExpirationForFiber(fiber) {
      return 0 !== expirationContext ? expirationContext : isWorking ? isCommitting ? 1 : nextRenderExpirationTime : !useSyncScheduling || fiber.internalContextTag & 1 ? computeAsyncExpiration() : 1;
    }

    function scheduleWork(fiber, expirationTime) {
      return scheduleWorkImpl(fiber, expirationTime, !1);
    }

    function scheduleWorkImpl(fiber, expirationTime) {
      for (; null !== fiber;) {
        if (0 === fiber.expirationTime || fiber.expirationTime > expirationTime) fiber.expirationTime = expirationTime;
        null !== fiber.alternate && (0 === fiber.alternate.expirationTime || fiber.alternate.expirationTime > expirationTime) && (fiber.alternate.expirationTime = expirationTime);
        if (null === fiber["return"]) if (3 === fiber.tag) {
          var root = fiber.stateNode;
          !isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime && (nextUnitOfWork = nextRoot = null, nextRenderExpirationTime = 0);
          requestWork(root, expirationTime);
          !isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime && (nextUnitOfWork = nextRoot = null, nextRenderExpirationTime = 0);
        } else break;
        fiber = fiber["return"];
      }
    }

    function scheduleErrorRecovery(fiber) {
      scheduleWorkImpl(fiber, 1, !0);
    }

    function recalculateCurrentTime() {
      return mostRecentCurrentTime = ((now() - startTime) / 10 | 0) + 2;
    }

    function scheduleCallbackWithExpiration(expirationTime) {
      if (0 !== callbackExpirationTime) {
        if (expirationTime > callbackExpirationTime) return;
        cancelDeferredCallback(callbackID);
      }

      var currentMs = now() - startTime;
      callbackExpirationTime = expirationTime;
      callbackID = scheduleDeferredCallback(performAsyncWork, {
        timeout: 10 * (expirationTime - 2) - currentMs
      });
    }

    function requestWork(root, expirationTime) {
      nestedUpdateCount > NESTED_UPDATE_LIMIT && invariant(!1, "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      if (null === root.nextScheduledRoot) root.remainingExpirationTime = expirationTime, null === lastScheduledRoot ? (firstScheduledRoot = lastScheduledRoot = root, root.nextScheduledRoot = root) : (lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = root, lastScheduledRoot.nextScheduledRoot = firstScheduledRoot);else {
        var remainingExpirationTime = root.remainingExpirationTime;
        if (0 === remainingExpirationTime || expirationTime < remainingExpirationTime) root.remainingExpirationTime = expirationTime;
      }
      isRendering || (isBatchingUpdates ? isUnbatchingUpdates && (nextFlushedRoot = root, nextFlushedExpirationTime = 1, performWorkOnRoot(root, 1, recalculateCurrentTime())) : 1 === expirationTime ? performWork(1, null) : scheduleCallbackWithExpiration(expirationTime));
    }

    function findHighestPriorityRoot() {
      var highestPriorityWork = 0,
          highestPriorityRoot = null;
      if (null !== lastScheduledRoot) for (var previousScheduledRoot = lastScheduledRoot, root = firstScheduledRoot; null !== root;) {
        var remainingExpirationTime = root.remainingExpirationTime;

        if (0 === remainingExpirationTime) {
          invariant(null !== previousScheduledRoot && null !== lastScheduledRoot, "Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.");

          if (root === root.nextScheduledRoot) {
            firstScheduledRoot = lastScheduledRoot = root.nextScheduledRoot = null;
            break;
          } else if (root === firstScheduledRoot) firstScheduledRoot = remainingExpirationTime = root.nextScheduledRoot, lastScheduledRoot.nextScheduledRoot = remainingExpirationTime, root.nextScheduledRoot = null;else if (root === lastScheduledRoot) {
            lastScheduledRoot = previousScheduledRoot;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            root.nextScheduledRoot = null;
            break;
          } else previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot, root.nextScheduledRoot = null;

          root = previousScheduledRoot.nextScheduledRoot;
        } else {
          if (0 === highestPriorityWork || remainingExpirationTime < highestPriorityWork) highestPriorityWork = remainingExpirationTime, highestPriorityRoot = root;
          if (root === lastScheduledRoot) break;
          previousScheduledRoot = root;
          root = root.nextScheduledRoot;
        }
      }
      previousScheduledRoot = nextFlushedRoot;
      null !== previousScheduledRoot && previousScheduledRoot === highestPriorityRoot ? nestedUpdateCount++ : nestedUpdateCount = 0;
      nextFlushedRoot = highestPriorityRoot;
      nextFlushedExpirationTime = highestPriorityWork;
    }

    function performAsyncWork(dl) {
      performWork(0, dl);
    }

    function performWork(minExpirationTime, dl) {
      deadline = dl;

      for (findHighestPriorityRoot(); null !== nextFlushedRoot && 0 !== nextFlushedExpirationTime && (0 === minExpirationTime || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire;) {
        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, recalculateCurrentTime()), findHighestPriorityRoot();
      }

      null !== deadline && (callbackExpirationTime = 0, callbackID = -1);
      0 !== nextFlushedExpirationTime && scheduleCallbackWithExpiration(nextFlushedExpirationTime);
      deadline = null;
      deadlineDidExpire = !1;
      nestedUpdateCount = 0;
      finishRendering();
    }

    function finishRendering() {
      if (null !== completedBatches) {
        var batches = completedBatches;
        completedBatches = null;

        for (var i = 0; i < batches.length; i++) {
          var batch = batches[i];

          try {
            batch._onComplete();
          } catch (error) {
            hasUnhandledError || (hasUnhandledError = !0, unhandledError = error);
          }
        }
      }

      if (hasUnhandledError) throw batches = unhandledError, unhandledError = null, hasUnhandledError = !1, batches;
    }

    function performWorkOnRoot(root, expirationTime, currentTime) {
      invariant(!isRendering, "performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.");
      isRendering = !0;
      expirationTime <= currentTime ? (currentTime = root.finishedWork, null !== currentTime ? completeRoot(root, currentTime, expirationTime) : (root.finishedWork = null, currentTime = renderRoot(root, expirationTime), null !== currentTime && completeRoot(root, currentTime, expirationTime))) : (currentTime = root.finishedWork, null !== currentTime ? completeRoot(root, currentTime, expirationTime) : (root.finishedWork = null, currentTime = renderRoot(root, expirationTime), null !== currentTime && (shouldYield() ? root.finishedWork = currentTime : completeRoot(root, currentTime, expirationTime))));
      isRendering = !1;
    }

    function completeRoot(root, finishedWork, expirationTime) {
      var firstBatch = root.firstBatch;

      if (null !== firstBatch && firstBatch._expirationTime <= expirationTime && (null === completedBatches ? completedBatches = [firstBatch] : completedBatches.push(firstBatch), firstBatch._defer)) {
        root.finishedWork = finishedWork;
        root.remainingExpirationTime = 0;
        return;
      }

      root.finishedWork = null;
      isCommitting = isWorking = !0;
      expirationTime = finishedWork.stateNode;
      invariant(expirationTime.current !== finishedWork, "Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.");
      expirationTime.isReadyForCommit = !1;
      ReactCurrentOwner.current = null;
      1 < finishedWork.effectTag ? null !== finishedWork.lastEffect ? (finishedWork.lastEffect.nextEffect = finishedWork, firstBatch = finishedWork.firstEffect) : firstBatch = finishedWork : firstBatch = finishedWork.firstEffect;
      prepareForCommit();

      for (nextEffect = firstBatch; null !== nextEffect;) {
        var didError = !1,
            _error = void 0;

        try {
          for (; null !== nextEffect;) {
            var effectTag = nextEffect.effectTag;
            effectTag & 16 && commitResetTextContent(nextEffect);

            if (effectTag & 128) {
              var current = nextEffect.alternate;
              null !== current && commitDetachRef(current);
            }

            switch (effectTag & -242) {
              case 2:
                commitPlacement(nextEffect);
                nextEffect.effectTag &= -3;
                break;

              case 6:
                commitPlacement(nextEffect);
                nextEffect.effectTag &= -3;
                commitWork(nextEffect.alternate, nextEffect);
                break;

              case 4:
                commitWork(nextEffect.alternate, nextEffect);
                break;

              case 8:
                isUnmounting = !0, commitDeletion(nextEffect), isUnmounting = !1;
            }

            nextEffect = nextEffect.nextEffect;
          }
        } catch (e) {
          didError = !0, _error = e;
        }

        didError && (invariant(null !== nextEffect, "Should have next effect. This error is likely caused by a bug in React. Please file an issue."), captureError(nextEffect, _error), null !== nextEffect && (nextEffect = nextEffect.nextEffect));
      }

      resetAfterCommit();
      expirationTime.current = finishedWork;

      for (nextEffect = firstBatch; null !== nextEffect;) {
        effectTag = !1;
        current = void 0;

        try {
          for (; null !== nextEffect;) {
            var effectTag$jscomp$0 = nextEffect.effectTag;
            effectTag$jscomp$0 & 36 && commitLifeCycles(nextEffect.alternate, nextEffect);
            effectTag$jscomp$0 & 128 && commitAttachRef(nextEffect);
            if (effectTag$jscomp$0 & 64) switch (firstBatch = nextEffect, didError = void 0, null !== capturedErrors && (didError = capturedErrors.get(firstBatch), capturedErrors["delete"](firstBatch), null == didError && null !== firstBatch.alternate && (firstBatch = firstBatch.alternate, didError = capturedErrors.get(firstBatch), capturedErrors["delete"](firstBatch))), invariant(null != didError, "No error for given unit of work. This error is likely caused by a bug in React. Please file an issue."), firstBatch.tag) {
              case 2:
                firstBatch.stateNode.componentDidCatch(didError.error, {
                  componentStack: didError.componentStack
                });
                break;

              case 3:
                null === firstUncaughtError && (firstUncaughtError = didError.error);
                break;

              default:
                invariant(!1, "Invalid type of work. This error is likely caused by a bug in React. Please file an issue.");
            }
            var next = nextEffect.nextEffect;
            nextEffect.nextEffect = null;
            nextEffect = next;
          }
        } catch (e) {
          effectTag = !0, current = e;
        }

        effectTag && (invariant(null !== nextEffect, "Should have next effect. This error is likely caused by a bug in React. Please file an issue."), captureError(nextEffect, current), null !== nextEffect && (nextEffect = nextEffect.nextEffect));
      }

      isWorking = isCommitting = !1;
      "function" === typeof onCommitRoot && onCommitRoot(finishedWork.stateNode);
      commitPhaseBoundaries && (commitPhaseBoundaries.forEach(scheduleErrorRecovery), commitPhaseBoundaries = null);
      null !== firstUncaughtError && (finishedWork = firstUncaughtError, firstUncaughtError = null, onUncaughtError(finishedWork));
      finishedWork = expirationTime.current.expirationTime;
      0 === finishedWork && (failedBoundaries = capturedErrors = null);
      root.remainingExpirationTime = finishedWork;
    }

    function shouldYield() {
      return null === deadline || deadline.timeRemaining() > timeHeuristicForUnitOfWork ? !1 : deadlineDidExpire = !0;
    }

    function onUncaughtError(error) {
      invariant(null !== nextFlushedRoot, "Should be working on a root. This error is likely caused by a bug in React. Please file an issue.");
      nextFlushedRoot.remainingExpirationTime = 0;
      hasUnhandledError || (hasUnhandledError = !0, unhandledError = error);
    }

    var hostContext = ReactFiberHostContext(config),
        hydrationContext = ReactFiberHydrationContext(config),
        popHostContainer = hostContext.popHostContainer,
        popHostContext = hostContext.popHostContext,
        resetHostContainer = hostContext.resetHostContainer,
        _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
        beginWork = _ReactFiberBeginWork.beginWork,
        beginFailedWork = _ReactFiberBeginWork.beginFailedWork,
        completeWork = ReactFiberCompleteWork(config, hostContext, hydrationContext).completeWork;

    hostContext = ReactFiberCommitWork(config, captureError);
    var commitResetTextContent = hostContext.commitResetTextContent,
        commitPlacement = hostContext.commitPlacement,
        commitDeletion = hostContext.commitDeletion,
        commitWork = hostContext.commitWork,
        commitLifeCycles = hostContext.commitLifeCycles,
        commitAttachRef = hostContext.commitAttachRef,
        commitDetachRef = hostContext.commitDetachRef,
        now = config.now,
        scheduleDeferredCallback = config.scheduleDeferredCallback,
        cancelDeferredCallback = config.cancelDeferredCallback,
        useSyncScheduling = config.useSyncScheduling,
        prepareForCommit = config.prepareForCommit,
        resetAfterCommit = config.resetAfterCommit,
        startTime = now(),
        mostRecentCurrentTime = 2,
        lastUniqueAsyncExpiration = 0,
        expirationContext = 0,
        isWorking = !1,
        nextUnitOfWork = null,
        nextRoot = null,
        nextRenderExpirationTime = 0,
        nextEffect = null,
        capturedErrors = null,
        failedBoundaries = null,
        commitPhaseBoundaries = null,
        firstUncaughtError = null,
        didFatal = !1,
        isCommitting = !1,
        isUnmounting = !1,
        firstScheduledRoot = null,
        lastScheduledRoot = null,
        callbackExpirationTime = 0,
        callbackID = -1,
        isRendering = !1,
        nextFlushedRoot = null,
        nextFlushedExpirationTime = 0,
        deadlineDidExpire = !1,
        hasUnhandledError = !1,
        unhandledError = null,
        deadline = null,
        isBatchingUpdates = !1,
        isUnbatchingUpdates = !1,
        completedBatches = null,
        NESTED_UPDATE_LIMIT = 1e3,
        nestedUpdateCount = 0,
        timeHeuristicForUnitOfWork = 1;
    return {
      computeAsyncExpiration: computeAsyncExpiration,
      computeExpirationForFiber: computeExpirationForFiber,
      scheduleWork: scheduleWork,
      requestWork: requestWork,
      flushRoot: function flushRoot(root, expirationTime) {
        invariant(!isRendering, "work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.");
        performWorkOnRoot(root, expirationTime, expirationTime);
        finishRendering();
      },
      batchedUpdates: function batchedUpdates(fn, a) {
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = !0;

        try {
          return fn(a);
        } finally {
          (isBatchingUpdates = previousIsBatchingUpdates) || isRendering || performWork(1, null);
        }
      },
      unbatchedUpdates: function unbatchedUpdates(fn) {
        if (isBatchingUpdates && !isUnbatchingUpdates) {
          isUnbatchingUpdates = !0;

          try {
            return fn();
          } finally {
            isUnbatchingUpdates = !1;
          }
        }

        return fn();
      },
      flushSync: function flushSync(fn) {
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = !0;

        try {
          a: {
            var previousExpirationContext = expirationContext;
            expirationContext = 1;

            try {
              var JSCompiler_inline_result = fn();
              break a;
            } finally {
              expirationContext = previousExpirationContext;
            }

            JSCompiler_inline_result = void 0;
          }

          return JSCompiler_inline_result;
        } finally {
          isBatchingUpdates = previousIsBatchingUpdates, invariant(!isRendering, "flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering."), performWork(1, null);
        }
      },
      deferredUpdates: function deferredUpdates(fn) {
        var previousExpirationContext = expirationContext;
        expirationContext = computeAsyncExpiration();

        try {
          return fn();
        } finally {
          expirationContext = previousExpirationContext;
        }
      },
      computeUniqueAsyncExpiration: function computeUniqueAsyncExpiration() {
        var result = computeAsyncExpiration();
        result <= lastUniqueAsyncExpiration && (result = lastUniqueAsyncExpiration + 1);
        return lastUniqueAsyncExpiration = result;
      }
    };
  }

  function ReactFiberReconciler$1(config) {
    function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
      var current = container.current;

      if (parentComponent) {
        parentComponent = parentComponent._reactInternalFiber;
        var parentContext;

        b: {
          invariant(2 === isFiberMountedImpl(parentComponent) && 2 === parentComponent.tag, "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");

          for (parentContext = parentComponent; 3 !== parentContext.tag;) {
            if (isContextProvider(parentContext)) {
              parentContext = parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
              break b;
            }

            parentContext = parentContext["return"];
            invariant(parentContext, "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
          }

          parentContext = parentContext.stateNode.context;
        }

        parentComponent = isContextProvider(parentComponent) ? processChildContext(parentComponent, parentContext) : parentContext;
      } else parentComponent = emptyObject;

      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      container = callback;
      insertUpdateIntoFiber(current, {
        expirationTime: expirationTime,
        partialState: {
          element: element
        },
        callback: void 0 === container ? null : container,
        isReplace: !1,
        isForced: !1,
        next: null
      });
      scheduleWork(current, expirationTime);
      return expirationTime;
    }

    function findHostInstance(fiber) {
      fiber = findCurrentHostFiber(fiber);
      return null === fiber ? null : fiber.stateNode;
    }

    var getPublicInstance = config.getPublicInstance;
    config = ReactFiberScheduler(config);
    var computeAsyncExpiration = config.computeAsyncExpiration,
        computeExpirationForFiber = config.computeExpirationForFiber,
        scheduleWork = config.scheduleWork;
    return {
      createContainer: function createContainer(containerInfo, hydrate) {
        var uninitializedFiber = createFiber(3, null, 0);
        containerInfo = {
          current: uninitializedFiber,
          containerInfo: containerInfo,
          pendingChildren: null,
          remainingExpirationTime: 0,
          isReadyForCommit: !1,
          finishedWork: null,
          context: null,
          pendingContext: null,
          hydrate: hydrate,
          firstBatch: null,
          nextScheduledRoot: null
        };
        return uninitializedFiber.stateNode = containerInfo;
      },
      updateContainer: function updateContainer(element, container, parentComponent, callback) {
        var current = container.current;
        current = null != element && null != element.type && null != element.type.prototype && !0 === element.type.prototype.unstable_isAsyncReactComponent ? computeAsyncExpiration() : computeExpirationForFiber(current);
        return updateContainerAtExpirationTime(element, container, parentComponent, current, callback);
      },
      updateContainerAtExpirationTime: updateContainerAtExpirationTime,
      flushRoot: config.flushRoot,
      requestWork: config.requestWork,
      computeUniqueAsyncExpiration: config.computeUniqueAsyncExpiration,
      batchedUpdates: config.batchedUpdates,
      unbatchedUpdates: config.unbatchedUpdates,
      deferredUpdates: config.deferredUpdates,
      flushSync: config.flushSync,
      getPublicRootInstance: function getPublicRootInstance(container) {
        container = container.current;
        if (!container.child) return null;

        switch (container.child.tag) {
          case 5:
            return getPublicInstance(container.child.stateNode);

          default:
            return container.child.stateNode;
        }
      },
      findHostInstance: findHostInstance,
      findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(fiber) {
        fiber = findCurrentHostFiberWithNoPortals(fiber);
        return null === fiber ? null : fiber.stateNode;
      },
      injectIntoDevTools: function injectIntoDevTools(devToolsConfig) {
        var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        return injectInternals(babelHelpers.extends({}, devToolsConfig, {
          findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
            return findHostInstance(fiber);
          },
          findFiberByHostInstance: function findFiberByHostInstance(instance) {
            return _findFiberByHostInstance ? _findFiberByHostInstance(instance) : null;
          }
        }));
      }
    };
  }

  var ReactFiberReconciler$2 = Object.freeze({
    default: ReactFiberReconciler$1
  }),
      ReactFiberReconciler$3 = ReactFiberReconciler$2 && ReactFiberReconciler$1 || ReactFiberReconciler$2,
      reactReconciler = ReactFiberReconciler$3["default"] ? ReactFiberReconciler$3["default"] : ReactFiberReconciler$3,
      viewConfigCallbacks = new Map(),
      viewConfigs = new Map(),
      ReactNativeFiberHostComponent = function () {
    function ReactNativeFiberHostComponent(tag, viewConfig) {
      if (!(this instanceof ReactNativeFiberHostComponent)) throw new TypeError("Cannot call a class as a function");
      this._nativeTag = tag;
      this._children = [];
      this.viewConfig = viewConfig;
    }

    ReactNativeFiberHostComponent.prototype.blur = function () {
      TextInputState.blurTextInput(this._nativeTag);
    };

    ReactNativeFiberHostComponent.prototype.focus = function () {
      TextInputState.focusTextInput(this._nativeTag);
    };

    ReactNativeFiberHostComponent.prototype.measure = function (callback) {
      UIManager.measure(this._nativeTag, mountSafeCallback(this, callback));
    };

    ReactNativeFiberHostComponent.prototype.measureInWindow = function (callback) {
      UIManager.measureInWindow(this._nativeTag, mountSafeCallback(this, callback));
    };

    ReactNativeFiberHostComponent.prototype.measureLayout = function (relativeToNativeNode, onSuccess, onFail) {
      UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback(this, onFail), mountSafeCallback(this, onSuccess));
    };

    ReactNativeFiberHostComponent.prototype.setNativeProps = function (nativeProps) {
      nativeProps = diffProperties(null, emptyObject$1, nativeProps, this.viewConfig.validAttributes);
      null != nativeProps && UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, nativeProps);
    };

    return ReactNativeFiberHostComponent;
  }(),
      now = "object" === typeof performance && "function" === typeof performance.now ? function () {
    return performance.now();
  } : function () {
    return Date.now();
  },
      scheduledCallback = null,
      frameDeadline = 0,
      frameDeadlineObject = {
    timeRemaining: function timeRemaining() {
      return frameDeadline - now();
    }
  };

  function setTimeoutCallback() {
    frameDeadline = now() + 5;
    var callback = scheduledCallback;
    scheduledCallback = null;
    null !== callback && callback(frameDeadlineObject);
  }

  function recursivelyUncacheFiberNode(node) {
    "number" === typeof node ? uncacheFiberNode(node) : (uncacheFiberNode(node._nativeTag), node._children.forEach(recursivelyUncacheFiberNode));
  }

  var NativeRenderer = reactReconciler({
    appendInitialChild: function appendInitialChild(parentInstance, child) {
      parentInstance._children.push(child);
    },
    createInstance: function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      hostContext = ReactNativeTagHandles.allocateTag();
      if (viewConfigs.has(type)) var viewConfig = viewConfigs.get(type);else viewConfig = viewConfigCallbacks.get(type), invariant("function" === typeof viewConfig, "View config not found for name %s", type), viewConfigCallbacks.set(type, null), viewConfig = viewConfig(), viewConfigs.set(type, viewConfig);
      invariant(viewConfig, "View config not found for name %s", type);
      type = viewConfig;
      viewConfig = diffProperties(null, emptyObject$1, props, type.validAttributes);
      UIManager.createView(hostContext, type.uiViewClassName, rootContainerInstance, viewConfig);
      rootContainerInstance = new ReactNativeFiberHostComponent(hostContext, type);
      instanceCache[hostContext] = internalInstanceHandle;
      instanceProps[hostContext] = props;
      return rootContainerInstance;
    },
    createTextInstance: function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
      hostContext = ReactNativeTagHandles.allocateTag();
      UIManager.createView(hostContext, "RCTRawText", rootContainerInstance, {
        text: text
      });
      instanceCache[hostContext] = internalInstanceHandle;
      return hostContext;
    },
    finalizeInitialChildren: function finalizeInitialChildren(parentInstance) {
      if (0 === parentInstance._children.length) return !1;

      var nativeTags = parentInstance._children.map(function (child) {
        return "number" === typeof child ? child : child._nativeTag;
      });

      UIManager.setChildren(parentInstance._nativeTag, nativeTags);
      return !1;
    },
    getRootHostContext: function getRootHostContext() {
      return emptyObject;
    },
    getChildHostContext: function getChildHostContext() {
      return emptyObject;
    },
    getPublicInstance: function getPublicInstance(instance) {
      return instance;
    },
    now: now,
    prepareForCommit: function prepareForCommit() {},
    prepareUpdate: function prepareUpdate() {
      return emptyObject;
    },
    resetAfterCommit: function resetAfterCommit() {},
    scheduleDeferredCallback: function scheduleDeferredCallback(callback) {
      scheduledCallback = callback;
      return setTimeout(setTimeoutCallback, 1);
    },
    cancelDeferredCallback: function cancelDeferredCallback(callbackID) {
      scheduledCallback = null;
      clearTimeout(callbackID);
    },
    shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree() {
      return !1;
    },
    shouldSetTextContent: function shouldSetTextContent() {
      return !1;
    },
    useSyncScheduling: !0,
    mutation: {
      appendChild: function appendChild(parentInstance, child) {
        var childTag = "number" === typeof child ? child : child._nativeTag,
            children = parentInstance._children,
            index = children.indexOf(child);
        0 <= index ? (children.splice(index, 1), children.push(child), UIManager.manageChildren(parentInstance._nativeTag, [index], [children.length - 1], [], [], [])) : (children.push(child), UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [children.length - 1], []));
      },
      appendChildToContainer: function appendChildToContainer(parentInstance, child) {
        UIManager.setChildren(parentInstance, ["number" === typeof child ? child : child._nativeTag]);
      },
      commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {
        UIManager.updateView(textInstance, "RCTRawText", {
          text: newText
        });
      },
      commitMount: function commitMount() {},
      commitUpdate: function commitUpdate(instance, updatePayloadTODO, type, oldProps, newProps) {
        updatePayloadTODO = instance.viewConfig;
        instanceProps[instance._nativeTag] = newProps;
        oldProps = diffProperties(null, oldProps, newProps, updatePayloadTODO.validAttributes);
        null != oldProps && UIManager.updateView(instance._nativeTag, updatePayloadTODO.uiViewClassName, oldProps);
      },
      insertBefore: function insertBefore(parentInstance, child, beforeChild) {
        var children = parentInstance._children,
            index = children.indexOf(child);
        0 <= index ? (children.splice(index, 1), beforeChild = children.indexOf(beforeChild), children.splice(beforeChild, 0, child), UIManager.manageChildren(parentInstance._nativeTag, [index], [beforeChild], [], [], [])) : (index = children.indexOf(beforeChild), children.splice(index, 0, child), UIManager.manageChildren(parentInstance._nativeTag, [], [], ["number" === typeof child ? child : child._nativeTag], [index], []));
      },
      insertInContainerBefore: function insertInContainerBefore(parentInstance) {
        invariant("number" !== typeof parentInstance, "Container does not support insertBefore operation");
      },
      removeChild: function removeChild(parentInstance, child) {
        recursivelyUncacheFiberNode(child);
        var children = parentInstance._children;
        child = children.indexOf(child);
        children.splice(child, 1);
        UIManager.manageChildren(parentInstance._nativeTag, [], [], [], [], [child]);
      },
      removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {
        recursivelyUncacheFiberNode(child);
        UIManager.manageChildren(parentInstance, [], [], [], [], [0]);
      },
      resetTextContent: function resetTextContent() {}
    }
  });

  function findNodeHandle(componentOrHandle) {
    if (null == componentOrHandle) return null;
    if ("number" === typeof componentOrHandle) return componentOrHandle;
    var internalInstance = componentOrHandle._reactInternalFiber;
    if (internalInstance) return NativeRenderer.findHostInstance(internalInstance);
    if (componentOrHandle) return componentOrHandle;
    invariant("object" === typeof componentOrHandle && "_nativeTag" in componentOrHandle || null != componentOrHandle.render && "function" === typeof componentOrHandle.render, "findNodeHandle(...): Argument is not a component (type: %s, keys: %s)", typeof componentOrHandle, Object.keys(componentOrHandle));
    invariant(!1, "findNodeHandle(...): Unable to find node handle for unmounted component.");
  }

  function findNumericNodeHandleFiber(componentOrHandle) {
    componentOrHandle = findNodeHandle(componentOrHandle);
    return null == componentOrHandle || "number" === typeof componentOrHandle ? componentOrHandle : componentOrHandle._nativeTag;
  }

  function _inherits(subClass, superClass) {
    if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    });
    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
  }

  var ReactNativeComponent = function (_React$Component) {
    function ReactNativeComponent() {
      if (!(this instanceof ReactNativeComponent)) throw new TypeError("Cannot call a class as a function");

      var call = _React$Component.apply(this, arguments);

      if (!this) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !call || "object" !== typeof call && "function" !== typeof call ? this : call;
    }

    _inherits(ReactNativeComponent, _React$Component);

    ReactNativeComponent.prototype.blur = function () {
      TextInputState.blurTextInput(findNumericNodeHandleFiber(this));
    };

    ReactNativeComponent.prototype.focus = function () {
      TextInputState.focusTextInput(findNumericNodeHandleFiber(this));
    };

    ReactNativeComponent.prototype.measure = function (callback) {
      UIManager.measure(findNumericNodeHandleFiber(this), mountSafeCallback(this, callback));
    };

    ReactNativeComponent.prototype.measureInWindow = function (callback) {
      UIManager.measureInWindow(findNumericNodeHandleFiber(this), mountSafeCallback(this, callback));
    };

    ReactNativeComponent.prototype.measureLayout = function (relativeToNativeNode, onSuccess, onFail) {
      UIManager.measureLayout(findNumericNodeHandleFiber(this), relativeToNativeNode, mountSafeCallback(this, onFail), mountSafeCallback(this, onSuccess));
    };

    ReactNativeComponent.prototype.setNativeProps = function (nativeProps) {
      var maybeInstance = void 0;

      try {
        maybeInstance = findNodeHandle(this);
      } catch (error) {}

      if (null != maybeInstance) {
        var viewConfig = maybeInstance.viewConfig;
        nativeProps = diffProperties(null, emptyObject$1, nativeProps, viewConfig.validAttributes);
        null != nativeProps && UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, nativeProps);
      }
    };

    return ReactNativeComponent;
  }(React.Component),
      getInspectorDataForViewTag = void 0;

  getInspectorDataForViewTag = function getInspectorDataForViewTag() {
    invariant(!1, "getInspectorDataForViewTag() is not available in production");
  };

  fiberBatchedUpdates = NativeRenderer.batchedUpdates;
  var roots = new Map();

  function fn$jscomp$inline_616(capturedError) {
    var componentStack = capturedError.componentStack,
        error = capturedError.error;

    if (error instanceof Error) {
      capturedError = error.message;
      var name = error.name;

      try {
        error.message = (capturedError ? name + ": " + capturedError : name) + "\n\nThis error is located at:" + componentStack;
      } catch (e) {}
    } else error = "string" === typeof error ? Error(error + "\n\nThis error is located at:" + componentStack) : Error("Unspecified error at:" + componentStack);

    ExceptionsManager.handleException(error, !1);
    return !1;
  }

  invariant(showDialog === defaultShowDialog, "The custom dialog was already injected.");
  invariant("function" === typeof fn$jscomp$inline_616, "Injected showDialog() must be a function.");
  showDialog = fn$jscomp$inline_616;
  var ReactNativeRenderer = {
    NativeComponent: ReactNativeComponent,
    findNodeHandle: findNumericNodeHandleFiber,
    render: function render(element, containerTag, callback) {
      var root = roots.get(containerTag);
      root || (root = NativeRenderer.createContainer(containerTag, !1), roots.set(containerTag, root));
      NativeRenderer.updateContainer(element, root, null, callback);
      return NativeRenderer.getPublicRootInstance(root);
    },
    unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
      var root = roots.get(containerTag);
      root && NativeRenderer.updateContainer(null, root, null, function () {
        roots["delete"](containerTag);
      });
    },
    unmountComponentAtNodeAndRemoveContainer: function unmountComponentAtNodeAndRemoveContainer(containerTag) {
      ReactNativeRenderer.unmountComponentAtNode(containerTag);
      UIManager.removeRootView(containerTag);
    },
    createPortal: function createPortal(children, containerTag) {
      return _createPortal(children, containerTag, null, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
    },
    unstable_batchedUpdates: batchedUpdates,
    flushSync: NativeRenderer.flushSync,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      NativeMethodsMixin: {
        measure: function measure(callback) {
          UIManager.measure(findNumericNodeHandleFiber(this), mountSafeCallback(this, callback));
        },
        measureInWindow: function measureInWindow(callback) {
          UIManager.measureInWindow(findNumericNodeHandleFiber(this), mountSafeCallback(this, callback));
        },
        measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(findNumericNodeHandleFiber(this), relativeToNativeNode, mountSafeCallback(this, onFail), mountSafeCallback(this, onSuccess));
        },
        setNativeProps: function setNativeProps(nativeProps) {
          var maybeInstance = void 0;

          try {
            maybeInstance = findNodeHandle(this);
          } catch (error) {}

          if (null != maybeInstance) {
            var viewConfig = maybeInstance.viewConfig;
            nativeProps = diffProperties(null, emptyObject$1, nativeProps, viewConfig.validAttributes);
            null != nativeProps && UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, nativeProps);
          }
        },
        focus: function focus() {
          TextInputState.focusTextInput(findNumericNodeHandleFiber(this));
        },
        blur: function blur() {
          TextInputState.blurTextInput(findNumericNodeHandleFiber(this));
        }
      },
      ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin,
      ReactGlobalSharedState: ReactGlobalSharedState,
      ReactNativeComponentTree: ReactNativeComponentTree,
      ReactNativePropRegistry: ReactNativePropRegistry,
      TouchHistoryMath: TouchHistoryMath,
      createReactNativeComponentClass: function createReactNativeComponentClass(name, callback) {
        invariant(!viewConfigCallbacks.has(name), "Tried to register two views with the same name %s", name);
        viewConfigCallbacks.set(name, callback);
        return name;
      },
      takeSnapshot: function takeSnapshot(view, options) {
        "number" !== typeof view && "window" !== view && (view = findNumericNodeHandleFiber(view) || "window");
        return UIManager.__takeSnapshot(view, options);
      }
    }
  };
  NativeRenderer.injectIntoDevTools({
    findFiberByHostInstance: getInstanceFromTag,
    getInspectorDataForViewTag: getInspectorDataForViewTag,
    bundleType: 0,
    version: "16.2.0",
    rendererPackageName: "react-native-renderer"
  });
  var ReactNativeRenderer$2 = Object.freeze({
    default: ReactNativeRenderer
  }),
      ReactNativeRenderer$3 = ReactNativeRenderer$2 && ReactNativeRenderer || ReactNativeRenderer$2;
  module.exports = ReactNativeRenderer$3["default"] ? ReactNativeRenderer$3["default"] : ReactNativeRenderer$3;
},164,[76,18,16,157,158,12,84,159,160,152,15,161,163],"ReactNativeRenderer-prod");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'ReactNative'),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  module.exports = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactDebugTool;
},165,[74],"ReactDebugTool");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/ActivityIndicator/ActivityIndicator.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var NativeMethodsMixin = require(_dependencyMap[1], 'NativeMethodsMixin');

  var Platform = require(_dependencyMap[2], 'Platform');

  var ProgressBarAndroid = require(_dependencyMap[3], 'ProgressBarAndroid');

  var PropTypes = require(_dependencyMap[4], 'prop-types');

  var React = require(_dependencyMap[5], 'React');

  var StyleSheet = require(_dependencyMap[6], 'StyleSheet');

  var View = require(_dependencyMap[7], 'View');

  var ViewPropTypes = require(_dependencyMap[8], 'ViewPropTypes');

  var createReactClass = require(_dependencyMap[9], 'create-react-class');

  var requireNativeComponent = require(_dependencyMap[10], 'requireNativeComponent');

  var GRAY = '#999999';
  var ActivityIndicator = createReactClass({
    displayName: 'ActivityIndicator',
    mixins: [NativeMethodsMixin],
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      animating: PropTypes.bool,
      color: ColorPropType,
      size: PropTypes.oneOfType([PropTypes.oneOf(['small', 'large']), PropTypes.number]),
      hidesWhenStopped: PropTypes.bool
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        animating: true,
        color: Platform.OS === 'ios' ? GRAY : undefined,
        hidesWhenStopped: true,
        size: 'small'
      };
    },
    render: function render() {
      var _props = this.props,
          onLayout = _props.onLayout,
          style = _props.style,
          props = babelHelpers.objectWithoutProperties(_props, ["onLayout", "style"]);
      var sizeStyle = void 0;

      switch (props.size) {
        case 'small':
          sizeStyle = styles.sizeSmall;
          break;

        case 'large':
          sizeStyle = styles.sizeLarge;
          break;

        default:
          sizeStyle = {
            height: props.size,
            width: props.size
          };
          break;
      }

      var nativeProps = babelHelpers.extends({}, props, {
        style: sizeStyle,
        styleAttr: 'Normal',
        indeterminate: true
      });
      return React.createElement(
        View,
        {
          onLayout: onLayout,
          style: [styles.container, style],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 114
          }
        },
        Platform.OS === 'ios' ? React.createElement(RCTActivityIndicator, babelHelpers.extends({}, nativeProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 116
          }
        })) : React.createElement(ProgressBarAndroid, babelHelpers.extends({}, nativeProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 118
          }
        }))
      );
    }
  });
  var styles = StyleSheet.create({
    container: {
      alignItems: 'center',
      justifyContent: 'center'
    },
    sizeSmall: {
      width: 20,
      height: 20
    },
    sizeLarge: {
      width: 36,
      height: 36
    }
  });

  if (Platform.OS === 'ios') {
    var RCTActivityIndicator = requireNativeComponent('RCTActivityIndicatorView', ActivityIndicator, {
      nativeOnly: {
        activityIndicatorViewStyle: true
      }
    });
  }

  module.exports = ActivityIndicator;
},166,[167,169,105,170,24,171,209,211,172,213,186],"ActivityIndicator");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var normalizeColor = require(_dependencyMap[0], 'normalizeColor');

  var colorPropType = function colorPropType(isRequired, props, propName, componentName, location, propFullName) {
    var color = props[propName];

    if (color === undefined || color === null) {
      if (isRequired) {
        return new Error('Required ' + location + ' `' + (propFullName || propName) + '` was not specified in `' + componentName + '`.');
      }

      return;
    }

    if (typeof color === 'number') {
      return;
    }

    if (normalizeColor(color) === null) {
      return new Error('Invalid ' + location + ' `' + (propFullName || propName) + '` supplied to `' + componentName + '`: ' + color + '\n' + "Valid color formats are\n  - '#f0f' (#rgb)\n  - '#f0fc' (#rgba)\n  - '#ff00ff' (#rrggbb)\n  - '#ff00ff00' (#rrggbbaa)\n  - 'rgb(255, 255, 255)'\n  - 'rgba(255, 255, 255, 1.0)'\n  - 'hsl(360, 100%, 100%)'\n  - 'hsla(360, 100%, 100%, 1.0)'\n  - 'transparent'\n  - 'red'\n  - 0xff00ff00 (0xrrggbbaa)\n");
    }
  };

  var ColorPropType = colorPropType.bind(null, false);
  ColorPropType.isRequired = colorPropType.bind(null, true);
  module.exports = ColorPropType;
},167,[168],"ColorPropType");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function normalizeColor(color) {
    var match;

    if (typeof color === 'number') {
      if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
        return color;
      }

      return null;
    }

    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + 'ff', 16) >>> 0;
    }

    if (names.hasOwnProperty(color)) {
      return names[color];
    }

    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 0x000000ff) >>> 0;
    }

    if (match = matchers.rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }

    if (match = matchers.hex3.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + 'ff', 16) >>> 0;
    }

    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }

    if (match = matchers.hex4.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }

    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 0x000000ff) >>> 0;
    }

    if (match = matchers.hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }

    return null;
  }

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }

  function hslToRgb(h, s, l) {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    var r = hue2rgb(p, q, h + 1 / 3);
    var g = hue2rgb(p, q, h);
    var b = hue2rgb(p, q, h - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }

  var NUMBER = '[-+]?\\d*\\.?\\d+';
  var PERCENTAGE = NUMBER + '%';

  function call() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return '\\(\\s*(' + args.join(')\\s*,\\s*(') + ')\\s*\\)';
  }

  var matchers = {
    rgb: new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER)),
    rgba: new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER)),
    hsl: new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
    hsla: new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)),
    hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#([0-9a-fA-F]{6})$/,
    hex8: /^#([0-9a-fA-F]{8})$/
  };

  function parse255(str) {
    var int = parseInt(str, 10);

    if (int < 0) {
      return 0;
    }

    if (int > 255) {
      return 255;
    }

    return int;
  }

  function parse360(str) {
    var int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }

  function parse1(str) {
    var num = parseFloat(str);

    if (num < 0) {
      return 0;
    }

    if (num > 1) {
      return 255;
    }

    return Math.round(num * 255);
  }

  function parsePercentage(str) {
    var int = parseFloat(str);

    if (int < 0) {
      return 0;
    }

    if (int > 100) {
      return 1;
    }

    return int / 100;
  }

  var names = {
    transparent: 0x00000000,
    aliceblue: 0xf0f8ffff,
    antiquewhite: 0xfaebd7ff,
    aqua: 0x00ffffff,
    aquamarine: 0x7fffd4ff,
    azure: 0xf0ffffff,
    beige: 0xf5f5dcff,
    bisque: 0xffe4c4ff,
    black: 0x000000ff,
    blanchedalmond: 0xffebcdff,
    blue: 0x0000ffff,
    blueviolet: 0x8a2be2ff,
    brown: 0xa52a2aff,
    burlywood: 0xdeb887ff,
    burntsienna: 0xea7e5dff,
    cadetblue: 0x5f9ea0ff,
    chartreuse: 0x7fff00ff,
    chocolate: 0xd2691eff,
    coral: 0xff7f50ff,
    cornflowerblue: 0x6495edff,
    cornsilk: 0xfff8dcff,
    crimson: 0xdc143cff,
    cyan: 0x00ffffff,
    darkblue: 0x00008bff,
    darkcyan: 0x008b8bff,
    darkgoldenrod: 0xb8860bff,
    darkgray: 0xa9a9a9ff,
    darkgreen: 0x006400ff,
    darkgrey: 0xa9a9a9ff,
    darkkhaki: 0xbdb76bff,
    darkmagenta: 0x8b008bff,
    darkolivegreen: 0x556b2fff,
    darkorange: 0xff8c00ff,
    darkorchid: 0x9932ccff,
    darkred: 0x8b0000ff,
    darksalmon: 0xe9967aff,
    darkseagreen: 0x8fbc8fff,
    darkslateblue: 0x483d8bff,
    darkslategray: 0x2f4f4fff,
    darkslategrey: 0x2f4f4fff,
    darkturquoise: 0x00ced1ff,
    darkviolet: 0x9400d3ff,
    deeppink: 0xff1493ff,
    deepskyblue: 0x00bfffff,
    dimgray: 0x696969ff,
    dimgrey: 0x696969ff,
    dodgerblue: 0x1e90ffff,
    firebrick: 0xb22222ff,
    floralwhite: 0xfffaf0ff,
    forestgreen: 0x228b22ff,
    fuchsia: 0xff00ffff,
    gainsboro: 0xdcdcdcff,
    ghostwhite: 0xf8f8ffff,
    gold: 0xffd700ff,
    goldenrod: 0xdaa520ff,
    gray: 0x808080ff,
    green: 0x008000ff,
    greenyellow: 0xadff2fff,
    grey: 0x808080ff,
    honeydew: 0xf0fff0ff,
    hotpink: 0xff69b4ff,
    indianred: 0xcd5c5cff,
    indigo: 0x4b0082ff,
    ivory: 0xfffff0ff,
    khaki: 0xf0e68cff,
    lavender: 0xe6e6faff,
    lavenderblush: 0xfff0f5ff,
    lawngreen: 0x7cfc00ff,
    lemonchiffon: 0xfffacdff,
    lightblue: 0xadd8e6ff,
    lightcoral: 0xf08080ff,
    lightcyan: 0xe0ffffff,
    lightgoldenrodyellow: 0xfafad2ff,
    lightgray: 0xd3d3d3ff,
    lightgreen: 0x90ee90ff,
    lightgrey: 0xd3d3d3ff,
    lightpink: 0xffb6c1ff,
    lightsalmon: 0xffa07aff,
    lightseagreen: 0x20b2aaff,
    lightskyblue: 0x87cefaff,
    lightslategray: 0x778899ff,
    lightslategrey: 0x778899ff,
    lightsteelblue: 0xb0c4deff,
    lightyellow: 0xffffe0ff,
    lime: 0x00ff00ff,
    limegreen: 0x32cd32ff,
    linen: 0xfaf0e6ff,
    magenta: 0xff00ffff,
    maroon: 0x800000ff,
    mediumaquamarine: 0x66cdaaff,
    mediumblue: 0x0000cdff,
    mediumorchid: 0xba55d3ff,
    mediumpurple: 0x9370dbff,
    mediumseagreen: 0x3cb371ff,
    mediumslateblue: 0x7b68eeff,
    mediumspringgreen: 0x00fa9aff,
    mediumturquoise: 0x48d1ccff,
    mediumvioletred: 0xc71585ff,
    midnightblue: 0x191970ff,
    mintcream: 0xf5fffaff,
    mistyrose: 0xffe4e1ff,
    moccasin: 0xffe4b5ff,
    navajowhite: 0xffdeadff,
    navy: 0x000080ff,
    oldlace: 0xfdf5e6ff,
    olive: 0x808000ff,
    olivedrab: 0x6b8e23ff,
    orange: 0xffa500ff,
    orangered: 0xff4500ff,
    orchid: 0xda70d6ff,
    palegoldenrod: 0xeee8aaff,
    palegreen: 0x98fb98ff,
    paleturquoise: 0xafeeeeff,
    palevioletred: 0xdb7093ff,
    papayawhip: 0xffefd5ff,
    peachpuff: 0xffdab9ff,
    peru: 0xcd853fff,
    pink: 0xffc0cbff,
    plum: 0xdda0ddff,
    powderblue: 0xb0e0e6ff,
    purple: 0x800080ff,
    rebeccapurple: 0x663399ff,
    red: 0xff0000ff,
    rosybrown: 0xbc8f8fff,
    royalblue: 0x4169e1ff,
    saddlebrown: 0x8b4513ff,
    salmon: 0xfa8072ff,
    sandybrown: 0xf4a460ff,
    seagreen: 0x2e8b57ff,
    seashell: 0xfff5eeff,
    sienna: 0xa0522dff,
    silver: 0xc0c0c0ff,
    skyblue: 0x87ceebff,
    slateblue: 0x6a5acdff,
    slategray: 0x708090ff,
    slategrey: 0x708090ff,
    snow: 0xfffafaff,
    springgreen: 0x00ff7fff,
    steelblue: 0x4682b4ff,
    tan: 0xd2b48cff,
    teal: 0x008080ff,
    thistle: 0xd8bfd8ff,
    tomato: 0xff6347ff,
    turquoise: 0x40e0d0ff,
    violet: 0xee82eeff,
    wheat: 0xf5deb3ff,
    white: 0xffffffff,
    whitesmoke: 0xf5f5f5ff,
    yellow: 0xffff00ff,
    yellowgreen: 0x9acd32ff
  };
  module.exports = normalizeColor;
},168,[],"normalizeColor");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'ReactNative'),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  var NativeMethodsMixin = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.NativeMethodsMixin;
  module.exports = NativeMethodsMixin;
},169,[74],"NativeMethodsMixin");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/ProgressBarAndroid/ProgressBarAndroid.android.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var PropTypes = require(_dependencyMap[1], 'prop-types');

  var React = require(_dependencyMap[2], 'React');

  var ReactNative = require(_dependencyMap[3], 'ReactNative');

  var ViewPropTypes = require(_dependencyMap[4], 'ViewPropTypes');

  var requireNativeComponent = require(_dependencyMap[5], 'requireNativeComponent');

  var STYLE_ATTRIBUTES = ['Horizontal', 'Normal', 'Small', 'Large', 'Inverse', 'SmallInverse', 'LargeInverse'];

  var indeterminateType = function indeterminateType(props, propName, componentName) {
    var checker = function checker() {
      var indeterminate = props[propName];
      var styleAttr = props.styleAttr;

      if (!indeterminate && styleAttr !== 'Horizontal') {
        return new Error('indeterminate=false is only valid for styleAttr=Horizontal');
      }
    };

    for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest[_key - 3] = arguments[_key];
    }

    return PropTypes.bool.apply(PropTypes, [props, propName, componentName].concat(rest)) || checker();
  };

  var ProgressBarAndroid = function (_ReactNative$NativeCo) {
    babelHelpers.inherits(ProgressBarAndroid, _ReactNative$NativeCo);

    function ProgressBarAndroid() {
      babelHelpers.classCallCheck(this, ProgressBarAndroid);
      return babelHelpers.possibleConstructorReturn(this, (ProgressBarAndroid.__proto__ || Object.getPrototypeOf(ProgressBarAndroid)).apply(this, arguments));
    }

    babelHelpers.createClass(ProgressBarAndroid, [{
      key: "render",
      value: function render() {
        return React.createElement(AndroidProgressBar, babelHelpers.extends({}, this.props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 112
          }
        }));
      }
    }]);
    return ProgressBarAndroid;
  }(ReactNative.NativeComponent);

  ProgressBarAndroid.propTypes = babelHelpers.extends({}, ViewPropTypes, {
    styleAttr: PropTypes.oneOf(STYLE_ATTRIBUTES),
    animating: PropTypes.bool,
    indeterminate: indeterminateType,
    progress: PropTypes.number,
    color: ColorPropType,
    testID: PropTypes.string
  });
  ProgressBarAndroid.defaultProps = {
    styleAttr: 'Normal',
    indeterminate: true,
    animating: true
  };
  var AndroidProgressBar = requireNativeComponent('AndroidProgressBar', ProgressBarAndroid, {
    nativeOnly: {
      animating: true
    }
  });
  module.exports = ProgressBarAndroid;
},170,[167,24,171,74,172,186],"ProgressBarAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  module.exports = require(_dependencyMap[0], 'react');
},171,[12],"React");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EdgeInsetsPropType = require(_dependencyMap[0], 'EdgeInsetsPropType');

  var PlatformViewPropTypes = require(_dependencyMap[1], 'PlatformViewPropTypes');

  var PropTypes = require(_dependencyMap[2], 'prop-types');

  var StyleSheetPropType = require(_dependencyMap[3], 'StyleSheetPropType');

  var ViewStylePropTypes = require(_dependencyMap[4], 'ViewStylePropTypes');

  var _require = require(_dependencyMap[5], 'ViewAccessibility'),
      AccessibilityComponentTypes = _require.AccessibilityComponentTypes,
      AccessibilityTraits = _require.AccessibilityTraits;

  var stylePropType = StyleSheetPropType(ViewStylePropTypes);
  module.exports = babelHelpers.extends({}, PlatformViewPropTypes, {
    accessible: PropTypes.bool,
    accessibilityLabel: PropTypes.node,
    accessibilityActions: PropTypes.arrayOf(PropTypes.string),
    accessibilityComponentType: PropTypes.oneOf(AccessibilityComponentTypes),
    accessibilityLiveRegion: PropTypes.oneOf(['none', 'polite', 'assertive']),
    importantForAccessibility: PropTypes.oneOf(['auto', 'yes', 'no', 'no-hide-descendants']),
    accessibilityTraits: PropTypes.oneOfType([PropTypes.oneOf(AccessibilityTraits), PropTypes.arrayOf(PropTypes.oneOf(AccessibilityTraits))]),
    accessibilityViewIsModal: PropTypes.bool,
    onAccessibilityAction: PropTypes.func,
    onAccessibilityTap: PropTypes.func,
    onMagicTap: PropTypes.func,
    testID: PropTypes.string,
    nativeID: PropTypes.string,
    onResponderGrant: PropTypes.func,
    onResponderMove: PropTypes.func,
    onResponderReject: PropTypes.func,
    onResponderRelease: PropTypes.func,
    onResponderTerminate: PropTypes.func,
    onResponderTerminationRequest: PropTypes.func,
    onStartShouldSetResponder: PropTypes.func,
    onStartShouldSetResponderCapture: PropTypes.func,
    onMoveShouldSetResponder: PropTypes.func,
    onMoveShouldSetResponderCapture: PropTypes.func,
    hitSlop: EdgeInsetsPropType,
    onLayout: PropTypes.func,
    pointerEvents: PropTypes.oneOf(['box-none', 'none', 'box-only', 'auto']),
    style: stylePropType,
    removeClippedSubviews: PropTypes.bool,
    renderToHardwareTextureAndroid: PropTypes.bool,
    shouldRasterizeIOS: PropTypes.bool,
    collapsable: PropTypes.bool,
    needsOffscreenAlphaCompositing: PropTypes.bool
  });
},172,[173,178,24,179,180,185],"ViewPropTypes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var PropTypes = require(_dependencyMap[0], 'prop-types');

  var createStrictShapeTypeChecker = require(_dependencyMap[1], 'createStrictShapeTypeChecker');

  var EdgeInsetsPropType = createStrictShapeTypeChecker({
    top: PropTypes.number,
    left: PropTypes.number,
    bottom: PropTypes.number,
    right: PropTypes.number
  });
  module.exports = EdgeInsetsPropType;
},173,[24,174],"EdgeInsetsPropType");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var merge = require(_dependencyMap[1], 'merge');

  function createStrictShapeTypeChecker(shapeTypes) {
    function checkType(isRequired, props, propName, componentName, location) {
      if (!props[propName]) {
        if (isRequired) {
          invariant(false, "Required object `" + propName + "` was not specified in " + ("`" + componentName + "`."));
        }

        return;
      }

      var propValue = props[propName];
      var propType = typeof propValue;
      var locationName = location || '(unknown)';

      if (propType !== 'object') {
        invariant(false, "Invalid " + locationName + " `" + propName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
      }

      var allKeys = merge(props[propName], shapeTypes);

      for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
        rest[_key - 5] = arguments[_key];
      }

      for (var key in allKeys) {
        var checker = shapeTypes[key];

        if (!checker) {
          invariant(false, "Invalid props." + propName + " key `" + key + "` supplied to `" + componentName + "`." + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }

        var error = checker.apply(undefined, [propValue, key, componentName, location].concat(rest));

        if (error) {
          invariant(false, error.message + '\nBad object: ' + JSON.stringify(props[propName], null, '  '));
        }
      }
    }

    function chainedCheckType(props, propName, componentName, location) {
      for (var _len2 = arguments.length, rest = Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {
        rest[_key2 - 4] = arguments[_key2];
      }

      return checkType.apply(undefined, [false, props, propName, componentName, location].concat(rest));
    }

    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }

  module.exports = createStrictShapeTypeChecker;
},174,[18,175],"createStrictShapeTypeChecker");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  var mergeInto = require(_dependencyMap[0], 'mergeInto');

  var merge = function merge(one, two) {
    var result = {};
    mergeInto(result, one);
    mergeInto(result, two);
    return result;
  };

  module.exports = merge;
},175,[176],"merge");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  var mergeHelpers = require(_dependencyMap[0], 'mergeHelpers');

  var checkMergeObjectArg = mergeHelpers.checkMergeObjectArg;
  var checkMergeIntoObjectArg = mergeHelpers.checkMergeIntoObjectArg;

  function mergeInto(one, two) {
    checkMergeIntoObjectArg(one);

    if (two != null) {
      checkMergeObjectArg(two);

      for (var key in two) {
        if (!two.hasOwnProperty(key)) {
          continue;
        }

        one[key] = two[key];
      }
    }
  }

  module.exports = mergeInto;
},176,[177],"mergeInto");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var MAX_MERGE_DEPTH = 36;

  var isTerminal = function isTerminal(o) {
    return typeof o !== 'object' || o instanceof Date || o === null;
  };

  var mergeHelpers = {
    MAX_MERGE_DEPTH: MAX_MERGE_DEPTH,
    isTerminal: isTerminal,
    normalizeMergeArg: function normalizeMergeArg(arg) {
      return arg === undefined || arg === null ? {} : arg;
    },
    checkMergeArrayArgs: function checkMergeArrayArgs(one, two) {
      invariant(Array.isArray(one) && Array.isArray(two), 'Tried to merge arrays, instead got %s and %s.', one, two);
    },
    checkMergeObjectArgs: function checkMergeObjectArgs(one, two) {
      mergeHelpers.checkMergeObjectArg(one);
      mergeHelpers.checkMergeObjectArg(two);
    },
    checkMergeObjectArg: function checkMergeObjectArg(arg) {
      invariant(!isTerminal(arg) && !Array.isArray(arg), 'Tried to merge an object, instead got %s.', arg);
    },
    checkMergeIntoObjectArg: function checkMergeIntoObjectArg(arg) {
      invariant((!isTerminal(arg) || typeof arg === 'function') && !Array.isArray(arg), 'Tried to merge into an object, instead got %s.', arg);
    },
    checkMergeLevel: function checkMergeLevel(level) {
      invariant(level < MAX_MERGE_DEPTH, 'Maximum deep merge depth exceeded. You may be attempting to merge ' + 'circular structures in an unsupported way.');
    },
    checkArrayStrategy: function checkArrayStrategy(strategy) {
      invariant(strategy === undefined || strategy in mergeHelpers.ArrayStrategies, 'You must provide an array strategy to deep merge functions to ' + 'instruct the deep merge how to resolve merging two arrays.');
    },
    ArrayStrategies: {
      Clobber: 'Clobber',
      Concat: 'Concat',
      IndexByIndex: 'IndexByIndex'
    }
  };
  module.exports = mergeHelpers;
},177,[18],"mergeHelpers");
__d(function (global, require, module, exports, _dependencyMap) {
  module.export = {};
},178,[],"PlatformViewPropTypes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var createStrictShapeTypeChecker = require(_dependencyMap[0], 'createStrictShapeTypeChecker');

  var flattenStyle = require(_dependencyMap[1], 'flattenStyle');

  function StyleSheetPropType(shape) {
    var shapePropType = createStrictShapeTypeChecker(shape);
    return function (props, propName, componentName, location) {
      var newProps = props;

      if (props[propName]) {
        newProps = {};
        newProps[propName] = flattenStyle(props[propName]);
      }

      for (var _len = arguments.length, rest = Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        rest[_key - 4] = arguments[_key];
      }

      return shapePropType.apply(undefined, [newProps, propName, componentName, location].concat(rest));
    };
  }

  module.exports = StyleSheetPropType;
},179,[174,152],"StyleSheetPropType");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var LayoutPropTypes = require(_dependencyMap[1], 'LayoutPropTypes');

  var ReactPropTypes = require(_dependencyMap[2], 'prop-types');

  var ShadowPropTypesIOS = require(_dependencyMap[3], 'ShadowPropTypesIOS');

  var TransformPropTypes = require(_dependencyMap[4], 'TransformPropTypes');

  var ViewStylePropTypes = babelHelpers.extends({}, LayoutPropTypes, ShadowPropTypesIOS, TransformPropTypes, {
    backfaceVisibility: ReactPropTypes.oneOf(['visible', 'hidden']),
    backgroundColor: ColorPropType,
    borderColor: ColorPropType,
    borderTopColor: ColorPropType,
    borderRightColor: ColorPropType,
    borderBottomColor: ColorPropType,
    borderLeftColor: ColorPropType,
    borderStartColor: ColorPropType,
    borderEndColor: ColorPropType,
    borderRadius: ReactPropTypes.number,
    borderTopLeftRadius: ReactPropTypes.number,
    borderTopRightRadius: ReactPropTypes.number,
    borderTopStartRadius: ReactPropTypes.number,
    borderTopEndRadius: ReactPropTypes.number,
    borderBottomLeftRadius: ReactPropTypes.number,
    borderBottomRightRadius: ReactPropTypes.number,
    borderBottomStartRadius: ReactPropTypes.number,
    borderBottomEndRadius: ReactPropTypes.number,
    borderStyle: ReactPropTypes.oneOf(['solid', 'dotted', 'dashed']),
    borderWidth: ReactPropTypes.number,
    borderTopWidth: ReactPropTypes.number,
    borderRightWidth: ReactPropTypes.number,
    borderBottomWidth: ReactPropTypes.number,
    borderLeftWidth: ReactPropTypes.number,
    opacity: ReactPropTypes.number,
    elevation: ReactPropTypes.number
  });
  module.exports = ViewStylePropTypes;
},180,[167,181,24,182,183],"ViewStylePropTypes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ReactPropTypes = require(_dependencyMap[0], 'prop-types');

  var LayoutPropTypes = {
    display: ReactPropTypes.oneOf(['none', 'flex']),
    width: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    height: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    start: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    end: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    top: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    left: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    right: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    bottom: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    minWidth: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    maxWidth: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    minHeight: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    maxHeight: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    margin: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginVertical: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginHorizontal: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginTop: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginBottom: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginLeft: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginRight: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginStart: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginEnd: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    padding: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingVertical: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingHorizontal: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingTop: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingBottom: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingLeft: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingRight: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingStart: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingEnd: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    borderWidth: ReactPropTypes.number,
    borderTopWidth: ReactPropTypes.number,
    borderStartWidth: ReactPropTypes.number,
    borderEndWidth: ReactPropTypes.number,
    borderRightWidth: ReactPropTypes.number,
    borderBottomWidth: ReactPropTypes.number,
    borderLeftWidth: ReactPropTypes.number,
    position: ReactPropTypes.oneOf(['absolute', 'relative']),
    flexDirection: ReactPropTypes.oneOf(['row', 'row-reverse', 'column', 'column-reverse']),
    flexWrap: ReactPropTypes.oneOf(['wrap', 'nowrap']),
    justifyContent: ReactPropTypes.oneOf(['flex-start', 'flex-end', 'center', 'space-between', 'space-around']),
    alignItems: ReactPropTypes.oneOf(['flex-start', 'flex-end', 'center', 'stretch', 'baseline']),
    alignSelf: ReactPropTypes.oneOf(['auto', 'flex-start', 'flex-end', 'center', 'stretch', 'baseline']),
    alignContent: ReactPropTypes.oneOf(['flex-start', 'flex-end', 'center', 'stretch', 'space-between', 'space-around']),
    overflow: ReactPropTypes.oneOf(['visible', 'hidden', 'scroll']),
    flex: ReactPropTypes.number,
    flexGrow: ReactPropTypes.number,
    flexShrink: ReactPropTypes.number,
    flexBasis: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    aspectRatio: ReactPropTypes.number,
    zIndex: ReactPropTypes.number,
    direction: ReactPropTypes.oneOf(['inherit', 'ltr', 'rtl'])
  };
  module.exports = LayoutPropTypes;
},181,[24],"LayoutPropTypes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var ReactPropTypes = require(_dependencyMap[1], 'prop-types');

  var ShadowPropTypesIOS = {
    shadowColor: ColorPropType,
    shadowOffset: ReactPropTypes.shape({
      width: ReactPropTypes.number,
      height: ReactPropTypes.number
    }),
    shadowOpacity: ReactPropTypes.number,
    shadowRadius: ReactPropTypes.number
  };
  module.exports = ShadowPropTypesIOS;
},182,[167,24],"ShadowPropTypesIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ReactPropTypes = require(_dependencyMap[0], 'prop-types');

  var deprecatedPropType = require(_dependencyMap[1], 'deprecatedPropType');

  var TransformMatrixPropType = function TransformMatrixPropType(props, propName, componentName) {
    if (props[propName]) {
      return new Error('The transformMatrix style property is deprecated. ' + 'Use `transform: [{ matrix: ... }]` instead.');
    }
  };

  var DecomposedMatrixPropType = function DecomposedMatrixPropType(props, propName, componentName) {
    if (props[propName]) {
      return new Error('The decomposedMatrix style property is deprecated. ' + 'Use `transform: [...]` instead.');
    }
  };

  var TransformPropTypes = {
    transform: ReactPropTypes.arrayOf(ReactPropTypes.oneOfType([ReactPropTypes.shape({
      perspective: ReactPropTypes.number
    }), ReactPropTypes.shape({
      rotate: ReactPropTypes.string
    }), ReactPropTypes.shape({
      rotateX: ReactPropTypes.string
    }), ReactPropTypes.shape({
      rotateY: ReactPropTypes.string
    }), ReactPropTypes.shape({
      rotateZ: ReactPropTypes.string
    }), ReactPropTypes.shape({
      scale: ReactPropTypes.number
    }), ReactPropTypes.shape({
      scaleX: ReactPropTypes.number
    }), ReactPropTypes.shape({
      scaleY: ReactPropTypes.number
    }), ReactPropTypes.shape({
      translateX: ReactPropTypes.number
    }), ReactPropTypes.shape({
      translateY: ReactPropTypes.number
    }), ReactPropTypes.shape({
      skewX: ReactPropTypes.string
    }), ReactPropTypes.shape({
      skewY: ReactPropTypes.string
    })])),
    transformMatrix: TransformMatrixPropType,
    decomposedMatrix: DecomposedMatrixPropType,
    scaleX: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
    scaleY: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
    rotation: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
    translateX: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
    translateY: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.')
  };
  module.exports = TransformPropTypes;
},183,[24,184],"TransformPropTypes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var UIManager = require(_dependencyMap[0], 'UIManager');

  function deprecatedPropType(propType, explanation) {
    return function validate(props, propName, componentName) {
      if (!UIManager[componentName] && props[propName] !== undefined) {
        console.warn("`" + propName + "` supplied to `" + componentName + "` has been deprecated. " + explanation);
      }

      for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        rest[_key - 3] = arguments[_key];
      }

      return propType.apply(undefined, [props, propName, componentName].concat(rest));
    };
  }

  module.exports = deprecatedPropType;
},184,[158],"deprecatedPropType");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    AccessibilityTraits: ['none', 'button', 'link', 'header', 'search', 'image', 'selected', 'plays', 'key', 'text', 'summary', 'disabled', 'frequentUpdates', 'startsMedia', 'adjustable', 'allowsDirectInteraction', 'pageTurn'],
    AccessibilityComponentTypes: ['none', 'button', 'radiobutton_checked', 'radiobutton_unchecked']
  };
},185,[],"ViewAccessibility");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Platform = require(_dependencyMap[0], 'Platform');

  var ReactNativeBridgeEventPlugin = require(_dependencyMap[1], 'ReactNativeBridgeEventPlugin');

  var ReactNativeStyleAttributes = require(_dependencyMap[2], 'ReactNativeStyleAttributes');

  var UIManager = require(_dependencyMap[3], 'UIManager');

  var createReactNativeComponentClass = require(_dependencyMap[4], 'createReactNativeComponentClass');

  var insetsDiffer = require(_dependencyMap[5], 'insetsDiffer');

  var matricesDiffer = require(_dependencyMap[6], 'matricesDiffer');

  var pointsDiffer = require(_dependencyMap[7], 'pointsDiffer');

  var processColor = require(_dependencyMap[8], 'processColor');

  var resolveAssetSource = require(_dependencyMap[9], 'resolveAssetSource');

  var sizesDiffer = require(_dependencyMap[10], 'sizesDiffer');

  var verifyPropTypes = require(_dependencyMap[11], 'verifyPropTypes');

  var invariant = require(_dependencyMap[12], 'fbjs/lib/invariant');

  var warning = require(_dependencyMap[13], 'fbjs/lib/warning');

  var hasAttachedDefaultEventTypes = false;

  function requireNativeComponent(viewName, componentInterface, extraConfig) {
    function attachDefaultEventTypes(viewConfig) {
      if (Platform.OS === 'android') {
        if (UIManager.ViewManagerNames) {
          viewConfig = merge(viewConfig, UIManager.getDefaultEventTypes());
        } else {
          viewConfig.bubblingEventTypes = merge(viewConfig.bubblingEventTypes, UIManager.genericBubblingEventTypes);
          viewConfig.directEventTypes = merge(viewConfig.directEventTypes, UIManager.genericDirectEventTypes);
        }
      }
    }

    function merge(destination, source) {
      if (!source) {
        return destination;
      }

      if (!destination) {
        return source;
      }

      for (var key in source) {
        if (!source.hasOwnProperty(key)) {
          continue;
        }

        var sourceValue = source[key];

        if (destination.hasOwnProperty(key)) {
          var destinationValue = destination[key];

          if (typeof sourceValue === 'object' && typeof destinationValue === 'object') {
            sourceValue = merge(destinationValue, sourceValue);
          }
        }

        destination[key] = sourceValue;
      }

      return destination;
    }

    function getViewConfig() {
      var viewConfig = UIManager[viewName];
      invariant(viewConfig != null && !viewConfig.NativeProps != null, 'Native component for "%s" does not exist', viewName);
      viewConfig.uiViewClassName = viewName;
      viewConfig.validAttributes = {};

      if (componentInterface) {
        viewConfig.propTypes = typeof componentInterface.__propTypesSecretDontUseThesePlease === 'object' ? componentInterface.__propTypesSecretDontUseThesePlease : componentInterface.propTypes;
      } else {
        viewConfig.propTypes = null;
      }

      var baseModuleName = viewConfig.baseModuleName;
      var nativeProps = babelHelpers.extends({}, viewConfig.NativeProps);

      while (baseModuleName) {
        var baseModule = UIManager[baseModuleName];

        if (!baseModule) {
          warning(false, 'Base module "%s" does not exist', baseModuleName);
          baseModuleName = null;
        } else {
          nativeProps = babelHelpers.extends({}, nativeProps, baseModule.NativeProps);
          baseModuleName = baseModule.baseModuleName;
        }
      }

      for (var key in nativeProps) {
        var useAttribute = false;
        var attribute = {};
        var differ = TypeToDifferMap[nativeProps[key]];

        if (differ) {
          attribute.diff = differ;
          useAttribute = true;
        }

        var processor = TypeToProcessorMap[nativeProps[key]];

        if (processor) {
          attribute.process = processor;
          useAttribute = true;
        }

        viewConfig.validAttributes[key] = useAttribute ? attribute : true;
      }

      viewConfig.validAttributes.style = ReactNativeStyleAttributes;

      if (__DEV__) {
        componentInterface && verifyPropTypes(componentInterface, viewConfig, extraConfig && extraConfig.nativeOnly);
      }

      if (!hasAttachedDefaultEventTypes) {
        attachDefaultEventTypes(viewConfig);
        hasAttachedDefaultEventTypes = true;
      }

      ReactNativeBridgeEventPlugin.processEventTypes(viewConfig);
      return viewConfig;
    }

    return createReactNativeComponentClass(viewName, getViewConfig);
  }

  var TypeToDifferMap = {
    CATransform3D: matricesDiffer,
    CGPoint: pointsDiffer,
    CGSize: sizesDiffer,
    UIEdgeInsets: insetsDiffer
  };

  function processColorArray(colors) {
    return colors && colors.map(processColor);
  }

  var TypeToProcessorMap = {
    CGColor: processColor,
    CGColorArray: processColorArray,
    UIColor: processColor,
    UIColorArray: processColorArray,
    CGImage: resolveAssetSource,
    UIImage: resolveAssetSource,
    RCTImageSource: resolveAssetSource,
    Color: processColor,
    ColorArray: processColorArray
  };
  module.exports = requireNativeComponent;
},186,[105,187,188,158,197,198,199,200,193,201,196,208,18,19],"requireNativeComponent");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'ReactNative'),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  module.exports = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactNativeBridgeEventPlugin;
},187,[74],"ReactNativeBridgeEventPlugin");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ImageStylePropTypes = require(_dependencyMap[0], 'ImageStylePropTypes');

  var TextStylePropTypes = require(_dependencyMap[1], 'TextStylePropTypes');

  var ViewStylePropTypes = require(_dependencyMap[2], 'ViewStylePropTypes');

  var keyMirror = require(_dependencyMap[3], 'fbjs/lib/keyMirror');

  var processColor = require(_dependencyMap[4], 'processColor');

  var processTransform = require(_dependencyMap[5], 'processTransform');

  var sizesDiffer = require(_dependencyMap[6], 'sizesDiffer');

  var ReactNativeStyleAttributes = babelHelpers.extends({}, keyMirror(ViewStylePropTypes), keyMirror(TextStylePropTypes), keyMirror(ImageStylePropTypes));
  ReactNativeStyleAttributes.transform = {
    process: processTransform
  };
  ReactNativeStyleAttributes.shadowOffset = {
    diff: sizesDiffer
  };
  var colorAttributes = {
    process: processColor
  };
  ReactNativeStyleAttributes.backgroundColor = colorAttributes;
  ReactNativeStyleAttributes.borderBottomColor = colorAttributes;
  ReactNativeStyleAttributes.borderColor = colorAttributes;
  ReactNativeStyleAttributes.borderLeftColor = colorAttributes;
  ReactNativeStyleAttributes.borderRightColor = colorAttributes;
  ReactNativeStyleAttributes.borderTopColor = colorAttributes;
  ReactNativeStyleAttributes.borderStartColor = colorAttributes;
  ReactNativeStyleAttributes.borderEndColor = colorAttributes;
  ReactNativeStyleAttributes.color = colorAttributes;
  ReactNativeStyleAttributes.shadowColor = colorAttributes;
  ReactNativeStyleAttributes.textDecorationColor = colorAttributes;
  ReactNativeStyleAttributes.tintColor = colorAttributes;
  ReactNativeStyleAttributes.textShadowColor = colorAttributes;
  ReactNativeStyleAttributes.overlayColor = colorAttributes;
  module.exports = ReactNativeStyleAttributes;
},188,[189,192,180,191,193,194,196],"ReactNativeStyleAttributes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var ImageResizeMode = require(_dependencyMap[1], 'ImageResizeMode');

  var LayoutPropTypes = require(_dependencyMap[2], 'LayoutPropTypes');

  var ReactPropTypes = require(_dependencyMap[3], 'prop-types');

  var ShadowPropTypesIOS = require(_dependencyMap[4], 'ShadowPropTypesIOS');

  var TransformPropTypes = require(_dependencyMap[5], 'TransformPropTypes');

  var ImageStylePropTypes = babelHelpers.extends({}, LayoutPropTypes, ShadowPropTypesIOS, TransformPropTypes, {
    resizeMode: ReactPropTypes.oneOf(Object.keys(ImageResizeMode)),
    backfaceVisibility: ReactPropTypes.oneOf(['visible', 'hidden']),
    backgroundColor: ColorPropType,
    borderColor: ColorPropType,
    borderWidth: ReactPropTypes.number,
    borderRadius: ReactPropTypes.number,
    overflow: ReactPropTypes.oneOf(['visible', 'hidden']),
    tintColor: ColorPropType,
    opacity: ReactPropTypes.number,
    overlayColor: ReactPropTypes.string,
    borderTopLeftRadius: ReactPropTypes.number,
    borderTopRightRadius: ReactPropTypes.number,
    borderBottomLeftRadius: ReactPropTypes.number,
    borderBottomRightRadius: ReactPropTypes.number
  });
  module.exports = ImageStylePropTypes;
},189,[167,190,181,24,182,183],"ImageStylePropTypes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var keyMirror = require(_dependencyMap[0], 'fbjs/lib/keyMirror');

  var ImageResizeMode = keyMirror({
    contain: null,
    cover: null,
    stretch: null,
    center: null,
    repeat: null
  });
  module.exports = ImageResizeMode;
},190,[191],"ImageResizeMode");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], './invariant');

  var keyMirror = function keyMirror(obj) {
    var ret = {};
    var key;
    !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;

    for (key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }

      ret[key] = key;
    }

    return ret;
  };

  module.exports = keyMirror;
},191,[18],"fbjs/lib/keyMirror.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var ReactPropTypes = require(_dependencyMap[1], 'prop-types');

  var ViewStylePropTypes = require(_dependencyMap[2], 'ViewStylePropTypes');

  var TextStylePropTypes = babelHelpers.extends({}, ViewStylePropTypes, {
    color: ColorPropType,
    fontFamily: ReactPropTypes.string,
    fontSize: ReactPropTypes.number,
    fontStyle: ReactPropTypes.oneOf(['normal', 'italic']),
    fontWeight: ReactPropTypes.oneOf(['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900']),
    fontVariant: ReactPropTypes.arrayOf(ReactPropTypes.oneOf(['small-caps', 'oldstyle-nums', 'lining-nums', 'tabular-nums', 'proportional-nums'])),
    textShadowOffset: ReactPropTypes.shape({
      width: ReactPropTypes.number,
      height: ReactPropTypes.number
    }),
    textShadowRadius: ReactPropTypes.number,
    textShadowColor: ColorPropType,
    letterSpacing: ReactPropTypes.number,
    lineHeight: ReactPropTypes.number,
    textAlign: ReactPropTypes.oneOf(['auto', 'left', 'right', 'center', 'justify']),
    textAlignVertical: ReactPropTypes.oneOf(['auto', 'top', 'bottom', 'center']),
    includeFontPadding: ReactPropTypes.bool,
    textDecorationLine: ReactPropTypes.oneOf(['none', 'underline', 'line-through', 'underline line-through']),
    textDecorationStyle: ReactPropTypes.oneOf(['solid', 'double', 'dotted', 'dashed']),
    textDecorationColor: ColorPropType,
    writingDirection: ReactPropTypes.oneOf(['auto', 'ltr', 'rtl'])
  });
  module.exports = TextStylePropTypes;
},192,[167,24,180],"TextStylePropTypes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Platform = require(_dependencyMap[0], 'Platform');

  var normalizeColor = require(_dependencyMap[1], 'normalizeColor');

  function processColor(color) {
    if (color === undefined || color === null) {
      return color;
    }

    var int32Color = normalizeColor(color);

    if (int32Color === null || int32Color === undefined) {
      return undefined;
    }

    int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0;

    if (Platform.OS === 'android') {
      int32Color = int32Color | 0x0;
    }

    return int32Color;
  }

  module.exports = processColor;
},193,[105,168],"processColor");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var MatrixMath = require(_dependencyMap[0], 'MatrixMath');

  var Platform = require(_dependencyMap[1], 'Platform');

  var invariant = require(_dependencyMap[2], 'fbjs/lib/invariant');

  var stringifySafe = require(_dependencyMap[3], 'stringifySafe');

  function processTransform(transform) {
    if (__DEV__) {
      _validateTransforms(transform);
    }

    if (Platform.OS === 'android' || Platform.OS === 'ios') {
      return transform;
    }

    var result = MatrixMath.createIdentityMatrix();
    transform.forEach(function (transformation) {
      var key = Object.keys(transformation)[0];
      var value = transformation[key];

      switch (key) {
        case 'matrix':
          MatrixMath.multiplyInto(result, result, value);
          break;

        case 'perspective':
          _multiplyTransform(result, MatrixMath.reusePerspectiveCommand, [value]);

          break;

        case 'rotateX':
          _multiplyTransform(result, MatrixMath.reuseRotateXCommand, [_convertToRadians(value)]);

          break;

        case 'rotateY':
          _multiplyTransform(result, MatrixMath.reuseRotateYCommand, [_convertToRadians(value)]);

          break;

        case 'rotate':
        case 'rotateZ':
          _multiplyTransform(result, MatrixMath.reuseRotateZCommand, [_convertToRadians(value)]);

          break;

        case 'scale':
          _multiplyTransform(result, MatrixMath.reuseScaleCommand, [value]);

          break;

        case 'scaleX':
          _multiplyTransform(result, MatrixMath.reuseScaleXCommand, [value]);

          break;

        case 'scaleY':
          _multiplyTransform(result, MatrixMath.reuseScaleYCommand, [value]);

          break;

        case 'translate':
          _multiplyTransform(result, MatrixMath.reuseTranslate3dCommand, [value[0], value[1], value[2] || 0]);

          break;

        case 'translateX':
          _multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [value, 0]);

          break;

        case 'translateY':
          _multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [0, value]);

          break;

        case 'skewX':
          _multiplyTransform(result, MatrixMath.reuseSkewXCommand, [_convertToRadians(value)]);

          break;

        case 'skewY':
          _multiplyTransform(result, MatrixMath.reuseSkewYCommand, [_convertToRadians(value)]);

          break;

        default:
          throw new Error('Invalid transform name: ' + key);
      }
    });
    return result;
  }

  function _multiplyTransform(result, matrixMathFunction, args) {
    var matrixToApply = MatrixMath.createIdentityMatrix();
    var argsWithIdentity = [matrixToApply].concat(args);
    matrixMathFunction.apply(this, argsWithIdentity);
    MatrixMath.multiplyInto(result, result, matrixToApply);
  }

  function _convertToRadians(value) {
    var floatValue = parseFloat(value);
    return value.indexOf('rad') > -1 ? floatValue : floatValue * Math.PI / 180;
  }

  function _validateTransforms(transform) {
    transform.forEach(function (transformation) {
      var keys = Object.keys(transformation);
      invariant(keys.length === 1, 'You must specify exactly one property per transform object. Passed properties: %s', stringifySafe(transformation));
      var key = keys[0];
      var value = transformation[key];

      _validateTransform(key, value, transformation);
    });
  }

  function _validateTransform(key, value, transformation) {
    invariant(!value.getValue, 'You passed an Animated.Value to a normal component. ' + 'You need to wrap that component in an Animated. For example, ' + 'replace <View /> by <Animated.View />.');
    var multivalueTransforms = ['matrix', 'translate'];

    if (multivalueTransforms.indexOf(key) !== -1) {
      invariant(Array.isArray(value), 'Transform with key of %s must have an array as the value: %s', key, stringifySafe(transformation));
    }

    switch (key) {
      case 'matrix':
        invariant(value.length === 9 || value.length === 16, 'Matrix transform must have a length of 9 (2d) or 16 (3d). ' + 'Provided matrix has a length of %s: %s', value.length, stringifySafe(transformation));
        break;

      case 'translate':
        invariant(value.length === 2 || value.length === 3, 'Transform with key translate must be an array of length 2 or 3, found %s: %s', value.length, stringifySafe(transformation));
        break;

      case 'rotateX':
      case 'rotateY':
      case 'rotateZ':
      case 'rotate':
      case 'skewX':
      case 'skewY':
        invariant(typeof value === 'string', 'Transform with key of "%s" must be a string: %s', key, stringifySafe(transformation));
        invariant(value.indexOf('deg') > -1 || value.indexOf('rad') > -1, 'Rotate transform must be expressed in degrees (deg) or radians ' + '(rad): %s', stringifySafe(transformation));
        break;

      case 'perspective':
        invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));
        invariant(value !== 0, 'Transform with key of "%s" cannot be zero: %s', key, stringifySafe(transformation));
        break;

      case 'translateX':
      case 'translateY':
      case 'scale':
      case 'scaleX':
      case 'scaleY':
        invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));
        break;

      default:
        invariant(false, 'Invalid transform %s: %s', key, stringifySafe(transformation));
    }
  }

  module.exports = processTransform;
},194,[195,105,18,92],"processTransform");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var MatrixMath = {
    createIdentityMatrix: function createIdentityMatrix() {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    },
    createCopy: function createCopy(m) {
      return [m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]];
    },
    createOrthographic: function createOrthographic(left, right, bottom, top, near, far) {
      var a = 2 / (right - left);
      var b = 2 / (top - bottom);
      var c = -2 / (far - near);
      var tx = -(right + left) / (right - left);
      var ty = -(top + bottom) / (top - bottom);
      var tz = -(far + near) / (far - near);
      return [a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, tx, ty, tz, 1];
    },
    createFrustum: function createFrustum(left, right, bottom, top, near, far) {
      var r_width = 1 / (right - left);
      var r_height = 1 / (top - bottom);
      var r_depth = 1 / (near - far);
      var x = 2 * (near * r_width);
      var y = 2 * (near * r_height);
      var A = (right + left) * r_width;
      var B = (top + bottom) * r_height;
      var C = (far + near) * r_depth;
      var D = 2 * (far * near * r_depth);
      return [x, 0, 0, 0, 0, y, 0, 0, A, B, C, -1, 0, 0, D, 0];
    },
    createPerspective: function createPerspective(fovInRadians, aspect, near, far) {
      var h = 1 / Math.tan(fovInRadians / 2);
      var r_depth = 1 / (near - far);
      var C = (far + near) * r_depth;
      var D = 2 * (far * near * r_depth);
      return [h / aspect, 0, 0, 0, 0, h, 0, 0, 0, 0, C, -1, 0, 0, D, 0];
    },
    createTranslate2d: function createTranslate2d(x, y) {
      var mat = MatrixMath.createIdentityMatrix();
      MatrixMath.reuseTranslate2dCommand(mat, x, y);
      return mat;
    },
    reuseTranslate2dCommand: function reuseTranslate2dCommand(matrixCommand, x, y) {
      matrixCommand[12] = x;
      matrixCommand[13] = y;
    },
    reuseTranslate3dCommand: function reuseTranslate3dCommand(matrixCommand, x, y, z) {
      matrixCommand[12] = x;
      matrixCommand[13] = y;
      matrixCommand[14] = z;
    },
    createScale: function createScale(factor) {
      var mat = MatrixMath.createIdentityMatrix();
      MatrixMath.reuseScaleCommand(mat, factor);
      return mat;
    },
    reuseScaleCommand: function reuseScaleCommand(matrixCommand, factor) {
      matrixCommand[0] = factor;
      matrixCommand[5] = factor;
    },
    reuseScale3dCommand: function reuseScale3dCommand(matrixCommand, x, y, z) {
      matrixCommand[0] = x;
      matrixCommand[5] = y;
      matrixCommand[10] = z;
    },
    reusePerspectiveCommand: function reusePerspectiveCommand(matrixCommand, p) {
      matrixCommand[11] = -1 / p;
    },
    reuseScaleXCommand: function reuseScaleXCommand(matrixCommand, factor) {
      matrixCommand[0] = factor;
    },
    reuseScaleYCommand: function reuseScaleYCommand(matrixCommand, factor) {
      matrixCommand[5] = factor;
    },
    reuseScaleZCommand: function reuseScaleZCommand(matrixCommand, factor) {
      matrixCommand[10] = factor;
    },
    reuseRotateXCommand: function reuseRotateXCommand(matrixCommand, radians) {
      matrixCommand[5] = Math.cos(radians);
      matrixCommand[6] = Math.sin(radians);
      matrixCommand[9] = -Math.sin(radians);
      matrixCommand[10] = Math.cos(radians);
    },
    reuseRotateYCommand: function reuseRotateYCommand(matrixCommand, amount) {
      matrixCommand[0] = Math.cos(amount);
      matrixCommand[2] = -Math.sin(amount);
      matrixCommand[8] = Math.sin(amount);
      matrixCommand[10] = Math.cos(amount);
    },
    reuseRotateZCommand: function reuseRotateZCommand(matrixCommand, radians) {
      matrixCommand[0] = Math.cos(radians);
      matrixCommand[1] = Math.sin(radians);
      matrixCommand[4] = -Math.sin(radians);
      matrixCommand[5] = Math.cos(radians);
    },
    createRotateZ: function createRotateZ(radians) {
      var mat = MatrixMath.createIdentityMatrix();
      MatrixMath.reuseRotateZCommand(mat, radians);
      return mat;
    },
    reuseSkewXCommand: function reuseSkewXCommand(matrixCommand, radians) {
      matrixCommand[4] = Math.tan(radians);
    },
    reuseSkewYCommand: function reuseSkewYCommand(matrixCommand, radians) {
      matrixCommand[1] = Math.tan(radians);
    },
    multiplyInto: function multiplyInto(out, a, b) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3],
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7],
          a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11],
          a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15];
      var b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    },
    determinant: function determinant(matrix) {
      var _matrix = babelHelpers.slicedToArray(matrix, 16),
          m00 = _matrix[0],
          m01 = _matrix[1],
          m02 = _matrix[2],
          m03 = _matrix[3],
          m10 = _matrix[4],
          m11 = _matrix[5],
          m12 = _matrix[6],
          m13 = _matrix[7],
          m20 = _matrix[8],
          m21 = _matrix[9],
          m22 = _matrix[10],
          m23 = _matrix[11],
          m30 = _matrix[12],
          m31 = _matrix[13],
          m32 = _matrix[14],
          m33 = _matrix[15];

      return m03 * m12 * m21 * m30 - m02 * m13 * m21 * m30 - m03 * m11 * m22 * m30 + m01 * m13 * m22 * m30 + m02 * m11 * m23 * m30 - m01 * m12 * m23 * m30 - m03 * m12 * m20 * m31 + m02 * m13 * m20 * m31 + m03 * m10 * m22 * m31 - m00 * m13 * m22 * m31 - m02 * m10 * m23 * m31 + m00 * m12 * m23 * m31 + m03 * m11 * m20 * m32 - m01 * m13 * m20 * m32 - m03 * m10 * m21 * m32 + m00 * m13 * m21 * m32 + m01 * m10 * m23 * m32 - m00 * m11 * m23 * m32 - m02 * m11 * m20 * m33 + m01 * m12 * m20 * m33 + m02 * m10 * m21 * m33 - m00 * m12 * m21 * m33 - m01 * m10 * m22 * m33 + m00 * m11 * m22 * m33;
    },
    inverse: function inverse(matrix) {
      var det = MatrixMath.determinant(matrix);

      if (!det) {
        return matrix;
      }

      var _matrix2 = babelHelpers.slicedToArray(matrix, 16),
          m00 = _matrix2[0],
          m01 = _matrix2[1],
          m02 = _matrix2[2],
          m03 = _matrix2[3],
          m10 = _matrix2[4],
          m11 = _matrix2[5],
          m12 = _matrix2[6],
          m13 = _matrix2[7],
          m20 = _matrix2[8],
          m21 = _matrix2[9],
          m22 = _matrix2[10],
          m23 = _matrix2[11],
          m30 = _matrix2[12],
          m31 = _matrix2[13],
          m32 = _matrix2[14],
          m33 = _matrix2[15];

      return [(m12 * m23 * m31 - m13 * m22 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 + m11 * m22 * m33) / det, (m03 * m22 * m31 - m02 * m23 * m31 - m03 * m21 * m32 + m01 * m23 * m32 + m02 * m21 * m33 - m01 * m22 * m33) / det, (m02 * m13 * m31 - m03 * m12 * m31 + m03 * m11 * m32 - m01 * m13 * m32 - m02 * m11 * m33 + m01 * m12 * m33) / det, (m03 * m12 * m21 - m02 * m13 * m21 - m03 * m11 * m22 + m01 * m13 * m22 + m02 * m11 * m23 - m01 * m12 * m23) / det, (m13 * m22 * m30 - m12 * m23 * m30 - m13 * m20 * m32 + m10 * m23 * m32 + m12 * m20 * m33 - m10 * m22 * m33) / det, (m02 * m23 * m30 - m03 * m22 * m30 + m03 * m20 * m32 - m00 * m23 * m32 - m02 * m20 * m33 + m00 * m22 * m33) / det, (m03 * m12 * m30 - m02 * m13 * m30 - m03 * m10 * m32 + m00 * m13 * m32 + m02 * m10 * m33 - m00 * m12 * m33) / det, (m02 * m13 * m20 - m03 * m12 * m20 + m03 * m10 * m22 - m00 * m13 * m22 - m02 * m10 * m23 + m00 * m12 * m23) / det, (m11 * m23 * m30 - m13 * m21 * m30 + m13 * m20 * m31 - m10 * m23 * m31 - m11 * m20 * m33 + m10 * m21 * m33) / det, (m03 * m21 * m30 - m01 * m23 * m30 - m03 * m20 * m31 + m00 * m23 * m31 + m01 * m20 * m33 - m00 * m21 * m33) / det, (m01 * m13 * m30 - m03 * m11 * m30 + m03 * m10 * m31 - m00 * m13 * m31 - m01 * m10 * m33 + m00 * m11 * m33) / det, (m03 * m11 * m20 - m01 * m13 * m20 - m03 * m10 * m21 + m00 * m13 * m21 + m01 * m10 * m23 - m00 * m11 * m23) / det, (m12 * m21 * m30 - m11 * m22 * m30 - m12 * m20 * m31 + m10 * m22 * m31 + m11 * m20 * m32 - m10 * m21 * m32) / det, (m01 * m22 * m30 - m02 * m21 * m30 + m02 * m20 * m31 - m00 * m22 * m31 - m01 * m20 * m32 + m00 * m21 * m32) / det, (m02 * m11 * m30 - m01 * m12 * m30 - m02 * m10 * m31 + m00 * m12 * m31 + m01 * m10 * m32 - m00 * m11 * m32) / det, (m01 * m12 * m20 - m02 * m11 * m20 + m02 * m10 * m21 - m00 * m12 * m21 - m01 * m10 * m22 + m00 * m11 * m22) / det];
    },
    transpose: function transpose(m) {
      return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
    },
    multiplyVectorByMatrix: function multiplyVectorByMatrix(v, m) {
      var _v = babelHelpers.slicedToArray(v, 4),
          vx = _v[0],
          vy = _v[1],
          vz = _v[2],
          vw = _v[3];

      return [vx * m[0] + vy * m[4] + vz * m[8] + vw * m[12], vx * m[1] + vy * m[5] + vz * m[9] + vw * m[13], vx * m[2] + vy * m[6] + vz * m[10] + vw * m[14], vx * m[3] + vy * m[7] + vz * m[11] + vw * m[15]];
    },
    v3Length: function v3Length(a) {
      return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    },
    v3Normalize: function v3Normalize(vector, v3Length) {
      var im = 1 / (v3Length || MatrixMath.v3Length(vector));
      return [vector[0] * im, vector[1] * im, vector[2] * im];
    },
    v3Dot: function v3Dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    },
    v3Combine: function v3Combine(a, b, aScale, bScale) {
      return [aScale * a[0] + bScale * b[0], aScale * a[1] + bScale * b[1], aScale * a[2] + bScale * b[2]];
    },
    v3Cross: function v3Cross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    },
    quaternionToDegreesXYZ: function quaternionToDegreesXYZ(q, matrix, row) {
      var _q = babelHelpers.slicedToArray(q, 4),
          qx = _q[0],
          qy = _q[1],
          qz = _q[2],
          qw = _q[3];

      var qw2 = qw * qw;
      var qx2 = qx * qx;
      var qy2 = qy * qy;
      var qz2 = qz * qz;
      var test = qx * qy + qz * qw;
      var unit = qw2 + qx2 + qy2 + qz2;
      var conv = 180 / Math.PI;

      if (test > 0.49999 * unit) {
        return [0, 2 * Math.atan2(qx, qw) * conv, 90];
      }

      if (test < -0.49999 * unit) {
        return [0, -2 * Math.atan2(qx, qw) * conv, -90];
      }

      return [MatrixMath.roundTo3Places(Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx2 - 2 * qz2) * conv), MatrixMath.roundTo3Places(Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy2 - 2 * qz2) * conv), MatrixMath.roundTo3Places(Math.asin(2 * qx * qy + 2 * qz * qw) * conv)];
    },
    roundTo3Places: function roundTo3Places(n) {
      var arr = n.toString().split('e');
      return Math.round(arr[0] + 'e' + (arr[1] ? +arr[1] - 3 : 3)) * 0.001;
    },
    decomposeMatrix: function decomposeMatrix(transformMatrix) {
      invariant(transformMatrix.length === 16, 'Matrix decomposition needs a list of 3d matrix values, received %s', transformMatrix);
      var perspective = [];
      var quaternion = [];
      var scale = [];
      var skew = [];
      var translation = [];

      if (!transformMatrix[15]) {
        return;
      }

      var matrix = [];
      var perspectiveMatrix = [];

      for (var i = 0; i < 4; i++) {
        matrix.push([]);

        for (var j = 0; j < 4; j++) {
          var value = transformMatrix[i * 4 + j] / transformMatrix[15];
          matrix[i].push(value);
          perspectiveMatrix.push(j === 3 ? 0 : value);
        }
      }

      perspectiveMatrix[15] = 1;

      if (!MatrixMath.determinant(perspectiveMatrix)) {
        return;
      }

      if (matrix[0][3] !== 0 || matrix[1][3] !== 0 || matrix[2][3] !== 0) {
        var rightHandSide = [matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]];
        var inversePerspectiveMatrix = MatrixMath.inverse(perspectiveMatrix);
        var transposedInversePerspectiveMatrix = MatrixMath.transpose(inversePerspectiveMatrix);
        var perspective = MatrixMath.multiplyVectorByMatrix(rightHandSide, transposedInversePerspectiveMatrix);
      } else {
        perspective[0] = perspective[1] = perspective[2] = 0;
        perspective[3] = 1;
      }

      for (var i = 0; i < 3; i++) {
        translation[i] = matrix[3][i];
      }

      var row = [];

      for (i = 0; i < 3; i++) {
        row[i] = [matrix[i][0], matrix[i][1], matrix[i][2]];
      }

      scale[0] = MatrixMath.v3Length(row[0]);
      row[0] = MatrixMath.v3Normalize(row[0], scale[0]);
      skew[0] = MatrixMath.v3Dot(row[0], row[1]);
      row[1] = MatrixMath.v3Combine(row[1], row[0], 1.0, -skew[0]);
      skew[0] = MatrixMath.v3Dot(row[0], row[1]);
      row[1] = MatrixMath.v3Combine(row[1], row[0], 1.0, -skew[0]);
      scale[1] = MatrixMath.v3Length(row[1]);
      row[1] = MatrixMath.v3Normalize(row[1], scale[1]);
      skew[0] /= scale[1];
      skew[1] = MatrixMath.v3Dot(row[0], row[2]);
      row[2] = MatrixMath.v3Combine(row[2], row[0], 1.0, -skew[1]);
      skew[2] = MatrixMath.v3Dot(row[1], row[2]);
      row[2] = MatrixMath.v3Combine(row[2], row[1], 1.0, -skew[2]);
      scale[2] = MatrixMath.v3Length(row[2]);
      row[2] = MatrixMath.v3Normalize(row[2], scale[2]);
      skew[1] /= scale[2];
      skew[2] /= scale[2];
      var pdum3 = MatrixMath.v3Cross(row[1], row[2]);

      if (MatrixMath.v3Dot(row[0], pdum3) < 0) {
        for (i = 0; i < 3; i++) {
          scale[i] *= -1;
          row[i][0] *= -1;
          row[i][1] *= -1;
          row[i][2] *= -1;
        }
      }

      quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
      quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
      quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
      quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));

      if (row[2][1] > row[1][2]) {
        quaternion[0] = -quaternion[0];
      }

      if (row[0][2] > row[2][0]) {
        quaternion[1] = -quaternion[1];
      }

      if (row[1][0] > row[0][1]) {
        quaternion[2] = -quaternion[2];
      }

      var rotationDegrees;

      if (quaternion[0] < 0.001 && quaternion[0] >= 0 && quaternion[1] < 0.001 && quaternion[1] >= 0) {
        rotationDegrees = [0, 0, MatrixMath.roundTo3Places(Math.atan2(row[0][1], row[0][0]) * 180 / Math.PI)];
      } else {
        rotationDegrees = MatrixMath.quaternionToDegreesXYZ(quaternion, matrix, row);
      }

      return {
        rotationDegrees: rotationDegrees,
        perspective: perspective,
        quaternion: quaternion,
        scale: scale,
        skew: skew,
        translation: translation,
        rotate: rotationDegrees[2],
        rotateX: rotationDegrees[0],
        rotateY: rotationDegrees[1],
        scaleX: scale[0],
        scaleY: scale[1],
        translateX: translation[0],
        translateY: translation[1]
      };
    }
  };
  module.exports = MatrixMath;
},195,[18],"MatrixMath");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var dummySize = {
    width: undefined,
    height: undefined
  };

  var sizesDiffer = function sizesDiffer(one, two) {
    one = one || dummySize;
    two = two || dummySize;
    return one !== two && (one.width !== two.width || one.height !== two.height);
  };

  module.exports = sizesDiffer;
},196,[],"sizesDiffer");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'ReactNative'),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  module.exports = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.createReactNativeComponentClass;
},197,[74],"createReactNativeComponentClass");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var dummyInsets = {
    top: undefined,
    left: undefined,
    right: undefined,
    bottom: undefined
  };

  var insetsDiffer = function insetsDiffer(one, two) {
    one = one || dummyInsets;
    two = two || dummyInsets;
    return one !== two && (one.top !== two.top || one.left !== two.left || one.right !== two.right || one.bottom !== two.bottom);
  };

  module.exports = insetsDiffer;
},198,[],"insetsDiffer");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var matricesDiffer = function matricesDiffer(one, two) {
    if (one === two) {
      return false;
    }

    return !one || !two || one[12] !== two[12] || one[13] !== two[13] || one[14] !== two[14] || one[5] !== two[5] || one[10] !== two[10] || one[1] !== two[1] || one[2] !== two[2] || one[3] !== two[3] || one[4] !== two[4] || one[6] !== two[6] || one[7] !== two[7] || one[8] !== two[8] || one[9] !== two[9] || one[11] !== two[11] || one[15] !== two[15];
  };

  module.exports = matricesDiffer;
},199,[],"matricesDiffer");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var dummyPoint = {
    x: undefined,
    y: undefined
  };

  var pointsDiffer = function pointsDiffer(one, two) {
    one = one || dummyPoint;
    two = two || dummyPoint;
    return one !== two && (one.x !== two.x || one.y !== two.y);
  };

  module.exports = pointsDiffer;
},200,[],"pointsDiffer");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AssetRegistry = require(_dependencyMap[0], 'AssetRegistry');

  var AssetSourceResolver = require(_dependencyMap[1], 'AssetSourceResolver');

  var NativeModules = require(_dependencyMap[2], 'NativeModules');

  var _customSourceTransformer = void 0,
      _serverURL = void 0,
      _scriptURL = void 0,
      _embeddedBundleURL = void 0;

  function getDevServerURL() {
    if (_serverURL === undefined) {
      var scriptURL = NativeModules.SourceCode.scriptURL;
      var match = scriptURL && scriptURL.match(/^https?:\/\/.*?\//);

      if (match) {
        _serverURL = match[0];
      } else {
        _serverURL = null;
      }
    }

    return _serverURL;
  }

  function _coerceLocalScriptURL(scriptURL) {
    if (scriptURL) {
      if (scriptURL.startsWith('assets://')) {
        return null;
      }

      scriptURL = scriptURL.substring(0, scriptURL.lastIndexOf('/') + 1);

      if (!scriptURL.includes('://')) {
        scriptURL = 'file://' + scriptURL;
      }
    }

    return scriptURL;
  }

  function getScriptURL() {
    if (_scriptURL === undefined) {
      var scriptURL = NativeModules.SourceCode.scriptURL;
      _scriptURL = _coerceLocalScriptURL(scriptURL);
    }

    return _scriptURL;
  }

  function getEmbeddedBundledURL() {
    var scriptURL = NativeModules.SourceCode.embeddedBundleURL;
    _embeddedBundleURL = _coerceLocalScriptURL(scriptURL);
    return _embeddedBundleURL;
  }

  function setCustomSourceTransformer(transformer) {
    _customSourceTransformer = transformer;
  }

  function resolveAssetSource(source) {
    if (typeof source === 'object') {
      return source;
    }

    var asset = AssetRegistry.getAssetByID(source);

    if (!asset) {
      return null;
    }

    var resolver = new AssetSourceResolver(getDevServerURL(), getScriptURL(), getEmbeddedBundledURL(), asset);

    if (_customSourceTransformer) {
      return _customSourceTransformer(resolver);
    }

    return resolver.defaultAsset();
  }

  module.exports = resolveAssetSource;
  module.exports.pickScale = AssetSourceResolver.pickScale;
  module.exports.setCustomSourceTransformer = setCustomSourceTransformer;
},201,[202,203,68],"resolveAssetSource");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var assets = [];

  function registerAsset(asset) {
    return assets.push(asset);
  }

  function getAssetByID(assetId) {
    return assets[assetId - 1];
  }

  module.exports = {
    registerAsset: registerAsset,
    getAssetByID: getAssetByID
  };
},202,[],"AssetRegistry");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var PixelRatio = require(_dependencyMap[0], 'PixelRatio');

  var Platform = require(_dependencyMap[1], 'Platform');

  var assetPathUtils = require(_dependencyMap[2], '../../local-cli/bundle/assetPathUtils');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  function getScaledAssetPath(asset) {
    var scale = AssetSourceResolver.pickScale(asset.scales, PixelRatio.get());
    var scaleSuffix = scale === 1 ? '' : '@' + scale + 'x';
    var assetDir = assetPathUtils.getBasePath(asset);
    return assetDir + '/' + asset.name + scaleSuffix + '.' + asset.type;
  }

  function getAssetPathInDrawableFolder(asset) {
    var scale = AssetSourceResolver.pickScale(asset.scales, PixelRatio.get());
    var drawbleFolder = assetPathUtils.getAndroidResourceFolderName(asset, scale);
    var fileName = assetPathUtils.getAndroidResourceIdentifier(asset);
    return drawbleFolder + '/' + fileName + '.' + asset.type;
  }

  var AssetSourceResolver = function () {
    function AssetSourceResolver(serverUrl, jsbundleUrl, embeddedBundleUrl, asset) {
      babelHelpers.classCallCheck(this, AssetSourceResolver);
      this.serverUrl = serverUrl;
      this.jsbundleUrl = jsbundleUrl;
      this.embeddedBundleUrl = embeddedBundleUrl;
      this.asset = asset;
    }

    babelHelpers.createClass(AssetSourceResolver, [{
      key: "isLoadedFromServer",
      value: function isLoadedFromServer() {
        return !!this.serverUrl;
      }
    }, {
      key: "isLoadedFromFileSystem",
      value: function isLoadedFromFileSystem() {
        return !!(this.jsbundleUrl && this.jsbundleUrl.startsWith('file://'));
      }
    }, {
      key: "canLoadFromEmbeddedBundledLocation",
      value: function canLoadFromEmbeddedBundledLocation() {
        return !!this.embeddedBundleUrl;
      }
    }, {
      key: "defaultAsset",
      value: function defaultAsset() {
        if (this.isLoadedFromServer()) {
          return this.assetServerURL();
        }

        if (Platform.OS === 'android') {
          return this.isLoadedFromFileSystem() ? this.drawableFolderInBundle() : this.resourceIdentifierWithoutScale();
        } else {
          return this.scaledAssetURLNearBundle();
        }
      }
    }, {
      key: "assetServerURL",
      value: function assetServerURL() {
        invariant(!!this.serverUrl, 'need server to load from');
        return this.fromSource(this.serverUrl + getScaledAssetPath(this.asset) + '?platform=' + Platform.OS + '&hash=' + this.asset.hash);
      }
    }, {
      key: "scaledAssetPath",
      value: function scaledAssetPath() {
        return this.fromSource(getScaledAssetPath(this.asset));
      }
    }, {
      key: "scaledAssetURLNearBundle",
      value: function scaledAssetURLNearBundle() {
        var path = this.jsbundleUrl || 'file://';
        return this.fromSource(path + getScaledAssetPath(this.asset));
      }
    }, {
      key: "scaledAssetURLInEmbeddedBundleUrl",
      value: function scaledAssetURLInEmbeddedBundleUrl() {
        var path = this.embeddedBundleUrl || 'file://';
        return this.fromSource(path + getScaledAssetPath(this.asset));
      }
    }, {
      key: "resourceIdentifierWithoutScale",
      value: function resourceIdentifierWithoutScale() {
        invariant(Platform.OS === 'android', 'resource identifiers work on Android');
        return this.fromSource(assetPathUtils.getAndroidResourceIdentifier(this.asset));
      }
    }, {
      key: "drawableFolderInBundle",
      value: function drawableFolderInBundle() {
        var path = this.jsbundleUrl || 'file://';
        return this.fromSource(path + getAssetPathInDrawableFolder(this.asset));
      }
    }, {
      key: "fromSource",
      value: function fromSource(source) {
        return {
          __packager_asset: true,
          width: this.asset.width,
          height: this.asset.height,
          uri: source,
          scale: AssetSourceResolver.pickScale(this.asset.scales, PixelRatio.get())
        };
      }
    }], [{
      key: "pickScale",
      value: function pickScale(scales, deviceScale) {
        for (var i = 0; i < scales.length; i++) {
          if (scales[i] >= deviceScale) {
            return scales[i];
          }
        }

        return scales[scales.length - 1] || 1;
      }
    }]);
    return AssetSourceResolver;
  }();

  module.exports = AssetSourceResolver;
},203,[204,105,207,18],"AssetSourceResolver");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Dimensions = require(_dependencyMap[0], 'Dimensions');

  var PixelRatio = function () {
    function PixelRatio() {
      babelHelpers.classCallCheck(this, PixelRatio);
    }

    babelHelpers.createClass(PixelRatio, null, [{
      key: "get",
      value: function get() {
        return Dimensions.get('window').scale;
      }
    }, {
      key: "getFontScale",
      value: function getFontScale() {
        return Dimensions.get('window').fontScale || PixelRatio.get();
      }
    }, {
      key: "getPixelSizeForLayoutSize",
      value: function getPixelSizeForLayoutSize(layoutSize) {
        return Math.round(layoutSize * PixelRatio.get());
      }
    }, {
      key: "roundToNearestPixel",
      value: function roundToNearestPixel(layoutSize) {
        var ratio = PixelRatio.get();
        return Math.round(layoutSize * ratio) / ratio;
      }
    }, {
      key: "startDetecting",
      value: function startDetecting() {}
    }]);
    return PixelRatio;
  }();

  module.exports = PixelRatio;
},204,[205],"PixelRatio");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var DeviceInfo = require(_dependencyMap[0], 'DeviceInfo');

  var EventEmitter = require(_dependencyMap[1], 'EventEmitter');

  var Platform = require(_dependencyMap[2], 'Platform');

  var RCTDeviceEventEmitter = require(_dependencyMap[3], 'RCTDeviceEventEmitter');

  var invariant = require(_dependencyMap[4], 'fbjs/lib/invariant');

  var eventEmitter = new EventEmitter();
  var dimensionsInitialized = false;
  var dimensions = {};

  var Dimensions = function () {
    function Dimensions() {
      babelHelpers.classCallCheck(this, Dimensions);
    }

    babelHelpers.createClass(Dimensions, null, [{
      key: "set",
      value: function set(dims) {
        if (dims && dims.windowPhysicalPixels) {
          dims = JSON.parse(JSON.stringify(dims));
          var windowPhysicalPixels = dims.windowPhysicalPixels;
          dims.window = {
            width: windowPhysicalPixels.width / windowPhysicalPixels.scale,
            height: windowPhysicalPixels.height / windowPhysicalPixels.scale,
            scale: windowPhysicalPixels.scale,
            fontScale: windowPhysicalPixels.fontScale
          };

          if (Platform.OS === 'android') {
            var screenPhysicalPixels = dims.screenPhysicalPixels;
            dims.screen = {
              width: screenPhysicalPixels.width / screenPhysicalPixels.scale,
              height: screenPhysicalPixels.height / screenPhysicalPixels.scale,
              scale: screenPhysicalPixels.scale,
              fontScale: screenPhysicalPixels.fontScale
            };
            delete dims.screenPhysicalPixels;
          } else {
            dims.screen = dims.window;
          }

          delete dims.windowPhysicalPixels;
        }

        babelHelpers.extends(dimensions, dims);

        if (dimensionsInitialized) {
          eventEmitter.emit('change', {
            window: dimensions.window,
            screen: dimensions.screen
          });
        } else {
          dimensionsInitialized = true;
        }
      }
    }, {
      key: "get",
      value: function get(dim) {
        invariant(dimensions[dim], 'No dimension set for key ' + dim);
        return dimensions[dim];
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        invariant(type === 'change', 'Trying to subscribe to unknown event: "%s"', type);
        eventEmitter.addListener(type, handler);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        invariant(type === 'change', 'Trying to remove listener for unknown event: "%s"', type);
        eventEmitter.removeListener(type, handler);
      }
    }]);
    return Dimensions;
  }();

  Dimensions.set(DeviceInfo.Dimensions);
  RCTDeviceEventEmitter.addListener('didUpdateDimensions', function (update) {
    Dimensions.set(update);
  });
  module.exports = Dimensions;
},205,[206,118,105,121,18],"Dimensions");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var DeviceInfo = require(_dependencyMap[0], 'NativeModules').DeviceInfo;

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  invariant(DeviceInfo, 'DeviceInfo native module is not installed correctly');
  module.exports = DeviceInfo;
},206,[68,18],"DeviceInfo");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function getAndroidAssetSuffix(scale) {
    switch (scale) {
      case 0.75:
        return 'ldpi';

      case 1:
        return 'mdpi';

      case 1.5:
        return 'hdpi';

      case 2:
        return 'xhdpi';

      case 3:
        return 'xxhdpi';

      case 4:
        return 'xxxhdpi';
    }

    throw new Error('no such scale');
  }

  var drawableFileTypes = new Set(['gif', 'jpeg', 'jpg', 'png', 'svg', 'webp', 'xml']);

  function getAndroidResourceFolderName(asset, scale) {
    if (!drawableFileTypes.has(asset.type)) {
      return 'raw';
    }

    var suffix = getAndroidAssetSuffix(scale);

    if (!suffix) {
      throw new Error('Don\'t know which android drawable suffix to use for asset: ' + JSON.stringify(asset));
    }

    var androidFolder = 'drawable-' + suffix;
    return androidFolder;
  }

  function getAndroidResourceIdentifier(asset) {
    var folderPath = getBasePath(asset);
    return (folderPath + '/' + asset.name).toLowerCase().replace(/\//g, '_').replace(/([^a-z0-9_])/g, '').replace(/^assets_/, '');
  }

  function getBasePath(asset) {
    var basePath = asset.httpServerLocation;

    if (basePath[0] === '/') {
      basePath = basePath.substr(1);
    }

    return basePath;
  }

  module.exports = {
    getAndroidAssetSuffix: getAndroidAssetSuffix,
    getAndroidResourceFolderName: getAndroidResourceFolderName,
    getAndroidResourceIdentifier: getAndroidResourceIdentifier,
    getBasePath: getBasePath
  };
},207,[],"react-native/local-cli/bundle/assetPathUtils.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ReactNativeStyleAttributes = require(_dependencyMap[0], 'ReactNativeStyleAttributes');

  function verifyPropTypes(componentInterface, viewConfig, nativePropsToIgnore) {
    if (!viewConfig) {
      return;
    }

    var componentName = componentInterface.displayName || componentInterface.name || 'unknown';
    var propTypes = componentInterface.__propTypesSecretDontUseThesePlease || componentInterface.propTypes;

    if (!propTypes) {
      throw new Error('`' + componentName + '` has no propTypes defined`');
    }

    var nativeProps = viewConfig.NativeProps;

    for (var prop in nativeProps) {
      if (!propTypes[prop] && !ReactNativeStyleAttributes[prop] && (!nativePropsToIgnore || !nativePropsToIgnore[prop])) {
        var message;

        if (propTypes.hasOwnProperty(prop)) {
          message = '`' + componentName + '` has incorrectly defined propType for native prop `' + viewConfig.uiViewClassName + '.' + prop + '` of native type `' + nativeProps[prop];
        } else {
          message = '`' + componentName + '` has no propType for native prop `' + viewConfig.uiViewClassName + '.' + prop + '` of native type `' + nativeProps[prop] + '`';
        }

        message += "\nIf you haven't changed this prop yourself, this usually means that " + 'your versions of the native code and JavaScript code are out of sync. Updating both ' + 'should make this error go away.';
        throw new Error(message);
      }
    }
  }

  module.exports = verifyPropTypes;
},208,[188],"verifyPropTypes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var PixelRatio = require(_dependencyMap[0], 'PixelRatio');

  var ReactNativePropRegistry = require(_dependencyMap[1], 'ReactNativePropRegistry');

  var ReactNativeStyleAttributes = require(_dependencyMap[2], 'ReactNativeStyleAttributes');

  var StyleSheetValidation = require(_dependencyMap[3], 'StyleSheetValidation');

  var flatten = require(_dependencyMap[4], 'flattenStyle');

  var hairlineWidth = PixelRatio.roundToNearestPixel(0.4);

  if (hairlineWidth === 0) {
    hairlineWidth = 1 / PixelRatio.get();
  }

  var absoluteFillObject = {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  var absoluteFill = ReactNativePropRegistry.register(absoluteFillObject);
  module.exports = {
    hairlineWidth: hairlineWidth,
    absoluteFill: absoluteFill,
    absoluteFillObject: absoluteFillObject,
    compose: function compose(style1, style2) {
      if (style1 && style2) {
        return [style1, style2];
      } else {
        return style1 || style2;
      }
    },
    flatten: flatten,
    setStyleAttributePreprocessor: function setStyleAttributePreprocessor(property, process) {
      var value = void 0;

      if (typeof ReactNativeStyleAttributes[property] === 'string') {
        value = {};
      } else if (typeof ReactNativeStyleAttributes[property] === 'object') {
        value = ReactNativeStyleAttributes[property];
      } else {
        console.error(property + " is not a valid style attribute");
        return;
      }

      if (__DEV__ && typeof value.process === 'function') {
        console.warn("Overwriting " + property + " style attribute preprocessor");
      }

      ReactNativeStyleAttributes[property] = babelHelpers.extends({}, value, {
        process: process
      });
    },
    create: function create(obj) {
      var result = {};

      for (var key in obj) {
        StyleSheetValidation.validateStyle(key, obj);
        result[key] = obj[key] && ReactNativePropRegistry.register(obj[key]);
      }

      return result;
    }
  };
},209,[204,153,188,210,152],"StyleSheet");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ImageStylePropTypes = require(_dependencyMap[0], 'ImageStylePropTypes');

  var TextStylePropTypes = require(_dependencyMap[1], 'TextStylePropTypes');

  var ViewStylePropTypes = require(_dependencyMap[2], 'ViewStylePropTypes');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  var StyleSheetValidation = function () {
    function StyleSheetValidation() {
      babelHelpers.classCallCheck(this, StyleSheetValidation);
    }

    babelHelpers.createClass(StyleSheetValidation, null, [{
      key: "validateStyleProp",
      value: function validateStyleProp(prop, style, caller) {
        if (!__DEV__) {
          return;
        }

        if (allStylePropTypes[prop] === undefined) {
          var message1 = '"' + prop + '" is not a valid style property.';
          var message2 = '\nValid style props: ' + JSON.stringify(Object.keys(allStylePropTypes).sort(), null, '  ');
          styleError(message1, style, caller, message2);
        }

        var error = allStylePropTypes[prop](style, prop, caller, 'prop', null, ReactPropTypesSecret);

        if (error) {
          styleError(error.message, style, caller);
        }
      }
    }, {
      key: "validateStyle",
      value: function validateStyle(name, styles) {
        if (!__DEV__) {
          return;
        }

        for (var prop in styles[name]) {
          StyleSheetValidation.validateStyleProp(prop, styles[name], 'StyleSheet ' + name);
        }
      }
    }, {
      key: "addValidStylePropTypes",
      value: function addValidStylePropTypes(stylePropTypes) {
        for (var key in stylePropTypes) {
          allStylePropTypes[key] = stylePropTypes[key];
        }
      }
    }]);
    return StyleSheetValidation;
  }();

  var styleError = function styleError(message1, style, caller, message2) {
    invariant(false, message1 + '\n' + (caller || '<<unknown>>') + ': ' + JSON.stringify(style, null, '  ') + (message2 || ''));
  };

  var allStylePropTypes = {};
  StyleSheetValidation.addValidStylePropTypes(ImageStylePropTypes);
  StyleSheetValidation.addValidStylePropTypes(TextStylePropTypes);
  StyleSheetValidation.addValidStylePropTypes(ViewStylePropTypes);
  module.exports = StyleSheetValidation;
},210,[189,192,180,18],"StyleSheetValidation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/View/View.js";

  var NativeMethodsMixin = require(_dependencyMap[0], 'NativeMethodsMixin');

  var Platform = require(_dependencyMap[1], 'Platform');

  var PropTypes = require(_dependencyMap[2], 'prop-types');

  var React = require(_dependencyMap[3], 'React');

  var ReactNativeStyleAttributes = require(_dependencyMap[4], 'ReactNativeStyleAttributes');

  var ReactNativeViewAttributes = require(_dependencyMap[5], 'ReactNativeViewAttributes');

  var ViewPropTypes = require(_dependencyMap[6], 'ViewPropTypes');

  var createReactClass = require(_dependencyMap[7], 'create-react-class');

  var invariant = require(_dependencyMap[8], 'fbjs/lib/invariant');

  var requireNativeComponent = require(_dependencyMap[9], 'requireNativeComponent');

  var View = createReactClass({
    displayName: 'View',
    mixins: [NativeMethodsMixin],
    propTypes: ViewPropTypes,
    viewConfig: {
      uiViewClassName: 'RCTView',
      validAttributes: ReactNativeViewAttributes.RCTView
    },
    contextTypes: {
      isInAParentText: PropTypes.bool
    },
    render: function render() {
      invariant(!(this.context.isInAParentText && Platform.OS === 'android'), 'Nesting of <View> within <Text> is not supported on Android.');
      return React.createElement(RCTView, babelHelpers.extends({}, this.props, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 71
        }
      }));
    }
  });
  var RCTView = requireNativeComponent('RCTView', View, {
    nativeOnly: {
      nativeBackgroundAndroid: true,
      nativeForegroundAndroid: true
    }
  });

  if (__DEV__) {
    var UIManager = require(_dependencyMap[10], 'UIManager');

    var viewConfig = UIManager.viewConfigs && UIManager.viewConfigs.RCTView || {};

    for (var prop in viewConfig.nativeProps) {
      var viewAny = View;

      if (!viewAny.propTypes[prop] && !ReactNativeStyleAttributes[prop]) {
        throw new Error('View is missing propType for native prop `' + prop + '`');
      }
    }
  }

  var ViewToExport = RCTView;

  if (__DEV__) {
    ViewToExport = View;
  }

  module.exports = ViewToExport;
},211,[169,105,24,171,188,212,172,213,18,186,158],"View");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ReactNativeStyleAttributes = require(_dependencyMap[0], 'ReactNativeStyleAttributes');

  var ReactNativeViewAttributes = {};
  ReactNativeViewAttributes.UIView = {
    pointerEvents: true,
    accessible: true,
    accessibilityActions: true,
    accessibilityLabel: true,
    accessibilityComponentType: true,
    accessibilityLiveRegion: true,
    accessibilityTraits: true,
    importantForAccessibility: true,
    nativeID: true,
    testID: true,
    renderToHardwareTextureAndroid: true,
    shouldRasterizeIOS: true,
    onLayout: true,
    onAccessibilityAction: true,
    onAccessibilityTap: true,
    onMagicTap: true,
    collapsable: true,
    needsOffscreenAlphaCompositing: true,
    style: ReactNativeStyleAttributes
  };
  ReactNativeViewAttributes.RCTView = babelHelpers.extends({}, ReactNativeViewAttributes.UIView, {
    removeClippedSubviews: true
  });
  module.exports = ReactNativeViewAttributes;
},212,[188],"ReactNativeViewAttributes");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var React = require(_dependencyMap[0], 'react');

  var factory = require(_dependencyMap[1], './factory');

  if (typeof React === 'undefined') {
    throw Error('create-react-class could not find the React object. If you are using script tags, ' + 'make sure that React is being loaded before create-react-class.');
  }

  var ReactNoopUpdateQueue = new React.Component().updater;
  module.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);
},213,[12,214],"create-react-class/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _assign = require(_dependencyMap[0], 'object-assign');

  var emptyObject = require(_dependencyMap[1], 'fbjs/lib/emptyObject');

  var _invariant = require(_dependencyMap[2], 'fbjs/lib/invariant');

  if (process.env.NODE_ENV !== 'production') {
    var warning = require(_dependencyMap[3], 'fbjs/lib/warning');
  }

  var MIXINS_KEY = 'mixins';

  function identity(fn) {
    return fn;
  }

  var ReactPropTypeLocationNames;

  if (process.env.NODE_ENV !== 'production') {
    ReactPropTypeLocationNames = {
      prop: 'prop',
      context: 'context',
      childContext: 'child context'
    };
  } else {
    ReactPropTypeLocationNames = {};
  }

  function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
    var injectedMixins = [];
    var ReactClassInterface = {
      mixins: 'DEFINE_MANY',
      statics: 'DEFINE_MANY',
      propTypes: 'DEFINE_MANY',
      contextTypes: 'DEFINE_MANY',
      childContextTypes: 'DEFINE_MANY',
      getDefaultProps: 'DEFINE_MANY_MERGED',
      getInitialState: 'DEFINE_MANY_MERGED',
      getChildContext: 'DEFINE_MANY_MERGED',
      render: 'DEFINE_ONCE',
      componentWillMount: 'DEFINE_MANY',
      componentDidMount: 'DEFINE_MANY',
      componentWillReceiveProps: 'DEFINE_MANY',
      shouldComponentUpdate: 'DEFINE_ONCE',
      componentWillUpdate: 'DEFINE_MANY',
      componentDidUpdate: 'DEFINE_MANY',
      componentWillUnmount: 'DEFINE_MANY',
      UNSAFE_componentWillMount: 'DEFINE_MANY',
      UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',
      UNSAFE_componentWillUpdate: 'DEFINE_MANY',
      updateComponent: 'OVERRIDE_BASE'
    };
    var ReactClassStaticInterface = {
      getDerivedStateFromProps: 'DEFINE_MANY_MERGED'
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function displayName(Constructor, _displayName) {
        Constructor.displayName = _displayName;
      },
      mixins: function mixins(Constructor, _mixins) {
        if (_mixins) {
          for (var i = 0; i < _mixins.length; i++) {
            mixSpecIntoComponent(Constructor, _mixins[i]);
          }
        }
      },
      childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, _childContextTypes, 'childContext');
        }

        Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
      },
      contextTypes: function contextTypes(Constructor, _contextTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, _contextTypes, 'context');
        }

        Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
      },
      getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
        } else {
          Constructor.getDefaultProps = _getDefaultProps;
        }
      },
      propTypes: function propTypes(Constructor, _propTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, _propTypes, 'prop');
        }

        Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
      },
      statics: function statics(Constructor, _statics) {
        mixStaticSpecIntoComponent(Constructor, _statics);
      },
      autobind: function autobind() {}
    };

    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          if (process.env.NODE_ENV !== 'production') {
            warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName);
          }
        }
      }
    }

    function validateMethodOverride(isAlreadyDefined, name) {
      var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

      if (ReactClassMixin.hasOwnProperty(name)) {
        _invariant(specPolicy === 'OVERRIDE_BASE', 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name);
      }

      if (isAlreadyDefined) {
        _invariant(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED', 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name);
      }
    }

    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {
        if (process.env.NODE_ENV !== 'production') {
          var typeofSpec = typeof spec;
          var isMixinValid = typeofSpec === 'object' && spec !== null;

          if (process.env.NODE_ENV !== 'production') {
            warning(isMixinValid, "%s: You're attempting to include a mixin that is either null " + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec);
          }
        }

        return;
      }

      _invariant(typeof spec !== 'function', "ReactClass: You're attempting to " + 'use a component class or function as a mixin. Instead, just use a ' + 'regular object.');

      _invariant(!isValidElement(spec), "ReactClass: You're attempting to " + 'use a component as a mixin. Instead, just use a regular object.');

      var proto = Constructor.prototype;
      var autoBindPairs = proto.__reactAutoBindPairs;

      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }

      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }

        if (name === MIXINS_KEY) {
          continue;
        }

        var property = spec[name];
        var isAlreadyDefined = proto.hasOwnProperty(name);
        validateMethodOverride(isAlreadyDefined, name);

        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
          var isFunction = typeof property === 'function';
          var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

          if (shouldAutoBind) {
            autoBindPairs.push(name, property);
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactClassInterface[name];

              _invariant(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY'), 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name);

              if (specPolicy === 'DEFINE_MANY_MERGED') {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === 'DEFINE_MANY') {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;

              if (process.env.NODE_ENV !== 'production') {
                if (typeof property === 'function' && spec.displayName) {
                  proto[name].displayName = spec.displayName + '_' + name;
                }
              }
            }
          }
        }
      }
    }

    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return;
      }

      for (var name in statics) {
        var property = statics[name];

        if (!statics.hasOwnProperty(name)) {
          continue;
        }

        var isReserved = name in RESERVED_SPEC_KEYS;

        _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name);

        var isAlreadyDefined = name in Constructor;

        if (isAlreadyDefined) {
          var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;

          _invariant(specPolicy === 'DEFINE_MANY_MERGED', 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name);

          Constructor[name] = createMergedResultFunction(Constructor[name], property);
          return;
        }

        Constructor[name] = property;
      }
    }

    function mergeIntoWithNoDuplicateKeys(one, two) {
      _invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.');

      for (var key in two) {
        if (two.hasOwnProperty(key)) {
          _invariant(one[key] === undefined, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key);

          one[key] = two[key];
        }
      }

      return one;
    }

    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);

        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }

        var c = {};
        mergeIntoWithNoDuplicateKeys(c, a);
        mergeIntoWithNoDuplicateKeys(c, b);
        return c;
      };
    }

    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }

    function bindAutoBindMethod(component, method) {
      var boundMethod = method.bind(component);

      if (process.env.NODE_ENV !== 'production') {
        boundMethod.__reactBoundContext = component;
        boundMethod.__reactBoundMethod = method;
        boundMethod.__reactBoundArguments = null;
        var componentName = component.constructor.displayName;
        var _bind = boundMethod.bind;

        boundMethod.bind = function (newThis) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          if (newThis !== component && newThis !== null) {
            if (process.env.NODE_ENV !== 'production') {
              warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName);
            }
          } else if (!args.length) {
            if (process.env.NODE_ENV !== 'production') {
              warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName);
            }

            return boundMethod;
          }

          var reboundMethod = _bind.apply(boundMethod, arguments);

          reboundMethod.__reactBoundContext = component;
          reboundMethod.__reactBoundMethod = method;
          reboundMethod.__reactBoundArguments = args;
          return reboundMethod;
        };
      }

      return boundMethod;
    }

    function bindAutoBindMethods(component) {
      var pairs = component.__reactAutoBindPairs;

      for (var i = 0; i < pairs.length; i += 2) {
        var autoBindKey = pairs[i];
        var method = pairs[i + 1];
        component[autoBindKey] = bindAutoBindMethod(component, method);
      }
    }

    var IsMountedPreMixin = {
      componentDidMount: function componentDidMount() {
        this.__isMounted = true;
      }
    };
    var IsMountedPostMixin = {
      componentWillUnmount: function componentWillUnmount() {
        this.__isMounted = false;
      }
    };
    var ReactClassMixin = {
      replaceState: function replaceState(newState, callback) {
        this.updater.enqueueReplaceState(this, newState, callback);
      },
      isMounted: function isMounted() {
        if (process.env.NODE_ENV !== 'production') {
          warning(this.__didWarnIsMounted, '%s: isMounted is deprecated. Instead, make sure to clean up ' + 'subscriptions and pending requests in componentWillUnmount to ' + 'prevent memory leaks.', this.constructor && this.constructor.displayName || this.name || 'Component');
          this.__didWarnIsMounted = true;
        }

        return !!this.__isMounted;
      }
    };

    var ReactClassComponent = function ReactClassComponent() {};

    _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

    function createClass(spec) {
      var Constructor = identity(function (props, context, updater) {
        if (process.env.NODE_ENV !== 'production') {
          warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory');
        }

        if (this.__reactAutoBindPairs.length) {
          bindAutoBindMethods(this);
        }

        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
        this.state = null;
        var initialState = this.getInitialState ? this.getInitialState() : null;

        if (process.env.NODE_ENV !== 'production') {
          if (initialState === undefined && this.getInitialState._isMockFunction) {
            initialState = null;
          }
        }

        _invariant(typeof initialState === 'object' && !Array.isArray(initialState), '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent');

        this.state = initialState;
      });
      Constructor.prototype = new ReactClassComponent();
      Constructor.prototype.constructor = Constructor;
      Constructor.prototype.__reactAutoBindPairs = [];
      injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
      mixSpecIntoComponent(Constructor, IsMountedPreMixin);
      mixSpecIntoComponent(Constructor, spec);
      mixSpecIntoComponent(Constructor, IsMountedPostMixin);

      if (Constructor.getDefaultProps) {
        Constructor.defaultProps = Constructor.getDefaultProps();
      }

      if (process.env.NODE_ENV !== 'production') {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps.isReactClassApproved = {};
        }

        if (Constructor.prototype.getInitialState) {
          Constructor.prototype.getInitialState.isReactClassApproved = {};
        }
      }

      _invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.');

      if (process.env.NODE_ENV !== 'production') {
        warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component');
        warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component');
        warning(!Constructor.prototype.UNSAFE_componentWillRecieveProps, '%s has a method called UNSAFE_componentWillRecieveProps(). ' + 'Did you mean UNSAFE_componentWillReceiveProps()?', spec.displayName || 'A component');
      }

      for (var methodName in ReactClassInterface) {
        if (!Constructor.prototype[methodName]) {
          Constructor.prototype[methodName] = null;
        }
      }

      return Constructor;
    }

    return createClass;
  }

  module.exports = factory;
},214,[14,15,18,19],"create-react-class/factory.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/ART/ReactNativeART.js";

  var Color = require(_dependencyMap[0], 'art/core/color');

  var Path = require(_dependencyMap[1], 'ARTSerializablePath');

  var Transform = require(_dependencyMap[2], 'art/core/transform');

  var React = require(_dependencyMap[3], 'React');

  var PropTypes = require(_dependencyMap[4], 'prop-types');

  var ReactNativeViewAttributes = require(_dependencyMap[5], 'ReactNativeViewAttributes');

  var createReactNativeComponentClass = require(_dependencyMap[6], 'createReactNativeComponentClass');

  var merge = require(_dependencyMap[7], 'merge');

  var invariant = require(_dependencyMap[8], 'fbjs/lib/invariant');

  function arrayDiffer(a, b) {
    if (a == null || b == null) {
      return true;
    }

    if (a.length !== b.length) {
      return true;
    }

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return true;
      }
    }

    return false;
  }

  function fontAndLinesDiffer(a, b) {
    if (a === b) {
      return false;
    }

    if (a.font !== b.font) {
      if (a.font === null) {
        return true;
      }

      if (b.font === null) {
        return true;
      }

      if (a.font.fontFamily !== b.font.fontFamily || a.font.fontSize !== b.font.fontSize || a.font.fontWeight !== b.font.fontWeight || a.font.fontStyle !== b.font.fontStyle) {
        return true;
      }
    }

    return arrayDiffer(a.lines, b.lines);
  }

  var SurfaceViewAttributes = merge(ReactNativeViewAttributes.UIView, {});
  var NodeAttributes = {
    transform: {
      diff: arrayDiffer
    },
    opacity: true
  };
  var GroupAttributes = merge(NodeAttributes, {
    clipping: {
      diff: arrayDiffer
    }
  });
  var RenderableAttributes = merge(NodeAttributes, {
    fill: {
      diff: arrayDiffer
    },
    stroke: {
      diff: arrayDiffer
    },
    strokeWidth: true,
    strokeCap: true,
    strokeJoin: true,
    strokeDash: {
      diff: arrayDiffer
    }
  });
  var ShapeAttributes = merge(RenderableAttributes, {
    d: {
      diff: arrayDiffer
    }
  });
  var TextAttributes = merge(RenderableAttributes, {
    alignment: true,
    frame: {
      diff: fontAndLinesDiffer
    },
    path: {
      diff: arrayDiffer
    }
  });
  var NativeSurfaceView = createReactNativeComponentClass('ARTSurfaceView', function () {
    return {
      validAttributes: SurfaceViewAttributes,
      uiViewClassName: 'ARTSurfaceView'
    };
  });
  var NativeGroup = createReactNativeComponentClass('ARTGroup', function () {
    return {
      validAttributes: GroupAttributes,
      uiViewClassName: 'ARTGroup'
    };
  });
  var NativeShape = createReactNativeComponentClass('ARTShape', function () {
    return {
      validAttributes: ShapeAttributes,
      uiViewClassName: 'ARTShape'
    };
  });
  var NativeText = createReactNativeComponentClass('ARTText', function () {
    return {
      validAttributes: TextAttributes,
      uiViewClassName: 'ARTText'
    };
  });

  function childrenAsString(children) {
    if (!children) {
      return '';
    }

    if (typeof children === 'string') {
      return children;
    }

    if (children.length) {
      return children.join('\n');
    }

    return '';
  }

  var Surface = function (_React$Component) {
    babelHelpers.inherits(Surface, _React$Component);

    function Surface() {
      babelHelpers.classCallCheck(this, Surface);
      return babelHelpers.possibleConstructorReturn(this, (Surface.__proto__ || Object.getPrototypeOf(Surface)).apply(this, arguments));
    }

    babelHelpers.createClass(Surface, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          isInSurface: true
        };
      }
    }, {
      key: "render",
      value: function render() {
        var props = this.props;
        var w = extractNumber(props.width, 0);
        var h = extractNumber(props.height, 0);
        return React.createElement(
          NativeSurfaceView,
          {
            style: [props.style, {
              width: w,
              height: h
            }],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 159
            }
          },
          this.props.children
        );
      }
    }]);
    return Surface;
  }(React.Component);

  Surface.childContextTypes = {
    isInSurface: PropTypes.bool
  };

  function extractNumber(value, defaultValue) {
    if (value == null) {
      return defaultValue;
    }

    return +value;
  }

  var pooledTransform = new Transform();

  function extractTransform(props) {
    var scaleX = props.scaleX != null ? props.scaleX : props.scale != null ? props.scale : 1;
    var scaleY = props.scaleY != null ? props.scaleY : props.scale != null ? props.scale : 1;
    pooledTransform.transformTo(1, 0, 0, 1, 0, 0).move(props.x || 0, props.y || 0).rotate(props.rotation || 0, props.originX, props.originY).scale(scaleX, scaleY, props.originX, props.originY);

    if (props.transform != null) {
      pooledTransform.transform(props.transform);
    }

    return [pooledTransform.xx, pooledTransform.yx, pooledTransform.xy, pooledTransform.yy, pooledTransform.x, pooledTransform.y];
  }

  function extractOpacity(props) {
    if (props.visible === false) {
      return 0;
    }

    if (props.opacity == null) {
      return 1;
    }

    return +props.opacity;
  }

  var Group = function (_React$Component2) {
    babelHelpers.inherits(Group, _React$Component2);

    function Group() {
      babelHelpers.classCallCheck(this, Group);
      return babelHelpers.possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).apply(this, arguments));
    }

    babelHelpers.createClass(Group, [{
      key: "render",
      value: function render() {
        var props = this.props;
        invariant(this.context.isInSurface, 'ART: <Group /> must be a child of a <Surface />');
        return React.createElement(
          NativeGroup,
          {
            opacity: extractOpacity(props),
            transform: extractTransform(props),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 231
            }
          },
          this.props.children
        );
      }
    }]);
    return Group;
  }(React.Component);

  Group.contextTypes = {
    isInSurface: PropTypes.bool.isRequired
  };

  var ClippingRectangle = function (_React$Component3) {
    babelHelpers.inherits(ClippingRectangle, _React$Component3);

    function ClippingRectangle() {
      babelHelpers.classCallCheck(this, ClippingRectangle);
      return babelHelpers.possibleConstructorReturn(this, (ClippingRectangle.__proto__ || Object.getPrototypeOf(ClippingRectangle)).apply(this, arguments));
    }

    babelHelpers.createClass(ClippingRectangle, [{
      key: "render",
      value: function render() {
        var props = this.props;
        var x = extractNumber(props.x, 0);
        var y = extractNumber(props.y, 0);
        var w = extractNumber(props.width, 0);
        var h = extractNumber(props.height, 0);
        var clipping = [x, y, w, h];
        var propsExcludingXAndY = merge(props);
        delete propsExcludingXAndY.x;
        delete propsExcludingXAndY.y;
        return React.createElement(
          NativeGroup,
          {
            clipping: clipping,
            opacity: extractOpacity(props),
            transform: extractTransform(propsExcludingXAndY),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 253
            }
          },
          this.props.children
        );
      }
    }]);
    return ClippingRectangle;
  }(React.Component);

  var SOLID_COLOR = 0;
  var LINEAR_GRADIENT = 1;
  var RADIAL_GRADIENT = 2;
  var PATTERN = 3;

  function insertColorIntoArray(color, targetArray, atIndex) {
    var c = new Color(color);
    targetArray[atIndex + 0] = c.red / 255;
    targetArray[atIndex + 1] = c.green / 255;
    targetArray[atIndex + 2] = c.blue / 255;
    targetArray[atIndex + 3] = c.alpha;
  }

  function insertColorsIntoArray(stops, targetArray, atIndex) {
    var i = 0;

    if ('length' in stops) {
      while (i < stops.length) {
        insertColorIntoArray(stops[i], targetArray, atIndex + i * 4);
        i++;
      }
    } else {
      for (var offset in stops) {
        insertColorIntoArray(stops[offset], targetArray, atIndex + i * 4);
        i++;
      }
    }

    return atIndex + i * 4;
  }

  function insertOffsetsIntoArray(stops, targetArray, atIndex, multi, reverse) {
    var offsetNumber;
    var i = 0;

    if ('length' in stops) {
      while (i < stops.length) {
        offsetNumber = i / (stops.length - 1) * multi;
        targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;
        i++;
      }
    } else {
      for (var offsetString in stops) {
        offsetNumber = +offsetString * multi;
        targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;
        i++;
      }
    }

    return atIndex + i;
  }

  function insertColorStopsIntoArray(stops, targetArray, atIndex) {
    var lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);
    insertOffsetsIntoArray(stops, targetArray, lastIndex, 1, false);
  }

  function insertDoubleColorStopsIntoArray(stops, targetArray, atIndex) {
    var lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);
    lastIndex = insertColorsIntoArray(stops, targetArray, lastIndex);
    lastIndex = insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, false);
    insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, true);
  }

  function applyBoundingBoxToBrushData(brushData, props) {
    var type = brushData[0];
    var width = +props.width;
    var height = +props.height;

    if (type === LINEAR_GRADIENT) {
      brushData[1] *= width;
      brushData[2] *= height;
      brushData[3] *= width;
      brushData[4] *= height;
    } else if (type === RADIAL_GRADIENT) {
      brushData[1] *= width;
      brushData[2] *= height;
      brushData[3] *= width;
      brushData[4] *= height;
      brushData[5] *= width;
      brushData[6] *= height;
    } else if (type === PATTERN) {}
  }

  function extractBrush(colorOrBrush, props) {
    if (colorOrBrush == null) {
      return null;
    }

    if (colorOrBrush._brush) {
      if (colorOrBrush._bb) {
        applyBoundingBoxToBrushData(colorOrBrush._brush, props);
        colorOrBrush._bb = false;
      }

      return colorOrBrush._brush;
    }

    var c = new Color(colorOrBrush);
    return [SOLID_COLOR, c.red / 255, c.green / 255, c.blue / 255, c.alpha];
  }

  function extractColor(color) {
    if (color == null) {
      return null;
    }

    var c = new Color(color);
    return [c.red / 255, c.green / 255, c.blue / 255, c.alpha];
  }

  function extractStrokeCap(strokeCap) {
    switch (strokeCap) {
      case 'butt':
        return 0;

      case 'square':
        return 2;

      default:
        return 1;
    }
  }

  function extractStrokeJoin(strokeJoin) {
    switch (strokeJoin) {
      case 'miter':
        return 0;

      case 'bevel':
        return 2;

      default:
        return 1;
    }
  }

  var Shape = function (_React$Component4) {
    babelHelpers.inherits(Shape, _React$Component4);

    function Shape() {
      babelHelpers.classCallCheck(this, Shape);
      return babelHelpers.possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).apply(this, arguments));
    }

    babelHelpers.createClass(Shape, [{
      key: "render",
      value: function render() {
        var props = this.props;
        var path = props.d || childrenAsString(props.children);
        var d = (path instanceof Path ? path : new Path(path)).toJSON();
        return React.createElement(NativeShape, {
          fill: extractBrush(props.fill, props),
          opacity: extractOpacity(props),
          stroke: extractColor(props.stroke),
          strokeCap: extractStrokeCap(props.strokeCap),
          strokeDash: props.strokeDash || null,
          strokeJoin: extractStrokeJoin(props.strokeJoin),
          strokeWidth: extractNumber(props.strokeWidth, 1),
          transform: extractTransform(props),
          d: d,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 401
          }
        });
      }
    }]);
    return Shape;
  }(React.Component);

  var cachedFontObjectsFromString = {};
  var fontFamilyPrefix = /^[\s"']*/;
  var fontFamilySuffix = /[\s"']*$/;

  function extractSingleFontFamily(fontFamilyString) {
    return fontFamilyString.split(',')[0].replace(fontFamilyPrefix, '').replace(fontFamilySuffix, '');
  }

  function parseFontString(font) {
    if (cachedFontObjectsFromString.hasOwnProperty(font)) {
      return cachedFontObjectsFromString[font];
    }

    var regexp = /^\s*((?:(?:normal|bold|italic)\s+)*)(?:(\d+(?:\.\d+)?)[ptexm\%]*(?:\s*\/.*?)?\s+)?\s*\"?([^\"]*)/i;
    var match = regexp.exec(font);

    if (!match) {
      return null;
    }

    var fontFamily = extractSingleFontFamily(match[3]);
    var fontSize = +match[2] || 12;
    var isBold = /bold/.exec(match[1]);
    var isItalic = /italic/.exec(match[1]);
    cachedFontObjectsFromString[font] = {
      fontFamily: fontFamily,
      fontSize: fontSize,
      fontWeight: isBold ? 'bold' : 'normal',
      fontStyle: isItalic ? 'italic' : 'normal'
    };
    return cachedFontObjectsFromString[font];
  }

  function extractFont(font) {
    if (font == null) {
      return null;
    }

    if (typeof font === 'string') {
      return parseFontString(font);
    }

    var fontFamily = extractSingleFontFamily(font.fontFamily);
    var fontSize = +font.fontSize || 12;
    var fontWeight = font.fontWeight != null ? font.fontWeight.toString() : '400';
    return {
      fontFamily: fontFamily,
      fontSize: fontSize,
      fontWeight: fontWeight,
      fontStyle: font.fontStyle
    };
  }

  var newLine = /\n/g;

  function extractFontAndLines(font, text) {
    return {
      font: extractFont(font),
      lines: text.split(newLine)
    };
  }

  function extractAlignment(alignment) {
    switch (alignment) {
      case 'right':
        return 1;

      case 'center':
        return 2;

      default:
        return 0;
    }
  }

  var Text = function (_React$Component5) {
    babelHelpers.inherits(Text, _React$Component5);

    function Text() {
      babelHelpers.classCallCheck(this, Text);
      return babelHelpers.possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));
    }

    babelHelpers.createClass(Text, [{
      key: "render",
      value: function render() {
        var props = this.props;
        var path = props.path;
        var textPath = path ? (path instanceof Path ? path : new Path(path)).toJSON() : null;
        var textFrame = extractFontAndLines(props.font, childrenAsString(props.children));
        return React.createElement(NativeText, {
          fill: extractBrush(props.fill, props),
          opacity: extractOpacity(props),
          stroke: extractColor(props.stroke),
          strokeCap: extractStrokeCap(props.strokeCap),
          strokeDash: props.strokeDash || null,
          strokeJoin: extractStrokeJoin(props.strokeJoin),
          strokeWidth: extractNumber(props.strokeWidth, 1),
          transform: extractTransform(props),
          alignment: extractAlignment(props.alignment),
          frame: textFrame,
          path: textPath,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 500
          }
        });
      }
    }]);
    return Text;
  }(React.Component);

  function LinearGradient(stops, x1, y1, x2, y2) {
    var type = LINEAR_GRADIENT;

    if (arguments.length < 5) {
      var angle = (x1 == null ? 270 : x1) * Math.PI / 180;
      var x = Math.cos(angle);
      var y = -Math.sin(angle);
      var l = (Math.abs(x) + Math.abs(y)) / 2;
      x *= l;
      y *= l;
      x1 = 0.5 - x;
      x2 = 0.5 + x;
      y1 = 0.5 - y;
      y2 = 0.5 + y;
      this._bb = true;
    } else {
      this._bb = false;
    }

    var brushData = [type, +x1, +y1, +x2, +y2];
    insertColorStopsIntoArray(stops, brushData, 5);
    this._brush = brushData;
  }

  function RadialGradient(stops, fx, fy, rx, ry, cx, cy) {
    if (ry == null) {
      ry = rx;
    }

    if (cx == null) {
      cx = fx;
    }

    if (cy == null) {
      cy = fy;
    }

    if (fx == null) {
      fx = fy = rx = ry = cx = cy = 0.5;
      this._bb = true;
    } else {
      this._bb = false;
    }

    var brushData = [RADIAL_GRADIENT, +fx, +fy, +rx * 2, +ry * 2, +cx, +cy];
    insertDoubleColorStopsIntoArray(stops, brushData, 7);
    this._brush = brushData;
  }

  function Pattern(url, width, height, left, top) {
    this._brush = [PATTERN, url, +left || 0, +top || 0, +width, +height];
  }

  var ReactART = {
    LinearGradient: LinearGradient,
    RadialGradient: RadialGradient,
    Pattern: Pattern,
    Transform: Transform,
    Path: Path,
    Surface: Surface,
    Group: Group,
    ClippingRectangle: ClippingRectangle,
    Shape: Shape,
    Text: Text
  };
  module.exports = ReactART;
},215,[216,217,220,171,24,212,197,175,18],"ReactNativeART");
__d(function (global, require, module, exports, _dependencyMap) {
	var colors = {
		maroon: '#800000',
		red: '#ff0000',
		orange: '#ffA500',
		yellow: '#ffff00',
		olive: '#808000',
		purple: '#800080',
		fuchsia: "#ff00ff",
		white: '#ffffff',
		lime: '#00ff00',
		green: '#008000',
		navy: '#000080',
		blue: '#0000ff',
		aqua: '#00ffff',
		teal: '#008080',
		black: '#000000',
		silver: '#c0c0c0',
		gray: '#808080'
	};

	var map = function map(array, fn) {
		var results = [];

		for (var i = 0, l = array.length; i < l; i++) {
			results[i] = fn(array[i], i);
		}

		return results;
	};

	var Color = function Color(color, type) {
		if (color.isColor) {
			this.red = color.red;
			this.green = color.green;
			this.blue = color.blue;
			this.alpha = color.alpha;
		} else {
			var namedColor = colors[color];

			if (namedColor) {
				color = namedColor;
				type = 'hex';
			}

			switch (typeof color) {
				case 'string':
					if (!type) type = (type = color.match(/^rgb|^hsb|^hsl/)) ? type[0] : 'hex';
					break;

				case 'object':
					type = type || 'rgb';
					color = color.toString();
					break;

				case 'number':
					type = 'hex';
					color = color.toString(16);
					break;
			}

			color = Color['parse' + type.toUpperCase()](color);
			this.red = color[0];
			this.green = color[1];
			this.blue = color[2];
			this.alpha = color[3];
		}

		this.isColor = true;
	};

	var limit = function limit(number, min, max) {
		return Math.min(max, Math.max(min, number));
	};

	var listMatch = /([-.\d]+\%?)\s*,\s*([-.\d]+\%?)\s*,\s*([-.\d]+\%?)\s*,?\s*([-.\d]*\%?)/;
	var hexMatch = /^#?([a-f0-9]{1,2})([a-f0-9]{1,2})([a-f0-9]{1,2})([a-f0-9]{0,2})$/i;

	Color.parseRGB = function (color) {
		return map(color.match(listMatch).slice(1), function (bit, i) {
			if (bit) bit = parseFloat(bit) * (bit[bit.length - 1] == '%' ? 2.55 : 1);
			return i < 3 ? Math.round((bit %= 256) < 0 ? bit + 256 : bit) : limit(bit === '' ? 1 : Number(bit), 0, 1);
		});
	};

	Color.parseHEX = function (color) {
		if (color.length == 1) color = color + color + color;
		return map(color.match(hexMatch).slice(1), function (bit, i) {
			if (i == 3) return bit ? parseInt(bit, 16) / 255 : 1;
			return parseInt(bit.length == 1 ? bit + bit : bit, 16);
		});
	};

	Color.parseHSB = function (color) {
		var hsb = map(color.match(listMatch).slice(1), function (bit, i) {
			if (bit) bit = parseFloat(bit);
			if (i === 0) return Math.round((bit %= 360) < 0 ? bit + 360 : bit);else if (i < 3) return limit(Math.round(bit), 0, 100);else return limit(bit === '' ? 1 : Number(bit), 0, 1);
		});
		var a = hsb[3];
		var br = Math.round(hsb[2] / 100 * 255);
		if (hsb[1] == 0) return [br, br, br, a];
		var hue = hsb[0];
		var f = hue % 60;
		var p = Math.round(hsb[2] * (100 - hsb[1]) / 10000 * 255);
		var q = Math.round(hsb[2] * (6000 - hsb[1] * f) / 600000 * 255);
		var t = Math.round(hsb[2] * (6000 - hsb[1] * (60 - f)) / 600000 * 255);

		switch (Math.floor(hue / 60)) {
			case 0:
				return [br, t, p, a];

			case 1:
				return [q, br, p, a];

			case 2:
				return [p, br, t, a];

			case 3:
				return [p, q, br, a];

			case 4:
				return [t, p, br, a];

			default:
				return [br, p, q, a];
		}
	};

	Color.parseHSL = function (color) {
		var hsb = map(color.match(listMatch).slice(1), function (bit, i) {
			if (bit) bit = parseFloat(bit);
			if (i === 0) return Math.round((bit %= 360) < 0 ? bit + 360 : bit);else if (i < 3) return limit(Math.round(bit), 0, 100);else return limit(bit === '' ? 1 : Number(bit), 0, 1);
		});
		var h = hsb[0] / 60;
		var s = hsb[1] / 100;
		var l = hsb[2] / 100;
		var a = hsb[3];
		var c = (1 - Math.abs(2 * l - 1)) * s;
		var x = c * (1 - Math.abs(h % 2 - 1));
		var m = l - c / 2;
		var p = Math.round((c + m) * 255);
		var q = Math.round((x + m) * 255);
		var t = Math.round(m * 255);

		switch (Math.floor(h)) {
			case 0:
				return [p, q, t, a];

			case 1:
				return [q, p, t, a];

			case 2:
				return [t, p, q, a];

			case 3:
				return [t, q, p, a];

			case 4:
				return [q, t, p, a];

			default:
				return [p, t, q, a];
		}
	};

	var toString = function toString(type, array) {
		if (array[3] != 1) type += 'a';else array.pop();
		return type + '(' + array.join(', ') + ')';
	};

	Color.prototype = {
		toHSB: function toHSB(array) {
			var red = this.red,
			    green = this.green,
			    blue = this.blue,
			    alpha = this.alpha;
			var max = Math.max(red, green, blue),
			    min = Math.min(red, green, blue),
			    delta = max - min;
			var hue = 0,
			    saturation = delta != 0 ? delta / max : 0,
			    brightness = max / 255;

			if (saturation) {
				var rr = (max - red) / delta,
				    gr = (max - green) / delta,
				    br = (max - blue) / delta;
				hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr;
				if ((hue /= 6) < 0) hue++;
			}

			var hsb = [Math.round(hue * 360), Math.round(saturation * 100), Math.round(brightness * 100), alpha];
			return array ? hsb : toString('hsb', hsb);
		},
		toHSL: function toHSL(array) {
			var red = this.red,
			    green = this.green,
			    blue = this.blue,
			    alpha = this.alpha;
			var max = Math.max(red, green, blue),
			    min = Math.min(red, green, blue),
			    delta = max - min;
			var hue = 0,
			    saturation = delta != 0 ? delta / (255 - Math.abs(max + min - 255)) : 0,
			    lightness = (max + min) / 512;

			if (saturation) {
				var rr = (max - red) / delta,
				    gr = (max - green) / delta,
				    br = (max - blue) / delta;
				hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr;
				if ((hue /= 6) < 0) hue++;
			}

			var hsl = [Math.round(hue * 360), Math.round(saturation * 100), Math.round(lightness * 100), alpha];
			return array ? hsl : toString('hsl', hsl);
		},
		toHEX: function toHEX(array) {
			var a = this.alpha;
			var alpha = (a = Math.round(a * 255).toString(16)).length == 1 ? a + a : a;
			var hex = map([this.red, this.green, this.blue], function (bit) {
				bit = bit.toString(16);
				return bit.length == 1 ? '0' + bit : bit;
			});
			return array ? hex.concat(alpha) : '#' + hex.join('') + (alpha == 'ff' ? '' : alpha);
		},
		toRGB: function toRGB(array) {
			var rgb = [this.red, this.green, this.blue, this.alpha];
			return array ? rgb : toString('rgb', rgb);
		}
	};
	Color.prototype.toString = Color.prototype.toRGB;

	Color.hex = function (hex) {
		return new Color(hex, 'hex');
	};

	if (this.hex == null) this.hex = Color.hex;

	Color.hsb = function (h, s, b, a) {
		return new Color([h || 0, s || 0, b || 0, a == null ? 1 : a], 'hsb');
	};

	if (this.hsb == null) this.hsb = Color.hsb;

	Color.hsl = function (h, s, l, a) {
		return new Color([h || 0, s || 0, l || 0, a == null ? 1 : a], 'hsl');
	};

	if (this.hsl == null) this.hsl = Color.hsl;

	Color.rgb = function (r, g, b, a) {
		return new Color([r || 0, g || 0, b || 0, a == null ? 1 : a], 'rgb');
	};

	if (this.rgb == null) this.rgb = Color.rgb;

	Color.detach = function (color) {
		color = new Color(color);
		return [Color.rgb(color.red, color.green, color.blue).toString(), color.alpha];
	};

	module.exports = Color;
},216,[],"art/core/color.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Class = require(_dependencyMap[0], 'art/core/class.js');

  var Path = require(_dependencyMap[1], 'art/core/path.js');

  var MOVE_TO = 0;
  var CLOSE = 1;
  var LINE_TO = 2;
  var CURVE_TO = 3;
  var ARC = 4;
  var SerializablePath = Class(Path, {
    initialize: function initialize(path) {
      this.reset();

      if (path instanceof SerializablePath) {
        this.path = path.path.slice(0);
      } else if (path) {
        if (path.applyToPath) {
          path.applyToPath(this);
        } else {
          this.push(path);
        }
      }
    },
    onReset: function onReset() {
      this.path = [];
    },
    onMove: function onMove(sx, sy, x, y) {
      this.path.push(MOVE_TO, x, y);
    },
    onLine: function onLine(sx, sy, x, y) {
      this.path.push(LINE_TO, x, y);
    },
    onBezierCurve: function onBezierCurve(sx, sy, p1x, p1y, p2x, p2y, x, y) {
      this.path.push(CURVE_TO, p1x, p1y, p2x, p2y, x, y);
    },
    _arcToBezier: Path.prototype.onArc,
    onArc: function onArc(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation) {
      if (rx !== ry || rotation) {
        return this._arcToBezier(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation);
      }

      this.path.push(ARC, cx, cy, rx, sa, ea, ccw ? 0 : 1);
    },
    onClose: function onClose() {
      this.path.push(CLOSE);
    },
    toJSON: function toJSON() {
      return this.path;
    }
  });
  module.exports = SerializablePath;
},217,[218,219],"ARTSerializablePath");
__d(function (global, require, module, exports, _dependencyMap) {
	module.exports = function (mixins) {
		var proto = {};

		for (var i = 0, l = arguments.length; i < l; i++) {
			var mixin = arguments[i];
			if (typeof mixin == 'function') mixin = mixin.prototype;

			for (var key in mixin) {
				proto[key] = mixin[key];
			}
		}

		if (!proto.initialize) proto.initialize = function () {};

		proto.constructor = function (a, b, c, d, e, f, g, h) {
			return new proto.initialize(a, b, c, d, e, f, g, h);
		};

		proto.constructor.prototype = proto.initialize.prototype = proto;
		return proto.constructor;
	};
},218,[],"art/core/class.js");
__d(function (global, require, module, exports, _dependencyMap) {
	var Class = require(_dependencyMap[0], './class');

	module.exports = Class({
		initialize: function initialize(path) {
			this.reset().push(path);
		},
		push: function push() {
			var p = Array.prototype.join.call(arguments, ' ').match(/[a-df-z]|[\-+]?(?:[\d\.]e[\-+]?|[^\s\-+,a-z])+/ig);
			if (!p) return this;
			var last,
			    cmd = p[0],
			    i = 1;

			while (cmd) {
				switch (cmd) {
					case 'm':
						this.move(p[i++], p[i++]);
						break;

					case 'l':
						this.line(p[i++], p[i++]);
						break;

					case 'c':
						this.curve(p[i++], p[i++], p[i++], p[i++], p[i++], p[i++]);
						break;

					case 's':
						this.curve(p[i++], p[i++], null, null, p[i++], p[i++]);
						break;

					case 'q':
						this.curve(p[i++], p[i++], p[i++], p[i++]);
						break;

					case 't':
						this.curve(p[i++], p[i++]);
						break;

					case 'a':
						this.arc(p[i + 5], p[i + 6], p[i], p[i + 1], p[i + 3], !+p[i + 4], p[i + 2]);
						i += 7;
						break;

					case 'h':
						this.line(p[i++], 0);
						break;

					case 'v':
						this.line(0, p[i++]);
						break;

					case 'M':
						this.moveTo(p[i++], p[i++]);
						break;

					case 'L':
						this.lineTo(p[i++], p[i++]);
						break;

					case 'C':
						this.curveTo(p[i++], p[i++], p[i++], p[i++], p[i++], p[i++]);
						break;

					case 'S':
						this.curveTo(p[i++], p[i++], null, null, p[i++], p[i++]);
						break;

					case 'Q':
						this.curveTo(p[i++], p[i++], p[i++], p[i++]);
						break;

					case 'T':
						this.curveTo(p[i++], p[i++]);
						break;

					case 'A':
						this.arcTo(p[i + 5], p[i + 6], p[i], p[i + 1], p[i + 3], !+p[i + 4], p[i + 2]);
						i += 7;
						break;

					case 'H':
						this.lineTo(p[i++], this.penY);
						break;

					case 'V':
						this.lineTo(this.penX, p[i++]);
						break;

					case 'Z':
					case 'z':
						this.close();
						break;

					default:
						cmd = last;
						i--;
						continue;
				}

				last = cmd;
				if (last == 'm') last = 'l';else if (last == 'M') last = 'L';
				cmd = p[i++];
			}

			return this;
		},
		reset: function reset() {
			this.penX = this.penY = 0;
			this.penDownX = this.penDownY = null;
			this._pivotX = this._pivotY = 0;
			this.onReset();
			return this;
		},
		move: function move(x, y) {
			this.onMove(this.penX, this.penY, this._pivotX = this.penX += +x, this._pivotY = this.penY += +y);
			return this;
		},
		moveTo: function moveTo(x, y) {
			this.onMove(this.penX, this.penY, this._pivotX = this.penX = +x, this._pivotY = this.penY = +y);
			return this;
		},
		line: function line(x, y) {
			return this.lineTo(this.penX + +x, this.penY + +y);
		},
		lineTo: function lineTo(x, y) {
			if (this.penDownX == null) {
				this.penDownX = this.penX;
				this.penDownY = this.penY;
			}

			this.onLine(this.penX, this.penY, this._pivotX = this.penX = +x, this._pivotY = this.penY = +y);
			return this;
		},
		curve: function curve(c1x, c1y, c2x, c2y, ex, ey) {
			var x = this.penX,
			    y = this.penY;
			return this.curveTo(x + +c1x, y + +c1y, c2x == null ? null : x + +c2x, c2y == null ? null : y + +c2y, ex == null ? null : x + +ex, ey == null ? null : y + +ey);
		},
		curveTo: function curveTo(c1x, c1y, c2x, c2y, ex, ey) {
			var x = this.penX,
			    y = this.penY;

			if (c2x == null) {
				c2x = +c1x;
				c2y = +c1y;
				c1x = x * 2 - (this._pivotX || 0);
				c1y = y * 2 - (this._pivotY || 0);
			}

			if (ex == null) {
				this._pivotX = +c1x;
				this._pivotY = +c1y;
				ex = +c2x;
				ey = +c2y;
				c2x = (ex + +c1x * 2) / 3;
				c2y = (ey + +c1y * 2) / 3;
				c1x = (x + +c1x * 2) / 3;
				c1y = (y + +c1y * 2) / 3;
			} else {
				this._pivotX = +c2x;
				this._pivotY = +c2y;
			}

			if (this.penDownX == null) {
				this.penDownX = x;
				this.penDownY = y;
			}

			this.onBezierCurve(x, y, +c1x, +c1y, +c2x, +c2y, this.penX = +ex, this.penY = +ey);
			return this;
		},
		arc: function arc(x, y, rx, ry, outer, counterClockwise, rotation) {
			return this.arcTo(this.penX + +x, this.penY + +y, rx, ry, outer, counterClockwise, rotation);
		},
		arcTo: function arcTo(x, y, rx, ry, outer, counterClockwise, rotation) {
			ry = Math.abs(+ry || +rx || +y - this.penY);
			rx = Math.abs(+rx || +x - this.penX);
			if (!rx || !ry || x == this.penX && y == this.penY) return this.lineTo(x, y);
			var tX = this.penX,
			    tY = this.penY,
			    clockwise = !+counterClockwise,
			    large = !!+outer;
			var rad = rotation ? rotation * Math.PI / 180 : 0,
			    cos = Math.cos(rad),
			    sin = Math.sin(rad);
			x -= tX;
			y -= tY;
			var cx = cos * x / 2 + sin * y / 2,
			    cy = -sin * x / 2 + cos * y / 2,
			    rxry = rx * rx * ry * ry,
			    rycx = ry * ry * cx * cx,
			    rxcy = rx * rx * cy * cy,
			    a = rxry - rxcy - rycx;

			if (a < 0) {
				a = Math.sqrt(1 - a / rxry);
				rx *= a;
				ry *= a;
				cx = x / 2;
				cy = y / 2;
			} else {
				a = Math.sqrt(a / (rxcy + rycx));
				if (large == clockwise) a = -a;
				var cxd = -a * cy * rx / ry,
				    cyd = a * cx * ry / rx;
				cx = cos * cxd - sin * cyd + x / 2;
				cy = sin * cxd + cos * cyd + y / 2;
			}

			var xx = cos / rx,
			    yx = sin / rx,
			    xy = -sin / ry,
			    yy = cos / ry;
			var sa = Math.atan2(xy * -cx + yy * -cy, xx * -cx + yx * -cy),
			    ea = Math.atan2(xy * (x - cx) + yy * (y - cy), xx * (x - cx) + yx * (y - cy));
			cx += tX;
			cy += tY;
			x += tX;
			y += tY;

			if (this.penDownX == null) {
				this.penDownX = this.penX;
				this.penDownY = this.penY;
			}

			this.onArc(tX, tY, this._pivotX = this.penX = x, this._pivotY = this.penY = y, cx, cy, rx, ry, sa, ea, !clockwise, rotation);
			return this;
		},
		counterArc: function counterArc(x, y, rx, ry, outer) {
			return this.arc(x, y, rx, ry, outer, true);
		},
		counterArcTo: function counterArcTo(x, y, rx, ry, outer) {
			return this.arcTo(x, y, rx, ry, outer, true);
		},
		close: function close() {
			if (this.penDownX != null) {
				this.onClose(this.penX, this.penY, this.penX = this.penDownX, this.penY = this.penDownY);
				this.penDownX = null;
			}

			return this;
		},
		onReset: function onReset() {},
		onMove: function onMove(sx, sy, ex, ey) {},
		onLine: function onLine(sx, sy, ex, ey) {
			this.onBezierCurve(sx, sy, sx, sy, ex, ey, ex, ey);
		},
		onBezierCurve: function onBezierCurve(sx, sy, c1x, c1y, c2x, c2y, ex, ey) {
			var gx = ex - sx,
			    gy = ey - sy,
			    g = gx * gx + gy * gy,
			    v1,
			    v2,
			    cx,
			    cy,
			    u;
			cx = c1x - sx;
			cy = c1y - sy;
			u = cx * gx + cy * gy;

			if (u > g) {
				cx -= gx;
				cy -= gy;
			} else if (u > 0 && g != 0) {
				cx -= u / g * gx;
				cy -= u / g * gy;
			}

			v1 = cx * cx + cy * cy;
			cx = c2x - sx;
			cy = c2y - sy;
			u = cx * gx + cy * gy;

			if (u > g) {
				cx -= gx;
				cy -= gy;
			} else if (u > 0 && g != 0) {
				cx -= u / g * gx;
				cy -= u / g * gy;
			}

			v2 = cx * cx + cy * cy;

			if (v1 < 0.01 && v2 < 0.01) {
				this.onLine(sx, sy, ex, ey);
				return;
			}

			if (isNaN(v1) || isNaN(v2)) {
				throw new Error('Bad input');
			}

			var s1x = (c1x + c2x) * 0.5,
			    s1y = (c1y + c2y) * 0.5,
			    l1x = (c1x + sx) * 0.5,
			    l1y = (c1y + sy) * 0.5,
			    l2x = (l1x + s1x) * 0.5,
			    l2y = (l1y + s1y) * 0.5,
			    r2x = (ex + c2x) * 0.5,
			    r2y = (ey + c2y) * 0.5,
			    r1x = (r2x + s1x) * 0.5,
			    r1y = (r2y + s1y) * 0.5,
			    l2r1x = (l2x + r1x) * 0.5,
			    l2r1y = (l2y + r1y) * 0.5;
			this.onBezierCurve(sx, sy, l1x, l1y, l2x, l2y, l2r1x, l2r1y);
			this.onBezierCurve(l2r1x, l2r1y, r1x, r1y, r2x, r2y, ex, ey);
		},
		onArc: function onArc(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation) {
			var rad = rotation ? rotation * Math.PI / 180 : 0,
			    cos = Math.cos(rad),
			    sin = Math.sin(rad),
			    xx = cos * rx,
			    yx = -sin * ry,
			    xy = sin * rx,
			    yy = cos * ry;
			var arc = ea - sa;
			if (arc < 0 && !ccw) arc += Math.PI * 2;else if (arc > 0 && ccw) arc -= Math.PI * 2;
			var n = Math.ceil(Math.abs(arc / (Math.PI / 2))),
			    step = arc / n,
			    k = 4 / 3 * Math.tan(step / 4);
			var x = Math.cos(sa),
			    y = Math.sin(sa);

			for (var i = 0; i < n; i++) {
				var cp1x = x - k * y,
				    cp1y = y + k * x;
				sa += step;
				x = Math.cos(sa);
				y = Math.sin(sa);
				var cp2x = x + k * y,
				    cp2y = y - k * x;
				this.onBezierCurve(sx, sy, cx + xx * cp1x + yx * cp1y, cy + xy * cp1x + yy * cp1y, cx + xx * cp2x + yx * cp2y, cy + xy * cp2x + yy * cp2y, sx = cx + xx * x + yx * y, sy = cy + xy * x + yy * y);
			}
		},
		onClose: function onClose(sx, sy, ex, ey) {
			this.onLine(sx, sy, ex, ey);
		}
	});
},219,[218],"art/core/path.js");
__d(function (global, require, module, exports, _dependencyMap) {
	var Class = require(_dependencyMap[0], './class');

	function Transform(xx, yx, xy, yy, x, y) {
		if (xx && typeof xx == 'object') {
			yx = xx.yx;
			yy = xx.yy;
			y = xx.y;
			xy = xx.xy;
			x = xx.x;
			xx = xx.xx;
		}

		this.xx = xx == null ? 1 : xx;
		this.yx = yx || 0;
		this.xy = xy || 0;
		this.yy = yy == null ? 1 : yy;
		this.x = (x == null ? this.x : x) || 0;
		this.y = (y == null ? this.y : y) || 0;

		this._transform();

		return this;
	}

	;
	module.exports = Class({
		initialize: Transform,
		_transform: function _transform() {},
		xx: 1,
		yx: 0,
		x: 0,
		xy: 0,
		yy: 1,
		y: 0,
		transform: function transform(xx, yx, xy, yy, x, y) {
			var m = this;

			if (xx && typeof xx == 'object') {
				yx = xx.yx;
				yy = xx.yy;
				y = xx.y;
				xy = xx.xy;
				x = xx.x;
				xx = xx.xx;
			}

			if (!x) x = 0;
			if (!y) y = 0;
			return this.transformTo(m.xx * xx + m.xy * yx, m.yx * xx + m.yy * yx, m.xx * xy + m.xy * yy, m.yx * xy + m.yy * yy, m.xx * x + m.xy * y + m.x, m.yx * x + m.yy * y + m.y);
		},
		transformTo: Transform,
		translate: function translate(x, y) {
			return this.transform(1, 0, 0, 1, x, y);
		},
		move: function move(x, y) {
			this.x += x || 0;
			this.y += y || 0;

			this._transform();

			return this;
		},
		scale: function scale(x, y) {
			if (y == null) y = x;
			return this.transform(x, 0, 0, y, 0, 0);
		},
		rotate: function rotate(deg, x, y) {
			if (x == null || y == null) {
				x = (this.left || 0) + (this.width || 0) / 2;
				y = (this.top || 0) + (this.height || 0) / 2;
			}

			var rad = deg * Math.PI / 180,
			    sin = Math.sin(rad),
			    cos = Math.cos(rad);
			this.transform(1, 0, 0, 1, x, y);
			var m = this;
			return this.transformTo(cos * m.xx - sin * m.yx, sin * m.xx + cos * m.yx, cos * m.xy - sin * m.yy, sin * m.xy + cos * m.yy, m.x, m.y).transform(1, 0, 0, 1, -x, -y);
		},
		moveTo: function moveTo(x, y) {
			var m = this;
			return this.transformTo(m.xx, m.yx, m.xy, m.yy, x, y);
		},
		rotateTo: function rotateTo(deg, x, y) {
			var m = this;
			var flip = m.yx / m.xx > m.yy / m.xy ? -1 : 1;
			if (m.xx < 0 ? m.xy >= 0 : m.xy < 0) flip = -flip;
			return this.rotate(deg - Math.atan2(flip * m.yx, flip * m.xx) * 180 / Math.PI, x, y);
		},
		scaleTo: function scaleTo(x, y) {
			var m = this;
			var h = Math.sqrt(m.xx * m.xx + m.yx * m.yx);
			m.xx /= h;
			m.yx /= h;
			h = Math.sqrt(m.yy * m.yy + m.xy * m.xy);
			m.yy /= h;
			m.xy /= h;
			return this.scale(x, y);
		},
		resizeTo: function resizeTo(width, height) {
			var w = this.width,
			    h = this.height;
			if (!w || !h) return this;
			return this.scaleTo(width / w, height / h);
		},
		inversePoint: function inversePoint(x, y) {
			var a = this.xx,
			    b = this.yx,
			    c = this.xy,
			    d = this.yy,
			    e = this.x,
			    f = this.y;
			var det = b * c - a * d;
			if (det == 0) return null;
			return {
				x: (d * (e - x) + c * (y - f)) / det,
				y: (a * (f - y) + b * (x - e)) / det
			};
		},
		point: function point(x, y) {
			var m = this;
			return {
				x: m.xx * x + m.xy * y + m.x,
				y: m.yx * x + m.yy * y + m.y
			};
		}
	});
},220,[218],"art/core/transform.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/Button.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var Platform = require(_dependencyMap[1], 'Platform');

  var React = require(_dependencyMap[2], 'React');

  var PropTypes = require(_dependencyMap[3], 'prop-types');

  var StyleSheet = require(_dependencyMap[4], 'StyleSheet');

  var Text = require(_dependencyMap[5], 'Text');

  var TouchableNativeFeedback = require(_dependencyMap[6], 'TouchableNativeFeedback');

  var TouchableOpacity = require(_dependencyMap[7], 'TouchableOpacity');

  var View = require(_dependencyMap[8], 'View');

  var invariant = require(_dependencyMap[9], 'fbjs/lib/invariant');

  var Button = function (_React$Component) {
    babelHelpers.inherits(Button, _React$Component);

    function Button() {
      babelHelpers.classCallCheck(this, Button);
      return babelHelpers.possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).apply(this, arguments));
    }

    babelHelpers.createClass(Button, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            accessibilityLabel = _props.accessibilityLabel,
            color = _props.color,
            onPress = _props.onPress,
            title = _props.title,
            hasTVPreferredFocus = _props.hasTVPreferredFocus,
            disabled = _props.disabled,
            testID = _props.testID;
        var buttonStyles = [styles.button];
        var textStyles = [styles.text];

        if (color) {
          if (Platform.OS === 'ios') {
            textStyles.push({
              color: color
            });
          } else {
            buttonStyles.push({
              backgroundColor: color
            });
          }
        }

        var accessibilityTraits = ['button'];

        if (disabled) {
          buttonStyles.push(styles.buttonDisabled);
          textStyles.push(styles.textDisabled);
          accessibilityTraits.push('disabled');
        }

        invariant(typeof title === 'string', 'The title prop of a Button must be a string');
        var formattedTitle = Platform.OS === 'android' ? title.toUpperCase() : title;
        var Touchable = Platform.OS === 'android' ? TouchableNativeFeedback : TouchableOpacity;
        return React.createElement(
          Touchable,
          {
            accessibilityComponentType: "button",
            accessibilityLabel: accessibilityLabel,
            accessibilityTraits: accessibilityTraits,
            hasTVPreferredFocus: hasTVPreferredFocus,
            testID: testID,
            disabled: disabled,
            onPress: onPress,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 128
            }
          },
          React.createElement(
            View,
            {
              style: buttonStyles,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 136
              }
            },
            React.createElement(
              Text,
              {
                style: textStyles,
                disabled: disabled,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 137
                }
              },
              formattedTitle
            )
          )
        );
      }
    }]);
    return Button;
  }(React.Component);

  Button.propTypes = {
    title: PropTypes.string.isRequired,
    accessibilityLabel: PropTypes.string,
    color: ColorPropType,
    disabled: PropTypes.bool,
    onPress: PropTypes.func.isRequired,
    testID: PropTypes.string,
    hasTVPreferredFocus: PropTypes.bool
  };
  var styles = StyleSheet.create({
    button: Platform.select({
      ios: {},
      android: {
        elevation: 4,
        backgroundColor: '#2196F3',
        borderRadius: 2
      }
    }),
    text: Platform.select({
      ios: {
        color: '#007AFF',
        textAlign: 'center',
        padding: 8,
        fontSize: 18
      },
      android: {
        color: 'white',
        textAlign: 'center',
        padding: 8,
        fontWeight: '500'
      }
    }),
    buttonDisabled: Platform.select({
      ios: {},
      android: {
        elevation: 0,
        backgroundColor: '#dfdfdf'
      }
    }),
    textDisabled: Platform.select({
      ios: {
        color: '#cdcdcd'
      },
      android: {
        color: '#a1a1a1'
      }
    })
  });
  module.exports = Button;
},221,[167,105,171,24,209,222,230,234,211,18],"Button");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Text/Text.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var EdgeInsetsPropType = require(_dependencyMap[1], 'EdgeInsetsPropType');

  var NativeMethodsMixin = require(_dependencyMap[2], 'NativeMethodsMixin');

  var Platform = require(_dependencyMap[3], 'Platform');

  var React = require(_dependencyMap[4], 'React');

  var PropTypes = require(_dependencyMap[5], 'prop-types');

  var ReactNativeViewAttributes = require(_dependencyMap[6], 'ReactNativeViewAttributes');

  var StyleSheetPropType = require(_dependencyMap[7], 'StyleSheetPropType');

  var TextStylePropTypes = require(_dependencyMap[8], 'TextStylePropTypes');

  var Touchable = require(_dependencyMap[9], 'Touchable');

  var createReactClass = require(_dependencyMap[10], 'create-react-class');

  var createReactNativeComponentClass = require(_dependencyMap[11], 'createReactNativeComponentClass');

  var mergeFast = require(_dependencyMap[12], 'mergeFast');

  var processColor = require(_dependencyMap[13], 'processColor');

  var stylePropType = StyleSheetPropType(TextStylePropTypes);
  var viewConfig = {
    validAttributes: mergeFast(ReactNativeViewAttributes.UIView, {
      isHighlighted: true,
      numberOfLines: true,
      ellipsizeMode: true,
      allowFontScaling: true,
      disabled: true,
      selectable: true,
      selectionColor: true,
      adjustsFontSizeToFit: true,
      minimumFontScale: true,
      textBreakStrategy: true
    }),
    uiViewClassName: 'RCTText'
  };
  var Text = createReactClass({
    displayName: 'Text',
    propTypes: {
      ellipsizeMode: PropTypes.oneOf(['head', 'middle', 'tail', 'clip']),
      numberOfLines: PropTypes.number,
      textBreakStrategy: PropTypes.oneOf(['simple', 'highQuality', 'balanced']),
      onLayout: PropTypes.func,
      onPress: PropTypes.func,
      onLongPress: PropTypes.func,
      pressRetentionOffset: EdgeInsetsPropType,
      selectable: PropTypes.bool,
      selectionColor: ColorPropType,
      suppressHighlighting: PropTypes.bool,
      style: stylePropType,
      testID: PropTypes.string,
      nativeID: PropTypes.string,
      allowFontScaling: PropTypes.bool,
      accessible: PropTypes.bool,
      adjustsFontSizeToFit: PropTypes.bool,
      minimumFontScale: PropTypes.number,
      disabled: PropTypes.bool
    },
    getDefaultProps: function getDefaultProps() {
      return {
        accessible: true,
        allowFontScaling: true,
        ellipsizeMode: 'tail'
      };
    },
    getInitialState: function getInitialState() {
      return mergeFast(Touchable.Mixin.touchableGetInitialState(), {
        isHighlighted: false
      });
    },
    mixins: [NativeMethodsMixin],
    viewConfig: viewConfig,
    getChildContext: function getChildContext() {
      return {
        isInAParentText: true
      };
    },
    childContextTypes: {
      isInAParentText: PropTypes.bool
    },
    contextTypes: {
      isInAParentText: PropTypes.bool
    },
    _handlers: null,
    _hasPressHandler: function _hasPressHandler() {
      return !!this.props.onPress || !!this.props.onLongPress;
    },
    touchableHandleActivePressIn: null,
    touchableHandleActivePressOut: null,
    touchableHandlePress: null,
    touchableHandleLongPress: null,
    touchableGetPressRectOffset: null,
    render: function render() {
      var _this = this;

      var newProps = this.props;

      if (this.props.onStartShouldSetResponder || this._hasPressHandler()) {
        if (!this._handlers) {
          this._handlers = {
            onStartShouldSetResponder: function onStartShouldSetResponder() {
              var shouldSetFromProps = _this.props.onStartShouldSetResponder && _this.props.onStartShouldSetResponder();

              var setResponder = shouldSetFromProps || _this._hasPressHandler();

              if (setResponder && !_this.touchableHandleActivePressIn) {
                for (var key in Touchable.Mixin) {
                  if (typeof Touchable.Mixin[key] === 'function') {
                    _this[key] = Touchable.Mixin[key].bind(_this);
                  }
                }

                _this.touchableHandleActivePressIn = function () {
                  if (_this.props.suppressHighlighting || !_this._hasPressHandler()) {
                    return;
                  }

                  _this.setState({
                    isHighlighted: true
                  });
                };

                _this.touchableHandleActivePressOut = function () {
                  if (_this.props.suppressHighlighting || !_this._hasPressHandler()) {
                    return;
                  }

                  _this.setState({
                    isHighlighted: false
                  });
                };

                _this.touchableHandlePress = function (e) {
                  _this.props.onPress && _this.props.onPress(e);
                };

                _this.touchableHandleLongPress = function (e) {
                  _this.props.onLongPress && _this.props.onLongPress(e);
                };

                _this.touchableGetPressRectOffset = function () {
                  return this.props.pressRetentionOffset || PRESS_RECT_OFFSET;
                };
              }

              return setResponder;
            },
            onResponderGrant: function (e, dispatchID) {
              this.touchableHandleResponderGrant(e, dispatchID);
              this.props.onResponderGrant && this.props.onResponderGrant.apply(this, arguments);
            }.bind(this),
            onResponderMove: function (e) {
              this.touchableHandleResponderMove(e);
              this.props.onResponderMove && this.props.onResponderMove.apply(this, arguments);
            }.bind(this),
            onResponderRelease: function (e) {
              this.touchableHandleResponderRelease(e);
              this.props.onResponderRelease && this.props.onResponderRelease.apply(this, arguments);
            }.bind(this),
            onResponderTerminate: function (e) {
              this.touchableHandleResponderTerminate(e);
              this.props.onResponderTerminate && this.props.onResponderTerminate.apply(this, arguments);
            }.bind(this),
            onResponderTerminationRequest: function () {
              var allowTermination = this.touchableHandleResponderTerminationRequest();

              if (allowTermination && this.props.onResponderTerminationRequest) {
                allowTermination = this.props.onResponderTerminationRequest.apply(this, arguments);
              }

              return allowTermination;
            }.bind(this)
          };
        }

        newProps = babelHelpers.extends({}, this.props, this._handlers, {
          isHighlighted: this.state.isHighlighted
        });
      }

      if (newProps.selectionColor != null) {
        newProps = babelHelpers.extends({}, newProps, {
          selectionColor: processColor(newProps.selectionColor)
        });
      }

      if (Touchable.TOUCH_TARGET_DEBUG && newProps.onPress) {
        newProps = babelHelpers.extends({}, newProps, {
          style: [this.props.style, {
            color: 'magenta'
          }]
        });
      }

      if (this.context.isInAParentText) {
        return React.createElement(RCTVirtualText, babelHelpers.extends({}, newProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 546
          }
        }));
      } else {
        return React.createElement(RCTText, babelHelpers.extends({}, newProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 548
          }
        }));
      }
    }
  });
  var PRESS_RECT_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var RCTText = createReactNativeComponentClass(viewConfig.uiViewClassName, function () {
    return viewConfig;
  });
  var RCTVirtualText = RCTText;

  if (Platform.OS === 'android') {
    RCTVirtualText = createReactNativeComponentClass('RCTVirtualText', function () {
      return {
        validAttributes: mergeFast(ReactNativeViewAttributes.UIView, {
          isHighlighted: true
        }),
        uiViewClassName: 'RCTVirtualText'
      };
    });
  }

  module.exports = Text;
},222,[167,173,169,105,171,24,212,179,192,223,213,197,229,193],"Text");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/Touchable/Touchable.js";

  var BoundingDimensions = require(_dependencyMap[0], 'BoundingDimensions');

  var Platform = require(_dependencyMap[1], 'Platform');

  var Position = require(_dependencyMap[2], 'Position');

  var React = require(_dependencyMap[3], 'React');

  var ReactNative = require(_dependencyMap[4], 'ReactNative');

  var TVEventHandler = require(_dependencyMap[5], 'TVEventHandler');

  var TouchEventUtils = require(_dependencyMap[6], 'fbjs/lib/TouchEventUtils');

  var UIManager = require(_dependencyMap[7], 'UIManager');

  var View = require(_dependencyMap[8], 'View');

  var keyMirror = require(_dependencyMap[9], 'fbjs/lib/keyMirror');

  var normalizeColor = require(_dependencyMap[10], 'normalizeColor');

  var States = keyMirror({
    NOT_RESPONDER: null,
    RESPONDER_INACTIVE_PRESS_IN: null,
    RESPONDER_INACTIVE_PRESS_OUT: null,
    RESPONDER_ACTIVE_PRESS_IN: null,
    RESPONDER_ACTIVE_PRESS_OUT: null,
    RESPONDER_ACTIVE_LONG_PRESS_IN: null,
    RESPONDER_ACTIVE_LONG_PRESS_OUT: null,
    ERROR: null
  });
  var IsActive = {
    RESPONDER_ACTIVE_PRESS_OUT: true,
    RESPONDER_ACTIVE_PRESS_IN: true
  };
  var IsPressingIn = {
    RESPONDER_INACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  };
  var IsLongPressingIn = {
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  };
  var Signals = keyMirror({
    DELAY: null,
    RESPONDER_GRANT: null,
    RESPONDER_RELEASE: null,
    RESPONDER_TERMINATED: null,
    ENTER_PRESS_RECT: null,
    LEAVE_PRESS_RECT: null,
    LONG_PRESS_DETECTED: null
  });
  var Transitions = {
    NOT_RESPONDER: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.ERROR,
      RESPONDER_TERMINATED: States.ERROR,
      ENTER_PRESS_RECT: States.ERROR,
      LEAVE_PRESS_RECT: States.ERROR,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_IN: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_IN,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_OUT: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_LONG_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_LONG_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    error: {
      DELAY: States.NOT_RESPONDER,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.NOT_RESPONDER,
      LEAVE_PRESS_RECT: States.NOT_RESPONDER,
      LONG_PRESS_DETECTED: States.NOT_RESPONDER
    }
  };
  var HIGHLIGHT_DELAY_MS = 130;
  var PRESS_EXPAND_PX = 20;
  var LONG_PRESS_THRESHOLD = 500;
  var LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;
  var LONG_PRESS_ALLOWED_MOVEMENT = 10;
  var TouchableMixin = {
    componentDidMount: function componentDidMount() {
      if (!Platform.isTVOS) {
        return;
      }

      this._tvEventHandler = new TVEventHandler();

      this._tvEventHandler.enable(this, function (cmp, evt) {
        var myTag = ReactNative.findNodeHandle(cmp);
        evt.dispatchConfig = {};

        if (myTag === evt.tag) {
          if (evt.eventType === 'focus') {
            cmp.touchableHandleActivePressIn && cmp.touchableHandleActivePressIn(evt);
          } else if (evt.eventType === 'blur') {
            cmp.touchableHandleActivePressOut && cmp.touchableHandleActivePressOut(evt);
          } else if (evt.eventType === 'select') {
            cmp.touchableHandlePress && cmp.touchableHandlePress(evt);
          }
        }
      });
    },
    componentWillUnmount: function componentWillUnmount() {
      if (this._tvEventHandler) {
        this._tvEventHandler.disable();

        delete this._tvEventHandler;
      }

      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
    },
    touchableGetInitialState: function touchableGetInitialState() {
      return {
        touchable: {
          touchState: undefined,
          responderID: null
        }
      };
    },
    touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {
      return !this.props.rejectResponderTermination;
    },
    touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {
      return !this.props.disabled;
    },
    touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {
      return true;
    },
    touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {
      var dispatchID = e.currentTarget;
      e.persist();
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
      this.pressOutDelayTimeout = null;
      this.state.touchable.touchState = States.NOT_RESPONDER;
      this.state.touchable.responderID = dispatchID;

      this._receiveSignal(Signals.RESPONDER_GRANT, e);

      var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;
      delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;

      if (delayMS !== 0) {
        this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);
      } else {
        this._handleDelay(e);
      }

      var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;
      longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;
      this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);
    },
    touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {
      this._receiveSignal(Signals.RESPONDER_RELEASE, e);
    },
    touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {
      this._receiveSignal(Signals.RESPONDER_TERMINATED, e);
    },
    touchableHandleResponderMove: function touchableHandleResponderMove(e) {
      if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {
        return;
      }

      if (!this.state.touchable.positionOnActivate) {
        return;
      }

      var positionOnActivate = this.state.touchable.positionOnActivate;
      var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;
      var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {
        left: PRESS_EXPAND_PX,
        right: PRESS_EXPAND_PX,
        top: PRESS_EXPAND_PX,
        bottom: PRESS_EXPAND_PX
      };
      var pressExpandLeft = pressRectOffset.left;
      var pressExpandTop = pressRectOffset.top;
      var pressExpandRight = pressRectOffset.right;
      var pressExpandBottom = pressRectOffset.bottom;
      var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;

      if (hitSlop) {
        pressExpandLeft += hitSlop.left;
        pressExpandTop += hitSlop.top;
        pressExpandRight += hitSlop.right;
        pressExpandBottom += hitSlop.bottom;
      }

      var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;

      if (this.pressInLocation) {
        var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);

        if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {
          this._cancelLongPressDelayTimeout();
        }
      }

      var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;

      if (isTouchWithinActive) {
        this._receiveSignal(Signals.ENTER_PRESS_RECT, e);

        var curState = this.state.touchable.touchState;

        if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {
          this._cancelLongPressDelayTimeout();
        }
      } else {
        this._cancelLongPressDelayTimeout();

        this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);
      }
    },
    _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {
      var tag = this.state.touchable.responderID;

      if (tag == null) {
        return;
      }

      UIManager.measure(tag, this._handleQueryLayout);
    },
    _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {
      if (!l && !t && !w && !h && !globalX && !globalY) {
        return;
      }

      this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);
      this.state.touchable.dimensionsOnActivate && BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);
      this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);
      this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(w, h);
    },
    _handleDelay: function _handleDelay(e) {
      this.touchableDelayTimeout = null;

      this._receiveSignal(Signals.DELAY, e);
    },
    _handleLongDelay: function _handleLongDelay(e) {
      this.longPressDelayTimeout = null;
      var curState = this.state.touchable.touchState;

      if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {
        console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');
      } else {
        this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);
      }
    },
    _receiveSignal: function _receiveSignal(signal, e) {
      var responderID = this.state.touchable.responderID;
      var curState = this.state.touchable.touchState;
      var nextState = Transitions[curState] && Transitions[curState][signal];

      if (!responderID && signal === Signals.RESPONDER_RELEASE) {
        return;
      }

      if (!nextState) {
        throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');
      }

      if (nextState === States.ERROR) {
        throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');
      }

      if (curState !== nextState) {
        this._performSideEffectsForTransition(curState, nextState, signal, e);

        this.state.touchable.touchState = nextState;
      }
    },
    _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.longPressDelayTimeout = null;
    },
    _isHighlight: function _isHighlight(state) {
      return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;
    },
    _savePressInLocation: function _savePressInLocation(e) {
      var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;
      var locationX = touch && touch.locationX;
      var locationY = touch && touch.locationY;
      this.pressInLocation = {
        pageX: pageX,
        pageY: pageY,
        locationX: locationX,
        locationY: locationY
      };
    },
    _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {
      var deltaX = aX - bX;
      var deltaY = aY - bY;
      return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    },
    _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {
      var curIsHighlight = this._isHighlight(curState);

      var newIsHighlight = this._isHighlight(nextState);

      var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;

      if (isFinalSignal) {
        this._cancelLongPressDelayTimeout();
      }

      if (!IsActive[curState] && IsActive[nextState]) {
        this._remeasureMetricsOnActivation();
      }

      if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {
        this.touchableHandleLongPress && this.touchableHandleLongPress(e);
      }

      if (newIsHighlight && !curIsHighlight) {
        this._startHighlight(e);
      } else if (!newIsHighlight && curIsHighlight) {
        this._endHighlight(e);
      }

      if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {
        var hasLongPressHandler = !!this.props.onLongPress;
        var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (!hasLongPressHandler || !this.touchableLongPressCancelsPress());
        var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;

        if (shouldInvokePress && this.touchableHandlePress) {
          if (!newIsHighlight && !curIsHighlight) {
            this._startHighlight(e);

            this._endHighlight(e);
          }

          this.touchableHandlePress(e);
        }
      }

      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.touchableDelayTimeout = null;
    },
    _startHighlight: function _startHighlight(e) {
      this._savePressInLocation(e);

      this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);
    },
    _endHighlight: function _endHighlight(e) {
      var _this = this;

      if (this.touchableHandleActivePressOut) {
        if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {
          this.pressOutDelayTimeout = setTimeout(function () {
            _this.touchableHandleActivePressOut(e);
          }, this.touchableGetPressOutDelayMS());
        } else {
          this.touchableHandleActivePressOut(e);
        }
      }
    }
  };
  var Touchable = {
    Mixin: TouchableMixin,
    TOUCH_TARGET_DEBUG: false,
    renderDebugView: function renderDebugView(_ref) {
      var color = _ref.color,
          hitSlop = _ref.hitSlop;

      if (!Touchable.TOUCH_TARGET_DEBUG) {
        return null;
      }

      if (!__DEV__) {
        throw Error('Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!');
      }

      var debugHitSlopStyle = {};
      hitSlop = hitSlop || {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };

      for (var key in hitSlop) {
        debugHitSlopStyle[key] = -hitSlop[key];
      }

      var hexColor = '#' + ('00000000' + normalizeColor(color).toString(16)).substr(-8);
      return React.createElement(View, {
        pointerEvents: "none",
        style: babelHelpers.extends({
          position: 'absolute',
          borderColor: hexColor.slice(0, -2) + '55',
          borderWidth: 1,
          borderStyle: 'dashed',
          backgroundColor: hexColor.slice(0, -2) + '0F'
        }, debugHitSlopStyle),
        __source: {
          fileName: _jsxFileName,
          lineNumber: 793
        }
      });
    }
  };
  module.exports = Touchable;
},223,[224,105,226,171,74,227,228,158,211,191,168],"Touchable");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var PooledClass = require(_dependencyMap[0], 'PooledClass');

  var twoArgumentPooler = PooledClass.twoArgumentPooler;

  function BoundingDimensions(width, height) {
    this.width = width;
    this.height = height;
  }

  BoundingDimensions.prototype.destructor = function () {
    this.width = null;
    this.height = null;
  };

  BoundingDimensions.getPooledFromElement = function (element) {
    return BoundingDimensions.getPooled(element.offsetWidth, element.offsetHeight);
  };

  PooledClass.addPoolingTo(BoundingDimensions, twoArgumentPooler);
  module.exports = BoundingDimensions;
},224,[225],"BoundingDimensions");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, copyFieldsFrom);
      return instance;
    } else {
      return new Klass(copyFieldsFrom);
    }
  };

  var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2);
      return instance;
    } else {
      return new Klass(a1, a2);
    }
  };

  var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3);
      return instance;
    } else {
      return new Klass(a1, a2, a3);
    }
  };

  var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3, a4);
      return instance;
    } else {
      return new Klass(a1, a2, a3, a4);
    }
  };

  var standardReleaser = function standardReleaser(instance) {
    var Klass = this;
    invariant(instance instanceof Klass, 'Trying to release an instance into a pool of a different type.');
    instance.destructor();

    if (Klass.instancePool.length < Klass.poolSize) {
      Klass.instancePool.push(instance);
    }
  };

  var DEFAULT_POOL_SIZE = 10;
  var DEFAULT_POOLER = oneArgumentPooler;

  var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
    var NewKlass = CopyConstructor;
    NewKlass.instancePool = [];
    NewKlass.getPooled = pooler || DEFAULT_POOLER;

    if (!NewKlass.poolSize) {
      NewKlass.poolSize = DEFAULT_POOL_SIZE;
    }

    NewKlass.release = standardReleaser;
    return NewKlass;
  };

  var PooledClass = {
    addPoolingTo: addPoolingTo,
    oneArgumentPooler: oneArgumentPooler,
    twoArgumentPooler: twoArgumentPooler,
    threeArgumentPooler: threeArgumentPooler,
    fourArgumentPooler: fourArgumentPooler
  };
  module.exports = PooledClass;
},225,[18],"PooledClass");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var PooledClass = require(_dependencyMap[0], 'PooledClass');

  var twoArgumentPooler = PooledClass.twoArgumentPooler;

  function Position(left, top) {
    this.left = left;
    this.top = top;
  }

  Position.prototype.destructor = function () {
    this.left = null;
    this.top = null;
  };

  PooledClass.addPoolingTo(Position, twoArgumentPooler);
  module.exports = Position;
},226,[225],"Position");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function TVEventHandler() {}

  TVEventHandler.prototype.enable = function (component, callback) {};

  TVEventHandler.prototype.disable = function () {};

  module.exports = TVEventHandler;
},227,[],"TVEventHandler");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  var TouchEventUtils = {
    extractSingleTouch: function extractSingleTouch(nativeEvent) {
      var touches = nativeEvent.touches;
      var changedTouches = nativeEvent.changedTouches;
      var hasTouches = touches && touches.length > 0;
      var hasChangedTouches = changedTouches && changedTouches.length > 0;
      return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;
    }
  };
  module.exports = TouchEventUtils;
},228,[],"fbjs/lib/TouchEventUtils.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var mergeFast = function mergeFast(one, two) {
    var ret = {};

    for (var keyOne in one) {
      ret[keyOne] = one[keyOne];
    }

    for (var keyTwo in two) {
      ret[keyTwo] = two[keyTwo];
    }

    return ret;
  };

  module.exports = mergeFast;
},229,[],"mergeFast");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Platform = require(_dependencyMap[0], 'Platform');

  var React = require(_dependencyMap[1], 'React');

  var PropTypes = require(_dependencyMap[2], 'prop-types');

  var ReactNative = require(_dependencyMap[3], 'ReactNative');

  var Touchable = require(_dependencyMap[4], 'Touchable');

  var TouchableWithoutFeedback = require(_dependencyMap[5], 'TouchableWithoutFeedback');

  var UIManager = require(_dependencyMap[6], 'UIManager');

  var createReactClass = require(_dependencyMap[7], 'create-react-class');

  var ensurePositiveDelayProps = require(_dependencyMap[8], 'ensurePositiveDelayProps');

  var processColor = require(_dependencyMap[9], 'processColor');

  var rippleBackgroundPropType = PropTypes.shape({
    type: PropTypes.oneOf(['RippleAndroid']),
    color: PropTypes.number,
    borderless: PropTypes.bool
  });
  var themeAttributeBackgroundPropType = PropTypes.shape({
    type: PropTypes.oneOf(['ThemeAttrAndroid']),
    attribute: PropTypes.string.isRequired
  });
  var backgroundPropType = PropTypes.oneOfType([rippleBackgroundPropType, themeAttributeBackgroundPropType]);
  var PRESS_RETENTION_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var TouchableNativeFeedback = createReactClass({
    displayName: 'TouchableNativeFeedback',
    propTypes: babelHelpers.extends({}, TouchableWithoutFeedback.propTypes, {
      background: backgroundPropType,
      useForeground: PropTypes.bool
    }),
    statics: {
      SelectableBackground: function SelectableBackground() {
        return {
          type: 'ThemeAttrAndroid',
          attribute: 'selectableItemBackground'
        };
      },
      SelectableBackgroundBorderless: function SelectableBackgroundBorderless() {
        return {
          type: 'ThemeAttrAndroid',
          attribute: 'selectableItemBackgroundBorderless'
        };
      },
      Ripple: function Ripple(color, borderless) {
        return {
          type: 'RippleAndroid',
          color: processColor(color),
          borderless: borderless
        };
      },
      canUseNativeForeground: function canUseNativeForeground() {
        return Platform.OS === 'android' && Platform.Version >= 23;
      }
    },
    mixins: [Touchable.Mixin],
    getDefaultProps: function getDefaultProps() {
      return {
        background: this.SelectableBackground()
      };
    },
    getInitialState: function getInitialState() {
      return this.touchableGetInitialState();
    },
    componentDidMount: function componentDidMount() {
      ensurePositiveDelayProps(this.props);
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      ensurePositiveDelayProps(nextProps);
    },
    touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
      this.props.onPressIn && this.props.onPressIn(e);

      this._dispatchPressedStateChange(true);

      this._dispatchHotspotUpdate(this.pressInLocation.locationX, this.pressInLocation.locationY);
    },
    touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
      this.props.onPressOut && this.props.onPressOut(e);

      this._dispatchPressedStateChange(false);
    },
    touchableHandlePress: function touchableHandlePress(e) {
      this.props.onPress && this.props.onPress(e);
    },
    touchableHandleLongPress: function touchableHandleLongPress(e) {
      this.props.onLongPress && this.props.onLongPress(e);
    },
    touchableGetPressRectOffset: function touchableGetPressRectOffset() {
      return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
    },
    touchableGetHitSlop: function touchableGetHitSlop() {
      return this.props.hitSlop;
    },
    touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
      return this.props.delayPressIn;
    },
    touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
      return this.props.delayLongPress;
    },
    touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
      return this.props.delayPressOut;
    },
    _handleResponderMove: function _handleResponderMove(e) {
      this.touchableHandleResponderMove(e);

      this._dispatchHotspotUpdate(e.nativeEvent.locationX, e.nativeEvent.locationY);
    },
    _dispatchHotspotUpdate: function _dispatchHotspotUpdate(destX, destY) {
      UIManager.dispatchViewManagerCommand(ReactNative.findNodeHandle(this), UIManager.RCTView.Commands.hotspotUpdate, [destX || 0, destY || 0]);
    },
    _dispatchPressedStateChange: function _dispatchPressedStateChange(pressed) {
      UIManager.dispatchViewManagerCommand(ReactNative.findNodeHandle(this), UIManager.RCTView.Commands.setPressed, [pressed]);
    },
    render: function render() {
      var _babelHelpers$extends;

      var child = React.Children.only(this.props.children);
      var children = child.props.children;

      if (Touchable.TOUCH_TARGET_DEBUG && child.type.displayName === 'View') {
        if (!Array.isArray(children)) {
          children = [children];
        }

        children.push(Touchable.renderDebugView({
          color: 'brown',
          hitSlop: this.props.hitSlop
        }));
      }

      if (this.props.useForeground && !TouchableNativeFeedback.canUseNativeForeground()) {
        console.warn('Requested foreground ripple, but it is not available on this version of Android. ' + 'Consider calling TouchableNativeFeedback.canUseNativeForeground() and using a different ' + 'Touchable if the result is false.');
      }

      var drawableProp = this.props.useForeground && TouchableNativeFeedback.canUseNativeForeground() ? 'nativeForegroundAndroid' : 'nativeBackgroundAndroid';
      var childProps = babelHelpers.extends({}, child.props, (_babelHelpers$extends = {}, babelHelpers.defineProperty(_babelHelpers$extends, drawableProp, this.props.background), babelHelpers.defineProperty(_babelHelpers$extends, "accessible", this.props.accessible !== false), babelHelpers.defineProperty(_babelHelpers$extends, "accessibilityLabel", this.props.accessibilityLabel), babelHelpers.defineProperty(_babelHelpers$extends, "accessibilityComponentType", this.props.accessibilityComponentType), babelHelpers.defineProperty(_babelHelpers$extends, "accessibilityTraits", this.props.accessibilityTraits), babelHelpers.defineProperty(_babelHelpers$extends, "children", children), babelHelpers.defineProperty(_babelHelpers$extends, "testID", this.props.testID), babelHelpers.defineProperty(_babelHelpers$extends, "onLayout", this.props.onLayout), babelHelpers.defineProperty(_babelHelpers$extends, "hitSlop", this.props.hitSlop), babelHelpers.defineProperty(_babelHelpers$extends, "onStartShouldSetResponder", this.touchableHandleStartShouldSetResponder), babelHelpers.defineProperty(_babelHelpers$extends, "onResponderTerminationRequest", this.touchableHandleResponderTerminationRequest), babelHelpers.defineProperty(_babelHelpers$extends, "onResponderGrant", this.touchableHandleResponderGrant), babelHelpers.defineProperty(_babelHelpers$extends, "onResponderMove", this._handleResponderMove), babelHelpers.defineProperty(_babelHelpers$extends, "onResponderRelease", this.touchableHandleResponderRelease), babelHelpers.defineProperty(_babelHelpers$extends, "onResponderTerminate", this.touchableHandleResponderTerminate), _babelHelpers$extends));
      return React.cloneElement(child, childProps);
    }
  });
  module.exports = TouchableNativeFeedback;
},230,[105,171,24,74,223,231,158,213,233,193],"TouchableNativeFeedback");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EdgeInsetsPropType = require(_dependencyMap[0], 'EdgeInsetsPropType');

  var React = require(_dependencyMap[1], 'React');

  var PropTypes = require(_dependencyMap[2], 'prop-types');

  var TimerMixin = require(_dependencyMap[3], 'react-timer-mixin');

  var Touchable = require(_dependencyMap[4], 'Touchable');

  var createReactClass = require(_dependencyMap[5], 'create-react-class');

  var ensurePositiveDelayProps = require(_dependencyMap[6], 'ensurePositiveDelayProps');

  var warning = require(_dependencyMap[7], 'fbjs/lib/warning');

  var _require = require(_dependencyMap[8], 'ViewAccessibility'),
      AccessibilityComponentTypes = _require.AccessibilityComponentTypes,
      AccessibilityTraits = _require.AccessibilityTraits;

  var PRESS_RETENTION_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var TouchableWithoutFeedback = createReactClass({
    displayName: 'TouchableWithoutFeedback',
    mixins: [TimerMixin, Touchable.Mixin],
    propTypes: {
      accessible: PropTypes.bool,
      accessibilityComponentType: PropTypes.oneOf(AccessibilityComponentTypes),
      accessibilityTraits: PropTypes.oneOfType([PropTypes.oneOf(AccessibilityTraits), PropTypes.arrayOf(PropTypes.oneOf(AccessibilityTraits))]),
      disabled: PropTypes.bool,
      onPress: PropTypes.func,
      onPressIn: PropTypes.func,
      onPressOut: PropTypes.func,
      onLayout: PropTypes.func,
      onLongPress: PropTypes.func,
      delayPressIn: PropTypes.number,
      delayPressOut: PropTypes.number,
      delayLongPress: PropTypes.number,
      pressRetentionOffset: EdgeInsetsPropType,
      hitSlop: EdgeInsetsPropType
    },
    getInitialState: function getInitialState() {
      return this.touchableGetInitialState();
    },
    componentDidMount: function componentDidMount() {
      ensurePositiveDelayProps(this.props);
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      ensurePositiveDelayProps(nextProps);
    },
    touchableHandlePress: function touchableHandlePress(e) {
      this.props.onPress && this.props.onPress(e);
    },
    touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
      this.props.onPressIn && this.props.onPressIn(e);
    },
    touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
      this.props.onPressOut && this.props.onPressOut(e);
    },
    touchableHandleLongPress: function touchableHandleLongPress(e) {
      this.props.onLongPress && this.props.onLongPress(e);
    },
    touchableGetPressRectOffset: function touchableGetPressRectOffset() {
      return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
    },
    touchableGetHitSlop: function touchableGetHitSlop() {
      return this.props.hitSlop;
    },
    touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
      return this.props.delayPressIn || 0;
    },
    touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
      return this.props.delayLongPress === 0 ? 0 : this.props.delayLongPress || 500;
    },
    touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
      return this.props.delayPressOut || 0;
    },
    render: function render() {
      var child = React.Children.only(this.props.children);
      var children = child.props.children;
      warning(!child.type || child.type.displayName !== 'Text', 'TouchableWithoutFeedback does not work well with Text children. Wrap children in a View instead. See ' + (child._owner && child._owner.getName && child._owner.getName() || '<unknown>'));

      if (Touchable.TOUCH_TARGET_DEBUG && child.type && child.type.displayName === 'View') {
        children = React.Children.toArray(children);
        children.push(Touchable.renderDebugView({
          color: 'red',
          hitSlop: this.props.hitSlop
        }));
      }

      var style = Touchable.TOUCH_TARGET_DEBUG && child.type && child.type.displayName === 'Text' ? [child.props.style, {
        color: 'red'
      }] : child.props.style;
      return React.cloneElement(child, {
        accessible: this.props.accessible !== false,
        accessibilityLabel: this.props.accessibilityLabel,
        accessibilityComponentType: this.props.accessibilityComponentType,
        accessibilityTraits: this.props.accessibilityTraits,
        nativeID: this.props.nativeID,
        testID: this.props.testID,
        onLayout: this.props.onLayout,
        hitSlop: this.props.hitSlop,
        onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
        onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
        onResponderGrant: this.touchableHandleResponderGrant,
        onResponderMove: this.touchableHandleResponderMove,
        onResponderRelease: this.touchableHandleResponderRelease,
        onResponderTerminate: this.touchableHandleResponderTerminate,
        style: style,
        children: children
      });
    }
  });
  module.exports = TouchableWithoutFeedback;
},231,[173,171,24,232,223,213,233,19,185],"TouchableWithoutFeedback");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var GLOBAL = typeof window === 'undefined' ? global : window;

  var setter = function setter(_setter, _clearer, array) {
    return function (callback, delta) {
      var id = _setter(function () {
        _clearer.call(this, id);

        callback.apply(this, arguments);
      }.bind(this), delta);

      if (!this[array]) {
        this[array] = [id];
      } else {
        this[array].push(id);
      }

      return id;
    };
  };

  var clearer = function clearer(_clearer, array) {
    return function (id) {
      if (this[array]) {
        var index = this[array].indexOf(id);

        if (index !== -1) {
          this[array].splice(index, 1);
        }
      }

      _clearer(id);
    };
  };

  var _timeouts = 'TimerMixin_timeouts';

  var _clearTimeout = clearer(GLOBAL.clearTimeout, _timeouts);

  var _setTimeout = setter(GLOBAL.setTimeout, _clearTimeout, _timeouts);

  var _intervals = 'TimerMixin_intervals';

  var _clearInterval = clearer(GLOBAL.clearInterval, _intervals);

  var _setInterval = setter(GLOBAL.setInterval, function () {}, _intervals);

  var _immediates = 'TimerMixin_immediates';

  var _clearImmediate = clearer(GLOBAL.clearImmediate, _immediates);

  var _setImmediate = setter(GLOBAL.setImmediate, _clearImmediate, _immediates);

  var _rafs = 'TimerMixin_rafs';

  var _cancelAnimationFrame = clearer(GLOBAL.cancelAnimationFrame, _rafs);

  var _requestAnimationFrame = setter(GLOBAL.requestAnimationFrame, _cancelAnimationFrame, _rafs);

  var TimerMixin = {
    componentWillUnmount: function componentWillUnmount() {
      this[_timeouts] && this[_timeouts].forEach(function (id) {
        GLOBAL.clearTimeout(id);
      });
      this[_timeouts] = null;
      this[_intervals] && this[_intervals].forEach(function (id) {
        GLOBAL.clearInterval(id);
      });
      this[_intervals] = null;
      this[_immediates] && this[_immediates].forEach(function (id) {
        GLOBAL.clearImmediate(id);
      });
      this[_immediates] = null;
      this[_rafs] && this[_rafs].forEach(function (id) {
        GLOBAL.cancelAnimationFrame(id);
      });
      this[_rafs] = null;
    },
    setTimeout: _setTimeout,
    clearTimeout: _clearTimeout,
    setInterval: _setInterval,
    clearInterval: _clearInterval,
    setImmediate: _setImmediate,
    clearImmediate: _clearImmediate,
    requestAnimationFrame: _requestAnimationFrame,
    cancelAnimationFrame: _cancelAnimationFrame
  };
  module.exports = TimerMixin;
},232,[],"react-timer-mixin/TimerMixin.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var ensurePositiveDelayProps = function ensurePositiveDelayProps(props) {
    invariant(!(props.delayPressIn < 0 || props.delayPressOut < 0 || props.delayLongPress < 0), 'Touchable components cannot have negative delay properties');
  };

  module.exports = ensurePositiveDelayProps;
},233,[18],"ensurePositiveDelayProps");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.js";

  var Animated = require(_dependencyMap[0], 'Animated');

  var Easing = require(_dependencyMap[1], 'Easing');

  var NativeMethodsMixin = require(_dependencyMap[2], 'NativeMethodsMixin');

  var React = require(_dependencyMap[3], 'React');

  var PropTypes = require(_dependencyMap[4], 'prop-types');

  var TimerMixin = require(_dependencyMap[5], 'react-timer-mixin');

  var Touchable = require(_dependencyMap[6], 'Touchable');

  var TouchableWithoutFeedback = require(_dependencyMap[7], 'TouchableWithoutFeedback');

  var createReactClass = require(_dependencyMap[8], 'create-react-class');

  var ensurePositiveDelayProps = require(_dependencyMap[9], 'ensurePositiveDelayProps');

  var flattenStyle = require(_dependencyMap[10], 'flattenStyle');

  var PRESS_RETENTION_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var TouchableOpacity = createReactClass({
    displayName: 'TouchableOpacity',
    mixins: [TimerMixin, Touchable.Mixin, NativeMethodsMixin],
    propTypes: babelHelpers.extends({}, TouchableWithoutFeedback.propTypes, {
      activeOpacity: PropTypes.number,
      hasTVPreferredFocus: PropTypes.bool,
      tvParallaxProperties: PropTypes.object
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        activeOpacity: 0.2
      };
    },
    getInitialState: function getInitialState() {
      return babelHelpers.extends({}, this.touchableGetInitialState(), {
        anim: new Animated.Value(this._getChildStyleOpacityWithDefault())
      });
    },
    componentDidMount: function componentDidMount() {
      ensurePositiveDelayProps(this.props);
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      ensurePositiveDelayProps(nextProps);
    },
    setOpacityTo: function setOpacityTo(value, duration) {
      Animated.timing(this.state.anim, {
        toValue: value,
        duration: duration,
        easing: Easing.inOut(Easing.quad),
        useNativeDriver: true
      }).start();
    },
    touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
      if (e.dispatchConfig.registrationName === 'onResponderGrant') {
        this._opacityActive(0);
      } else {
        this._opacityActive(150);
      }

      this.props.onPressIn && this.props.onPressIn(e);
    },
    touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
      this._opacityInactive(250);

      this.props.onPressOut && this.props.onPressOut(e);
    },
    touchableHandlePress: function touchableHandlePress(e) {
      this.props.onPress && this.props.onPress(e);
    },
    touchableHandleLongPress: function touchableHandleLongPress(e) {
      this.props.onLongPress && this.props.onLongPress(e);
    },
    touchableGetPressRectOffset: function touchableGetPressRectOffset() {
      return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
    },
    touchableGetHitSlop: function touchableGetHitSlop() {
      return this.props.hitSlop;
    },
    touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
      return this.props.delayPressIn || 0;
    },
    touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
      return this.props.delayLongPress === 0 ? 0 : this.props.delayLongPress || 500;
    },
    touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
      return this.props.delayPressOut;
    },
    _opacityActive: function _opacityActive(duration) {
      this.setOpacityTo(this.props.activeOpacity, duration);
    },
    _opacityInactive: function _opacityInactive(duration) {
      this.setOpacityTo(this._getChildStyleOpacityWithDefault(), duration);
    },
    _getChildStyleOpacityWithDefault: function _getChildStyleOpacityWithDefault() {
      var childStyle = flattenStyle(this.props.style) || {};
      return childStyle.opacity == undefined ? 1 : childStyle.opacity;
    },
    render: function render() {
      return React.createElement(
        Animated.View,
        {
          accessible: this.props.accessible !== false,
          accessibilityLabel: this.props.accessibilityLabel,
          accessibilityComponentType: this.props.accessibilityComponentType,
          accessibilityTraits: this.props.accessibilityTraits,
          style: [this.props.style, {
            opacity: this.state.anim
          }],
          nativeID: this.props.nativeID,
          testID: this.props.testID,
          onLayout: this.props.onLayout,
          isTVSelectable: true,
          hasTVPreferredFocus: this.props.hasTVPreferredFocus,
          tvParallaxProperties: this.props.tvParallaxProperties,
          hitSlop: this.props.hitSlop,
          onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
          onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
          onResponderGrant: this.touchableHandleResponderGrant,
          onResponderMove: this.touchableHandleResponderMove,
          onResponderRelease: this.touchableHandleResponderRelease,
          onResponderTerminate: this.touchableHandleResponderTerminate,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 245
          }
        },
        this.props.children,
        Touchable.renderDebugView({
          color: 'cyan',
          hitSlop: this.props.hitSlop
        })
      );
    }
  });
  module.exports = TouchableOpacity;
},234,[235,260,169,171,24,232,223,231,213,233,152],"TouchableOpacity");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedImplementation = require(_dependencyMap[0], 'AnimatedImplementation');

  var Image = require(_dependencyMap[1], 'Image');

  var Text = require(_dependencyMap[2], 'Text');

  var View = require(_dependencyMap[3], 'View');

  var AnimatedScrollView = void 0;
  var Animated = {
    View: AnimatedImplementation.createAnimatedComponent(View),
    Text: AnimatedImplementation.createAnimatedComponent(Text),
    Image: AnimatedImplementation.createAnimatedComponent(Image),

    get ScrollView() {
      if (!AnimatedScrollView) {
        AnimatedScrollView = AnimatedImplementation.createAnimatedComponent(require(_dependencyMap[4], 'ScrollView'));
      }

      return AnimatedScrollView;
    }

  };
  babelHelpers.extends(Animated, AnimatedImplementation);
  module.exports = Animated;
},235,[236,263,222,211,265],"Animated");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], './AnimatedEvent'),
      AnimatedEvent = _require.AnimatedEvent,
      attachNativeEvent = _require.attachNativeEvent;

  var AnimatedAddition = require(_dependencyMap[1], './nodes/AnimatedAddition');

  var AnimatedDiffClamp = require(_dependencyMap[2], './nodes/AnimatedDiffClamp');

  var AnimatedDivision = require(_dependencyMap[3], './nodes/AnimatedDivision');

  var AnimatedInterpolation = require(_dependencyMap[4], './nodes/AnimatedInterpolation');

  var AnimatedModulo = require(_dependencyMap[5], './nodes/AnimatedModulo');

  var AnimatedMultiplication = require(_dependencyMap[6], './nodes/AnimatedMultiplication');

  var AnimatedNode = require(_dependencyMap[7], './nodes/AnimatedNode');

  var AnimatedProps = require(_dependencyMap[8], './nodes/AnimatedProps');

  var AnimatedTracking = require(_dependencyMap[9], './nodes/AnimatedTracking');

  var AnimatedValue = require(_dependencyMap[10], './nodes/AnimatedValue');

  var AnimatedValueXY = require(_dependencyMap[11], './nodes/AnimatedValueXY');

  var DecayAnimation = require(_dependencyMap[12], './animations/DecayAnimation');

  var SpringAnimation = require(_dependencyMap[13], './animations/SpringAnimation');

  var TimingAnimation = require(_dependencyMap[14], './animations/TimingAnimation');

  var createAnimatedComponent = require(_dependencyMap[15], './createAnimatedComponent');

  var add = function add(a, b) {
    return new AnimatedAddition(a, b);
  };

  var divide = function divide(a, b) {
    return new AnimatedDivision(a, b);
  };

  var multiply = function multiply(a, b) {
    return new AnimatedMultiplication(a, b);
  };

  var modulo = function modulo(a, modulus) {
    return new AnimatedModulo(a, modulus);
  };

  var diffClamp = function diffClamp(a, min, max) {
    return new AnimatedDiffClamp(a, min, max);
  };

  var _combineCallbacks = function _combineCallbacks(callback, config) {
    if (callback && config.onComplete) {
      return function () {
        config.onComplete && config.onComplete.apply(config, arguments);
        callback && callback.apply(undefined, arguments);
      };
    } else {
      return callback || config.onComplete;
    }
  };

  var maybeVectorAnim = function maybeVectorAnim(value, config, anim) {
    if (value instanceof AnimatedValueXY) {
      var configX = babelHelpers.extends({}, config);
      var configY = babelHelpers.extends({}, config);

      for (var key in config) {
        var _config$key = config[key],
            x = _config$key.x,
            y = _config$key.y;

        if (x !== undefined && y !== undefined) {
          configX[key] = x;
          configY[key] = y;
        }
      }

      var aX = anim(value.x, configX);
      var aY = anim(value.y, configY);
      return parallel([aX, aY], {
        stopTogether: false
      });
    }

    return null;
  };

  var spring = function spring(value, config) {
    var start = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();

      if (configuration.toValue instanceof AnimatedNode) {
        singleValue.track(new AnimatedTracking(singleValue, configuration.toValue, SpringAnimation, singleConfig, callback));
      } else {
        singleValue.animate(new SpringAnimation(singleConfig), callback);
      }
    };

    return maybeVectorAnim(value, config, spring) || {
      start: function (_start) {
        function start(_x) {
          return _start.apply(this, arguments);
        }

        start.toString = function () {
          return _start.toString();
        };

        return start;
      }(function (callback) {
        start(value, config, callback);
      }),
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = babelHelpers.extends({}, config, {
          iterations: iterations
        });
        start(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };

  var timing = function timing(value, config) {
    var start = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();

      if (configuration.toValue instanceof AnimatedNode) {
        singleValue.track(new AnimatedTracking(singleValue, configuration.toValue, TimingAnimation, singleConfig, callback));
      } else {
        singleValue.animate(new TimingAnimation(singleConfig), callback);
      }
    };

    return maybeVectorAnim(value, config, timing) || {
      start: function (_start2) {
        function start(_x2) {
          return _start2.apply(this, arguments);
        }

        start.toString = function () {
          return _start2.toString();
        };

        return start;
      }(function (callback) {
        start(value, config, callback);
      }),
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = babelHelpers.extends({}, config, {
          iterations: iterations
        });
        start(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };

  var decay = function decay(value, config) {
    var start = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      singleValue.animate(new DecayAnimation(singleConfig), callback);
    };

    return maybeVectorAnim(value, config, decay) || {
      start: function (_start3) {
        function start(_x3) {
          return _start3.apply(this, arguments);
        }

        start.toString = function () {
          return _start3.toString();
        };

        return start;
      }(function (callback) {
        start(value, config, callback);
      }),
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = babelHelpers.extends({}, config, {
          iterations: iterations
        });
        start(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };

  var sequence = function sequence(animations) {
    var current = 0;
    return {
      start: function start(callback) {
        var onComplete = function onComplete(result) {
          if (!result.finished) {
            callback && callback(result);
            return;
          }

          current++;

          if (current === animations.length) {
            callback && callback(result);
            return;
          }

          animations[current].start(onComplete);
        };

        if (animations.length === 0) {
          callback && callback({
            finished: true
          });
        } else {
          animations[current].start(onComplete);
        }
      },
      stop: function stop() {
        if (current < animations.length) {
          animations[current].stop();
        }
      },
      reset: function reset() {
        animations.forEach(function (animation, idx) {
          if (idx <= current) {
            animation.reset();
          }
        });
        current = 0;
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.sequence animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
  };

  var parallel = function parallel(animations, config) {
    var doneCount = 0;
    var hasEnded = {};
    var stopTogether = !(config && config.stopTogether === false);
    var result = {
      start: function start(callback) {
        if (doneCount === animations.length) {
          callback && callback({
            finished: true
          });
          return;
        }

        animations.forEach(function (animation, idx) {
          var cb = function cb(endResult) {
            hasEnded[idx] = true;
            doneCount++;

            if (doneCount === animations.length) {
              doneCount = 0;
              callback && callback(endResult);
              return;
            }

            if (!endResult.finished && stopTogether) {
              result.stop();
            }
          };

          if (!animation) {
            cb({
              finished: true
            });
          } else {
            animation.start(cb);
          }
        });
      },
      stop: function stop() {
        animations.forEach(function (animation, idx) {
          !hasEnded[idx] && animation.stop();
          hasEnded[idx] = true;
        });
      },
      reset: function reset() {
        animations.forEach(function (animation, idx) {
          animation.reset();
          hasEnded[idx] = false;
          doneCount = 0;
        });
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.parallel animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
    return result;
  };

  var delay = function delay(time) {
    return timing(new AnimatedValue(0), {
      toValue: 0,
      delay: time,
      duration: 0
    });
  };

  var stagger = function stagger(time, animations) {
    return parallel(animations.map(function (animation, i) {
      return sequence([delay(time * i), animation]);
    }));
  };

  var loop = function loop(animation) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$iterations = _ref.iterations,
        iterations = _ref$iterations === undefined ? -1 : _ref$iterations;

    var isFinished = false;
    var iterationsSoFar = 0;
    return {
      start: function start(callback) {
        var restart = function restart() {
          var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            finished: true
          };

          if (isFinished || iterationsSoFar === iterations || result.finished === false) {
            callback && callback(result);
          } else {
            iterationsSoFar++;
            animation.reset();
            animation.start(restart);
          }
        };

        if (!animation || iterations === 0) {
          callback && callback({
            finished: true
          });
        } else {
          if (animation._isUsingNativeDriver()) {
            animation._startNativeLoop(iterations);
          } else {
            restart();
          }
        }
      },
      stop: function stop() {
        isFinished = true;
        animation.stop();
      },
      reset: function reset() {
        iterationsSoFar = 0;
        isFinished = false;
        animation.reset();
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.loop animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return animation._isUsingNativeDriver();
      }
    };
  };

  function forkEvent(event, listener) {
    if (!event) {
      return listener;
    } else if (event instanceof AnimatedEvent) {
      event.__addListener(listener);

      return event;
    } else {
      return function () {
        typeof event === 'function' && event.apply(undefined, arguments);
        listener.apply(undefined, arguments);
      };
    }
  }

  function unforkEvent(event, listener) {
    if (event && event instanceof AnimatedEvent) {
      event.__removeListener(listener);
    }
  }

  var event = function event(argMapping, config) {
    var animatedEvent = new AnimatedEvent(argMapping, config);

    if (animatedEvent.__isNative) {
      return animatedEvent;
    } else {
      return animatedEvent.__getHandler();
    }
  };

  module.exports = {
    Value: AnimatedValue,
    ValueXY: AnimatedValueXY,
    Interpolation: AnimatedInterpolation,
    Node: AnimatedNode,
    decay: decay,
    timing: timing,
    spring: spring,
    add: add,
    divide: divide,
    multiply: multiply,
    modulo: modulo,
    diffClamp: diffClamp,
    delay: delay,
    sequence: sequence,
    parallel: parallel,
    stagger: stagger,
    loop: loop,
    event: event,
    createAnimatedComponent: createAnimatedComponent,
    attachNativeEvent: attachNativeEvent,
    forkEvent: forkEvent,
    unforkEvent: unforkEvent,
    __PropsOnlyForTests: AnimatedProps
  };
},236,[237,245,246,247,239,248,249,240,250,253,238,254,255,257,259,262],"AnimatedImplementation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedValue = require(_dependencyMap[0], './nodes/AnimatedValue');

  var NativeAnimatedHelper = require(_dependencyMap[1], './NativeAnimatedHelper');

  var ReactNative = require(_dependencyMap[2], 'ReactNative');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var _require = require(_dependencyMap[1], './NativeAnimatedHelper'),
      shouldUseNativeDriver = _require.shouldUseNativeDriver;

  function attachNativeEvent(viewRef, eventName, argMapping) {
    var eventMappings = [];

    var traverse = function traverse(value, path) {
      if (value instanceof AnimatedValue) {
        value.__makeNative();

        eventMappings.push({
          nativeEventPath: path,
          animatedValueTag: value.__getNativeTag()
        });
      } else if (typeof value === 'object') {
        for (var _key in value) {
          traverse(value[_key], path.concat(_key));
        }
      }
    };

    invariant(argMapping[0] && argMapping[0].nativeEvent, 'Native driven events only support animated values contained inside `nativeEvent`.');
    traverse(argMapping[0].nativeEvent, []);
    var viewTag = ReactNative.findNodeHandle(viewRef);
    eventMappings.forEach(function (mapping) {
      NativeAnimatedHelper.API.addAnimatedEventToView(viewTag, eventName, mapping);
    });
    return {
      detach: function detach() {
        eventMappings.forEach(function (mapping) {
          NativeAnimatedHelper.API.removeAnimatedEventFromView(viewTag, eventName, mapping.animatedValueTag);
        });
      }
    };
  }

  var AnimatedEvent = function () {
    function AnimatedEvent(argMapping) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      babelHelpers.classCallCheck(this, AnimatedEvent);
      this._listeners = [];
      this._argMapping = argMapping;

      if (config.listener) {
        this.__addListener(config.listener);
      }

      this._callListeners = this._callListeners.bind(this);
      this._attachedEvent = null;
      this.__isNative = shouldUseNativeDriver(config);

      if (__DEV__) {
        this._validateMapping();
      }
    }

    babelHelpers.createClass(AnimatedEvent, [{
      key: "__addListener",
      value: function __addListener(callback) {
        this._listeners.push(callback);
      }
    }, {
      key: "__removeListener",
      value: function __removeListener(callback) {
        this._listeners = this._listeners.filter(function (listener) {
          return listener !== callback;
        });
      }
    }, {
      key: "__attach",
      value: function __attach(viewRef, eventName) {
        invariant(this.__isNative, 'Only native driven events need to be attached.');
        this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
      }
    }, {
      key: "__detach",
      value: function __detach(viewTag, eventName) {
        invariant(this.__isNative, 'Only native driven events need to be detached.');
        this._attachedEvent && this._attachedEvent.detach();
      }
    }, {
      key: "__getHandler",
      value: function __getHandler() {
        var _this = this;

        if (this.__isNative) {
          return this._callListeners;
        }

        return function () {
          for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            args[_key2] = arguments[_key2];
          }

          var traverse = function traverse(recMapping, recEvt, key) {
            if (typeof recEvt === 'number' && recMapping instanceof AnimatedValue) {
              recMapping.setValue(recEvt);
            } else if (typeof recMapping === 'object') {
              for (var mappingKey in recMapping) {
                traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
              }
            }
          };

          if (!_this.__isNative) {
            _this._argMapping.forEach(function (mapping, idx) {
              traverse(mapping, args[idx], 'arg' + idx);
            });
          }

          _this._callListeners.apply(_this, babelHelpers.toConsumableArray(args));
        };
      }
    }, {
      key: "_callListeners",
      value: function _callListeners() {
        for (var _len2 = arguments.length, args = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
          args[_key3] = arguments[_key3];
        }

        this._listeners.forEach(function (listener) {
          return listener.apply(undefined, args);
        });
      }
    }, {
      key: "_validateMapping",
      value: function _validateMapping() {
        var traverse = function traverse(recMapping, recEvt, key) {
          if (typeof recEvt === 'number') {
            invariant(recMapping instanceof AnimatedValue, 'Bad mapping of type ' + typeof recMapping + ' for key ' + key + ', event value must map to AnimatedValue');
            return;
          }

          invariant(typeof recMapping === 'object', 'Bad mapping of type ' + typeof recMapping + ' for key ' + key);
          invariant(typeof recEvt === 'object', 'Bad event of type ' + typeof recEvt + ' for key ' + key);

          for (var mappingKey in recMapping) {
            traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
          }
        };
      }
    }]);
    return AnimatedEvent;
  }();

  module.exports = {
    AnimatedEvent: AnimatedEvent,
    attachNativeEvent: attachNativeEvent
  };
},237,[238,241,74,18],"AnimatedEvent");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedInterpolation = require(_dependencyMap[0], './AnimatedInterpolation');

  var AnimatedNode = require(_dependencyMap[1], './AnimatedNode');

  var AnimatedWithChildren = require(_dependencyMap[2], './AnimatedWithChildren');

  var InteractionManager = require(_dependencyMap[3], 'InteractionManager');

  var NativeAnimatedHelper = require(_dependencyMap[4], '../NativeAnimatedHelper');

  var NativeAnimatedAPI = NativeAnimatedHelper.API;
  var _uniqueId = 1;

  function _flush(rootNode) {
    var animatedStyles = new Set();

    function findAnimatedStyles(node) {
      if (typeof node.update === 'function') {
        animatedStyles.add(node);
      } else {
        node.__getChildren().forEach(findAnimatedStyles);
      }
    }

    findAnimatedStyles(rootNode);
    animatedStyles.forEach(function (animatedStyle) {
      return animatedStyle.update();
    });
  }

  var AnimatedValue = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedValue, _AnimatedWithChildren);

    function AnimatedValue(value) {
      babelHelpers.classCallCheck(this, AnimatedValue);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedValue.__proto__ || Object.getPrototypeOf(AnimatedValue)).call(this));

      _this._startingValue = _this._value = value;
      _this._offset = 0;
      _this._animation = null;
      _this._listeners = {};
      return _this;
    }

    babelHelpers.createClass(AnimatedValue, [{
      key: "__detach",
      value: function __detach() {
        this.stopAnimation();
        babelHelpers.get(AnimatedValue.prototype.__proto__ || Object.getPrototypeOf(AnimatedValue.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._value + this._offset;
      }
    }, {
      key: "__makeNative",
      value: function __makeNative() {
        babelHelpers.get(AnimatedValue.prototype.__proto__ || Object.getPrototypeOf(AnimatedValue.prototype), "__makeNative", this).call(this);

        if (Object.keys(this._listeners).length) {
          this._startListeningToNativeValueUpdates();
        }
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        if (this._animation) {
          this._animation.stop();

          this._animation = null;
        }

        this._updateValue(value, !this.__isNative);

        if (this.__isNative) {
          NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value);
        }
      }
    }, {
      key: "setOffset",
      value: function setOffset(offset) {
        this._offset = offset;

        if (this.__isNative) {
          NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset);
        }
      }
    }, {
      key: "flattenOffset",
      value: function flattenOffset() {
        this._value += this._offset;
        this._offset = 0;

        if (this.__isNative) {
          NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
        }
      }
    }, {
      key: "extractOffset",
      value: function extractOffset() {
        this._offset += this._value;
        this._value = 0;

        if (this.__isNative) {
          NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
        }
      }
    }, {
      key: "addListener",
      value: function addListener(callback) {
        var id = String(_uniqueId++);
        this._listeners[id] = callback;

        if (this.__isNative) {
          this._startListeningToNativeValueUpdates();
        }

        return id;
      }
    }, {
      key: "removeListener",
      value: function removeListener(id) {
        delete this._listeners[id];

        if (this.__isNative && Object.keys(this._listeners).length === 0) {
          this._stopListeningForNativeValueUpdates();
        }
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        this._listeners = {};

        if (this.__isNative) {
          this._stopListeningForNativeValueUpdates();
        }
      }
    }, {
      key: "_startListeningToNativeValueUpdates",
      value: function _startListeningToNativeValueUpdates() {
        var _this2 = this;

        if (this.__nativeAnimatedValueListener) {
          return;
        }

        NativeAnimatedAPI.startListeningToAnimatedNodeValue(this.__getNativeTag());
        this.__nativeAnimatedValueListener = NativeAnimatedHelper.nativeEventEmitter.addListener('onAnimatedValueUpdate', function (data) {
          if (data.tag !== _this2.__getNativeTag()) {
            return;
          }

          _this2._updateValue(data.value, false);
        });
      }
    }, {
      key: "_stopListeningForNativeValueUpdates",
      value: function _stopListeningForNativeValueUpdates() {
        if (!this.__nativeAnimatedValueListener) {
          return;
        }

        this.__nativeAnimatedValueListener.remove();

        this.__nativeAnimatedValueListener = null;
        NativeAnimatedAPI.stopListeningToAnimatedNodeValue(this.__getNativeTag());
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation(callback) {
        this.stopTracking();
        this._animation && this._animation.stop();
        this._animation = null;
        callback && callback(this.__getValue());
      }
    }, {
      key: "resetAnimation",
      value: function resetAnimation(callback) {
        this.stopAnimation(callback);
        this._value = this._startingValue;
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "animate",
      value: function animate(animation, callback) {
        var _this3 = this;

        var handle = null;

        if (animation.__isInteraction) {
          handle = InteractionManager.createInteractionHandle();
        }

        var previousAnimation = this._animation;
        this._animation && this._animation.stop();
        this._animation = animation;
        animation.start(this._value, function (value) {
          _this3._updateValue(value, true);
        }, function (result) {
          _this3._animation = null;

          if (handle !== null) {
            InteractionManager.clearInteractionHandle(handle);
          }

          callback && callback(result);
        }, previousAnimation, this);
      }
    }, {
      key: "stopTracking",
      value: function stopTracking() {
        this._tracking && this._tracking.__detach();
        this._tracking = null;
      }
    }, {
      key: "track",
      value: function track(tracking) {
        this.stopTracking();
        this._tracking = tracking;
      }
    }, {
      key: "_updateValue",
      value: function _updateValue(value, flush) {
        this._value = value;

        if (flush) {
          _flush(this);
        }

        for (var _key in this._listeners) {
          this._listeners[_key]({
            value: this.__getValue()
          });
        }
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'value',
          value: this._value,
          offset: this._offset
        };
      }
    }]);
    return AnimatedValue;
  }(AnimatedWithChildren);

  module.exports = AnimatedValue;
},238,[239,240,242,243,241],"AnimatedValue");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedNode = require(_dependencyMap[0], './AnimatedNode');

  var AnimatedWithChildren = require(_dependencyMap[1], './AnimatedWithChildren');

  var NativeAnimatedHelper = require(_dependencyMap[2], '../NativeAnimatedHelper');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var normalizeColor = require(_dependencyMap[4], 'normalizeColor');

  var linear = function linear(t) {
    return t;
  };

  function createInterpolation(config) {
    if (config.outputRange && typeof config.outputRange[0] === 'string') {
      return createInterpolationFromStringOutputRange(config);
    }

    var outputRange = config.outputRange;
    checkInfiniteRange('outputRange', outputRange);
    var inputRange = config.inputRange;
    checkInfiniteRange('inputRange', inputRange);
    checkValidInputRange(inputRange);
    invariant(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');
    var easing = config.easing || linear;
    var extrapolateLeft = 'extend';

    if (config.extrapolateLeft !== undefined) {
      extrapolateLeft = config.extrapolateLeft;
    } else if (config.extrapolate !== undefined) {
      extrapolateLeft = config.extrapolate;
    }

    var extrapolateRight = 'extend';

    if (config.extrapolateRight !== undefined) {
      extrapolateRight = config.extrapolateRight;
    } else if (config.extrapolate !== undefined) {
      extrapolateRight = config.extrapolate;
    }

    return function (input) {
      invariant(typeof input === 'number', 'Cannot interpolation an input which is not a number');
      var range = findRange(input, inputRange);
      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
    };
  }

  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
    var result = input;

    if (result < inputMin) {
      if (extrapolateLeft === 'identity') {
        return result;
      } else if (extrapolateLeft === 'clamp') {
        result = inputMin;
      } else if (extrapolateLeft === 'extend') {}
    }

    if (result > inputMax) {
      if (extrapolateRight === 'identity') {
        return result;
      } else if (extrapolateRight === 'clamp') {
        result = inputMax;
      } else if (extrapolateRight === 'extend') {}
    }

    if (outputMin === outputMax) {
      return outputMin;
    }

    if (inputMin === inputMax) {
      if (input <= inputMin) {
        return outputMin;
      }

      return outputMax;
    }

    if (inputMin === -Infinity) {
      result = -result;
    } else if (inputMax === Infinity) {
      result = result - inputMin;
    } else {
      result = (result - inputMin) / (inputMax - inputMin);
    }

    result = easing(result);

    if (outputMin === -Infinity) {
      result = -result;
    } else if (outputMax === Infinity) {
      result = result + outputMin;
    } else {
      result = result * (outputMax - outputMin) + outputMin;
    }

    return result;
  }

  function colorToRgba(input) {
    var int32Color = normalizeColor(input);

    if (int32Color === null) {
      return input;
    }

    int32Color = int32Color || 0;
    var r = (int32Color & 0xff000000) >>> 24;
    var g = (int32Color & 0x00ff0000) >>> 16;
    var b = (int32Color & 0x0000ff00) >>> 8;
    var a = (int32Color & 0x000000ff) / 255;
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
  }

  var stringShapeRegex = /[0-9\.-]+/g;

  function createInterpolationFromStringOutputRange(config) {
    var outputRange = config.outputRange;
    invariant(outputRange.length >= 2, 'Bad output range');
    outputRange = outputRange.map(colorToRgba);
    checkPattern(outputRange);
    var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {
      return [];
    });
    outputRange.forEach(function (value) {
      value.match(stringShapeRegex).forEach(function (number, i) {
        outputRanges[i].push(+number);
      });
    });
    var interpolations = outputRange[0].match(stringShapeRegex).map(function (value, i) {
      return createInterpolation(babelHelpers.extends({}, config, {
        outputRange: outputRanges[i]
      }));
    });
    var shouldRound = isRgbOrRgba(outputRange[0]);
    return function (input) {
      var i = 0;
      return outputRange[0].replace(stringShapeRegex, function () {
        var val = +interpolations[i++](input);
        var rounded = shouldRound && i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
        return String(rounded);
      });
    };
  }

  function isRgbOrRgba(range) {
    return typeof range === 'string' && range.startsWith('rgb');
  }

  function checkPattern(arr) {
    var pattern = arr[0].replace(stringShapeRegex, '');

    for (var i = 1; i < arr.length; ++i) {
      invariant(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
    }
  }

  function findRange(input, inputRange) {
    var i = void 0;

    for (i = 1; i < inputRange.length - 1; ++i) {
      if (inputRange[i] >= input) {
        break;
      }
    }

    return i - 1;
  }

  function checkValidInputRange(arr) {
    invariant(arr.length >= 2, 'inputRange must have at least 2 elements');

    for (var i = 1; i < arr.length; ++i) {
      invariant(arr[i] >= arr[i - 1], 'inputRange must be monotonically increasing ' + arr);
    }
  }

  function checkInfiniteRange(name, arr) {
    invariant(arr.length >= 2, name + ' must have at least 2 elements');
    invariant(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity, name + 'cannot be ]-infinity;+infinity[ ' + arr);
  }

  var AnimatedInterpolation = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedInterpolation, _AnimatedWithChildren);

    function AnimatedInterpolation(parent, config) {
      babelHelpers.classCallCheck(this, AnimatedInterpolation);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedInterpolation.__proto__ || Object.getPrototypeOf(AnimatedInterpolation)).call(this));

      _this._parent = parent;
      _this._config = config;
      _this._interpolation = createInterpolation(config);
      return _this;
    }

    babelHelpers.createClass(AnimatedInterpolation, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._parent.__makeNative();

        babelHelpers.get(AnimatedInterpolation.prototype.__proto__ || Object.getPrototypeOf(AnimatedInterpolation.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        var parentValue = this._parent.__getValue();

        invariant(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');
        return this._interpolation(parentValue);
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._parent.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._parent.__removeChild(this);

        babelHelpers.get(AnimatedInterpolation.prototype.__proto__ || Object.getPrototypeOf(AnimatedInterpolation.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__transformDataType",
      value: function __transformDataType(range) {
        return range.map(function (value) {
          if (typeof value !== 'string') {
            return value;
          }

          if (/deg$/.test(value)) {
            var degrees = parseFloat(value) || 0;
            var radians = degrees * Math.PI / 180.0;
            return radians;
          } else {
            return parseFloat(value) || 0;
          }
        });
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        if (__DEV__) {
          NativeAnimatedHelper.validateInterpolation(this._config);
        }

        return {
          inputRange: this._config.inputRange,
          outputRange: this.__transformDataType(this._config.outputRange),
          extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || 'extend',
          extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || 'extend',
          type: 'interpolation'
        };
      }
    }]);
    return AnimatedInterpolation;
  }(AnimatedWithChildren);

  AnimatedInterpolation.__createInterpolation = createInterpolation;
  module.exports = AnimatedInterpolation;
},239,[240,242,241,18,168],"AnimatedInterpolation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeAnimatedHelper = require(_dependencyMap[0], '../NativeAnimatedHelper');

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  var AnimatedNode = function () {
    function AnimatedNode() {
      babelHelpers.classCallCheck(this, AnimatedNode);
    }

    babelHelpers.createClass(AnimatedNode, [{
      key: "__attach",
      value: function __attach() {}
    }, {
      key: "__detach",
      value: function __detach() {
        if (this.__isNative && this.__nativeTag != null) {
          NativeAnimatedHelper.API.dropAnimatedNode(this.__nativeTag);
          this.__nativeTag = undefined;
        }
      }
    }, {
      key: "__getValue",
      value: function __getValue() {}
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        return this.__getValue();
      }
    }, {
      key: "__addChild",
      value: function __addChild(child) {}
    }, {
      key: "__removeChild",
      value: function __removeChild(child) {}
    }, {
      key: "__getChildren",
      value: function __getChildren() {
        return [];
      }
    }, {
      key: "__makeNative",
      value: function __makeNative() {
        if (!this.__isNative) {
          throw new Error('This node cannot be made a "native" animated node');
        }
      }
    }, {
      key: "__getNativeTag",
      value: function __getNativeTag() {
        NativeAnimatedHelper.assertNativeAnimatedModule();
        invariant(this.__isNative, 'Attempt to get native tag from node not marked as "native"');

        if (this.__nativeTag == null) {
          var nativeTag = NativeAnimatedHelper.generateNewNodeTag();
          NativeAnimatedHelper.API.createAnimatedNode(nativeTag, this.__getNativeConfig());
          this.__nativeTag = nativeTag;
        }

        return this.__nativeTag;
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        throw new Error('This JS animated node type cannot be used as native animated node');
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.__getValue();
      }
    }]);
    return AnimatedNode;
  }();

  module.exports = AnimatedNode;
},240,[241,18],"AnimatedNode");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeAnimatedModule = require(_dependencyMap[0], 'NativeModules').NativeAnimatedModule;

  var NativeEventEmitter = require(_dependencyMap[1], 'NativeEventEmitter');

  var invariant = require(_dependencyMap[2], 'fbjs/lib/invariant');

  var __nativeAnimatedNodeTagCount = 1;
  var __nativeAnimationIdCount = 1;
  var nativeEventEmitter = void 0;
  var API = {
    createAnimatedNode: function createAnimatedNode(tag, config) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.createAnimatedNode(tag, config);
    },
    startListeningToAnimatedNodeValue: function startListeningToAnimatedNodeValue(tag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.startListeningToAnimatedNodeValue(tag);
    },
    stopListeningToAnimatedNodeValue: function stopListeningToAnimatedNodeValue(tag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.stopListeningToAnimatedNodeValue(tag);
    },
    connectAnimatedNodes: function connectAnimatedNodes(parentTag, childTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.connectAnimatedNodes(parentTag, childTag);
    },
    disconnectAnimatedNodes: function disconnectAnimatedNodes(parentTag, childTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.disconnectAnimatedNodes(parentTag, childTag);
    },
    startAnimatingNode: function startAnimatingNode(animationId, nodeTag, config, endCallback) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.startAnimatingNode(animationId, nodeTag, config, endCallback);
    },
    stopAnimation: function stopAnimation(animationId) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.stopAnimation(animationId);
    },
    setAnimatedNodeValue: function setAnimatedNodeValue(nodeTag, value) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.setAnimatedNodeValue(nodeTag, value);
    },
    setAnimatedNodeOffset: function setAnimatedNodeOffset(nodeTag, offset) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.setAnimatedNodeOffset(nodeTag, offset);
    },
    flattenAnimatedNodeOffset: function flattenAnimatedNodeOffset(nodeTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.flattenAnimatedNodeOffset(nodeTag);
    },
    extractAnimatedNodeOffset: function extractAnimatedNodeOffset(nodeTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.extractAnimatedNodeOffset(nodeTag);
    },
    connectAnimatedNodeToView: function connectAnimatedNodeToView(nodeTag, viewTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.connectAnimatedNodeToView(nodeTag, viewTag);
    },
    disconnectAnimatedNodeFromView: function disconnectAnimatedNodeFromView(nodeTag, viewTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.disconnectAnimatedNodeFromView(nodeTag, viewTag);
    },
    dropAnimatedNode: function dropAnimatedNode(tag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.dropAnimatedNode(tag);
    },
    addAnimatedEventToView: function addAnimatedEventToView(viewTag, eventName, eventMapping) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.addAnimatedEventToView(viewTag, eventName, eventMapping);
    },
    removeAnimatedEventFromView: function removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag);
    }
  };
  var STYLES_WHITELIST = {
    opacity: true,
    transform: true,
    shadowOpacity: true,
    shadowRadius: true,
    scaleX: true,
    scaleY: true,
    translateX: true,
    translateY: true
  };
  var TRANSFORM_WHITELIST = {
    translateX: true,
    translateY: true,
    scale: true,
    scaleX: true,
    scaleY: true,
    rotate: true,
    rotateX: true,
    rotateY: true,
    perspective: true
  };
  var SUPPORTED_INTERPOLATION_PARAMS = {
    inputRange: true,
    outputRange: true,
    extrapolate: true,
    extrapolateRight: true,
    extrapolateLeft: true
  };

  function addWhitelistedStyleProp(prop) {
    STYLES_WHITELIST[prop] = true;
  }

  function addWhitelistedTransformProp(prop) {
    TRANSFORM_WHITELIST[prop] = true;
  }

  function addWhitelistedInterpolationParam(param) {
    SUPPORTED_INTERPOLATION_PARAMS[param] = true;
  }

  function validateTransform(configs) {
    configs.forEach(function (config) {
      if (!TRANSFORM_WHITELIST.hasOwnProperty(config.property)) {
        throw new Error("Property '" + config.property + "' is not supported by native animated module");
      }
    });
  }

  function validateStyles(styles) {
    for (var key in styles) {
      if (!STYLES_WHITELIST.hasOwnProperty(key)) {
        throw new Error("Style property '" + key + "' is not supported by native animated module");
      }
    }
  }

  function validateInterpolation(config) {
    for (var key in config) {
      if (!SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(key)) {
        throw new Error("Interpolation property '" + key + "' is not supported by native animated module");
      }
    }
  }

  function generateNewNodeTag() {
    return __nativeAnimatedNodeTagCount++;
  }

  function generateNewAnimationId() {
    return __nativeAnimationIdCount++;
  }

  function assertNativeAnimatedModule() {
    invariant(NativeAnimatedModule, 'Native animated module is not available');
  }

  var _warnedMissingNativeAnimated = false;

  function shouldUseNativeDriver(config) {
    if (config.useNativeDriver && !NativeAnimatedModule) {
      if (!_warnedMissingNativeAnimated) {
        console.warn('Animated: `useNativeDriver` is not supported because the native ' + 'animated module is missing. Falling back to JS-based animation. To ' + 'resolve this, add `RCTAnimation` module to this app, or remove ' + '`useNativeDriver`. ' + 'More info: https://github.com/facebook/react-native/issues/11094#issuecomment-263240420');
        _warnedMissingNativeAnimated = true;
      }

      return false;
    }

    return config.useNativeDriver || false;
  }

  module.exports = {
    API: API,
    addWhitelistedStyleProp: addWhitelistedStyleProp,
    addWhitelistedTransformProp: addWhitelistedTransformProp,
    addWhitelistedInterpolationParam: addWhitelistedInterpolationParam,
    validateStyles: validateStyles,
    validateTransform: validateTransform,
    validateInterpolation: validateInterpolation,
    generateNewNodeTag: generateNewNodeTag,
    generateNewAnimationId: generateNewAnimationId,
    assertNativeAnimatedModule: assertNativeAnimatedModule,
    shouldUseNativeDriver: shouldUseNativeDriver,

    get nativeEventEmitter() {
      if (!nativeEventEmitter) {
        nativeEventEmitter = new NativeEventEmitter(NativeAnimatedModule);
      }

      return nativeEventEmitter;
    }

  };
},241,[68,120,18],"NativeAnimatedHelper");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedNode = require(_dependencyMap[0], './AnimatedNode');

  var NativeAnimatedHelper = require(_dependencyMap[1], '../NativeAnimatedHelper');

  var AnimatedWithChildren = function (_AnimatedNode) {
    babelHelpers.inherits(AnimatedWithChildren, _AnimatedNode);

    function AnimatedWithChildren() {
      babelHelpers.classCallCheck(this, AnimatedWithChildren);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedWithChildren.__proto__ || Object.getPrototypeOf(AnimatedWithChildren)).call(this));

      _this._children = [];
      return _this;
    }

    babelHelpers.createClass(AnimatedWithChildren, [{
      key: "__makeNative",
      value: function __makeNative() {
        if (!this.__isNative) {
          this.__isNative = true;

          for (var _iterator = this._children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var child = _ref;

            child.__makeNative();

            NativeAnimatedHelper.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
          }
        }
      }
    }, {
      key: "__addChild",
      value: function __addChild(child) {
        if (this._children.length === 0) {
          this.__attach();
        }

        this._children.push(child);

        if (this.__isNative) {
          child.__makeNative();

          NativeAnimatedHelper.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
        }
      }
    }, {
      key: "__removeChild",
      value: function __removeChild(child) {
        var index = this._children.indexOf(child);

        if (index === -1) {
          console.warn("Trying to remove a child that doesn't exist");
          return;
        }

        if (this.__isNative && child.__isNative) {
          NativeAnimatedHelper.API.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
        }

        this._children.splice(index, 1);

        if (this._children.length === 0) {
          this.__detach();
        }
      }
    }, {
      key: "__getChildren",
      value: function __getChildren() {
        return this._children;
      }
    }]);
    return AnimatedWithChildren;
  }(AnimatedNode);

  module.exports = AnimatedWithChildren;
},242,[240,241],"AnimatedWithChildren");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var BatchedBridge = require(_dependencyMap[0], 'BatchedBridge');

  var EventEmitter = require(_dependencyMap[1], 'EventEmitter');

  var Set = require(_dependencyMap[2], 'Set');

  var TaskQueue = require(_dependencyMap[3], 'TaskQueue');

  var infoLog = require(_dependencyMap[4], 'infoLog');

  var invariant = require(_dependencyMap[5], 'fbjs/lib/invariant');

  var keyMirror = require(_dependencyMap[6], 'fbjs/lib/keyMirror');

  var _emitter = new EventEmitter();

  var DEBUG_DELAY = 0;
  var DEBUG = false;
  var InteractionManager = {
    Events: keyMirror({
      interactionStart: true,
      interactionComplete: true
    }),
    runAfterInteractions: function runAfterInteractions(task) {
      var tasks = [];
      var promise = new Promise(function (resolve) {
        _scheduleUpdate();

        if (task) {
          tasks.push(task);
        }

        tasks.push({
          run: resolve,
          name: 'resolve ' + (task && task.name || '?')
        });

        _taskQueue.enqueueTasks(tasks);
      });
      return {
        then: promise.then.bind(promise),
        done: function done() {
          if (promise.done) {
            return promise.done.apply(promise, arguments);
          } else {
            console.warn('Tried to call done when not supported by current Promise implementation.');
          }
        },
        cancel: function cancel() {
          _taskQueue.cancelTasks(tasks);
        }
      };
    },
    createInteractionHandle: function createInteractionHandle() {
      DEBUG && infoLog('create interaction handle');

      _scheduleUpdate();

      var handle = ++_inc;

      _addInteractionSet.add(handle);

      return handle;
    },
    clearInteractionHandle: function clearInteractionHandle(handle) {
      DEBUG && infoLog('clear interaction handle');
      invariant(!!handle, 'Must provide a handle to clear.');

      _scheduleUpdate();

      _addInteractionSet.delete(handle);

      _deleteInteractionSet.add(handle);
    },
    addListener: _emitter.addListener.bind(_emitter),
    setDeadline: function setDeadline(deadline) {
      _deadline = deadline;
    }
  };

  var _interactionSet = new Set();

  var _addInteractionSet = new Set();

  var _deleteInteractionSet = new Set();

  var _taskQueue = new TaskQueue({
    onMoreTasks: _scheduleUpdate
  });

  var _nextUpdateHandle = 0;
  var _inc = 0;

  var _deadline = -1;

  function _scheduleUpdate() {
    if (!_nextUpdateHandle) {
      if (_deadline > 0) {
        _nextUpdateHandle = setTimeout(_processUpdate, 0 + DEBUG_DELAY);
      } else {
        _nextUpdateHandle = setImmediate(_processUpdate);
      }
    }
  }

  function _processUpdate() {
    _nextUpdateHandle = 0;
    var interactionCount = _interactionSet.size;

    _addInteractionSet.forEach(function (handle) {
      return _interactionSet.add(handle);
    });

    _deleteInteractionSet.forEach(function (handle) {
      return _interactionSet.delete(handle);
    });

    var nextInteractionCount = _interactionSet.size;

    if (interactionCount !== 0 && nextInteractionCount === 0) {
      _emitter.emit(InteractionManager.Events.interactionComplete);
    } else if (interactionCount === 0 && nextInteractionCount !== 0) {
      _emitter.emit(InteractionManager.Events.interactionStart);
    }

    if (nextInteractionCount === 0) {
      while (_taskQueue.hasTasksToProcess()) {
        _taskQueue.processNext();

        if (_deadline > 0 && BatchedBridge.getEventLoopRunningTime() >= _deadline) {
          _scheduleUpdate();

          break;
        }
      }
    }

    _addInteractionSet.clear();

    _deleteInteractionSet.clear();
  }

  module.exports = InteractionManager;
},243,[69,118,83,244,145,18,191],"InteractionManager");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var infoLog = require(_dependencyMap[0], 'infoLog');

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  var DEBUG = false;

  var TaskQueue = function () {
    function TaskQueue(_ref) {
      var onMoreTasks = _ref.onMoreTasks;
      babelHelpers.classCallCheck(this, TaskQueue);
      this._onMoreTasks = onMoreTasks;
      this._queueStack = [{
        tasks: [],
        popable: false
      }];
    }

    babelHelpers.createClass(TaskQueue, [{
      key: "enqueue",
      value: function enqueue(task) {
        this._getCurrentQueue().push(task);
      }
    }, {
      key: "enqueueTasks",
      value: function enqueueTasks(tasks) {
        var _this = this;

        tasks.forEach(function (task) {
          return _this.enqueue(task);
        });
      }
    }, {
      key: "cancelTasks",
      value: function cancelTasks(tasksToCancel) {
        this._queueStack = this._queueStack.map(function (queue) {
          return babelHelpers.extends({}, queue, {
            tasks: queue.tasks.filter(function (task) {
              return tasksToCancel.indexOf(task) === -1;
            })
          });
        }).filter(function (queue, idx) {
          return queue.tasks.length > 0 || idx === 0;
        });
      }
    }, {
      key: "hasTasksToProcess",
      value: function hasTasksToProcess() {
        return this._getCurrentQueue().length > 0;
      }
    }, {
      key: "processNext",
      value: function processNext() {
        var queue = this._getCurrentQueue();

        if (queue.length) {
          var task = queue.shift();

          try {
            if (task.gen) {
              DEBUG && infoLog('genPromise for task ' + task.name);

              this._genPromise(task);
            } else if (task.run) {
              DEBUG && infoLog('run task ' + task.name);
              task.run();
            } else {
              invariant(typeof task === 'function', 'Expected Function, SimpleTask, or PromiseTask, but got:\n' + JSON.stringify(task, null, 2));
              DEBUG && infoLog('run anonymous task');
              task();
            }
          } catch (e) {
            e.message = 'TaskQueue: Error with task ' + (task.name || '') + ': ' + e.message;
            throw e;
          }
        }
      }
    }, {
      key: "_getCurrentQueue",
      value: function _getCurrentQueue() {
        var stackIdx = this._queueStack.length - 1;
        var queue = this._queueStack[stackIdx];

        if (queue.popable && queue.tasks.length === 0 && this._queueStack.length > 1) {
          this._queueStack.pop();

          DEBUG && infoLog('popped queue: ', {
            stackIdx: stackIdx,
            queueStackSize: this._queueStack.length
          });
          return this._getCurrentQueue();
        } else {
          return queue.tasks;
        }
      }
    }, {
      key: "_genPromise",
      value: function _genPromise(task) {
        var _this2 = this;

        this._queueStack.push({
          tasks: [],
          popable: false
        });

        var stackIdx = this._queueStack.length - 1;
        DEBUG && infoLog('push new queue: ', {
          stackIdx: stackIdx
        });
        DEBUG && infoLog('exec gen task ' + task.name);
        task.gen().then(function () {
          DEBUG && infoLog('onThen for gen task ' + task.name, {
            stackIdx: stackIdx,
            queueStackSize: _this2._queueStack.length
          });
          _this2._queueStack[stackIdx].popable = true;
          _this2.hasTasksToProcess() && _this2._onMoreTasks();
        }).catch(function (ex) {
          ex.message = "TaskQueue: Error resolving Promise in task " + task.name + ": " + ex.message;
          throw ex;
        }).done();
      }
    }]);
    return TaskQueue;
  }();

  module.exports = TaskQueue;
},244,[145,18],"TaskQueue");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedInterpolation = require(_dependencyMap[0], './AnimatedInterpolation');

  var AnimatedNode = require(_dependencyMap[1], './AnimatedNode');

  var AnimatedValue = require(_dependencyMap[2], './AnimatedValue');

  var AnimatedWithChildren = require(_dependencyMap[3], './AnimatedWithChildren');

  var AnimatedAddition = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedAddition, _AnimatedWithChildren);

    function AnimatedAddition(a, b) {
      babelHelpers.classCallCheck(this, AnimatedAddition);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedAddition.__proto__ || Object.getPrototypeOf(AnimatedAddition)).call(this));

      _this._a = typeof a === 'number' ? new AnimatedValue(a) : a;
      _this._b = typeof b === 'number' ? new AnimatedValue(b) : b;
      return _this;
    }

    babelHelpers.createClass(AnimatedAddition, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        this._b.__makeNative();

        babelHelpers.get(AnimatedAddition.prototype.__proto__ || Object.getPrototypeOf(AnimatedAddition.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._a.__getValue() + this._b.__getValue();
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        babelHelpers.get(AnimatedAddition.prototype.__proto__ || Object.getPrototypeOf(AnimatedAddition.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'addition',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);
    return AnimatedAddition;
  }(AnimatedWithChildren);

  module.exports = AnimatedAddition;
},245,[239,240,238,242],"AnimatedAddition");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedInterpolation = require(_dependencyMap[0], './AnimatedInterpolation');

  var AnimatedNode = require(_dependencyMap[1], './AnimatedNode');

  var AnimatedWithChildren = require(_dependencyMap[2], './AnimatedWithChildren');

  var AnimatedDiffClamp = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedDiffClamp, _AnimatedWithChildren);

    function AnimatedDiffClamp(a, min, max) {
      babelHelpers.classCallCheck(this, AnimatedDiffClamp);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedDiffClamp.__proto__ || Object.getPrototypeOf(AnimatedDiffClamp)).call(this));

      _this._a = a;
      _this._min = min;
      _this._max = max;
      _this._value = _this._lastValue = _this._a.__getValue();
      return _this;
    }

    babelHelpers.createClass(AnimatedDiffClamp, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        babelHelpers.get(AnimatedDiffClamp.prototype.__proto__ || Object.getPrototypeOf(AnimatedDiffClamp.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        var value = this._a.__getValue();

        var diff = value - this._lastValue;
        this._lastValue = value;
        this._value = Math.min(Math.max(this._value + diff, this._min), this._max);
        return this._value;
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        babelHelpers.get(AnimatedDiffClamp.prototype.__proto__ || Object.getPrototypeOf(AnimatedDiffClamp.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'diffclamp',
          input: this._a.__getNativeTag(),
          min: this._min,
          max: this._max
        };
      }
    }]);
    return AnimatedDiffClamp;
  }(AnimatedWithChildren);

  module.exports = AnimatedDiffClamp;
},246,[239,240,242],"AnimatedDiffClamp");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedInterpolation = require(_dependencyMap[0], './AnimatedInterpolation');

  var AnimatedNode = require(_dependencyMap[1], './AnimatedNode');

  var AnimatedValue = require(_dependencyMap[2], './AnimatedValue');

  var AnimatedWithChildren = require(_dependencyMap[3], './AnimatedWithChildren');

  var AnimatedDivision = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedDivision, _AnimatedWithChildren);

    function AnimatedDivision(a, b) {
      babelHelpers.classCallCheck(this, AnimatedDivision);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedDivision.__proto__ || Object.getPrototypeOf(AnimatedDivision)).call(this));

      _this._a = typeof a === 'number' ? new AnimatedValue(a) : a;
      _this._b = typeof b === 'number' ? new AnimatedValue(b) : b;
      return _this;
    }

    babelHelpers.createClass(AnimatedDivision, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        this._b.__makeNative();

        babelHelpers.get(AnimatedDivision.prototype.__proto__ || Object.getPrototypeOf(AnimatedDivision.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        var a = this._a.__getValue();

        var b = this._b.__getValue();

        if (b === 0) {
          console.error('Detected division by zero in AnimatedDivision');
        }

        return a / b;
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        babelHelpers.get(AnimatedDivision.prototype.__proto__ || Object.getPrototypeOf(AnimatedDivision.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'division',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);
    return AnimatedDivision;
  }(AnimatedWithChildren);

  module.exports = AnimatedDivision;
},247,[239,240,238,242],"AnimatedDivision");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedInterpolation = require(_dependencyMap[0], './AnimatedInterpolation');

  var AnimatedNode = require(_dependencyMap[1], './AnimatedNode');

  var AnimatedWithChildren = require(_dependencyMap[2], './AnimatedWithChildren');

  var AnimatedModulo = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedModulo, _AnimatedWithChildren);

    function AnimatedModulo(a, modulus) {
      babelHelpers.classCallCheck(this, AnimatedModulo);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedModulo.__proto__ || Object.getPrototypeOf(AnimatedModulo)).call(this));

      _this._a = a;
      _this._modulus = modulus;
      return _this;
    }

    babelHelpers.createClass(AnimatedModulo, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        babelHelpers.get(AnimatedModulo.prototype.__proto__ || Object.getPrototypeOf(AnimatedModulo.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return (this._a.__getValue() % this._modulus + this._modulus) % this._modulus;
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        babelHelpers.get(AnimatedModulo.prototype.__proto__ || Object.getPrototypeOf(AnimatedModulo.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'modulus',
          input: this._a.__getNativeTag(),
          modulus: this._modulus
        };
      }
    }]);
    return AnimatedModulo;
  }(AnimatedWithChildren);

  module.exports = AnimatedModulo;
},248,[239,240,242],"AnimatedModulo");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedInterpolation = require(_dependencyMap[0], './AnimatedInterpolation');

  var AnimatedNode = require(_dependencyMap[1], './AnimatedNode');

  var AnimatedValue = require(_dependencyMap[2], './AnimatedValue');

  var AnimatedWithChildren = require(_dependencyMap[3], './AnimatedWithChildren');

  var AnimatedMultiplication = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedMultiplication, _AnimatedWithChildren);

    function AnimatedMultiplication(a, b) {
      babelHelpers.classCallCheck(this, AnimatedMultiplication);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedMultiplication.__proto__ || Object.getPrototypeOf(AnimatedMultiplication)).call(this));

      _this._a = typeof a === 'number' ? new AnimatedValue(a) : a;
      _this._b = typeof b === 'number' ? new AnimatedValue(b) : b;
      return _this;
    }

    babelHelpers.createClass(AnimatedMultiplication, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        this._b.__makeNative();

        babelHelpers.get(AnimatedMultiplication.prototype.__proto__ || Object.getPrototypeOf(AnimatedMultiplication.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._a.__getValue() * this._b.__getValue();
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        babelHelpers.get(AnimatedMultiplication.prototype.__proto__ || Object.getPrototypeOf(AnimatedMultiplication.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'multiplication',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);
    return AnimatedMultiplication;
  }(AnimatedWithChildren);

  module.exports = AnimatedMultiplication;
},249,[239,240,238,242],"AnimatedMultiplication");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], '../AnimatedEvent'),
      AnimatedEvent = _require.AnimatedEvent;

  var AnimatedNode = require(_dependencyMap[1], './AnimatedNode');

  var AnimatedStyle = require(_dependencyMap[2], './AnimatedStyle');

  var NativeAnimatedHelper = require(_dependencyMap[3], '../NativeAnimatedHelper');

  var ReactNative = require(_dependencyMap[4], 'ReactNative');

  var invariant = require(_dependencyMap[5], 'fbjs/lib/invariant');

  var AnimatedProps = function (_AnimatedNode) {
    babelHelpers.inherits(AnimatedProps, _AnimatedNode);

    function AnimatedProps(props, callback) {
      babelHelpers.classCallCheck(this, AnimatedProps);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedProps.__proto__ || Object.getPrototypeOf(AnimatedProps)).call(this));

      if (props.style) {
        props = babelHelpers.extends({}, props, {
          style: new AnimatedStyle(props.style)
        });
      }

      _this._props = props;
      _this._callback = callback;

      _this.__attach();

      return _this;
    }

    babelHelpers.createClass(AnimatedProps, [{
      key: "__getValue",
      value: function __getValue() {
        var props = {};

        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof AnimatedNode) {
            if (!value.__isNative || value instanceof AnimatedStyle) {
              props[key] = value.__getValue();
            }
          } else if (value instanceof AnimatedEvent) {
            props[key] = value.__getHandler();
          } else {
            props[key] = value;
          }
        }

        return props;
      }
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        var props = {};

        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof AnimatedNode) {
            props[key] = value.__getAnimatedValue();
          }
        }

        return props;
      }
    }, {
      key: "__attach",
      value: function __attach() {
        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof AnimatedNode) {
            value.__addChild(this);
          }
        }
      }
    }, {
      key: "__detach",
      value: function __detach() {
        if (this.__isNative && this._animatedView) {
          this.__disconnectAnimatedView();
        }

        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof AnimatedNode) {
            value.__removeChild(this);
          }
        }

        babelHelpers.get(AnimatedProps.prototype.__proto__ || Object.getPrototypeOf(AnimatedProps.prototype), "__detach", this).call(this);
      }
    }, {
      key: "update",
      value: function update() {
        this._callback();
      }
    }, {
      key: "__makeNative",
      value: function __makeNative() {
        if (!this.__isNative) {
          this.__isNative = true;

          for (var key in this._props) {
            var value = this._props[key];

            if (value instanceof AnimatedNode) {
              value.__makeNative();
            }
          }

          if (this._animatedView) {
            this.__connectAnimatedView();
          }
        }
      }
    }, {
      key: "setNativeView",
      value: function setNativeView(animatedView) {
        if (this._animatedView === animatedView) {
          return;
        }

        this._animatedView = animatedView;

        if (this.__isNative) {
          this.__connectAnimatedView();
        }
      }
    }, {
      key: "__connectAnimatedView",
      value: function __connectAnimatedView() {
        invariant(this.__isNative, 'Expected node to be marked as "native"');
        var nativeViewTag = ReactNative.findNodeHandle(this._animatedView);
        invariant(nativeViewTag != null, 'Unable to locate attached view in the native tree');
        NativeAnimatedHelper.API.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
      }
    }, {
      key: "__disconnectAnimatedView",
      value: function __disconnectAnimatedView() {
        invariant(this.__isNative, 'Expected node to be marked as "native"');
        var nativeViewTag = ReactNative.findNodeHandle(this._animatedView);
        invariant(nativeViewTag != null, 'Unable to locate attached view in the native tree');
        NativeAnimatedHelper.API.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var propsConfig = {};

        for (var propKey in this._props) {
          var value = this._props[propKey];

          if (value instanceof AnimatedNode) {
            propsConfig[propKey] = value.__getNativeTag();
          }
        }

        return {
          type: 'props',
          props: propsConfig
        };
      }
    }]);
    return AnimatedProps;
  }(AnimatedNode);

  module.exports = AnimatedProps;
},250,[237,240,251,241,74,18],"AnimatedProps");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedNode = require(_dependencyMap[0], './AnimatedNode');

  var AnimatedTransform = require(_dependencyMap[1], './AnimatedTransform');

  var AnimatedWithChildren = require(_dependencyMap[2], './AnimatedWithChildren');

  var NativeAnimatedHelper = require(_dependencyMap[3], '../NativeAnimatedHelper');

  var flattenStyle = require(_dependencyMap[4], 'flattenStyle');

  var AnimatedStyle = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedStyle, _AnimatedWithChildren);

    function AnimatedStyle(style) {
      babelHelpers.classCallCheck(this, AnimatedStyle);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedStyle.__proto__ || Object.getPrototypeOf(AnimatedStyle)).call(this));

      style = flattenStyle(style) || {};

      if (style.transform) {
        style = babelHelpers.extends({}, style, {
          transform: new AnimatedTransform(style.transform)
        });
      }

      _this._style = style;
      return _this;
    }

    babelHelpers.createClass(AnimatedStyle, [{
      key: "_walkStyleAndGetValues",
      value: function _walkStyleAndGetValues(style) {
        var updatedStyle = {};

        for (var key in style) {
          var value = style[key];

          if (value instanceof AnimatedNode) {
            if (!value.__isNative) {
              updatedStyle[key] = value.__getValue();
            }
          } else if (value && !Array.isArray(value) && typeof value === 'object') {
            updatedStyle[key] = this._walkStyleAndGetValues(value);
          } else {
            updatedStyle[key] = value;
          }
        }

        return updatedStyle;
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._walkStyleAndGetValues(this._style);
      }
    }, {
      key: "_walkStyleAndGetAnimatedValues",
      value: function _walkStyleAndGetAnimatedValues(style) {
        var updatedStyle = {};

        for (var key in style) {
          var value = style[key];

          if (value instanceof AnimatedNode) {
            updatedStyle[key] = value.__getAnimatedValue();
          } else if (value && !Array.isArray(value) && typeof value === 'object') {
            updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);
          }
        }

        return updatedStyle;
      }
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        return this._walkStyleAndGetAnimatedValues(this._style);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        for (var key in this._style) {
          var value = this._style[key];

          if (value instanceof AnimatedNode) {
            value.__addChild(this);
          }
        }
      }
    }, {
      key: "__detach",
      value: function __detach() {
        for (var key in this._style) {
          var value = this._style[key];

          if (value instanceof AnimatedNode) {
            value.__removeChild(this);
          }
        }

        babelHelpers.get(AnimatedStyle.prototype.__proto__ || Object.getPrototypeOf(AnimatedStyle.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__makeNative",
      value: function __makeNative() {
        babelHelpers.get(AnimatedStyle.prototype.__proto__ || Object.getPrototypeOf(AnimatedStyle.prototype), "__makeNative", this).call(this);

        for (var key in this._style) {
          var value = this._style[key];

          if (value instanceof AnimatedNode) {
            value.__makeNative();
          }
        }
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var styleConfig = {};

        for (var styleKey in this._style) {
          if (this._style[styleKey] instanceof AnimatedNode) {
            styleConfig[styleKey] = this._style[styleKey].__getNativeTag();
          }
        }

        NativeAnimatedHelper.validateStyles(styleConfig);
        return {
          type: 'style',
          style: styleConfig
        };
      }
    }]);
    return AnimatedStyle;
  }(AnimatedWithChildren);

  module.exports = AnimatedStyle;
},251,[240,252,242,241,152],"AnimatedStyle");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedNode = require(_dependencyMap[0], './AnimatedNode');

  var AnimatedWithChildren = require(_dependencyMap[1], './AnimatedWithChildren');

  var NativeAnimatedHelper = require(_dependencyMap[2], '../NativeAnimatedHelper');

  var AnimatedTransform = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedTransform, _AnimatedWithChildren);

    function AnimatedTransform(transforms) {
      babelHelpers.classCallCheck(this, AnimatedTransform);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedTransform.__proto__ || Object.getPrototypeOf(AnimatedTransform)).call(this));

      _this._transforms = transforms;
      return _this;
    }

    babelHelpers.createClass(AnimatedTransform, [{
      key: "__makeNative",
      value: function __makeNative() {
        babelHelpers.get(AnimatedTransform.prototype.__proto__ || Object.getPrototypeOf(AnimatedTransform.prototype), "__makeNative", this).call(this);

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              value.__makeNative();
            }
          }
        });
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._transforms.map(function (transform) {
          var result = {};

          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              result[key] = value.__getValue();
            } else {
              result[key] = value;
            }
          }

          return result;
        });
      }
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        return this._transforms.map(function (transform) {
          var result = {};

          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              result[key] = value.__getAnimatedValue();
            } else {
              result[key] = value;
            }
          }

          return result;
        });
      }
    }, {
      key: "__attach",
      value: function __attach() {
        var _this2 = this;

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              value.__addChild(_this2);
            }
          }
        });
      }
    }, {
      key: "__detach",
      value: function __detach() {
        var _this3 = this;

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              value.__removeChild(_this3);
            }
          }
        });

        babelHelpers.get(AnimatedTransform.prototype.__proto__ || Object.getPrototypeOf(AnimatedTransform.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var transConfigs = [];

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              transConfigs.push({
                type: 'animated',
                property: key,
                nodeTag: value.__getNativeTag()
              });
            } else {
              transConfigs.push({
                type: 'static',
                property: key,
                value: value
              });
            }
          }
        });

        NativeAnimatedHelper.validateTransform(transConfigs);
        return {
          type: 'transform',
          transforms: transConfigs
        };
      }
    }]);
    return AnimatedTransform;
  }(AnimatedWithChildren);

  module.exports = AnimatedTransform;
},252,[240,242,241],"AnimatedTransform");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedValue = require(_dependencyMap[0], './AnimatedValue');

  var AnimatedNode = require(_dependencyMap[1], './AnimatedNode');

  var AnimatedTracking = function (_AnimatedNode) {
    babelHelpers.inherits(AnimatedTracking, _AnimatedNode);

    function AnimatedTracking(value, parent, animationClass, animationConfig, callback) {
      babelHelpers.classCallCheck(this, AnimatedTracking);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedTracking.__proto__ || Object.getPrototypeOf(AnimatedTracking)).call(this));

      _this._value = value;
      _this._parent = parent;
      _this._animationClass = animationClass;
      _this._animationConfig = animationConfig;
      _this._callback = callback;

      _this.__attach();

      return _this;
    }

    babelHelpers.createClass(AnimatedTracking, [{
      key: "__getValue",
      value: function __getValue() {
        return this._parent.__getValue();
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._parent.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._parent.__removeChild(this);

        babelHelpers.get(AnimatedTracking.prototype.__proto__ || Object.getPrototypeOf(AnimatedTracking.prototype), "__detach", this).call(this);
      }
    }, {
      key: "update",
      value: function update() {
        this._value.animate(new this._animationClass(babelHelpers.extends({}, this._animationConfig, {
          toValue: this._animationConfig.toValue.__getValue()
        })), this._callback);
      }
    }]);
    return AnimatedTracking;
  }(AnimatedNode);

  module.exports = AnimatedTracking;
},253,[238,240],"AnimatedTracking");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedValue = require(_dependencyMap[0], './AnimatedValue');

  var AnimatedWithChildren = require(_dependencyMap[1], './AnimatedWithChildren');

  var invariant = require(_dependencyMap[2], 'fbjs/lib/invariant');

  var _uniqueId = 1;

  var AnimatedValueXY = function (_AnimatedWithChildren) {
    babelHelpers.inherits(AnimatedValueXY, _AnimatedWithChildren);

    function AnimatedValueXY(valueIn) {
      babelHelpers.classCallCheck(this, AnimatedValueXY);

      var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedValueXY.__proto__ || Object.getPrototypeOf(AnimatedValueXY)).call(this));

      var value = valueIn || {
        x: 0,
        y: 0
      };

      if (typeof value.x === 'number' && typeof value.y === 'number') {
        _this.x = new AnimatedValue(value.x);
        _this.y = new AnimatedValue(value.y);
      } else {
        invariant(value.x instanceof AnimatedValue && value.y instanceof AnimatedValue, 'AnimatedValueXY must be initalized with an object of numbers or ' + 'AnimatedValues.');
        _this.x = value.x;
        _this.y = value.y;
      }

      _this._listeners = {};
      return _this;
    }

    babelHelpers.createClass(AnimatedValueXY, [{
      key: "setValue",
      value: function setValue(value) {
        this.x.setValue(value.x);
        this.y.setValue(value.y);
      }
    }, {
      key: "setOffset",
      value: function setOffset(offset) {
        this.x.setOffset(offset.x);
        this.y.setOffset(offset.y);
      }
    }, {
      key: "flattenOffset",
      value: function flattenOffset() {
        this.x.flattenOffset();
        this.y.flattenOffset();
      }
    }, {
      key: "extractOffset",
      value: function extractOffset() {
        this.x.extractOffset();
        this.y.extractOffset();
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return {
          x: this.x.__getValue(),
          y: this.y.__getValue()
        };
      }
    }, {
      key: "resetAnimation",
      value: function resetAnimation(callback) {
        this.x.resetAnimation();
        this.y.resetAnimation();
        callback && callback(this.__getValue());
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation(callback) {
        this.x.stopAnimation();
        this.y.stopAnimation();
        callback && callback(this.__getValue());
      }
    }, {
      key: "addListener",
      value: function addListener(callback) {
        var _this2 = this;

        var id = String(_uniqueId++);

        var jointCallback = function jointCallback(_ref) {
          var number = _ref.value;
          callback(_this2.__getValue());
        };

        this._listeners[id] = {
          x: this.x.addListener(jointCallback),
          y: this.y.addListener(jointCallback)
        };
        return id;
      }
    }, {
      key: "removeListener",
      value: function removeListener(id) {
        this.x.removeListener(this._listeners[id].x);
        this.y.removeListener(this._listeners[id].y);
        delete this._listeners[id];
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        this.x.removeAllListeners();
        this.y.removeAllListeners();
        this._listeners = {};
      }
    }, {
      key: "getLayout",
      value: function getLayout() {
        return {
          left: this.x,
          top: this.y
        };
      }
    }, {
      key: "getTranslateTransform",
      value: function getTranslateTransform() {
        return [{
          translateX: this.x
        }, {
          translateY: this.y
        }];
      }
    }]);
    return AnimatedValueXY;
  }(AnimatedWithChildren);

  module.exports = AnimatedValueXY;
},254,[238,242,18],"AnimatedValueXY");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Animation = require(_dependencyMap[0], './Animation');

  var _require = require(_dependencyMap[1], '../NativeAnimatedHelper'),
      shouldUseNativeDriver = _require.shouldUseNativeDriver;

  var DecayAnimation = function (_Animation) {
    babelHelpers.inherits(DecayAnimation, _Animation);

    function DecayAnimation(config) {
      babelHelpers.classCallCheck(this, DecayAnimation);

      var _this = babelHelpers.possibleConstructorReturn(this, (DecayAnimation.__proto__ || Object.getPrototypeOf(DecayAnimation)).call(this));

      _this._deceleration = config.deceleration !== undefined ? config.deceleration : 0.998;
      _this._velocity = config.velocity;
      _this._useNativeDriver = shouldUseNativeDriver(config);
      _this.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;
      _this.__iterations = config.iterations !== undefined ? config.iterations : 1;
      return _this;
    }

    babelHelpers.createClass(DecayAnimation, [{
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        return {
          type: 'decay',
          deceleration: this._deceleration,
          velocity: this._velocity,
          iterations: this.__iterations
        };
      }
    }, {
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
        this.__active = true;
        this._lastValue = fromValue;
        this._fromValue = fromValue;
        this._onUpdate = onUpdate;
        this.__onEnd = onEnd;
        this._startTime = Date.now();

        if (this._useNativeDriver) {
          this.__startNativeAnimation(animatedValue);
        } else {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        var now = Date.now();
        var value = this._fromValue + this._velocity / (1 - this._deceleration) * (1 - Math.exp(-(1 - this._deceleration) * (now - this._startTime)));

        this._onUpdate(value);

        if (Math.abs(this._lastValue - value) < 0.1) {
          this.__debouncedOnEnd({
            finished: true
          });

          return;
        }

        this._lastValue = value;

        if (this.__active) {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        babelHelpers.get(DecayAnimation.prototype.__proto__ || Object.getPrototypeOf(DecayAnimation.prototype), "stop", this).call(this);
        this.__active = false;
        global.cancelAnimationFrame(this._animationFrame);

        this.__debouncedOnEnd({
          finished: false
        });
      }
    }]);
    return DecayAnimation;
  }(Animation);

  module.exports = DecayAnimation;
},255,[256,241],"DecayAnimation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeAnimatedHelper = require(_dependencyMap[0], 'NativeAnimatedHelper');

  var Animation = function () {
    function Animation() {
      babelHelpers.classCallCheck(this, Animation);
    }

    babelHelpers.createClass(Animation, [{
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {}
    }, {
      key: "stop",
      value: function stop() {
        if (this.__nativeId) {
          NativeAnimatedHelper.API.stopAnimation(this.__nativeId);
        }
      }
    }, {
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        throw new Error('This animation type cannot be offloaded to native');
      }
    }, {
      key: "__debouncedOnEnd",
      value: function __debouncedOnEnd(result) {
        var onEnd = this.__onEnd;
        this.__onEnd = null;
        onEnd && onEnd(result);
      }
    }, {
      key: "__startNativeAnimation",
      value: function __startNativeAnimation(animatedValue) {
        animatedValue.__makeNative();

        this.__nativeId = NativeAnimatedHelper.generateNewAnimationId();
        NativeAnimatedHelper.API.startAnimatingNode(this.__nativeId, animatedValue.__getNativeTag(), this.__getNativeAnimationConfig(), this.__debouncedOnEnd.bind(this));
      }
    }]);
    return Animation;
  }();

  module.exports = Animation;
},256,[241],"Animation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedValue = require(_dependencyMap[0], '../nodes/AnimatedValue');

  var AnimatedValueXY = require(_dependencyMap[1], '../nodes/AnimatedValueXY');

  var Animation = require(_dependencyMap[2], './Animation');

  var SpringConfig = require(_dependencyMap[3], '../SpringConfig');

  var invariant = require(_dependencyMap[4], 'fbjs/lib/invariant');

  var _require = require(_dependencyMap[5], '../NativeAnimatedHelper'),
      shouldUseNativeDriver = _require.shouldUseNativeDriver;

  function withDefault(value, defaultValue) {
    if (value === undefined || value === null) {
      return defaultValue;
    }

    return value;
  }

  var SpringAnimation = function (_Animation) {
    babelHelpers.inherits(SpringAnimation, _Animation);

    function SpringAnimation(config) {
      babelHelpers.classCallCheck(this, SpringAnimation);

      var _this = babelHelpers.possibleConstructorReturn(this, (SpringAnimation.__proto__ || Object.getPrototypeOf(SpringAnimation)).call(this));

      _this._overshootClamping = withDefault(config.overshootClamping, false);
      _this._restDisplacementThreshold = withDefault(config.restDisplacementThreshold, 0.001);
      _this._restSpeedThreshold = withDefault(config.restSpeedThreshold, 0.001);
      _this._initialVelocity = withDefault(config.velocity, 0);
      _this._lastVelocity = withDefault(config.velocity, 0);
      _this._toValue = config.toValue;
      _this._delay = withDefault(config.delay, 0);
      _this._useNativeDriver = shouldUseNativeDriver(config);
      _this.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;
      _this.__iterations = config.iterations !== undefined ? config.iterations : 1;

      if (config.stiffness !== undefined || config.damping !== undefined || config.mass !== undefined) {
        invariant(config.bounciness === undefined && config.speed === undefined && config.tension === undefined && config.friction === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        _this._stiffness = withDefault(config.stiffness, 100);
        _this._damping = withDefault(config.damping, 10);
        _this._mass = withDefault(config.mass, 1);
      } else if (config.bounciness !== undefined || config.speed !== undefined) {
        invariant(config.tension === undefined && config.friction === undefined && config.stiffness === undefined && config.damping === undefined && config.mass === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        var springConfig = SpringConfig.fromBouncinessAndSpeed(withDefault(config.bounciness, 8), withDefault(config.speed, 12));
        _this._stiffness = springConfig.stiffness;
        _this._damping = springConfig.damping;
        _this._mass = 1;
      } else {
        var _springConfig = SpringConfig.fromOrigamiTensionAndFriction(withDefault(config.tension, 40), withDefault(config.friction, 7));

        _this._stiffness = _springConfig.stiffness;
        _this._damping = _springConfig.damping;
        _this._mass = 1;
      }

      invariant(_this._stiffness > 0, 'Stiffness value must be greater than 0');
      invariant(_this._damping > 0, 'Damping value must be greater than 0');
      invariant(_this._mass > 0, 'Mass value must be greater than 0');
      return _this;
    }

    babelHelpers.createClass(SpringAnimation, [{
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        return {
          type: 'spring',
          overshootClamping: this._overshootClamping,
          restDisplacementThreshold: this._restDisplacementThreshold,
          restSpeedThreshold: this._restSpeedThreshold,
          stiffness: this._stiffness,
          damping: this._damping,
          mass: this._mass,
          initialVelocity: withDefault(this._initialVelocity, this._lastVelocity),
          toValue: this._toValue,
          iterations: this.__iterations
        };
      }
    }, {
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
        var _this2 = this;

        this.__active = true;
        this._startPosition = fromValue;
        this._lastPosition = this._startPosition;
        this._onUpdate = onUpdate;
        this.__onEnd = onEnd;
        this._lastTime = Date.now();
        this._frameTime = 0.0;

        if (previousAnimation instanceof SpringAnimation) {
          var internalState = previousAnimation.getInternalState();
          this._lastPosition = internalState.lastPosition;
          this._lastVelocity = internalState.lastVelocity;
          this._initialVelocity = this._lastVelocity;
          this._lastTime = internalState.lastTime;
        }

        var start = function start() {
          if (_this2._useNativeDriver) {
            _this2.__startNativeAnimation(animatedValue);
          } else {
            _this2.onUpdate();
          }
        };

        if (this._delay) {
          this._timeout = setTimeout(start, this._delay);
        } else {
          start();
        }
      }
    }, {
      key: "getInternalState",
      value: function getInternalState() {
        return {
          lastPosition: this._lastPosition,
          lastVelocity: this._lastVelocity,
          lastTime: this._lastTime
        };
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        var MAX_STEPS = 64;
        var now = Date.now();

        if (now > this._lastTime + MAX_STEPS) {
          now = this._lastTime + MAX_STEPS;
        }

        var deltaTime = (now - this._lastTime) / 1000;
        this._frameTime += deltaTime;
        var c = this._damping;
        var m = this._mass;
        var k = this._stiffness;
        var v0 = -this._initialVelocity;
        var zeta = c / (2 * Math.sqrt(k * m));
        var omega0 = Math.sqrt(k / m);
        var omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta);
        var x0 = this._toValue - this._startPosition;
        var position = 0.0;
        var velocity = 0.0;
        var t = this._frameTime;

        if (zeta < 1) {
          var envelope = Math.exp(-zeta * omega0 * t);
          position = this._toValue - envelope * ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) + x0 * Math.cos(omega1 * t));
          velocity = zeta * omega0 * envelope * (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 + x0 * Math.cos(omega1 * t)) - envelope * (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) - omega1 * x0 * Math.sin(omega1 * t));
        } else {
          var _envelope = Math.exp(-omega0 * t);

          position = this._toValue - _envelope * (x0 + (v0 + omega0 * x0) * t);
          velocity = _envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));
        }

        this._lastTime = now;
        this._lastPosition = position;
        this._lastVelocity = velocity;

        this._onUpdate(position);

        if (!this.__active) {
          return;
        }

        var isOvershooting = false;

        if (this._overshootClamping && this._stiffness !== 0) {
          if (this._startPosition < this._toValue) {
            isOvershooting = position > this._toValue;
          } else {
            isOvershooting = position < this._toValue;
          }
        }

        var isVelocity = Math.abs(velocity) <= this._restSpeedThreshold;

        var isDisplacement = true;

        if (this._stiffness !== 0) {
          isDisplacement = Math.abs(this._toValue - position) <= this._restDisplacementThreshold;
        }

        if (isOvershooting || isVelocity && isDisplacement) {
          if (this._stiffness !== 0) {
            this._lastPosition = this._toValue;
            this._lastVelocity = 0;

            this._onUpdate(this._toValue);
          }

          this.__debouncedOnEnd({
            finished: true
          });

          return;
        }

        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }, {
      key: "stop",
      value: function stop() {
        babelHelpers.get(SpringAnimation.prototype.__proto__ || Object.getPrototypeOf(SpringAnimation.prototype), "stop", this).call(this);
        this.__active = false;
        clearTimeout(this._timeout);
        global.cancelAnimationFrame(this._animationFrame);

        this.__debouncedOnEnd({
          finished: false
        });
      }
    }]);
    return SpringAnimation;
  }(Animation);

  module.exports = SpringAnimation;
},257,[238,254,256,258,18,241],"SpringAnimation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function stiffnessFromOrigamiValue(oValue) {
    return (oValue - 30) * 3.62 + 194;
  }

  function dampingFromOrigamiValue(oValue) {
    return (oValue - 8) * 3 + 25;
  }

  function fromOrigamiTensionAndFriction(tension, friction) {
    return {
      stiffness: stiffnessFromOrigamiValue(tension),
      damping: dampingFromOrigamiValue(friction)
    };
  }

  function fromBouncinessAndSpeed(bounciness, speed) {
    function normalize(value, startValue, endValue) {
      return (value - startValue) / (endValue - startValue);
    }

    function projectNormal(n, start, end) {
      return start + n * (end - start);
    }

    function linearInterpolation(t, start, end) {
      return t * end + (1 - t) * start;
    }

    function quadraticOutInterpolation(t, start, end) {
      return linearInterpolation(2 * t - t * t, start, end);
    }

    function b3Friction1(x) {
      return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
    }

    function b3Friction2(x) {
      return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
    }

    function b3Friction3(x) {
      return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
    }

    function b3Nobounce(tension) {
      if (tension <= 18) {
        return b3Friction1(tension);
      } else if (tension > 18 && tension <= 44) {
        return b3Friction2(tension);
      } else {
        return b3Friction3(tension);
      }
    }

    var b = normalize(bounciness / 1.7, 0, 20);
    b = projectNormal(b, 0, 0.8);
    var s = normalize(speed / 1.7, 0, 20);
    var bouncyTension = projectNormal(s, 0.5, 200);
    var bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
    return {
      stiffness: stiffnessFromOrigamiValue(bouncyTension),
      damping: dampingFromOrigamiValue(bouncyFriction)
    };
  }

  module.exports = {
    fromOrigamiTensionAndFriction: fromOrigamiTensionAndFriction,
    fromBouncinessAndSpeed: fromBouncinessAndSpeed
  };
},258,[],"SpringConfig");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var AnimatedValue = require(_dependencyMap[0], '../nodes/AnimatedValue');

  var AnimatedValueXY = require(_dependencyMap[1], '../nodes/AnimatedValueXY');

  var Animation = require(_dependencyMap[2], './Animation');

  var _require = require(_dependencyMap[3], '../NativeAnimatedHelper'),
      shouldUseNativeDriver = _require.shouldUseNativeDriver;

  var _easeInOut = void 0;

  function easeInOut() {
    if (!_easeInOut) {
      var Easing = require(_dependencyMap[4], 'Easing');

      _easeInOut = Easing.inOut(Easing.ease);
    }

    return _easeInOut;
  }

  var TimingAnimation = function (_Animation) {
    babelHelpers.inherits(TimingAnimation, _Animation);

    function TimingAnimation(config) {
      babelHelpers.classCallCheck(this, TimingAnimation);

      var _this = babelHelpers.possibleConstructorReturn(this, (TimingAnimation.__proto__ || Object.getPrototypeOf(TimingAnimation)).call(this));

      _this._toValue = config.toValue;
      _this._easing = config.easing !== undefined ? config.easing : easeInOut();
      _this._duration = config.duration !== undefined ? config.duration : 500;
      _this._delay = config.delay !== undefined ? config.delay : 0;
      _this.__iterations = config.iterations !== undefined ? config.iterations : 1;
      _this.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;
      _this._useNativeDriver = shouldUseNativeDriver(config);
      return _this;
    }

    babelHelpers.createClass(TimingAnimation, [{
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        var frameDuration = 1000.0 / 60.0;
        var frames = [];

        for (var dt = 0.0; dt < this._duration; dt += frameDuration) {
          frames.push(this._easing(dt / this._duration));
        }

        frames.push(this._easing(1));
        return {
          type: 'frames',
          frames: frames,
          toValue: this._toValue,
          iterations: this.__iterations
        };
      }
    }, {
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
        var _this2 = this;

        this.__active = true;
        this._fromValue = fromValue;
        this._onUpdate = onUpdate;
        this.__onEnd = onEnd;

        var start = function start() {
          if (_this2._duration === 0 && !_this2._useNativeDriver) {
            _this2._onUpdate(_this2._toValue);

            _this2.__debouncedOnEnd({
              finished: true
            });
          } else {
            _this2._startTime = Date.now();

            if (_this2._useNativeDriver) {
              _this2.__startNativeAnimation(animatedValue);
            } else {
              _this2._animationFrame = requestAnimationFrame(_this2.onUpdate.bind(_this2));
            }
          }
        };

        if (this._delay) {
          this._timeout = setTimeout(start, this._delay);
        } else {
          start();
        }
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        var now = Date.now();

        if (now >= this._startTime + this._duration) {
          if (this._duration === 0) {
            this._onUpdate(this._toValue);
          } else {
            this._onUpdate(this._fromValue + this._easing(1) * (this._toValue - this._fromValue));
          }

          this.__debouncedOnEnd({
            finished: true
          });

          return;
        }

        this._onUpdate(this._fromValue + this._easing((now - this._startTime) / this._duration) * (this._toValue - this._fromValue));

        if (this.__active) {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        babelHelpers.get(TimingAnimation.prototype.__proto__ || Object.getPrototypeOf(TimingAnimation.prototype), "stop", this).call(this);
        this.__active = false;
        clearTimeout(this._timeout);
        global.cancelAnimationFrame(this._animationFrame);

        this.__debouncedOnEnd({
          finished: false
        });
      }
    }]);
    return TimingAnimation;
  }(Animation);

  module.exports = TimingAnimation;
},259,[238,254,256,241,260],"TimingAnimation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _ease = void 0;

  var Easing = function () {
    function Easing() {
      babelHelpers.classCallCheck(this, Easing);
    }

    babelHelpers.createClass(Easing, null, [{
      key: "step0",
      value: function step0(n) {
        return n > 0 ? 1 : 0;
      }
    }, {
      key: "step1",
      value: function step1(n) {
        return n >= 1 ? 1 : 0;
      }
    }, {
      key: "linear",
      value: function linear(t) {
        return t;
      }
    }, {
      key: "ease",
      value: function ease(t) {
        if (!_ease) {
          _ease = Easing.bezier(0.42, 0, 1, 1);
        }

        return _ease(t);
      }
    }, {
      key: "quad",
      value: function quad(t) {
        return t * t;
      }
    }, {
      key: "cubic",
      value: function cubic(t) {
        return t * t * t;
      }
    }, {
      key: "poly",
      value: function poly(n) {
        return function (t) {
          return Math.pow(t, n);
        };
      }
    }, {
      key: "sin",
      value: function sin(t) {
        return 1 - Math.cos(t * Math.PI / 2);
      }
    }, {
      key: "circle",
      value: function circle(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
    }, {
      key: "exp",
      value: function exp(t) {
        return Math.pow(2, 10 * (t - 1));
      }
    }, {
      key: "elastic",
      value: function elastic() {
        var bounciness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var p = bounciness * Math.PI;
        return function (t) {
          return 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * p);
        };
      }
    }, {
      key: "back",
      value: function back(s) {
        if (s === undefined) {
          s = 1.70158;
        }

        return function (t) {
          return t * t * ((s + 1) * t - s);
        };
      }
    }, {
      key: "bounce",
      value: function bounce(t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }

        if (t < 2 / 2.75) {
          t -= 1.5 / 2.75;
          return 7.5625 * t * t + 0.75;
        }

        if (t < 2.5 / 2.75) {
          t -= 2.25 / 2.75;
          return 7.5625 * t * t + 0.9375;
        }

        t -= 2.625 / 2.75;
        return 7.5625 * t * t + 0.984375;
      }
    }, {
      key: "bezier",
      value: function bezier(x1, y1, x2, y2) {
        var _bezier = require(_dependencyMap[0], 'bezier');

        return _bezier(x1, y1, x2, y2);
      }
    }, {
      key: "in",
      value: function _in(easing) {
        return easing;
      }
    }, {
      key: "out",
      value: function out(easing) {
        return function (t) {
          return 1 - easing(1 - t);
        };
      }
    }, {
      key: "inOut",
      value: function inOut(easing) {
        return function (t) {
          if (t < 0.5) {
            return easing(t * 2) / 2;
          }

          return 1 - easing((1 - t) * 2) / 2;
        };
      }
    }]);
    return Easing;
  }();

  module.exports = Easing;
},260,[261],"Easing");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === 'function';

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  module.exports = function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function BezierEasing(x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x;
      }

      if (x === 0) {
        return 0;
      }

      if (x === 1) {
        return 1;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  };
},261,[],"bezier");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Animated/src/createAnimatedComponent.js";

  var _require = require(_dependencyMap[0], './AnimatedEvent'),
      AnimatedEvent = _require.AnimatedEvent;

  var AnimatedProps = require(_dependencyMap[1], './nodes/AnimatedProps');

  var React = require(_dependencyMap[2], 'React');

  var ViewStylePropTypes = require(_dependencyMap[3], 'ViewStylePropTypes');

  function createAnimatedComponent(Component) {
    var AnimatedComponent = function (_React$Component) {
      babelHelpers.inherits(AnimatedComponent, _React$Component);

      function AnimatedComponent(props) {
        babelHelpers.classCallCheck(this, AnimatedComponent);

        var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedComponent.__proto__ || Object.getPrototypeOf(AnimatedComponent)).call(this, props));

        _this._invokeAnimatedPropsCallbackOnMount = false;
        _this._eventDetachers = [];

        _this._animatedPropsCallback = function () {
          if (_this._component == null) {
            _this._invokeAnimatedPropsCallbackOnMount = true;
          } else if (AnimatedComponent.__skipSetNativeProps_FOR_TESTS_ONLY || typeof _this._component.setNativeProps !== 'function') {
            _this.forceUpdate();
          } else if (!_this._propsAnimated.__isNative) {
            _this._component.setNativeProps(_this._propsAnimated.__getAnimatedValue());
          } else {
            throw new Error('Attempting to run JS driven animation on animated ' + 'node that has been moved to "native" earlier by starting an ' + 'animation with `useNativeDriver: true`');
          }
        };

        _this._setComponentRef = _this._setComponentRef.bind(_this);
        return _this;
      }

      babelHelpers.createClass(AnimatedComponent, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this._propsAnimated && this._propsAnimated.__detach();

          this._detachNativeEvents();
        }
      }, {
        key: "setNativeProps",
        value: function setNativeProps(props) {
          this._component.setNativeProps(props);
        }
      }, {
        key: "componentWillMount",
        value: function componentWillMount() {
          this._attachProps(this.props);
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          if (this._invokeAnimatedPropsCallbackOnMount) {
            this._invokeAnimatedPropsCallbackOnMount = false;

            this._animatedPropsCallback();
          }

          this._propsAnimated.setNativeView(this._component);

          this._attachNativeEvents();
        }
      }, {
        key: "_attachNativeEvents",
        value: function _attachNativeEvents() {
          var _this2 = this;

          var scrollableNode = this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;

          var _loop = function _loop(key) {
            var prop = _this2.props[key];

            if (prop instanceof AnimatedEvent && prop.__isNative) {
              prop.__attach(scrollableNode, key);

              _this2._eventDetachers.push(function () {
                return prop.__detach(scrollableNode, key);
              });
            }
          };

          for (var key in this.props) {
            _loop(key);
          }
        }
      }, {
        key: "_detachNativeEvents",
        value: function _detachNativeEvents() {
          this._eventDetachers.forEach(function (remove) {
            return remove();
          });

          this._eventDetachers = [];
        }
      }, {
        key: "_attachProps",
        value: function _attachProps(nextProps) {
          var oldPropsAnimated = this._propsAnimated;
          this._propsAnimated = new AnimatedProps(nextProps, this._animatedPropsCallback);
          oldPropsAnimated && oldPropsAnimated.__detach();
        }
      }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(newProps) {
          this._attachProps(newProps);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (this._component !== this._prevComponent) {
            this._propsAnimated.setNativeView(this._component);
          }

          if (this._component !== this._prevComponent || prevProps !== this.props) {
            this._detachNativeEvents();

            this._attachNativeEvents();
          }
        }
      }, {
        key: "render",
        value: function render() {
          var props = this._propsAnimated.__getValue();

          return React.createElement(Component, babelHelpers.extends({}, props, {
            ref: this._setComponentRef,
            collapsable: this._propsAnimated.__isNative ? false : props.collapsable,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 147
            }
          }));
        }
      }, {
        key: "_setComponentRef",
        value: function _setComponentRef(c) {
          this._prevComponent = this._component;
          this._component = c;
        }
      }, {
        key: "getNode",
        value: function getNode() {
          return this._component;
        }
      }]);
      return AnimatedComponent;
    }(React.Component);

    AnimatedComponent.__skipSetNativeProps_FOR_TESTS_ONLY = false;
    var propTypes = Component.propTypes;
    AnimatedComponent.propTypes = {
      style: function style(props, propName, componentName) {
        if (!propTypes) {
          return;
        }

        for (var key in ViewStylePropTypes) {
          if (!propTypes[key] && props[key] !== undefined) {
            console.warn('You are setting the style `{ ' + key + ': ... }` as a prop. You ' + 'should nest it in a style object. ' + 'E.g. `{ style: { ' + key + ': ... } }`');
          }
        }
      }
    };
    return AnimatedComponent;
  }

  module.exports = createAnimatedComponent;
},262,[237,250,171,180],"createAnimatedComponent");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Image/Image.android.js";

  var ImageResizeMode = require(_dependencyMap[0], 'ImageResizeMode');

  var ImageStylePropTypes = require(_dependencyMap[1], 'ImageStylePropTypes');

  var NativeMethodsMixin = require(_dependencyMap[2], 'NativeMethodsMixin');

  var NativeModules = require(_dependencyMap[3], 'NativeModules');

  var React = require(_dependencyMap[4], 'React');

  var PropTypes = require(_dependencyMap[5], 'prop-types');

  var ReactNativeViewAttributes = require(_dependencyMap[6], 'ReactNativeViewAttributes');

  var Set = require(_dependencyMap[7], 'Set');

  var StyleSheet = require(_dependencyMap[8], 'StyleSheet');

  var StyleSheetPropType = require(_dependencyMap[9], 'StyleSheetPropType');

  var View = require(_dependencyMap[10], 'View');

  var ViewPropTypes = require(_dependencyMap[11], 'ViewPropTypes');

  var ViewStylePropTypes = require(_dependencyMap[12], 'ViewStylePropTypes');

  var createReactClass = require(_dependencyMap[13], 'create-react-class');

  var filterObject = require(_dependencyMap[14], 'fbjs/lib/filterObject');

  var flattenStyle = require(_dependencyMap[15], 'flattenStyle');

  var merge = require(_dependencyMap[16], 'merge');

  var requireNativeComponent = require(_dependencyMap[17], 'requireNativeComponent');

  var resolveAssetSource = require(_dependencyMap[18], 'resolveAssetSource');

  var ImageLoader = NativeModules.ImageLoader;
  var _requestId = 1;

  function generateRequestId() {
    return _requestId++;
  }

  var ImageViewAttributes = merge(ReactNativeViewAttributes.UIView, {
    src: true,
    loadingIndicatorSrc: true,
    resizeMethod: true,
    resizeMode: true,
    progressiveRenderingEnabled: true,
    fadeDuration: true,
    shouldNotifyLoadEvents: true
  });
  var ViewStyleKeys = new Set(Object.keys(ViewStylePropTypes));
  var ImageSpecificStyleKeys = new Set(Object.keys(ImageStylePropTypes).filter(function (x) {
    return !ViewStyleKeys.has(x);
  }));
  var Image = createReactClass({
    displayName: 'Image',
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      style: StyleSheetPropType(ImageStylePropTypes),
      source: PropTypes.oneOfType([PropTypes.shape({
        uri: PropTypes.string,
        headers: PropTypes.objectOf(PropTypes.string)
      }), PropTypes.number, PropTypes.arrayOf(PropTypes.shape({
        uri: PropTypes.string,
        width: PropTypes.number,
        height: PropTypes.number,
        headers: PropTypes.objectOf(PropTypes.string)
      }))]),
      blurRadius: PropTypes.number,
      loadingIndicatorSource: PropTypes.oneOfType([PropTypes.shape({
        uri: PropTypes.string
      }), PropTypes.number]),
      progressiveRenderingEnabled: PropTypes.bool,
      fadeDuration: PropTypes.number,
      onLoadStart: PropTypes.func,
      onError: PropTypes.func,
      onLoad: PropTypes.func,
      onLoadEnd: PropTypes.func,
      testID: PropTypes.string,
      resizeMethod: PropTypes.oneOf(['auto', 'resize', 'scale']),
      resizeMode: PropTypes.oneOf(['cover', 'contain', 'stretch', 'center'])
    }),
    statics: {
      resizeMode: ImageResizeMode,
      getSize: function getSize(url, success, failure) {
        return ImageLoader.getSize(url).then(function (sizes) {
          success(sizes.width, sizes.height);
        }).catch(failure || function () {
          console.warn('Failed to get size for image: ' + url);
        });
      },
      prefetch: function prefetch(url, callback) {
        var requestId = generateRequestId();
        callback && callback(requestId);
        return ImageLoader.prefetchImage(url, requestId);
      },
      abortPrefetch: function abortPrefetch(requestId) {
        ImageLoader.abortRequest(requestId);
      },
      queryCache: function queryCache(urls) {
        return regeneratorRuntime.async(function queryCache$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return regeneratorRuntime.awrap(ImageLoader.queryCache(urls));

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      },
      resolveAssetSource: resolveAssetSource
    },
    mixins: [NativeMethodsMixin],
    viewConfig: {
      uiViewClassName: 'RCTView',
      validAttributes: ReactNativeViewAttributes.RCTView
    },
    contextTypes: {
      isInAParentText: PropTypes.bool
    },
    render: function render() {
      var source = resolveAssetSource(this.props.source);
      var loadingIndicatorSource = resolveAssetSource(this.props.loadingIndicatorSource);

      if (source && source.uri === '') {
        console.warn('source.uri should not be an empty string');
      }

      if (this.props.src) {
        console.warn('The <Image> component requires a `source` property rather than `src`.');
      }

      if (this.props.children) {
        throw new Error('The <Image> component cannot contain children. If you want to render content on top of the image, consider using the <ImageBackground> component or absolute positioning.');
      }

      if (source && (source.uri || Array.isArray(source))) {
        var style = void 0;
        var sources = void 0;

        if (source.uri) {
          var _width = source.width,
              _height = source.height;
          style = flattenStyle([{
            width: _width,
            height: _height
          }, styles.base, this.props.style]);
          sources = [{
            uri: source.uri
          }];
        } else {
          style = flattenStyle([styles.base, this.props.style]);
          sources = source;
        }

        var _props = this.props,
            onLoadStart = _props.onLoadStart,
            onLoad = _props.onLoad,
            onLoadEnd = _props.onLoadEnd,
            onError = _props.onError;
        var nativeProps = merge(this.props, {
          style: style,
          shouldNotifyLoadEvents: !!(onLoadStart || onLoad || onLoadEnd || onError),
          src: sources,
          headers: source.headers,
          loadingIndicatorSrc: loadingIndicatorSource ? loadingIndicatorSource.uri : null
        });

        if (this.context.isInAParentText) {
          return React.createElement(RCTTextInlineImage, babelHelpers.extends({}, nativeProps, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 302
            }
          }));
        } else {
          return React.createElement(RKImage, babelHelpers.extends({}, nativeProps, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 304
            }
          }));
        }
      }

      return null;
    }
  });
  var styles = StyleSheet.create({
    base: {
      overflow: 'hidden'
    }
  });
  var cfg = {
    nativeOnly: {
      src: true,
      headers: true,
      loadingIndicatorSrc: true,
      shouldNotifyLoadEvents: true
    }
  };
  var RKImage = requireNativeComponent('RCTImageView', Image, cfg);
  var RCTTextInlineImage = requireNativeComponent('RCTTextInlineImage', Image, cfg);
  module.exports = Image;
},263,[190,189,169,68,171,24,212,83,209,179,211,172,180,213,264,152,175,186,201],"Image");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function filterObject(object, callback, context) {
    if (!object) {
      return null;
    }

    var result = {};

    for (var name in object) {
      if (hasOwnProperty.call(object, name) && callback.call(context, object[name], name, object)) {
        result[name] = object[name];
      }
    }

    return result;
  }

  module.exports = filterObject;
},264,[],"fbjs/lib/filterObject.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js";

  var Animated = require(_dependencyMap[0], 'Animated');

  var ColorPropType = require(_dependencyMap[1], 'ColorPropType');

  var EdgeInsetsPropType = require(_dependencyMap[2], 'EdgeInsetsPropType');

  var Platform = require(_dependencyMap[3], 'Platform');

  var PointPropType = require(_dependencyMap[4], 'PointPropType');

  var PropTypes = require(_dependencyMap[5], 'prop-types');

  var React = require(_dependencyMap[6], 'React');

  var ReactNative = require(_dependencyMap[7], 'ReactNative');

  var ScrollResponder = require(_dependencyMap[8], 'ScrollResponder');

  var ScrollViewStickyHeader = require(_dependencyMap[9], 'ScrollViewStickyHeader');

  var StyleSheet = require(_dependencyMap[10], 'StyleSheet');

  var StyleSheetPropType = require(_dependencyMap[11], 'StyleSheetPropType');

  var View = require(_dependencyMap[12], 'View');

  var ViewPropTypes = require(_dependencyMap[13], 'ViewPropTypes');

  var ViewStylePropTypes = require(_dependencyMap[14], 'ViewStylePropTypes');

  var createReactClass = require(_dependencyMap[15], 'create-react-class');

  var dismissKeyboard = require(_dependencyMap[16], 'dismissKeyboard');

  var flattenStyle = require(_dependencyMap[17], 'flattenStyle');

  var invariant = require(_dependencyMap[18], 'fbjs/lib/invariant');

  var processDecelerationRate = require(_dependencyMap[19], 'processDecelerationRate');

  var requireNativeComponent = require(_dependencyMap[20], 'requireNativeComponent');

  var warning = require(_dependencyMap[21], 'fbjs/lib/warning');

  var ScrollView = createReactClass({
    displayName: 'ScrollView',
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      automaticallyAdjustContentInsets: PropTypes.bool,
      contentInset: EdgeInsetsPropType,
      contentOffset: PointPropType,
      bounces: PropTypes.bool,
      bouncesZoom: PropTypes.bool,
      alwaysBounceHorizontal: PropTypes.bool,
      alwaysBounceVertical: PropTypes.bool,
      centerContent: PropTypes.bool,
      contentContainerStyle: StyleSheetPropType(ViewStylePropTypes),
      decelerationRate: PropTypes.oneOfType([PropTypes.oneOf(['fast', 'normal']), PropTypes.number]),
      horizontal: PropTypes.bool,
      indicatorStyle: PropTypes.oneOf(['default', 'black', 'white']),
      directionalLockEnabled: PropTypes.bool,
      canCancelContentTouches: PropTypes.bool,
      keyboardDismissMode: PropTypes.oneOf(['none', 'on-drag', 'interactive']),
      keyboardShouldPersistTaps: PropTypes.oneOf(['always', 'never', 'handled', false, true]),
      maximumZoomScale: PropTypes.number,
      minimumZoomScale: PropTypes.number,
      onMomentumScrollBegin: PropTypes.func,
      onMomentumScrollEnd: PropTypes.func,
      onScroll: PropTypes.func,
      onContentSizeChange: PropTypes.func,
      pagingEnabled: PropTypes.bool,
      pinchGestureEnabled: PropTypes.bool,
      scrollEnabled: PropTypes.bool,
      scrollEventThrottle: PropTypes.number,
      scrollIndicatorInsets: EdgeInsetsPropType,
      scrollsToTop: PropTypes.bool,
      showsHorizontalScrollIndicator: PropTypes.bool,
      showsVerticalScrollIndicator: PropTypes.bool,
      stickyHeaderIndices: PropTypes.arrayOf(PropTypes.number),
      snapToInterval: PropTypes.number,
      snapToAlignment: PropTypes.oneOf(['start', 'center', 'end']),
      removeClippedSubviews: PropTypes.bool,
      zoomScale: PropTypes.number,
      contentInsetAdjustmentBehavior: PropTypes.oneOf(['automatic', 'scrollableAxes', 'never', 'always']),
      refreshControl: PropTypes.element,
      endFillColor: ColorPropType,
      scrollPerfTag: PropTypes.string,
      overScrollMode: PropTypes.oneOf(['auto', 'always', 'never']),
      DEPRECATED_sendUpdatedChildFrames: PropTypes.bool
    }),
    mixins: [ScrollResponder.Mixin],
    _scrollAnimatedValue: new Animated.Value(0),
    _scrollAnimatedValueAttachment: null,
    _stickyHeaderRefs: new Map(),
    _headerLayoutYs: new Map(),
    getInitialState: function getInitialState() {
      return this.scrollResponderMixinGetInitialState();
    },
    componentWillMount: function componentWillMount() {
      this._scrollAnimatedValue = new Animated.Value(this.props.contentOffset ? this.props.contentOffset.y : 0);

      this._scrollAnimatedValue.setOffset(this.props.contentInset ? this.props.contentInset.top : 0);

      this._stickyHeaderRefs = new Map();
      this._headerLayoutYs = new Map();
    },
    componentDidMount: function componentDidMount() {
      this._updateAnimatedNodeAttachment();
    },
    componentDidUpdate: function componentDidUpdate() {
      this._updateAnimatedNodeAttachment();
    },
    componentWillUnmount: function componentWillUnmount() {
      if (this._scrollAnimatedValueAttachment) {
        this._scrollAnimatedValueAttachment.detach();
      }
    },
    setNativeProps: function setNativeProps(props) {
      this._scrollViewRef && this._scrollViewRef.setNativeProps(props);
    },
    getScrollResponder: function getScrollResponder() {
      return this;
    },
    getScrollableNode: function getScrollableNode() {
      return ReactNative.findNodeHandle(this._scrollViewRef);
    },
    getInnerViewNode: function getInnerViewNode() {
      return ReactNative.findNodeHandle(this._innerViewRef);
    },
    scrollTo: function scrollTo(y, x, animated) {
      if (typeof y === 'number') {
        console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, ' + 'animated: true})` instead.');
      } else {
        var _ref = y || {};

        x = _ref.x;
        y = _ref.y;
        animated = _ref.animated;
      }

      this.getScrollResponder().scrollResponderScrollTo({
        x: x || 0,
        y: y || 0,
        animated: animated !== false
      });
    },
    scrollToEnd: function scrollToEnd(options) {
      var animated = (options && options.animated) !== false;
      this.getScrollResponder().scrollResponderScrollToEnd({
        animated: animated
      });
    },
    scrollWithoutAnimationTo: function scrollWithoutAnimationTo() {
      var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      console.warn('`scrollWithoutAnimationTo` is deprecated. Use `scrollTo` instead');
      this.scrollTo({
        x: x,
        y: y,
        animated: false
      });
    },
    flashScrollIndicators: function flashScrollIndicators() {
      this.getScrollResponder().scrollResponderFlashScrollIndicators();
    },
    _getKeyForIndex: function _getKeyForIndex(index, childArray) {
      var child = childArray[index];
      return child && child.key;
    },
    _updateAnimatedNodeAttachment: function _updateAnimatedNodeAttachment() {
      if (this._scrollAnimatedValueAttachment) {
        this._scrollAnimatedValueAttachment.detach();
      }

      if (this.props.stickyHeaderIndices && this.props.stickyHeaderIndices.length > 0) {
        this._scrollAnimatedValueAttachment = Animated.attachNativeEvent(this._scrollViewRef, 'onScroll', [{
          nativeEvent: {
            contentOffset: {
              y: this._scrollAnimatedValue
            }
          }
        }]);
      }
    },
    _setStickyHeaderRef: function _setStickyHeaderRef(key, ref) {
      if (ref) {
        this._stickyHeaderRefs.set(key, ref);
      } else {
        this._stickyHeaderRefs.delete(key);
      }
    },
    _onStickyHeaderLayout: function _onStickyHeaderLayout(index, event, key) {
      if (!this.props.stickyHeaderIndices) {
        return;
      }

      var childArray = React.Children.toArray(this.props.children);

      if (key !== this._getKeyForIndex(index, childArray)) {
        return;
      }

      var layoutY = event.nativeEvent.layout.y;

      this._headerLayoutYs.set(key, layoutY);

      var indexOfIndex = this.props.stickyHeaderIndices.indexOf(index);
      var previousHeaderIndex = this.props.stickyHeaderIndices[indexOfIndex - 1];

      if (previousHeaderIndex != null) {
        var previousHeader = this._stickyHeaderRefs.get(this._getKeyForIndex(previousHeaderIndex, childArray));

        previousHeader && previousHeader.setNextHeaderY(layoutY);
      }
    },
    _handleScroll: function _handleScroll(e) {
      if (__DEV__) {
        if (this.props.onScroll && this.props.scrollEventThrottle == null && Platform.OS === 'ios') {
          console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + 'cause frame drops, use a bigger number if you don\'t need as ' + 'much precision.');
        }
      }

      if (Platform.OS === 'android') {
        if (this.props.keyboardDismissMode === 'on-drag') {
          dismissKeyboard();
        }
      }

      this.scrollResponderHandleScroll(e);
    },
    _handleContentOnLayout: function _handleContentOnLayout(e) {
      var _e$nativeEvent$layout = e.nativeEvent.layout,
          width = _e$nativeEvent$layout.width,
          height = _e$nativeEvent$layout.height;
      this.props.onContentSizeChange && this.props.onContentSizeChange(width, height);
    },
    _scrollViewRef: null,
    _setScrollViewRef: function _setScrollViewRef(ref) {
      this._scrollViewRef = ref;
    },
    _innerViewRef: null,
    _setInnerViewRef: function _setInnerViewRef(ref) {
      this._innerViewRef = ref;
    },
    render: function render() {
      var _this = this;

      var ScrollViewClass = void 0;
      var ScrollContentContainerViewClass = void 0;

      if (Platform.OS === 'ios') {
        ScrollViewClass = RCTScrollView;
        ScrollContentContainerViewClass = RCTScrollContentView;
        warning(!this.props.snapToInterval || !this.props.pagingEnabled, 'snapToInterval is currently ignored when pagingEnabled is true.');
      } else if (Platform.OS === 'android') {
        if (this.props.horizontal) {
          ScrollViewClass = AndroidHorizontalScrollView;
          ScrollContentContainerViewClass = AndroidHorizontalScrollContentView;
        } else {
          ScrollViewClass = AndroidScrollView;
          ScrollContentContainerViewClass = View;
        }
      }

      invariant(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');
      invariant(ScrollContentContainerViewClass !== undefined, 'ScrollContentContainerViewClass must not be undefined');
      var contentContainerStyle = [this.props.horizontal && styles.contentContainerHorizontal, this.props.contentContainerStyle];
      var style = void 0,
          childLayoutProps = void 0;

      if (__DEV__ && this.props.style) {
        style = flattenStyle(this.props.style);
        childLayoutProps = ['alignItems', 'justifyContent'].filter(function (prop) {
          return style && style[prop] !== undefined;
        });
        invariant(childLayoutProps.length === 0, 'ScrollView child layout (' + JSON.stringify(childLayoutProps) + ') must be applied through the contentContainerStyle prop.');
      }

      var contentSizeChangeProps = {};

      if (this.props.onContentSizeChange) {
        contentSizeChangeProps = {
          onLayout: this._handleContentOnLayout
        };
      }

      var stickyHeaderIndices = this.props.stickyHeaderIndices;
      var hasStickyHeaders = stickyHeaderIndices && stickyHeaderIndices.length > 0;
      var childArray = hasStickyHeaders && React.Children.toArray(this.props.children);
      var children = hasStickyHeaders ? childArray.map(function (child, index) {
        var indexOfIndex = child ? stickyHeaderIndices.indexOf(index) : -1;

        if (indexOfIndex > -1) {
          var key = child.key;
          var nextIndex = stickyHeaderIndices[indexOfIndex + 1];
          return React.createElement(
            ScrollViewStickyHeader,
            {
              key: key,
              ref: function ref(_ref2) {
                return _this._setStickyHeaderRef(key, _ref2);
              },
              nextHeaderLayoutY: _this._headerLayoutYs.get(_this._getKeyForIndex(nextIndex, childArray)),
              onLayout: function onLayout(event) {
                return _this._onStickyHeaderLayout(index, event, key);
              },
              scrollAnimatedValue: _this._scrollAnimatedValue,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 700
              }
            },
            child
          );
        } else {
          return child;
        }
      }) : this.props.children;
      var contentContainer = React.createElement(
        ScrollContentContainerViewClass,
        babelHelpers.extends({}, contentSizeChangeProps, {
          ref: this._setInnerViewRef,
          style: contentContainerStyle,
          removeClippedSubviews: Platform.OS === 'android' && hasStickyHeaders ? false : this.props.removeClippedSubviews,
          collapsable: false,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 717
          }
        }),
        children
      );
      var alwaysBounceHorizontal = this.props.alwaysBounceHorizontal !== undefined ? this.props.alwaysBounceHorizontal : this.props.horizontal;
      var alwaysBounceVertical = this.props.alwaysBounceVertical !== undefined ? this.props.alwaysBounceVertical : !this.props.horizontal;
      var DEPRECATED_sendUpdatedChildFrames = !!this.props.DEPRECATED_sendUpdatedChildFrames;
      var baseStyle = this.props.horizontal ? styles.baseHorizontal : styles.baseVertical;
      var props = babelHelpers.extends({}, this.props, {
        alwaysBounceHorizontal: alwaysBounceHorizontal,
        alwaysBounceVertical: alwaysBounceVertical,
        style: [baseStyle, this.props.style],
        onContentSizeChange: null,
        onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,
        onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,
        onResponderGrant: this.scrollResponderHandleResponderGrant,
        onResponderReject: this.scrollResponderHandleResponderReject,
        onResponderRelease: this.scrollResponderHandleResponderRelease,
        onResponderTerminate: this.scrollResponderHandleTerminate,
        onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,
        onScroll: this._handleScroll,
        onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,
        onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,
        onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,
        onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,
        onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,
        onTouchEnd: this.scrollResponderHandleTouchEnd,
        onTouchMove: this.scrollResponderHandleTouchMove,
        onTouchStart: this.scrollResponderHandleTouchStart,
        onTouchCancel: this.scrollResponderHandleTouchCancel,
        scrollEventThrottle: hasStickyHeaders ? 1 : this.props.scrollEventThrottle,
        sendMomentumEvents: this.props.onMomentumScrollBegin || this.props.onMomentumScrollEnd ? true : false,
        DEPRECATED_sendUpdatedChildFrames: DEPRECATED_sendUpdatedChildFrames
      });
      var decelerationRate = this.props.decelerationRate;

      if (decelerationRate) {
        props.decelerationRate = processDecelerationRate(decelerationRate);
      }

      var refreshControl = this.props.refreshControl;

      if (refreshControl) {
        if (Platform.OS === 'ios') {
          return React.createElement(
            ScrollViewClass,
            babelHelpers.extends({}, props, {
              ref: this._setScrollViewRef,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 789
              }
            }),
            Platform.isTVOS ? null : refreshControl,
            contentContainer
          );
        } else if (Platform.OS === 'android') {
          return React.cloneElement(refreshControl, {
            style: props.style
          }, React.createElement(
            ScrollViewClass,
            babelHelpers.extends({}, props, {
              style: baseStyle,
              ref: this._setScrollViewRef,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 804
              }
            }),
            contentContainer
          ));
        }
      }

      return React.createElement(
        ScrollViewClass,
        babelHelpers.extends({}, props, {
          ref: this._setScrollViewRef,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 811
          }
        }),
        contentContainer
      );
    }
  });
  var styles = StyleSheet.create({
    baseVertical: {
      flexGrow: 1,
      flexShrink: 1,
      flexDirection: 'column',
      overflow: 'scroll'
    },
    baseHorizontal: {
      flexGrow: 1,
      flexShrink: 1,
      flexDirection: 'row',
      overflow: 'scroll'
    },
    contentContainerHorizontal: {
      flexDirection: 'row'
    }
  });
  var nativeOnlyProps = void 0,
      AndroidScrollView = void 0,
      AndroidHorizontalScrollContentView = void 0,
      AndroidHorizontalScrollView = void 0,
      RCTScrollView = void 0,
      RCTScrollContentView = void 0;

  if (Platform.OS === 'android') {
    nativeOnlyProps = {
      nativeOnly: {
        sendMomentumEvents: true
      }
    };
    AndroidScrollView = requireNativeComponent('RCTScrollView', ScrollView, nativeOnlyProps);
    AndroidHorizontalScrollView = requireNativeComponent('AndroidHorizontalScrollView', ScrollView, nativeOnlyProps);
    AndroidHorizontalScrollContentView = requireNativeComponent('AndroidHorizontalScrollContentView');
  } else if (Platform.OS === 'ios') {
    nativeOnlyProps = {
      nativeOnly: {
        onMomentumScrollBegin: true,
        onMomentumScrollEnd: true,
        onScrollBeginDrag: true,
        onScrollEndDrag: true
      }
    };
    RCTScrollView = requireNativeComponent('RCTScrollView', ScrollView, nativeOnlyProps);
    RCTScrollContentView = requireNativeComponent('RCTScrollContentView', View);
  }

  module.exports = ScrollView;
},265,[235,167,173,105,266,24,171,74,267,274,209,179,211,172,180,213,270,152,18,275,186,19],"ScrollView");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var PropTypes = require(_dependencyMap[0], 'prop-types');

  var createStrictShapeTypeChecker = require(_dependencyMap[1], 'createStrictShapeTypeChecker');

  var PointPropType = createStrictShapeTypeChecker({
    x: PropTypes.number,
    y: PropTypes.number
  });
  module.exports = PointPropType;
},266,[24,174],"PointPropType");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Dimensions = require(_dependencyMap[0], 'Dimensions');

  var FrameRateLogger = require(_dependencyMap[1], 'FrameRateLogger');

  var Keyboard = require(_dependencyMap[2], 'Keyboard');

  var ReactNative = require(_dependencyMap[3], 'ReactNative');

  var Subscribable = require(_dependencyMap[4], 'Subscribable');

  var TextInputState = require(_dependencyMap[5], 'TextInputState');

  var UIManager = require(_dependencyMap[6], 'UIManager');

  var invariant = require(_dependencyMap[7], 'fbjs/lib/invariant');

  var nullthrows = require(_dependencyMap[8], 'fbjs/lib/nullthrows');

  var performanceNow = require(_dependencyMap[9], 'fbjs/lib/performanceNow');

  var warning = require(_dependencyMap[10], 'fbjs/lib/warning');

  var _require = require(_dependencyMap[11], 'NativeModules'),
      ScrollViewManager = _require.ScrollViewManager;

  var _require2 = require(_dependencyMap[12], 'ReactNativeComponentTree'),
      getInstanceFromNode = _require2.getInstanceFromNode;

  var IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;

  function isTagInstanceOfTextInput(tag) {
    var instance = getInstanceFromNode(tag);
    return instance && instance.viewConfig && (instance.viewConfig.uiViewClassName === 'AndroidTextInput' || instance.viewConfig.uiViewClassName === 'RCTTextView' || instance.viewConfig.uiViewClassName === 'RCTTextField');
  }

  var ScrollResponderMixin = {
    mixins: [Subscribable.Mixin],
    scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {
      return {
        isTouching: false,
        lastMomentumScrollBeginTime: 0,
        lastMomentumScrollEndTime: 0,
        observedScrollSinceBecomingResponder: false,
        becameResponderWhileAnimating: false
      };
    },
    scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {
      return this.state.isTouching;
    },
    scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder(e) {
      var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();

      if (this.props.keyboardShouldPersistTaps === 'handled' && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput) {
        return true;
      }

      return false;
    },
    scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {
      var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
      var keyboardShouldPersistTaps = this.props.keyboardShouldPersistTaps;
      var keyboardNeverPersistTaps = !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';

      if (keyboardNeverPersistTaps && currentlyFocusedTextInput != null && !isTagInstanceOfTextInput(e.target)) {
        return true;
      }

      return this.scrollResponderIsAnimating();
    },
    scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {},
    scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {
      return !this.state.observedScrollSinceBecomingResponder;
    },
    scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {
      var nativeEvent = e.nativeEvent;
      this.state.isTouching = nativeEvent.touches.length !== 0;
      this.props.onTouchEnd && this.props.onTouchEnd(e);
    },
    scrollResponderHandleTouchCancel: function scrollResponderHandleTouchCancel(e) {
      this.state.isTouching = false;
      this.props.onTouchCancel && this.props.onTouchCancel(e);
    },
    scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {
      this.props.onResponderRelease && this.props.onResponderRelease(e);
      var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();

      if (this.props.keyboardShouldPersistTaps !== true && this.props.keyboardShouldPersistTaps !== 'always' && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {
        this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);
        TextInputState.blurTextInput(currentlyFocusedTextInput);
      }
    },
    scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {
      this.state.observedScrollSinceBecomingResponder = true;
      this.props.onScroll && this.props.onScroll(e);
    },
    scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {
      this.state.observedScrollSinceBecomingResponder = false;
      this.props.onResponderGrant && this.props.onResponderGrant(e);
      this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
    },
    scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {
      FrameRateLogger.beginScroll();
      this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
    },
    scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {
      var velocity = e.nativeEvent.velocity;

      if (!this.scrollResponderIsAnimating() && (!velocity || velocity.x === 0 && velocity.y === 0)) {
        FrameRateLogger.endScroll();
      }

      this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
    },
    scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {
      this.state.lastMomentumScrollBeginTime = performanceNow();
      this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
    },
    scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {
      FrameRateLogger.endScroll();
      this.state.lastMomentumScrollEndTime = performanceNow();
      this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
    },
    scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {
      this.state.isTouching = true;
      this.props.onTouchStart && this.props.onTouchStart(e);
    },
    scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {
      this.props.onTouchMove && this.props.onTouchMove(e);
    },
    scrollResponderIsAnimating: function scrollResponderIsAnimating() {
      var now = performanceNow();
      var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;
      var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;
      return isAnimating;
    },
    scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {
      return this.getScrollableNode ? this.getScrollableNode() : ReactNative.findNodeHandle(this);
    },
    scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {
      if (typeof x === 'number') {
        console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');
      } else {
        var _ref = x || {};

        x = _ref.x;
        y = _ref.y;
        animated = _ref.animated;
      }

      UIManager.dispatchViewManagerCommand(nullthrows(this.scrollResponderGetScrollableNode()), UIManager.RCTScrollView.Commands.scrollTo, [x || 0, y || 0, animated !== false]);
    },
    scrollResponderScrollToEnd: function scrollResponderScrollToEnd(options) {
      var animated = (options && options.animated) !== false;
      UIManager.dispatchViewManagerCommand(this.scrollResponderGetScrollableNode(), UIManager.RCTScrollView.Commands.scrollToEnd, [animated]);
    },
    scrollResponderScrollWithoutAnimationTo: function scrollResponderScrollWithoutAnimationTo(offsetX, offsetY) {
      console.warn('`scrollResponderScrollWithoutAnimationTo` is deprecated. Use `scrollResponderScrollTo` instead');
      this.scrollResponderScrollTo({
        x: offsetX,
        y: offsetY,
        animated: false
      });
    },
    scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) {
      invariant(ScrollViewManager && ScrollViewManager.zoomToRect, 'zoomToRect is not implemented');

      if ('animated' in rect) {
        var animated = rect.animated,
            rect = babelHelpers.objectWithoutProperties(rect, ["animated"]);
      } else if (typeof animated !== 'undefined') {
        console.warn('`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead');
      }

      ScrollViewManager.zoomToRect(this.scrollResponderGetScrollableNode(), rect, animated !== false);
    },
    scrollResponderFlashScrollIndicators: function scrollResponderFlashScrollIndicators() {
      UIManager.dispatchViewManagerCommand(this.scrollResponderGetScrollableNode(), UIManager.RCTScrollView.Commands.flashScrollIndicators, []);
    },
    scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {
      this.additionalScrollOffset = additionalOffset || 0;
      this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;
      UIManager.measureLayout(nodeHandle, ReactNative.findNodeHandle(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
    },
    scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {
      var keyboardScreenY = Dimensions.get('window').height;

      if (this.keyboardWillOpenTo) {
        keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;
      }

      var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;

      if (this.preventNegativeScrollOffset) {
        scrollOffsetY = Math.max(0, scrollOffsetY);
      }

      this.scrollResponderScrollTo({
        x: 0,
        y: scrollOffsetY,
        animated: true
      });
      this.additionalOffset = 0;
      this.preventNegativeScrollOffset = false;
    },
    scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {
      console.error('Error measuring text field: ', e);
    },
    componentWillMount: function componentWillMount() {
      var keyboardShouldPersistTaps = this.props.keyboardShouldPersistTaps;
      warning(typeof keyboardShouldPersistTaps !== 'boolean', "'keyboardShouldPersistTaps={" + keyboardShouldPersistTaps + "}' is deprecated. " + ("Use 'keyboardShouldPersistTaps=\"" + (keyboardShouldPersistTaps ? 'always' : 'never') + "\"' instead"));
      this.keyboardWillOpenTo = null;
      this.additionalScrollOffset = 0;
      this.addListenerOn(Keyboard, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);
      this.addListenerOn(Keyboard, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);
      this.addListenerOn(Keyboard, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);
      this.addListenerOn(Keyboard, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);
    },
    scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {
      this.keyboardWillOpenTo = e;
      this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);
    },
    scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {
      this.keyboardWillOpenTo = null;
      this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);
    },
    scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {
      if (e) {
        this.keyboardWillOpenTo = e;
      }

      this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);
    },
    scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {
      this.keyboardWillOpenTo = null;
      this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);
    }
  };
  var ScrollResponder = {
    Mixin: ScrollResponderMixin
  };
  module.exports = ScrollResponder;
},267,[205,268,269,74,271,159,158,18,272,106,19,68,273],"ScrollResponder");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = require(_dependencyMap[0], 'NativeModules');

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  var FrameRateLogger = {
    setGlobalOptions: function setGlobalOptions(options) {
      if (options.debug !== undefined) {
        invariant(NativeModules.FrameRateLogger, 'Trying to debug FrameRateLogger without the native module!');
      }

      NativeModules.FrameRateLogger && NativeModules.FrameRateLogger.setGlobalOptions(options);
    },
    setContext: function setContext(context) {
      NativeModules.FrameRateLogger && NativeModules.FrameRateLogger.setContext(context);
    },
    beginScroll: function beginScroll() {
      NativeModules.FrameRateLogger && NativeModules.FrameRateLogger.beginScroll();
    },
    endScroll: function endScroll() {
      NativeModules.FrameRateLogger && NativeModules.FrameRateLogger.endScroll();
    }
  };
  module.exports = FrameRateLogger;
},268,[68,18],"FrameRateLogger");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var NativeEventEmitter = require(_dependencyMap[1], 'NativeEventEmitter');

  var KeyboardObserver = require(_dependencyMap[2], 'NativeModules').KeyboardObserver;

  var dismissKeyboard = require(_dependencyMap[3], 'dismissKeyboard');

  var KeyboardEventEmitter = new NativeEventEmitter(KeyboardObserver);
  var Keyboard = {
    addListener: function addListener(eventName, callback) {
      invariant(false, 'Dummy method used for documentation');
    },
    removeListener: function removeListener(eventName, callback) {
      invariant(false, 'Dummy method used for documentation');
    },
    removeAllListeners: function removeAllListeners(eventName) {
      invariant(false, 'Dummy method used for documentation');
    },
    dismiss: function dismiss() {
      invariant(false, 'Dummy method used for documentation');
    }
  };
  Keyboard = KeyboardEventEmitter;
  Keyboard.dismiss = dismissKeyboard;
  module.exports = Keyboard;
},269,[18,120,68,270],"Keyboard");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var TextInputState = require(_dependencyMap[0], 'TextInputState');

  function dismissKeyboard() {
    TextInputState.blurTextInput(TextInputState.currentlyFocusedField());
  }

  module.exports = dismissKeyboard;
},270,[159],"dismissKeyboard");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Subscribable = {};
  Subscribable.Mixin = {
    componentWillMount: function componentWillMount() {
      this._subscribableSubscriptions = [];
    },
    componentWillUnmount: function componentWillUnmount() {
      this._subscribableSubscriptions.forEach(function (subscription) {
        return subscription.remove();
      });

      this._subscribableSubscriptions = null;
    },
    addListenerOn: function addListenerOn(eventEmitter, eventType, listener, context) {
      this._subscribableSubscriptions.push(eventEmitter.addListener(eventType, listener, context));
    }
  };
  module.exports = Subscribable;
},271,[],"Subscribable");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  var nullthrows = function nullthrows(x) {
    if (x != null) {
      return x;
    }

    throw new Error("Got unexpected null or undefined");
  };

  module.exports = nullthrows;
},272,[],"fbjs/lib/nullthrows.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'ReactNative'),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  module.exports = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactNativeComponentTree;
},273,[74],"ReactNativeComponentTree");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js";

  var Animated = require(_dependencyMap[0], 'Animated');

  var React = require(_dependencyMap[1], 'React');

  var StyleSheet = require(_dependencyMap[2], 'StyleSheet');

  var ScrollViewStickyHeader = function (_React$Component) {
    babelHelpers.inherits(ScrollViewStickyHeader, _React$Component);

    function ScrollViewStickyHeader(props, context) {
      babelHelpers.classCallCheck(this, ScrollViewStickyHeader);

      var _this = babelHelpers.possibleConstructorReturn(this, (ScrollViewStickyHeader.__proto__ || Object.getPrototypeOf(ScrollViewStickyHeader)).call(this, props, context));

      _this._onLayout = function (event) {
        _this.setState({
          measured: true,
          layoutY: event.nativeEvent.layout.y,
          layoutHeight: event.nativeEvent.layout.height
        });

        _this.props.onLayout(event);

        var child = React.Children.only(_this.props.children);

        if (child.props.onLayout) {
          child.props.onLayout(event);
        }
      };

      _this.state = {
        measured: false,
        layoutY: 0,
        layoutHeight: 0,
        nextHeaderLayoutY: props.nextHeaderLayoutY
      };
      return _this;
    }

    babelHelpers.createClass(ScrollViewStickyHeader, [{
      key: "setNextHeaderY",
      value: function setNextHeaderY(y) {
        this.setState({
          nextHeaderLayoutY: y
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _state = this.state,
            measured = _state.measured,
            layoutHeight = _state.layoutHeight,
            layoutY = _state.layoutY,
            nextHeaderLayoutY = _state.nextHeaderLayoutY;
        var inputRange = [-1, 0];
        var outputRange = [0, 0];

        if (measured) {
          inputRange.push(layoutY);
          outputRange.push(0);
          var collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;

          if (collisionPoint >= layoutY) {
            inputRange.push(collisionPoint, collisionPoint + 1);
            outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);
          } else {
            inputRange.push(layoutY + 1);
            outputRange.push(1);
          }
        }

        var translateY = this.props.scrollAnimatedValue.interpolate({
          inputRange: inputRange,
          outputRange: outputRange
        });
        var child = React.Children.only(this.props.children);
        return React.createElement(
          Animated.View,
          {
            collapsable: false,
            onLayout: this._onLayout,
            style: [child.props.style, styles.header, {
              transform: [{
                translateY: translateY
              }]
            }],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 96
            }
          },
          React.cloneElement(child, {
            style: styles.fill,
            onLayout: undefined
          })
        );
      }
    }]);
    return ScrollViewStickyHeader;
  }(React.Component);

  var styles = StyleSheet.create({
    header: {
      zIndex: 10
    },
    fill: {
      flex: 1
    }
  });
  module.exports = ScrollViewStickyHeader;
},274,[235,171,209],"ScrollViewStickyHeader");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function processDecelerationRate(decelerationRate) {
    if (decelerationRate === 'normal') {
      decelerationRate = 0.998;
    } else if (decelerationRate === 'fast') {
      decelerationRate = 0.99;
    }

    return decelerationRate;
  }

  module.exports = processDecelerationRate;
},275,[],"processDecelerationRate");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/CheckBox/CheckBox.android.js";

  var NativeMethodsMixin = require(_dependencyMap[0], 'NativeMethodsMixin');

  var PropTypes = require(_dependencyMap[1], 'prop-types');

  var React = require(_dependencyMap[2], 'React');

  var StyleSheet = require(_dependencyMap[3], 'StyleSheet');

  var ViewPropTypes = require(_dependencyMap[4], 'ViewPropTypes');

  var createReactClass = require(_dependencyMap[5], 'create-react-class');

  var requireNativeComponent = require(_dependencyMap[6], 'requireNativeComponent');

  var CheckBox = createReactClass({
    displayName: 'CheckBox',
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      value: PropTypes.bool,
      disabled: PropTypes.bool,
      onChange: PropTypes.func,
      onValueChange: PropTypes.func,
      testID: PropTypes.string
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        value: false,
        disabled: false
      };
    },
    mixins: [NativeMethodsMixin],
    _rctCheckBox: {},
    _onChange: function _onChange(event) {
      this._rctCheckBox.setNativeProps({
        value: this.props.value
      });

      this.props.onChange && this.props.onChange(event);
      this.props.onValueChange && this.props.onValueChange(event.nativeEvent.value);
    },
    render: function render() {
      var _this = this;

      var props = babelHelpers.extends({}, this.props);

      props.onStartShouldSetResponder = function () {
        return true;
      };

      props.onResponderTerminationRequest = function () {
        return false;
      };

      props.enabled = !this.props.disabled;
      props.on = this.props.value;
      props.style = [styles.rctCheckBox, this.props.style];
      return React.createElement(RCTCheckBox, babelHelpers.extends({}, props, {
        ref: function ref(_ref) {
          _this._rctCheckBox = _ref;
        },
        onChange: this._onChange,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 140
        }
      }));
    }
  });
  var styles = StyleSheet.create({
    rctCheckBox: {
      height: 32,
      width: 32
    }
  });
  var RCTCheckBox = requireNativeComponent('AndroidCheckBox', CheckBox, {
    nativeOnly: {
      onChange: true,
      on: true,
      enabled: true
    }
  });
  module.exports = CheckBox;
},276,[169,24,171,209,172,213,186],"CheckBox");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/DatePicker/DatePickerIOS.android.js";

  var React = require(_dependencyMap[0], 'React');

  var StyleSheet = require(_dependencyMap[1], 'StyleSheet');

  var Text = require(_dependencyMap[2], 'Text');

  var View = require(_dependencyMap[3], 'View');

  var DummyDatePickerIOS = function (_React$Component) {
    babelHelpers.inherits(DummyDatePickerIOS, _React$Component);

    function DummyDatePickerIOS() {
      babelHelpers.classCallCheck(this, DummyDatePickerIOS);
      return babelHelpers.possibleConstructorReturn(this, (DummyDatePickerIOS.__proto__ || Object.getPrototypeOf(DummyDatePickerIOS)).apply(this, arguments));
    }

    babelHelpers.createClass(DummyDatePickerIOS, [{
      key: "render",
      value: function render() {
        return React.createElement(
          View,
          {
            style: [styles.dummyDatePickerIOS, this.props.style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 22
            }
          },
          React.createElement(
            Text,
            {
              style: styles.datePickerText,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 23
              }
            },
            "DatePickerIOS is not supported on this platform!"
          )
        );
      }
    }]);
    return DummyDatePickerIOS;
  }(React.Component);

  var styles = StyleSheet.create({
    dummyDatePickerIOS: {
      height: 100,
      width: 300,
      backgroundColor: '#ffbcbc',
      borderWidth: 1,
      borderColor: 'red',
      alignItems: 'center',
      justifyContent: 'center',
      margin: 10
    },
    datePickerText: {
      color: '#333333',
      margin: 20
    }
  });
  module.exports = DummyDatePickerIOS;
},277,[171,209,222,211],"DatePickerIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/DrawerAndroid/DrawerLayoutAndroid.android.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var NativeMethodsMixin = require(_dependencyMap[1], 'NativeMethodsMixin');

  var Platform = require(_dependencyMap[2], 'Platform');

  var React = require(_dependencyMap[3], 'React');

  var PropTypes = require(_dependencyMap[4], 'prop-types');

  var ReactNative = require(_dependencyMap[5], 'ReactNative');

  var StatusBar = require(_dependencyMap[6], 'StatusBar');

  var StyleSheet = require(_dependencyMap[7], 'StyleSheet');

  var UIManager = require(_dependencyMap[8], 'UIManager');

  var View = require(_dependencyMap[9], 'View');

  var ViewPropTypes = require(_dependencyMap[10], 'ViewPropTypes');

  var DrawerConsts = UIManager.AndroidDrawerLayout.Constants;

  var createReactClass = require(_dependencyMap[11], 'create-react-class');

  var dismissKeyboard = require(_dependencyMap[12], 'dismissKeyboard');

  var requireNativeComponent = require(_dependencyMap[13], 'requireNativeComponent');

  var RK_DRAWER_REF = 'drawerlayout';
  var INNERVIEW_REF = 'innerView';
  var DRAWER_STATES = ['Idle', 'Dragging', 'Settling'];
  var DrawerLayoutAndroid = createReactClass({
    displayName: 'DrawerLayoutAndroid',
    statics: {
      positions: DrawerConsts.DrawerPosition
    },
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      keyboardDismissMode: PropTypes.oneOf(['none', 'on-drag']),
      drawerBackgroundColor: ColorPropType,
      drawerPosition: PropTypes.oneOf([DrawerConsts.DrawerPosition.Left, DrawerConsts.DrawerPosition.Right]),
      drawerWidth: PropTypes.number,
      drawerLockMode: PropTypes.oneOf(['unlocked', 'locked-closed', 'locked-open']),
      onDrawerSlide: PropTypes.func,
      onDrawerStateChanged: PropTypes.func,
      onDrawerOpen: PropTypes.func,
      onDrawerClose: PropTypes.func,
      renderNavigationView: PropTypes.func.isRequired,
      statusBarBackgroundColor: ColorPropType
    }),
    mixins: [NativeMethodsMixin],
    getDefaultProps: function getDefaultProps() {
      return {
        drawerBackgroundColor: 'white'
      };
    },
    getInitialState: function getInitialState() {
      return {
        statusBarBackgroundColor: undefined
      };
    },
    getInnerViewNode: function getInnerViewNode() {
      return this.refs[INNERVIEW_REF].getInnerViewNode();
    },
    render: function render() {
      var drawStatusBar = Platform.Version >= 21 && this.props.statusBarBackgroundColor;
      var drawerViewWrapper = React.createElement(
        View,
        {
          style: [styles.drawerSubview, {
            width: this.props.drawerWidth,
            backgroundColor: this.props.drawerBackgroundColor
          }],
          collapsable: false,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 176
          }
        },
        this.props.renderNavigationView(),
        drawStatusBar && React.createElement(View, {
          style: styles.drawerStatusBar,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 183
          }
        })
      );
      var childrenWrapper = React.createElement(
        View,
        {
          ref: INNERVIEW_REF,
          style: styles.mainSubview,
          collapsable: false,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 186
          }
        },
        drawStatusBar && React.createElement(StatusBar, {
          translucent: true,
          backgroundColor: this.props.statusBarBackgroundColor,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 188
          }
        }),
        drawStatusBar && React.createElement(View, {
          style: [styles.statusBar, {
            backgroundColor: this.props.statusBarBackgroundColor
          }],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 193
          }
        }),
        this.props.children
      );
      return React.createElement(
        AndroidDrawerLayout,
        babelHelpers.extends({}, this.props, {
          ref: RK_DRAWER_REF,
          drawerWidth: this.props.drawerWidth,
          drawerPosition: this.props.drawerPosition,
          drawerLockMode: this.props.drawerLockMode,
          style: [styles.base, this.props.style],
          onDrawerSlide: this._onDrawerSlide,
          onDrawerOpen: this._onDrawerOpen,
          onDrawerClose: this._onDrawerClose,
          onDrawerStateChanged: this._onDrawerStateChanged,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 200
          }
        }),
        childrenWrapper,
        drawerViewWrapper
      );
    },
    _onDrawerSlide: function _onDrawerSlide(event) {
      if (this.props.onDrawerSlide) {
        this.props.onDrawerSlide(event);
      }

      if (this.props.keyboardDismissMode === 'on-drag') {
        dismissKeyboard();
      }
    },
    _onDrawerOpen: function _onDrawerOpen() {
      if (this.props.onDrawerOpen) {
        this.props.onDrawerOpen();
      }
    },
    _onDrawerClose: function _onDrawerClose() {
      if (this.props.onDrawerClose) {
        this.props.onDrawerClose();
      }
    },
    _onDrawerStateChanged: function _onDrawerStateChanged(event) {
      if (this.props.onDrawerStateChanged) {
        this.props.onDrawerStateChanged(DRAWER_STATES[event.nativeEvent.drawerState]);
      }
    },
    openDrawer: function openDrawer() {
      UIManager.dispatchViewManagerCommand(this._getDrawerLayoutHandle(), UIManager.AndroidDrawerLayout.Commands.openDrawer, null);
    },
    closeDrawer: function closeDrawer() {
      UIManager.dispatchViewManagerCommand(this._getDrawerLayoutHandle(), UIManager.AndroidDrawerLayout.Commands.closeDrawer, null);
    },
    _getDrawerLayoutHandle: function _getDrawerLayoutHandle() {
      return ReactNative.findNodeHandle(this.refs[RK_DRAWER_REF]);
    }
  });
  var styles = StyleSheet.create({
    base: {
      flex: 1,
      elevation: 16
    },
    mainSubview: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    drawerSubview: {
      position: 'absolute',
      top: 0,
      bottom: 0
    },
    statusBar: {
      height: StatusBar.currentHeight
    },
    drawerStatusBar: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      height: StatusBar.currentHeight,
      backgroundColor: 'rgba(0, 0, 0, 0.251)'
    }
  });
  var AndroidDrawerLayout = requireNativeComponent('AndroidDrawerLayout', DrawerLayoutAndroid);
  module.exports = DrawerLayoutAndroid;
},278,[167,169,105,171,24,74,279,209,158,211,172,213,270,186],"DrawerLayoutAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var React = require(_dependencyMap[0], 'React');

  var PropTypes = require(_dependencyMap[1], 'prop-types');

  var ColorPropType = require(_dependencyMap[2], 'ColorPropType');

  var Platform = require(_dependencyMap[3], 'Platform');

  var processColor = require(_dependencyMap[4], 'processColor');

  var StatusBarManager = require(_dependencyMap[5], 'NativeModules').StatusBarManager;

  function mergePropsStack(propsStack, defaultValues) {
    return propsStack.reduce(function (prev, cur) {
      for (var prop in cur) {
        if (cur[prop] != null) {
          prev[prop] = cur[prop];
        }
      }

      return prev;
    }, babelHelpers.extends({}, defaultValues));
  }

  function createStackEntry(props) {
    return {
      backgroundColor: props.backgroundColor != null ? {
        value: props.backgroundColor,
        animated: props.animated
      } : null,
      barStyle: props.barStyle != null ? {
        value: props.barStyle,
        animated: props.animated
      } : null,
      translucent: props.translucent,
      hidden: props.hidden != null ? {
        value: props.hidden,
        animated: props.animated,
        transition: props.showHideTransition
      } : null,
      networkActivityIndicatorVisible: props.networkActivityIndicatorVisible
    };
  }

  var StatusBar = function (_React$Component) {
    babelHelpers.inherits(StatusBar, _React$Component);

    function StatusBar() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, StatusBar);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = StatusBar.__proto__ || Object.getPrototypeOf(StatusBar)).call.apply(_ref, [this].concat(args))), _this), _this._stackEntry = null, _this._updatePropsStack = function () {
        clearImmediate(StatusBar._updateImmediate);
        StatusBar._updateImmediate = setImmediate(function () {
          var oldProps = StatusBar._currentValues;
          var mergedProps = mergePropsStack(StatusBar._propsStack, StatusBar._defaultProps);

          if (Platform.OS === 'ios') {
            if (!oldProps || oldProps.barStyle.value !== mergedProps.barStyle.value) {
              StatusBarManager.setStyle(mergedProps.barStyle.value, mergedProps.barStyle.animated);
            }

            if (!oldProps || oldProps.hidden.value !== mergedProps.hidden.value) {
              StatusBarManager.setHidden(mergedProps.hidden.value, mergedProps.hidden.animated ? mergedProps.hidden.transition : 'none');
            }

            if (!oldProps || oldProps.networkActivityIndicatorVisible !== mergedProps.networkActivityIndicatorVisible) {
              StatusBarManager.setNetworkActivityIndicatorVisible(mergedProps.networkActivityIndicatorVisible);
            }
          } else if (Platform.OS === 'android') {
            if (!oldProps || oldProps.barStyle.value !== mergedProps.barStyle.value) {
              StatusBarManager.setStyle(mergedProps.barStyle.value);
            }

            if (!oldProps || oldProps.backgroundColor.value !== mergedProps.backgroundColor.value) {
              StatusBarManager.setColor(processColor(mergedProps.backgroundColor.value), mergedProps.backgroundColor.animated);
            }

            if (!oldProps || oldProps.hidden.value !== mergedProps.hidden.value) {
              StatusBarManager.setHidden(mergedProps.hidden.value);
            }

            if (!oldProps || oldProps.translucent !== mergedProps.translucent) {
              StatusBarManager.setTranslucent(mergedProps.translucent);
            }
          }

          StatusBar._currentValues = mergedProps;
        });
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(StatusBar, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._stackEntry = createStackEntry(this.props);

        StatusBar._propsStack.push(this._stackEntry);

        this._updatePropsStack();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var index = StatusBar._propsStack.indexOf(this._stackEntry);

        StatusBar._propsStack.splice(index, 1);

        this._updatePropsStack();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var index = StatusBar._propsStack.indexOf(this._stackEntry);

        this._stackEntry = createStackEntry(this.props);
        StatusBar._propsStack[index] = this._stackEntry;

        this._updatePropsStack();
      }
    }, {
      key: "render",
      value: function render() {
        return null;
      }
    }], [{
      key: "setHidden",
      value: function setHidden(hidden, animation) {
        animation = animation || 'none';
        StatusBar._defaultProps.hidden.value = hidden;

        if (Platform.OS === 'ios') {
          StatusBarManager.setHidden(hidden, animation);
        } else if (Platform.OS === 'android') {
          StatusBarManager.setHidden(hidden);
        }
      }
    }, {
      key: "setBarStyle",
      value: function setBarStyle(style, animated) {
        animated = animated || false;
        StatusBar._defaultProps.barStyle.value = style;

        if (Platform.OS === 'ios') {
          StatusBarManager.setStyle(style, animated);
        } else if (Platform.OS === 'android') {
          StatusBarManager.setStyle(style);
        }
      }
    }, {
      key: "setNetworkActivityIndicatorVisible",
      value: function setNetworkActivityIndicatorVisible(visible) {
        if (Platform.OS !== 'ios') {
          console.warn('`setNetworkActivityIndicatorVisible` is only available on iOS');
          return;
        }

        StatusBar._defaultProps.networkActivityIndicatorVisible = visible;
        StatusBarManager.setNetworkActivityIndicatorVisible(visible);
      }
    }, {
      key: "setBackgroundColor",
      value: function setBackgroundColor(color, animated) {
        if (Platform.OS !== 'android') {
          console.warn('`setBackgroundColor` is only available on Android');
          return;
        }

        animated = animated || false;
        StatusBar._defaultProps.backgroundColor.value = color;
        StatusBarManager.setColor(processColor(color), animated);
      }
    }, {
      key: "setTranslucent",
      value: function setTranslucent(translucent) {
        if (Platform.OS !== 'android') {
          console.warn('`setTranslucent` is only available on Android');
          return;
        }

        StatusBar._defaultProps.translucent = translucent;
        StatusBarManager.setTranslucent(translucent);
      }
    }]);
    return StatusBar;
  }(React.Component);

  StatusBar._propsStack = [];
  StatusBar._defaultProps = createStackEntry({
    animated: false,
    showHideTransition: 'fade',
    backgroundColor: 'black',
    barStyle: 'default',
    translucent: false,
    hidden: false,
    networkActivityIndicatorVisible: false
  });
  StatusBar._updateImmediate = null;
  StatusBar._currentValues = null;
  StatusBar.currentHeight = StatusBarManager.HEIGHT;
  StatusBar.propTypes = {
    hidden: PropTypes.bool,
    animated: PropTypes.bool,
    backgroundColor: ColorPropType,
    translucent: PropTypes.bool,
    barStyle: PropTypes.oneOf(['default', 'light-content', 'dark-content']),
    networkActivityIndicatorVisible: PropTypes.bool,
    showHideTransition: PropTypes.oneOf(['fade', 'slide'])
  };
  StatusBar.defaultProps = {
    animated: false,
    showHideTransition: 'fade'
  };
  module.exports = StatusBar;
},279,[171,24,167,105,193,68],"StatusBar");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Lists/FlatList.js";

  var MetroListView = require(_dependencyMap[0], 'MetroListView');

  var React = require(_dependencyMap[1], 'React');

  var View = require(_dependencyMap[2], 'View');

  var VirtualizedList = require(_dependencyMap[3], 'VirtualizedList');

  var ListView = require(_dependencyMap[4], 'ListView');

  var invariant = require(_dependencyMap[5], 'fbjs/lib/invariant');

  var defaultProps = babelHelpers.extends({}, VirtualizedList.defaultProps, {
    numColumns: 1
  });

  var FlatList = function (_React$PureComponent) {
    babelHelpers.inherits(FlatList, _React$PureComponent);
    babelHelpers.createClass(FlatList, [{
      key: "scrollToEnd",
      value: function scrollToEnd(params) {
        if (this._listRef) {
          this._listRef.scrollToEnd(params);
        }
      }
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(params) {
        if (this._listRef) {
          this._listRef.scrollToIndex(params);
        }
      }
    }, {
      key: "scrollToItem",
      value: function scrollToItem(params) {
        if (this._listRef) {
          this._listRef.scrollToItem(params);
        }
      }
    }, {
      key: "scrollToOffset",
      value: function scrollToOffset(params) {
        if (this._listRef) {
          this._listRef.scrollToOffset(params);
        }
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        if (this._listRef) {
          this._listRef.recordInteraction();
        }
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        if (this._listRef) {
          this._listRef.flashScrollIndicators();
        }
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        if (this._listRef) {
          return this._listRef.getScrollResponder();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        if (this._listRef) {
          return this._listRef.getScrollableNode();
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        if (this._listRef) {
          this._listRef.setNativeProps(props);
        }
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {
        this._checkProps(this.props);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        invariant(nextProps.numColumns === this.props.numColumns, 'Changing numColumns on the fly is not supported. Change the key prop on FlatList when ' + 'changing the number of columns to force a fresh render of the component.');
        invariant(nextProps.onViewableItemsChanged === this.props.onViewableItemsChanged, 'Changing onViewableItemsChanged on the fly is not supported');
        invariant(nextProps.viewabilityConfig === this.props.viewabilityConfig, 'Changing viewabilityConfig on the fly is not supported');
        invariant(nextProps.viewabilityConfigCallbackPairs === this.props.viewabilityConfigCallbackPairs, 'Changing viewabilityConfigCallbackPairs on the fly is not supported');

        this._checkProps(nextProps);
      }
    }]);

    function FlatList(props) {
      babelHelpers.classCallCheck(this, FlatList);

      var _this = babelHelpers.possibleConstructorReturn(this, (FlatList.__proto__ || Object.getPrototypeOf(FlatList)).call(this, props));

      _this._hasWarnedLegacy = false;
      _this._virtualizedListPairs = [];

      _this._captureRef = function (ref) {
        _this._listRef = ref;
      };

      _this._getItem = function (data, index) {
        var numColumns = _this.props.numColumns;

        if (numColumns > 1) {
          var ret = [];

          for (var kk = 0; kk < numColumns; kk++) {
            var _item = data[index * numColumns + kk];
            _item && ret.push(_item);
          }

          return ret;
        } else {
          return data[index];
        }
      };

      _this._getItemCount = function (data) {
        return data ? Math.ceil(data.length / _this.props.numColumns) : 0;
      };

      _this._keyExtractor = function (items, index) {
        var _this$props = _this.props,
            keyExtractor = _this$props.keyExtractor,
            numColumns = _this$props.numColumns;

        if (numColumns > 1) {
          invariant(Array.isArray(items), 'FlatList: Encountered internal consistency error, expected each item to consist of an ' + 'array with 1-%s columns; instead, received a single item.', numColumns);
          return items.map(function (it, kk) {
            return keyExtractor(it, index * numColumns + kk);
          }).join(':');
        } else {
          return keyExtractor(items, index);
        }
      };

      _this._renderItem = function (info) {
        var _this$props2 = _this.props,
            renderItem = _this$props2.renderItem,
            numColumns = _this$props2.numColumns,
            columnWrapperStyle = _this$props2.columnWrapperStyle;

        if (numColumns > 1) {
          var _item2 = info.item,
              _index = info.index;
          invariant(Array.isArray(_item2), 'Expected array of items with numColumns > 1');
          return React.createElement(
            View,
            {
              style: [{
                flexDirection: 'row'
              }, columnWrapperStyle],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 607
              }
            },
            _item2.map(function (it, kk) {
              var element = renderItem({
                item: it,
                index: _index * numColumns + kk,
                separators: info.separators
              });
              return element && React.cloneElement(element, {
                key: kk
              });
            })
          );
        } else {
          return renderItem(info);
        }
      };

      if (_this.props.viewabilityConfigCallbackPairs) {
        _this._virtualizedListPairs = _this.props.viewabilityConfigCallbackPairs.map(function (pair) {
          return {
            viewabilityConfig: pair.viewabilityConfig,
            onViewableItemsChanged: _this._createOnViewableItemsChanged(pair.onViewableItemsChanged)
          };
        });
      } else if (_this.props.onViewableItemsChanged) {
        _this._virtualizedListPairs.push({
          viewabilityConfig: _this.props.viewabilityConfig,
          onViewableItemsChanged: _this._createOnViewableItemsChanged(_this.props.onViewableItemsChanged)
        });
      }

      return _this;
    }

    babelHelpers.createClass(FlatList, [{
      key: "_checkProps",
      value: function _checkProps(props) {
        var getItem = props.getItem,
            getItemCount = props.getItemCount,
            horizontal = props.horizontal,
            legacyImplementation = props.legacyImplementation,
            numColumns = props.numColumns,
            columnWrapperStyle = props.columnWrapperStyle,
            onViewableItemsChanged = props.onViewableItemsChanged,
            viewabilityConfigCallbackPairs = props.viewabilityConfigCallbackPairs;
        invariant(!getItem && !getItemCount, 'FlatList does not support custom data formats.');

        if (numColumns > 1) {
          invariant(!horizontal, 'numColumns does not support horizontal.');
        } else {
          invariant(!columnWrapperStyle, 'columnWrapperStyle not supported for single column lists');
        }

        if (legacyImplementation) {
          invariant(numColumns === 1, 'Legacy list does not support multiple columns.');

          if (!this._hasWarnedLegacy) {
            console.warn('FlatList: Using legacyImplementation - some features not supported and performance ' + 'may suffer');
            this._hasWarnedLegacy = true;
          }
        }

        invariant(!(onViewableItemsChanged && viewabilityConfigCallbackPairs), 'FlatList does not support setting both onViewableItemsChanged and ' + 'viewabilityConfigCallbackPairs.');
      }
    }, {
      key: "_pushMultiColumnViewable",
      value: function _pushMultiColumnViewable(arr, v) {
        var _props = this.props,
            numColumns = _props.numColumns,
            keyExtractor = _props.keyExtractor;
        v.item.forEach(function (item, ii) {
          invariant(v.index != null, 'Missing index!');
          var index = v.index * numColumns + ii;
          arr.push(babelHelpers.extends({}, v, {
            item: item,
            key: keyExtractor(item, index),
            index: index
          }));
        });
      }
    }, {
      key: "_createOnViewableItemsChanged",
      value: function _createOnViewableItemsChanged(onViewableItemsChanged) {
        var _this2 = this;

        return function (info) {
          var numColumns = _this2.props.numColumns;

          if (onViewableItemsChanged) {
            if (numColumns > 1) {
              var _changed = [];
              var _viewableItems = [];
              info.viewableItems.forEach(function (v) {
                return _this2._pushMultiColumnViewable(_viewableItems, v);
              });
              info.changed.forEach(function (v) {
                return _this2._pushMultiColumnViewable(_changed, v);
              });
              onViewableItemsChanged({
                viewableItems: _viewableItems,
                changed: _changed
              });
            } else {
              onViewableItemsChanged(info);
            }
          }
        };
      }
    }, {
      key: "render",
      value: function render() {
        if (this.props.legacyImplementation) {
          return React.createElement(MetroListView, babelHelpers.extends({}, this.props, {
            items: this.props.data,
            ref: this._captureRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 626
            }
          }));
        } else {
          return React.createElement(VirtualizedList, babelHelpers.extends({}, this.props, {
            renderItem: this._renderItem,
            getItem: this._getItem,
            getItemCount: this._getItemCount,
            keyExtractor: this._keyExtractor,
            ref: this._captureRef,
            viewabilityConfigCallbackPairs: this._virtualizedListPairs,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 634
            }
          }));
        }
      }
    }]);
    return FlatList;
  }(React.PureComponent);

  FlatList.defaultProps = defaultProps;
  module.exports = FlatList;
},280,[281,171,211,288,282,18],"FlatList");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Lists/MetroListView.js";

  var ListView = require(_dependencyMap[0], 'ListView');

  var React = require(_dependencyMap[1], 'React');

  var RefreshControl = require(_dependencyMap[2], 'RefreshControl');

  var ScrollView = require(_dependencyMap[3], 'ScrollView');

  var invariant = require(_dependencyMap[4], 'fbjs/lib/invariant');

  var MetroListView = function (_React$Component) {
    babelHelpers.inherits(MetroListView, _React$Component);

    function MetroListView() {
      var _ref,
          _this2 = this;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, MetroListView);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = MetroListView.__proto__ || Object.getPrototypeOf(MetroListView)).call.apply(_ref, [this].concat(args))), _this), _this.state = _this._computeState(_this.props, {
        ds: new ListView.DataSource({
          rowHasChanged: function rowHasChanged(itemA, itemB) {
            return true;
          },
          sectionHeaderHasChanged: function sectionHeaderHasChanged() {
            return true;
          },
          getSectionHeaderData: function getSectionHeaderData(dataBlob, sectionID) {
            return _this.state.sectionHeaderData[sectionID];
          }
        }),
        sectionHeaderData: {}
      }), _this._captureRef = function (ref) {
        _this._listRef = ref;
      }, _this._renderFooter = function () {
        return React.createElement(_this2.props.FooterComponent, {
          key: "$footer",
          __source: {
            fileName: _jsxFileName,
            lineNumber: 183
          }
        });
      }, _this._renderRow = function (item, sectionID, rowID, highlightRow) {
        return _this.props.renderItem({
          item: item,
          index: rowID
        });
      }, _this._renderSectionHeader = function (section, sectionID) {
        var renderSectionHeader = _this.props.renderSectionHeader;
        invariant(renderSectionHeader, 'Must provide renderSectionHeader with sections prop');
        return renderSectionHeader({
          section: section
        });
      }, _this._renderSeparator = function (sID, rID) {
        return React.createElement(_this2.props.SeparatorComponent, {
          key: sID + rID,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 199
          }
        });
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(MetroListView, [{
      key: "scrollToEnd",
      value: function scrollToEnd(params) {
        throw new Error('scrollToEnd not supported in legacy ListView.');
      }
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(params) {
        throw new Error('scrollToIndex not supported in legacy ListView.');
      }
    }, {
      key: "scrollToItem",
      value: function scrollToItem(params) {
        throw new Error('scrollToItem not supported in legacy ListView.');
      }
    }, {
      key: "scrollToLocation",
      value: function scrollToLocation(params) {
        throw new Error('scrollToLocation not supported in legacy ListView.');
      }
    }, {
      key: "scrollToOffset",
      value: function scrollToOffset(params) {
        var animated = params.animated,
            offset = params.offset;

        this._listRef.scrollTo(this.props.horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "getListRef",
      value: function getListRef() {
        return this._listRef;
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        if (this._listRef) {
          this._listRef.setNativeProps(props);
        }
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(newProps) {
        var _this3 = this;

        this.setState(function (state) {
          return _this3._computeState(newProps, state);
        });
      }
    }, {
      key: "render",
      value: function render() {
        return React.createElement(ListView, babelHelpers.extends({}, this.props, {
          dataSource: this.state.ds,
          ref: this._captureRef,
          renderRow: this._renderRow,
          renderFooter: this.props.FooterComponent && this._renderFooter,
          renderSectionHeader: this.props.sections && this._renderSectionHeader,
          renderSeparator: this.props.SeparatorComponent && this._renderSeparator,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 143
          }
        }));
      }
    }, {
      key: "_computeState",
      value: function _computeState(props, state) {
        var sectionHeaderData = {};

        if (props.sections) {
          invariant(!props.items, 'Cannot have both sections and items props.');
          var _sections = {};
          props.sections.forEach(function (sectionIn, ii) {
            var sectionID = 's' + ii;
            _sections[sectionID] = sectionIn.data;
            sectionHeaderData[sectionID] = sectionIn;
          });
          return {
            ds: state.ds.cloneWithRowsAndSections(_sections),
            sectionHeaderData: sectionHeaderData
          };
        } else {
          invariant(!props.sections, 'Cannot have both sections and items props.');
          return {
            ds: state.ds.cloneWithRows(props.items),
            sectionHeaderData: sectionHeaderData
          };
        }
      }
    }]);
    return MetroListView;
  }(React.Component);

  MetroListView.defaultProps = {
    keyExtractor: function keyExtractor(item, index) {
      return item.key || String(index);
    },
    renderScrollComponent: function renderScrollComponent(props) {
      if (props.onRefresh) {
        return React.createElement(ScrollView, babelHelpers.extends({}, props, {
          refreshControl: React.createElement(RefreshControl, {
            refreshing: props.refreshing,
            onRefresh: props.onRefresh,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 117
            }
          }),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 110
          }
        }));
      } else {
        return React.createElement(ScrollView, babelHelpers.extends({}, props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 125
          }
        }));
      }
    }
  };
  module.exports = MetroListView;
},281,[282,171,287,265,18],"MetroListView");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Lists/ListView/ListView.js";

  var ListViewDataSource = require(_dependencyMap[0], 'ListViewDataSource');

  var Platform = require(_dependencyMap[1], 'Platform');

  var React = require(_dependencyMap[2], 'React');

  var PropTypes = require(_dependencyMap[3], 'prop-types');

  var ReactNative = require(_dependencyMap[4], 'ReactNative');

  var RCTScrollViewManager = require(_dependencyMap[5], 'NativeModules').ScrollViewManager;

  var ScrollView = require(_dependencyMap[6], 'ScrollView');

  var ScrollResponder = require(_dependencyMap[7], 'ScrollResponder');

  var StaticRenderer = require(_dependencyMap[8], 'StaticRenderer');

  var TimerMixin = require(_dependencyMap[9], 'react-timer-mixin');

  var View = require(_dependencyMap[10], 'View');

  var cloneReferencedElement = require(_dependencyMap[11], 'react-clone-referenced-element');

  var createReactClass = require(_dependencyMap[12], 'create-react-class');

  var isEmpty = require(_dependencyMap[13], 'isEmpty');

  var merge = require(_dependencyMap[14], 'merge');

  var DEFAULT_PAGE_SIZE = 1;
  var DEFAULT_INITIAL_ROWS = 10;
  var DEFAULT_SCROLL_RENDER_AHEAD = 1000;
  var DEFAULT_END_REACHED_THRESHOLD = 1000;
  var DEFAULT_SCROLL_CALLBACK_THROTTLE = 50;
  var ListView = createReactClass({
    displayName: 'ListView',
    _childFrames: [],
    _sentEndForContentLength: null,
    _scrollComponent: null,
    _prevRenderedRowsCount: 0,
    _visibleRows: {},
    scrollProperties: {},
    mixins: [ScrollResponder.Mixin, TimerMixin],
    statics: {
      DataSource: ListViewDataSource
    },
    propTypes: babelHelpers.extends({}, ScrollView.propTypes, {
      dataSource: PropTypes.instanceOf(ListViewDataSource).isRequired,
      renderSeparator: PropTypes.func,
      renderRow: PropTypes.func.isRequired,
      initialListSize: PropTypes.number.isRequired,
      onEndReached: PropTypes.func,
      onEndReachedThreshold: PropTypes.number.isRequired,
      pageSize: PropTypes.number.isRequired,
      renderFooter: PropTypes.func,
      renderHeader: PropTypes.func,
      renderSectionHeader: PropTypes.func,
      renderScrollComponent: PropTypes.func.isRequired,
      scrollRenderAheadDistance: PropTypes.number.isRequired,
      onChangeVisibleRows: PropTypes.func,
      removeClippedSubviews: PropTypes.bool,
      stickySectionHeadersEnabled: PropTypes.bool,
      stickyHeaderIndices: PropTypes.arrayOf(PropTypes.number).isRequired,
      enableEmptySections: PropTypes.bool
    }),
    getMetrics: function getMetrics() {
      return {
        contentLength: this.scrollProperties.contentLength,
        totalRows: this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount(),
        renderedRows: this.state.curRenderedRowsCount,
        visibleRows: Object.keys(this._visibleRows).length
      };
    },
    getScrollResponder: function getScrollResponder() {
      if (this._scrollComponent && this._scrollComponent.getScrollResponder) {
        return this._scrollComponent.getScrollResponder();
      }
    },
    getScrollableNode: function getScrollableNode() {
      if (this._scrollComponent && this._scrollComponent.getScrollableNode) {
        return this._scrollComponent.getScrollableNode();
      } else {
        return ReactNative.findNodeHandle(this._scrollComponent);
      }
    },
    scrollTo: function scrollTo() {
      if (this._scrollComponent && this._scrollComponent.scrollTo) {
        var _scrollComponent;

        (_scrollComponent = this._scrollComponent).scrollTo.apply(_scrollComponent, arguments);
      }
    },
    scrollToEnd: function scrollToEnd(options) {
      if (this._scrollComponent) {
        if (this._scrollComponent.scrollToEnd) {
          this._scrollComponent.scrollToEnd(options);
        } else {
          console.warn('The scroll component used by the ListView does not support ' + 'scrollToEnd. Check the renderScrollComponent prop of your ListView.');
        }
      }
    },
    flashScrollIndicators: function flashScrollIndicators() {
      if (this._scrollComponent && this._scrollComponent.flashScrollIndicators) {
        this._scrollComponent.flashScrollIndicators();
      }
    },
    setNativeProps: function setNativeProps(props) {
      if (this._scrollComponent) {
        this._scrollComponent.setNativeProps(props);
      }
    },
    getDefaultProps: function getDefaultProps() {
      return {
        initialListSize: DEFAULT_INITIAL_ROWS,
        pageSize: DEFAULT_PAGE_SIZE,
        renderScrollComponent: function renderScrollComponent(props) {
          return React.createElement(ScrollView, babelHelpers.extends({}, props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 338
            }
          }));
        },
        scrollRenderAheadDistance: DEFAULT_SCROLL_RENDER_AHEAD,
        onEndReachedThreshold: DEFAULT_END_REACHED_THRESHOLD,
        stickySectionHeadersEnabled: Platform.OS === 'ios',
        stickyHeaderIndices: []
      };
    },
    getInitialState: function getInitialState() {
      return {
        curRenderedRowsCount: this.props.initialListSize,
        highlightedRow: {}
      };
    },
    getInnerViewNode: function getInnerViewNode() {
      return this._scrollComponent.getInnerViewNode();
    },
    componentWillMount: function componentWillMount() {
      this.scrollProperties = {
        visibleLength: null,
        contentLength: null,
        offset: 0
      };
      this._childFrames = [];
      this._visibleRows = {};
      this._prevRenderedRowsCount = 0;
      this._sentEndForContentLength = null;
    },
    componentDidMount: function componentDidMount() {
      var _this = this;

      this.requestAnimationFrame(function () {
        _this._measureAndUpdateScrollProps();
      });
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.props.dataSource !== nextProps.dataSource || this.props.initialListSize !== nextProps.initialListSize) {
        this.setState(function (state, props) {
          _this2._prevRenderedRowsCount = 0;
          return {
            curRenderedRowsCount: Math.min(Math.max(state.curRenderedRowsCount, props.initialListSize), props.enableEmptySections ? props.dataSource.getRowAndSectionCount() : props.dataSource.getRowCount())
          };
        }, function () {
          return _this2._renderMoreRowsIfNeeded();
        });
      }
    },
    componentDidUpdate: function componentDidUpdate() {
      var _this3 = this;

      this.requestAnimationFrame(function () {
        _this3._measureAndUpdateScrollProps();
      });
    },
    _onRowHighlighted: function _onRowHighlighted(sectionID, rowID) {
      this.setState({
        highlightedRow: {
          sectionID: sectionID,
          rowID: rowID
        }
      });
    },
    render: function render() {
      var bodyComponents = [];
      var dataSource = this.props.dataSource;
      var allRowIDs = dataSource.rowIdentities;
      var rowCount = 0;
      var stickySectionHeaderIndices = [];
      var renderSectionHeader = this.props.renderSectionHeader;
      var header = this.props.renderHeader && this.props.renderHeader();
      var footer = this.props.renderFooter && this.props.renderFooter();
      var totalIndex = header ? 1 : 0;

      for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
        var sectionID = dataSource.sectionIdentities[sectionIdx];
        var rowIDs = allRowIDs[sectionIdx];

        if (rowIDs.length === 0) {
          if (this.props.enableEmptySections === undefined) {
            var warning = require(_dependencyMap[15], 'fbjs/lib/warning');

            warning(false, 'In next release empty section headers will be rendered.' + " In this release you can use 'enableEmptySections' flag to render empty section headers.");
            continue;
          } else {
            var invariant = require(_dependencyMap[16], 'fbjs/lib/invariant');

            invariant(this.props.enableEmptySections, "In next release 'enableEmptySections' flag will be deprecated, empty section headers will always be rendered." + ' If empty section headers are not desirable their indices should be excluded from sectionIDs object.' + " In this release 'enableEmptySections' may only have value 'true' to allow empty section headers rendering.");
          }
        }

        if (renderSectionHeader) {
          var element = renderSectionHeader(dataSource.getSectionHeaderData(sectionIdx), sectionID);

          if (element) {
            bodyComponents.push(React.cloneElement(element, {
              key: 's_' + sectionID
            }));

            if (this.props.stickySectionHeadersEnabled) {
              stickySectionHeaderIndices.push(totalIndex);
            }

            totalIndex++;
          }
        }

        for (var rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {
          var rowID = rowIDs[rowIdx];
          var comboID = sectionID + '_' + rowID;
          var shouldUpdateRow = rowCount >= this._prevRenderedRowsCount && dataSource.rowShouldUpdate(sectionIdx, rowIdx);
          var row = React.createElement(StaticRenderer, {
            key: 'r_' + comboID,
            shouldUpdate: !!shouldUpdateRow,
            render: this.props.renderRow.bind(null, dataSource.getRowData(sectionIdx, rowIdx), sectionID, rowID, this._onRowHighlighted),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 473
            }
          });
          bodyComponents.push(row);
          totalIndex++;

          if (this.props.renderSeparator && (rowIdx !== rowIDs.length - 1 || sectionIdx === allRowIDs.length - 1)) {
            var adjacentRowHighlighted = this.state.highlightedRow.sectionID === sectionID && (this.state.highlightedRow.rowID === rowID || this.state.highlightedRow.rowID === rowIDs[rowIdx + 1]);
            var separator = this.props.renderSeparator(sectionID, rowID, adjacentRowHighlighted);

            if (separator) {
              bodyComponents.push(React.createElement(
                View,
                {
                  key: 's_' + comboID,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 502
                  }
                },
                separator
              ));
              totalIndex++;
            }
          }

          if (++rowCount === this.state.curRenderedRowsCount) {
            break;
          }
        }

        if (rowCount >= this.state.curRenderedRowsCount) {
          break;
        }
      }

      var _props = this.props,
          renderScrollComponent = _props.renderScrollComponent,
          props = babelHelpers.objectWithoutProperties(_props, ["renderScrollComponent"]);

      if (!props.scrollEventThrottle) {
        props.scrollEventThrottle = DEFAULT_SCROLL_CALLBACK_THROTTLE;
      }

      if (props.removeClippedSubviews === undefined) {
        props.removeClippedSubviews = true;
      }

      babelHelpers.extends(props, {
        onScroll: this._onScroll,
        stickyHeaderIndices: this.props.stickyHeaderIndices.concat(stickySectionHeaderIndices),
        onKeyboardWillShow: undefined,
        onKeyboardWillHide: undefined,
        onKeyboardDidShow: undefined,
        onKeyboardDidHide: undefined
      });
      return cloneReferencedElement(renderScrollComponent(props), {
        ref: this._setScrollComponentRef,
        onContentSizeChange: this._onContentSizeChange,
        onLayout: this._onLayout,
        DEPRECATED_sendUpdatedChildFrames: typeof props.onChangeVisibleRows !== undefined
      }, header, bodyComponents, footer);
    },
    _measureAndUpdateScrollProps: function _measureAndUpdateScrollProps() {
      var scrollComponent = this.getScrollResponder();

      if (!scrollComponent || !scrollComponent.getInnerViewNode) {
        return;
      }

      RCTScrollViewManager && RCTScrollViewManager.calculateChildFrames && RCTScrollViewManager.calculateChildFrames(ReactNative.findNodeHandle(scrollComponent), this._updateVisibleRows);
    },
    _setScrollComponentRef: function _setScrollComponentRef(scrollComponent) {
      this._scrollComponent = scrollComponent;
    },
    _onContentSizeChange: function _onContentSizeChange(width, height) {
      var contentLength = !this.props.horizontal ? height : width;

      if (contentLength !== this.scrollProperties.contentLength) {
        this.scrollProperties.contentLength = contentLength;

        this._updateVisibleRows();

        this._renderMoreRowsIfNeeded();
      }

      this.props.onContentSizeChange && this.props.onContentSizeChange(width, height);
    },
    _onLayout: function _onLayout(event) {
      var _event$nativeEvent$la = event.nativeEvent.layout,
          width = _event$nativeEvent$la.width,
          height = _event$nativeEvent$la.height;
      var visibleLength = !this.props.horizontal ? height : width;

      if (visibleLength !== this.scrollProperties.visibleLength) {
        this.scrollProperties.visibleLength = visibleLength;

        this._updateVisibleRows();

        this._renderMoreRowsIfNeeded();
      }

      this.props.onLayout && this.props.onLayout(event);
    },
    _maybeCallOnEndReached: function _maybeCallOnEndReached(event) {
      if (this.props.onEndReached && this.scrollProperties.contentLength !== this._sentEndForContentLength && this._getDistanceFromEnd(this.scrollProperties) < this.props.onEndReachedThreshold && this.state.curRenderedRowsCount === (this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount())) {
        this._sentEndForContentLength = this.scrollProperties.contentLength;
        this.props.onEndReached(event);
        return true;
      }

      return false;
    },
    _renderMoreRowsIfNeeded: function _renderMoreRowsIfNeeded() {
      if (this.scrollProperties.contentLength === null || this.scrollProperties.visibleLength === null || this.state.curRenderedRowsCount === (this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount())) {
        this._maybeCallOnEndReached();

        return;
      }

      var distanceFromEnd = this._getDistanceFromEnd(this.scrollProperties);

      if (distanceFromEnd < this.props.scrollRenderAheadDistance) {
        this._pageInNewRows();
      }
    },
    _pageInNewRows: function _pageInNewRows() {
      var _this4 = this;

      this.setState(function (state, props) {
        var rowsToRender = Math.min(state.curRenderedRowsCount + props.pageSize, props.enableEmptySections ? props.dataSource.getRowAndSectionCount() : props.dataSource.getRowCount());
        _this4._prevRenderedRowsCount = state.curRenderedRowsCount;
        return {
          curRenderedRowsCount: rowsToRender
        };
      }, function () {
        _this4._measureAndUpdateScrollProps();

        _this4._prevRenderedRowsCount = _this4.state.curRenderedRowsCount;
      });
    },
    _getDistanceFromEnd: function _getDistanceFromEnd(scrollProperties) {
      return scrollProperties.contentLength - scrollProperties.visibleLength - scrollProperties.offset;
    },
    _updateVisibleRows: function _updateVisibleRows(updatedFrames) {
      var _this5 = this;

      if (!this.props.onChangeVisibleRows) {
        return;
      }

      if (updatedFrames) {
        updatedFrames.forEach(function (newFrame) {
          _this5._childFrames[newFrame.index] = merge(newFrame);
        });
      }

      var isVertical = !this.props.horizontal;
      var dataSource = this.props.dataSource;
      var visibleMin = this.scrollProperties.offset;
      var visibleMax = visibleMin + this.scrollProperties.visibleLength;
      var allRowIDs = dataSource.rowIdentities;
      var header = this.props.renderHeader && this.props.renderHeader();
      var totalIndex = header ? 1 : 0;
      var visibilityChanged = false;
      var changedRows = {};

      for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
        var rowIDs = allRowIDs[sectionIdx];

        if (rowIDs.length === 0) {
          continue;
        }

        var sectionID = dataSource.sectionIdentities[sectionIdx];

        if (this.props.renderSectionHeader) {
          totalIndex++;
        }

        var visibleSection = this._visibleRows[sectionID];

        if (!visibleSection) {
          visibleSection = {};
        }

        for (var rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {
          var rowID = rowIDs[rowIdx];
          var frame = this._childFrames[totalIndex];
          totalIndex++;

          if (this.props.renderSeparator && (rowIdx !== rowIDs.length - 1 || sectionIdx === allRowIDs.length - 1)) {
            totalIndex++;
          }

          if (!frame) {
            break;
          }

          var rowVisible = visibleSection[rowID];
          var min = isVertical ? frame.y : frame.x;
          var max = min + (isVertical ? frame.height : frame.width);

          if (!min && !max || min === max) {
            break;
          }

          if (min > visibleMax || max < visibleMin) {
            if (rowVisible) {
              visibilityChanged = true;
              delete visibleSection[rowID];

              if (!changedRows[sectionID]) {
                changedRows[sectionID] = {};
              }

              changedRows[sectionID][rowID] = false;
            }
          } else if (!rowVisible) {
            visibilityChanged = true;
            visibleSection[rowID] = true;

            if (!changedRows[sectionID]) {
              changedRows[sectionID] = {};
            }

            changedRows[sectionID][rowID] = true;
          }
        }

        if (!isEmpty(visibleSection)) {
          this._visibleRows[sectionID] = visibleSection;
        } else if (this._visibleRows[sectionID]) {
          delete this._visibleRows[sectionID];
        }
      }

      visibilityChanged && this.props.onChangeVisibleRows(this._visibleRows, changedRows);
    },
    _onScroll: function _onScroll(e) {
      var isVertical = !this.props.horizontal;
      this.scrollProperties.visibleLength = e.nativeEvent.layoutMeasurement[isVertical ? 'height' : 'width'];
      this.scrollProperties.contentLength = e.nativeEvent.contentSize[isVertical ? 'height' : 'width'];
      this.scrollProperties.offset = e.nativeEvent.contentOffset[isVertical ? 'y' : 'x'];

      this._updateVisibleRows(e.nativeEvent.updatedChildFrames);

      if (!this._maybeCallOnEndReached(e)) {
        this._renderMoreRowsIfNeeded();
      }

      if (this.props.onEndReached && this._getDistanceFromEnd(this.scrollProperties) > this.props.onEndReachedThreshold) {
        this._sentEndForContentLength = null;
      }

      this.props.onScroll && this.props.onScroll(e);
    }
  });
  module.exports = ListView;
},282,[283,105,171,24,74,68,265,267,285,232,211,286,213,284,175,19,18],"ListView");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var isEmpty = require(_dependencyMap[1], 'isEmpty');

  var warning = require(_dependencyMap[2], 'fbjs/lib/warning');

  function defaultGetRowData(dataBlob, sectionID, rowID) {
    return dataBlob[sectionID][rowID];
  }

  function defaultGetSectionHeaderData(dataBlob, sectionID) {
    return dataBlob[sectionID];
  }

  var ListViewDataSource = function () {
    function ListViewDataSource(params) {
      babelHelpers.classCallCheck(this, ListViewDataSource);
      invariant(params && typeof params.rowHasChanged === 'function', 'Must provide a rowHasChanged function.');
      this._rowHasChanged = params.rowHasChanged;
      this._getRowData = params.getRowData || defaultGetRowData;
      this._sectionHeaderHasChanged = params.sectionHeaderHasChanged;
      this._getSectionHeaderData = params.getSectionHeaderData || defaultGetSectionHeaderData;
      this._dataBlob = null;
      this._dirtyRows = [];
      this._dirtySections = [];
      this._cachedRowCount = 0;
      this.rowIdentities = [];
      this.sectionIdentities = [];
    }

    babelHelpers.createClass(ListViewDataSource, [{
      key: "cloneWithRows",
      value: function cloneWithRows(dataBlob, rowIdentities) {
        var rowIds = rowIdentities ? [[].concat(babelHelpers.toConsumableArray(rowIdentities))] : null;

        if (!this._sectionHeaderHasChanged) {
          this._sectionHeaderHasChanged = function () {
            return false;
          };
        }

        return this.cloneWithRowsAndSections({
          s1: dataBlob
        }, ['s1'], rowIds);
      }
    }, {
      key: "cloneWithRowsAndSections",
      value: function cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities) {
        invariant(typeof this._sectionHeaderHasChanged === 'function', 'Must provide a sectionHeaderHasChanged function with section data.');
        invariant(!sectionIdentities || !rowIdentities || sectionIdentities.length === rowIdentities.length, 'row and section ids lengths must be the same');
        var newSource = new ListViewDataSource({
          getRowData: this._getRowData,
          getSectionHeaderData: this._getSectionHeaderData,
          rowHasChanged: this._rowHasChanged,
          sectionHeaderHasChanged: this._sectionHeaderHasChanged
        });
        newSource._dataBlob = dataBlob;

        if (sectionIdentities) {
          newSource.sectionIdentities = sectionIdentities;
        } else {
          newSource.sectionIdentities = Object.keys(dataBlob);
        }

        if (rowIdentities) {
          newSource.rowIdentities = rowIdentities;
        } else {
          newSource.rowIdentities = [];
          newSource.sectionIdentities.forEach(function (sectionID) {
            newSource.rowIdentities.push(Object.keys(dataBlob[sectionID]));
          });
        }

        newSource._cachedRowCount = countRows(newSource.rowIdentities);

        newSource._calculateDirtyArrays(this._dataBlob, this.sectionIdentities, this.rowIdentities);

        return newSource;
      }
    }, {
      key: "getRowCount",
      value: function getRowCount() {
        return this._cachedRowCount;
      }
    }, {
      key: "getRowAndSectionCount",
      value: function getRowAndSectionCount() {
        return this._cachedRowCount + this.sectionIdentities.length;
      }
    }, {
      key: "rowShouldUpdate",
      value: function rowShouldUpdate(sectionIndex, rowIndex) {
        var needsUpdate = this._dirtyRows[sectionIndex][rowIndex];
        warning(needsUpdate !== undefined, 'missing dirtyBit for section, row: ' + sectionIndex + ', ' + rowIndex);
        return needsUpdate;
      }
    }, {
      key: "getRowData",
      value: function getRowData(sectionIndex, rowIndex) {
        var sectionID = this.sectionIdentities[sectionIndex];
        var rowID = this.rowIdentities[sectionIndex][rowIndex];
        warning(sectionID !== undefined && rowID !== undefined, 'rendering invalid section, row: ' + sectionIndex + ', ' + rowIndex);
        return this._getRowData(this._dataBlob, sectionID, rowID);
      }
    }, {
      key: "getRowIDForFlatIndex",
      value: function getRowIDForFlatIndex(index) {
        var accessIndex = index;

        for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
          if (accessIndex >= this.rowIdentities[ii].length) {
            accessIndex -= this.rowIdentities[ii].length;
          } else {
            return this.rowIdentities[ii][accessIndex];
          }
        }

        return null;
      }
    }, {
      key: "getSectionIDForFlatIndex",
      value: function getSectionIDForFlatIndex(index) {
        var accessIndex = index;

        for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
          if (accessIndex >= this.rowIdentities[ii].length) {
            accessIndex -= this.rowIdentities[ii].length;
          } else {
            return this.sectionIdentities[ii];
          }
        }

        return null;
      }
    }, {
      key: "getSectionLengths",
      value: function getSectionLengths() {
        var results = [];

        for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
          results.push(this.rowIdentities[ii].length);
        }

        return results;
      }
    }, {
      key: "sectionHeaderShouldUpdate",
      value: function sectionHeaderShouldUpdate(sectionIndex) {
        var needsUpdate = this._dirtySections[sectionIndex];
        warning(needsUpdate !== undefined, 'missing dirtyBit for section: ' + sectionIndex);
        return needsUpdate;
      }
    }, {
      key: "getSectionHeaderData",
      value: function getSectionHeaderData(sectionIndex) {
        if (!this._getSectionHeaderData) {
          return null;
        }

        var sectionID = this.sectionIdentities[sectionIndex];
        warning(sectionID !== undefined, 'renderSection called on invalid section: ' + sectionIndex);
        return this._getSectionHeaderData(this._dataBlob, sectionID);
      }
    }, {
      key: "_calculateDirtyArrays",
      value: function _calculateDirtyArrays(prevDataBlob, prevSectionIDs, prevRowIDs) {
        var prevSectionsHash = keyedDictionaryFromArray(prevSectionIDs);
        var prevRowsHash = {};

        for (var ii = 0; ii < prevRowIDs.length; ii++) {
          var sectionID = prevSectionIDs[ii];
          warning(!prevRowsHash[sectionID], 'SectionID appears more than once: ' + sectionID);
          prevRowsHash[sectionID] = keyedDictionaryFromArray(prevRowIDs[ii]);
        }

        this._dirtySections = [];
        this._dirtyRows = [];
        var dirty;

        for (var sIndex = 0; sIndex < this.sectionIdentities.length; sIndex++) {
          var sectionID = this.sectionIdentities[sIndex];
          dirty = !prevSectionsHash[sectionID];
          var sectionHeaderHasChanged = this._sectionHeaderHasChanged;

          if (!dirty && sectionHeaderHasChanged) {
            dirty = sectionHeaderHasChanged(this._getSectionHeaderData(prevDataBlob, sectionID), this._getSectionHeaderData(this._dataBlob, sectionID));
          }

          this._dirtySections.push(!!dirty);

          this._dirtyRows[sIndex] = [];

          for (var rIndex = 0; rIndex < this.rowIdentities[sIndex].length; rIndex++) {
            var rowID = this.rowIdentities[sIndex][rIndex];
            dirty = !prevSectionsHash[sectionID] || !prevRowsHash[sectionID][rowID] || this._rowHasChanged(this._getRowData(prevDataBlob, sectionID, rowID), this._getRowData(this._dataBlob, sectionID, rowID));

            this._dirtyRows[sIndex].push(!!dirty);
          }
        }
      }
    }]);
    return ListViewDataSource;
  }();

  function countRows(allRowIDs) {
    var totalRows = 0;

    for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
      var rowIDs = allRowIDs[sectionIdx];
      totalRows += rowIDs.length;
    }

    return totalRows;
  }

  function keyedDictionaryFromArray(arr) {
    if (isEmpty(arr)) {
      return {};
    }

    var result = {};

    for (var ii = 0; ii < arr.length; ii++) {
      var key = arr[ii];
      warning(!result[key], 'Value appears more than once in array: ' + key);
      result[key] = true;
    }

    return result;
  }

  module.exports = ListViewDataSource;
},283,[18,284,19],"ListViewDataSource");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function isEmpty(obj) {
    if (Array.isArray(obj)) {
      return obj.length === 0;
    } else if (typeof obj === 'object') {
      for (var i in obj) {
        return false;
      }

      return true;
    } else {
      return !obj;
    }
  }

  module.exports = isEmpty;
},284,[],"isEmpty");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var React = require(_dependencyMap[0], 'React');

  var PropTypes = require(_dependencyMap[1], 'prop-types');

  var StaticRenderer = function (_React$Component) {
    babelHelpers.inherits(StaticRenderer, _React$Component);

    function StaticRenderer() {
      babelHelpers.classCallCheck(this, StaticRenderer);
      return babelHelpers.possibleConstructorReturn(this, (StaticRenderer.__proto__ || Object.getPrototypeOf(StaticRenderer)).apply(this, arguments));
    }

    babelHelpers.createClass(StaticRenderer, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps) {
        return nextProps.shouldUpdate;
      }
    }, {
      key: "render",
      value: function render() {
        return this.props.render();
      }
    }]);
    return StaticRenderer;
  }(React.Component);

  StaticRenderer.propTypes = {
    shouldUpdate: PropTypes.bool.isRequired,
    render: PropTypes.func.isRequired
  };
  module.exports = StaticRenderer;
},285,[171,24],"StaticRenderer");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var React = require(_dependencyMap[0], 'react');

  function cloneReferencedElement(element, config) {
    var cloneRef = config.ref;
    var originalRef = element.ref;

    for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }

    if (originalRef == null || cloneRef == null) {
      return React.cloneElement.apply(React, [element, config].concat(children));
    }

    if (typeof originalRef !== 'function') {
      if (__DEV__) {
        console.warn('Cloning an element with a ref that will be overwritten because it ' + 'is not a function. Use a composable callback-style ref instead. ' + 'Ignoring ref: ' + originalRef);
      }

      return React.cloneElement.apply(React, [element, config].concat(children));
    }

    return React.cloneElement.apply(React, [element, babelHelpers.extends({}, config, {
      ref: function ref(component) {
        cloneRef(component);
        originalRef(component);
      }
    })].concat(children));
  }

  module.exports = cloneReferencedElement;
},286,[12],"react-clone-referenced-element/cloneReferencedElement.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/RefreshControl/RefreshControl.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var NativeMethodsMixin = require(_dependencyMap[1], 'NativeMethodsMixin');

  var Platform = require(_dependencyMap[2], 'Platform');

  var React = require(_dependencyMap[3], 'React');

  var PropTypes = require(_dependencyMap[4], 'prop-types');

  var ViewPropTypes = require(_dependencyMap[5], 'ViewPropTypes');

  var createReactClass = require(_dependencyMap[6], 'create-react-class');

  var requireNativeComponent = require(_dependencyMap[7], 'requireNativeComponent');

  if (Platform.OS === 'android') {
    var RefreshLayoutConsts = require(_dependencyMap[8], 'UIManager').AndroidSwipeRefreshLayout.Constants;
  } else {
    var RefreshLayoutConsts = {
      SIZE: {}
    };
  }

  var RefreshControl = createReactClass({
    displayName: 'RefreshControl',
    statics: {
      SIZE: RefreshLayoutConsts.SIZE
    },
    mixins: [NativeMethodsMixin],
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      onRefresh: PropTypes.func,
      refreshing: PropTypes.bool.isRequired,
      tintColor: ColorPropType,
      titleColor: ColorPropType,
      title: PropTypes.string,
      enabled: PropTypes.bool,
      colors: PropTypes.arrayOf(ColorPropType),
      progressBackgroundColor: ColorPropType,
      size: PropTypes.oneOf([RefreshLayoutConsts.SIZE.DEFAULT, RefreshLayoutConsts.SIZE.LARGE]),
      progressViewOffset: PropTypes.number
    }),
    _nativeRef: null,
    _lastNativeRefreshing: false,
    componentDidMount: function componentDidMount() {
      this._lastNativeRefreshing = this.props.refreshing;
    },
    componentDidUpdate: function componentDidUpdate(prevProps) {
      if (this.props.refreshing !== prevProps.refreshing) {
        this._lastNativeRefreshing = this.props.refreshing;
      } else if (this.props.refreshing !== this._lastNativeRefreshing) {
        this._nativeRef.setNativeProps({
          refreshing: this.props.refreshing
        });

        this._lastNativeRefreshing = this.props.refreshing;
      }
    },
    render: function render() {
      var _this = this;

      return React.createElement(NativeRefreshControl, babelHelpers.extends({}, this.props, {
        ref: function ref(_ref) {
          _this._nativeRef = _ref;
        },
        onRefresh: this._onRefresh,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 156
        }
      }));
    },
    _onRefresh: function _onRefresh() {
      this._lastNativeRefreshing = true;
      this.props.onRefresh && this.props.onRefresh();
      this.forceUpdate();
    }
  });

  if (Platform.OS === 'ios') {
    var NativeRefreshControl = requireNativeComponent('RCTRefreshControl', RefreshControl);
  } else if (Platform.OS === 'android') {
    var NativeRefreshControl = requireNativeComponent('AndroidSwipeRefreshLayout', RefreshControl);
  }

  module.exports = RefreshControl;
},287,[167,169,105,171,24,172,213,186,158],"RefreshControl");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Lists/VirtualizedList.js";

  var Batchinator = require(_dependencyMap[0], 'Batchinator');

  var FillRateHelper = require(_dependencyMap[1], 'FillRateHelper');

  var PropTypes = require(_dependencyMap[2], 'prop-types');

  var React = require(_dependencyMap[3], 'React');

  var ReactNative = require(_dependencyMap[4], 'ReactNative');

  var RefreshControl = require(_dependencyMap[5], 'RefreshControl');

  var ScrollView = require(_dependencyMap[6], 'ScrollView');

  var StyleSheet = require(_dependencyMap[7], 'StyleSheet');

  var View = require(_dependencyMap[8], 'View');

  var ViewabilityHelper = require(_dependencyMap[9], 'ViewabilityHelper');

  var flattenStyle = require(_dependencyMap[10], 'flattenStyle');

  var infoLog = require(_dependencyMap[11], 'infoLog');

  var invariant = require(_dependencyMap[12], 'fbjs/lib/invariant');

  var warning = require(_dependencyMap[13], 'fbjs/lib/warning');

  var _require = require(_dependencyMap[14], 'VirtualizeUtils'),
      computeWindowedRenderLimits = _require.computeWindowedRenderLimits;

  var _usedIndexForKey = false;

  var VirtualizedList = function (_React$PureComponent) {
    babelHelpers.inherits(VirtualizedList, _React$PureComponent);
    babelHelpers.createClass(VirtualizedList, [{
      key: "scrollToEnd",
      value: function scrollToEnd(params) {
        var animated = params ? params.animated : true;
        var veryLast = this.props.getItemCount(this.props.data) - 1;

        var frame = this._getFrameMetricsApprox(veryLast);

        var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);

        this._scrollRef.scrollTo(this.props.horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(params) {
        var _props = this.props,
            data = _props.data,
            horizontal = _props.horizontal,
            getItemCount = _props.getItemCount,
            getItemLayout = _props.getItemLayout,
            onScrollToIndexFailed = _props.onScrollToIndexFailed;
        var animated = params.animated,
            index = params.index,
            viewOffset = params.viewOffset,
            viewPosition = params.viewPosition;
        invariant(index >= 0 && index < getItemCount(data), "scrollToIndex out of range: " + index + " vs " + (getItemCount(data) - 1));

        if (!getItemLayout && index > this._highestMeasuredFrameIndex) {
          invariant(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');
          onScrollToIndexFailed({
            averageItemLength: this._averageCellLength,
            highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
            index: index
          });
          return;
        }

        var frame = this._getFrameMetricsApprox(index);

        var offset = Math.max(0, frame.offset - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);

        this._scrollRef.scrollTo(horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "scrollToItem",
      value: function scrollToItem(params) {
        var item = params.item;
        var _props2 = this.props,
            data = _props2.data,
            getItem = _props2.getItem,
            getItemCount = _props2.getItemCount;
        var itemCount = getItemCount(data);

        for (var _index = 0; _index < itemCount; _index++) {
          if (getItem(data, _index) === item) {
            this.scrollToIndex(babelHelpers.extends({}, params, {
              index: _index
            }));
            break;
          }
        }
      }
    }, {
      key: "scrollToOffset",
      value: function scrollToOffset(params) {
        var animated = params.animated,
            offset = params.offset;

        this._scrollRef.scrollTo(this.props.horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        this._viewabilityTuples.forEach(function (t) {
          t.viewabilityHelper.recordInteraction();
        });

        this._updateViewableItems(this.props.data);
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        this._scrollRef.flashScrollIndicators();
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        if (this._scrollRef && this._scrollRef.getScrollResponder) {
          return this._scrollRef.getScrollResponder();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        if (this._scrollRef && this._scrollRef.getScrollableNode) {
          return this._scrollRef.getScrollableNode();
        } else {
          return ReactNative.findNodeHandle(this._scrollRef);
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        if (this._scrollRef) {
          this._scrollRef.setNativeProps(props);
        }
      }
    }, {
      key: "getChildContext",
      value: function getChildContext() {
        return {
          virtualizedList: {
            horizontal: this.props.horizontal
          }
        };
      }
    }]);

    function VirtualizedList(props, context) {
      babelHelpers.classCallCheck(this, VirtualizedList);

      var _this = babelHelpers.possibleConstructorReturn(this, (VirtualizedList.__proto__ || Object.getPrototypeOf(VirtualizedList)).call(this, props, context));

      _initialiseProps.call(_this);

      invariant(!props.onScroll || !props.onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');
      invariant(!(_this._isNestedWithSameOrientation() && props.onViewableItemsChanged), 'Nesting lists that scroll in the same direction does not support onViewableItemsChanged' + 'on the inner list.');
      _this._fillRateHelper = new FillRateHelper(_this._getFrameMetrics);
      _this._updateCellsToRenderBatcher = new Batchinator(_this._updateCellsToRender, _this.props.updateCellsBatchingPeriod);

      if (_this.props.viewabilityConfigCallbackPairs) {
        _this._viewabilityTuples = _this.props.viewabilityConfigCallbackPairs.map(function (pair) {
          return {
            viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),
            onViewableItemsChanged: pair.onViewableItemsChanged
          };
        });
      } else if (_this.props.onViewableItemsChanged) {
        _this._viewabilityTuples.push({
          viewabilityHelper: new ViewabilityHelper(_this.props.viewabilityConfig),
          onViewableItemsChanged: _this.props.onViewableItemsChanged
        });
      }

      _this.state = {
        first: _this.props.initialScrollIndex || 0,
        last: Math.min(_this.props.getItemCount(_this.props.data), (_this.props.initialScrollIndex || 0) + _this.props.initialNumToRender) - 1
      };
      return _this;
    }

    babelHelpers.createClass(VirtualizedList, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        if (this.props.initialScrollIndex) {
          this._initialScrollIndexTimeout = setTimeout(function () {
            return _this2.scrollToIndex({
              animated: false,
              index: _this2.props.initialScrollIndex
            });
          }, 0);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._updateViewableItems(null);

        this._updateCellsToRenderBatcher.dispose();

        this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.dispose();
        });

        this._fillRateHelper.deactivateAndFlush();

        clearTimeout(this._initialScrollIndexTimeout);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(newProps) {
        var data = newProps.data,
            extraData = newProps.extraData,
            getItemCount = newProps.getItemCount,
            maxToRenderPerBatch = newProps.maxToRenderPerBatch;
        this.setState({
          first: Math.max(0, Math.min(this.state.first, getItemCount(data) - 1 - maxToRenderPerBatch)),
          last: Math.max(0, Math.min(this.state.last, getItemCount(data) - 1))
        });

        if (data !== this.props.data || extraData !== this.props.extraData) {
          this._hasDataChangedSinceEndReached = true;

          this._viewabilityTuples.forEach(function (tuple) {
            tuple.viewabilityHelper.resetViewableIndices();
          });
        }
      }
    }, {
      key: "_pushCells",
      value: function _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
        var _this3 = this;

        var _props3 = this.props,
            CellRendererComponent = _props3.CellRendererComponent,
            ItemSeparatorComponent = _props3.ItemSeparatorComponent,
            data = _props3.data,
            getItem = _props3.getItem,
            getItemCount = _props3.getItemCount,
            horizontal = _props3.horizontal,
            keyExtractor = _props3.keyExtractor;
        var stickyOffset = this.props.ListHeaderComponent ? 1 : 0;
        var end = getItemCount(data) - 1;
        var prevCellKey = void 0;
        last = Math.min(end, last);

        var _loop = function _loop(ii) {
          var item = getItem(data, ii);
          var key = keyExtractor(item, ii);

          if (stickyIndicesFromProps.has(ii + stickyOffset)) {
            stickyHeaderIndices.push(cells.length);
          }

          cells.push(React.createElement(CellRenderer, {
            CellRendererComponent: CellRendererComponent,
            ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
            cellKey: key,
            fillRateHelper: _this3._fillRateHelper,
            horizontal: horizontal,
            index: ii,
            inversionStyle: inversionStyle,
            item: item,
            key: key,
            prevCellKey: prevCellKey,
            onUpdateSeparators: _this3._onUpdateSeparators,
            onLayout: function onLayout(e) {
              return _this3._onCellLayout(e, key, ii);
            },
            onUnmount: _this3._onCellUnmount,
            parentProps: _this3.props,
            ref: function ref(_ref) {
              _this3._cellRefs[key] = _ref;
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 556
            }
          }));
          prevCellKey = key;
        };

        for (var ii = first; ii <= last; ii++) {
          _loop(ii);
        }
      }
    }, {
      key: "_isVirtualizationDisabled",
      value: function _isVirtualizationDisabled() {
        return this.props.disableVirtualization || this._isNestedWithSameOrientation();
      }
    }, {
      key: "_isNestedWithSameOrientation",
      value: function _isNestedWithSameOrientation() {
        var nestedContext = this.context.virtualizedList;
        return !!(nestedContext && !!nestedContext.horizontal === !!this.props.horizontal);
      }
    }, {
      key: "render",
      value: function render() {
        if (__DEV__) {
          var flatStyles = flattenStyle(this.props.contentContainerStyle);
          warning(flatStyles == null || flatStyles.flexWrap !== 'wrap', '`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');
        }

        var _props4 = this.props,
            ListEmptyComponent = _props4.ListEmptyComponent,
            ListFooterComponent = _props4.ListFooterComponent,
            ListHeaderComponent = _props4.ListHeaderComponent;
        var _props5 = this.props,
            data = _props5.data,
            horizontal = _props5.horizontal;

        var isVirtualizationDisabled = this._isVirtualizationDisabled();

        var inversionStyle = this.props.inverted ? this.props.horizontal ? styles.horizontallyInverted : styles.verticallyInverted : null;
        var cells = [];
        var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
        var stickyHeaderIndices = [];

        if (ListHeaderComponent) {
          if (stickyIndicesFromProps.has(0)) {
            stickyHeaderIndices.push(0);
          }

          var element = React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : React.createElement(ListHeaderComponent, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 633
            }
          });
          cells.push(React.createElement(
            View,
            {
              key: "$header",
              onLayout: this._onLayoutHeader,
              style: inversionStyle,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 636
              }
            },
            element
          ));
        }

        var itemCount = this.props.getItemCount(data);

        if (itemCount > 0) {
          _usedIndexForKey = false;
          var spacerKey = !horizontal ? 'height' : 'width';
          var lastInitialIndex = this.props.initialScrollIndex ? -1 : this.props.initialNumToRender - 1;
          var _state = this.state,
              _first = _state.first,
              _last = _state.last;

          this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, 0, lastInitialIndex, inversionStyle);

          var firstAfterInitial = Math.max(lastInitialIndex + 1, _first);

          if (!isVirtualizationDisabled && _first > lastInitialIndex + 1) {
            var insertedStickySpacer = false;

            if (stickyIndicesFromProps.size > 0) {
              var stickyOffset = ListHeaderComponent ? 1 : 0;

              for (var ii = firstAfterInitial - 1; ii > lastInitialIndex; ii--) {
                if (stickyIndicesFromProps.has(ii + stickyOffset)) {
                  var initBlock = this._getFrameMetricsApprox(lastInitialIndex);

                  var stickyBlock = this._getFrameMetricsApprox(ii);

                  var leadSpace = stickyBlock.offset - (initBlock.offset + initBlock.length);
                  cells.push(React.createElement(View, {
                    key: "$sticky_lead",
                    style: babelHelpers.defineProperty({}, spacerKey, leadSpace),
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 673
                    }
                  }));

                  this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, ii, ii, inversionStyle);

                  var trailSpace = this._getFrameMetricsApprox(_first).offset - (stickyBlock.offset + stickyBlock.length);
                  cells.push(React.createElement(View, {
                    key: "$sticky_trail",
                    style: babelHelpers.defineProperty({}, spacerKey, trailSpace),
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 687
                    }
                  }));
                  insertedStickySpacer = true;
                  break;
                }
              }
            }

            if (!insertedStickySpacer) {
              var _initBlock = this._getFrameMetricsApprox(lastInitialIndex);

              var firstSpace = this._getFrameMetricsApprox(_first).offset - (_initBlock.offset + _initBlock.length);

              cells.push(React.createElement(View, {
                key: "$lead_spacer",
                style: babelHelpers.defineProperty({}, spacerKey, firstSpace),
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 700
                }
              }));
            }
          }

          this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, firstAfterInitial, _last, inversionStyle);

          if (!this._hasWarned.keys && _usedIndexForKey) {
            console.warn('VirtualizedList: missing keys for items, make sure to specify a key property on each ' + 'item or provide a custom keyExtractor.');
            this._hasWarned.keys = true;
          }

          if (!isVirtualizationDisabled && _last < itemCount - 1) {
            var lastFrame = this._getFrameMetricsApprox(_last);

            var end = this.props.getItemLayout ? itemCount - 1 : Math.min(itemCount - 1, this._highestMeasuredFrameIndex);

            var endFrame = this._getFrameMetricsApprox(end);

            var tailSpacerLength = endFrame.offset + endFrame.length - (lastFrame.offset + lastFrame.length);
            cells.push(React.createElement(View, {
              key: "$tail_spacer",
              style: babelHelpers.defineProperty({}, spacerKey, tailSpacerLength),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 733
              }
            }));
          }
        } else if (ListEmptyComponent) {
          var _element = React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : React.createElement(ListEmptyComponent, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 741
            }
          });

          cells.push(React.createElement(
            View,
            {
              key: "$empty",
              onLayout: this._onLayoutEmpty,
              style: inversionStyle,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 744
              }
            },
            _element
          ));
        }

        if (ListFooterComponent) {
          var _element2 = React.isValidElement(ListFooterComponent) ? ListFooterComponent : React.createElement(ListFooterComponent, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 757
            }
          });

          cells.push(React.createElement(
            View,
            {
              key: "$footer",
              onLayout: this._onLayoutFooter,
              style: inversionStyle,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 760
              }
            },
            _element2
          ));
        }

        var scrollProps = babelHelpers.extends({}, this.props, {
          onContentSizeChange: this._onContentSizeChange,
          onLayout: this._onLayout,
          onScroll: this._onScroll,
          onScrollBeginDrag: this._onScrollBeginDrag,
          onScrollEndDrag: this._onScrollEndDrag,
          onMomentumScrollEnd: this._onMomentumScrollEnd,
          scrollEventThrottle: this.props.scrollEventThrottle,
          stickyHeaderIndices: stickyHeaderIndices
        });

        if (inversionStyle) {
          scrollProps.style = [inversionStyle, this.props.style];
        }

        var ret = React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
          ref: this._captureScrollRef
        }, cells);

        if (this.props.debug) {
          return React.createElement(
            View,
            {
              style: {
                flex: 1
              },
              __source: {
                fileName: _jsxFileName,
                lineNumber: 793
              }
            },
            ret,
            this._renderDebugOverlay()
          );
        } else {
          return ret;
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this._scheduleCellsToRenderUpdate();
      }
    }, {
      key: "_computeBlankness",
      value: function _computeBlankness() {
        this._fillRateHelper.computeBlankness(this.props, this.state, this._scrollMetrics);
      }
    }, {
      key: "_onCellLayout",
      value: function _onCellLayout(e, cellKey, index) {
        var layout = e.nativeEvent.layout;
        var next = {
          offset: this._selectOffset(layout),
          length: this._selectLength(layout),
          index: index,
          inLayout: true
        };
        var curr = this._frames[cellKey];

        if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {
          this._totalCellLength += next.length - (curr ? curr.length : 0);
          this._totalCellsMeasured += curr ? 0 : 1;
          this._averageCellLength = this._totalCellLength / this._totalCellsMeasured;
          this._frames[cellKey] = next;
          this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);

          this._scheduleCellsToRenderUpdate();
        } else {
          this._frames[cellKey].inLayout = true;
        }

        this._computeBlankness();
      }
    }, {
      key: "_renderDebugOverlay",
      value: function _renderDebugOverlay() {
        var normalize = this._scrollMetrics.visibleLength / this._scrollMetrics.contentLength;
        var framesInLayout = [];
        var itemCount = this.props.getItemCount(this.props.data);

        for (var ii = 0; ii < itemCount; ii++) {
          var frame = this._getFrameMetricsApprox(ii);

          if (frame.inLayout) {
            framesInLayout.push(frame);
          }
        }

        var windowTop = this._getFrameMetricsApprox(this.state.first).offset;

        var frameLast = this._getFrameMetricsApprox(this.state.last);

        var windowLen = frameLast.offset + frameLast.length - windowTop;
        var visTop = this._scrollMetrics.offset;
        var visLen = this._scrollMetrics.visibleLength;
        var baseStyle = {
          position: 'absolute',
          top: 0,
          right: 0
        };
        return React.createElement(
          View,
          {
            style: babelHelpers.extends({}, baseStyle, {
              bottom: 0,
              width: 20,
              borderColor: 'blue',
              borderWidth: 1
            }),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 952
            }
          },
          framesInLayout.map(function (f, ii) {
            return React.createElement(View, {
              key: 'f' + ii,
              style: babelHelpers.extends({}, baseStyle, {
                left: 0,
                top: f.offset * normalize,
                height: f.length * normalize,
                backgroundColor: 'orange'
              }),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 961
              }
            });
          }),
          React.createElement(View, {
            style: babelHelpers.extends({}, baseStyle, {
              left: 0,
              top: windowTop * normalize,
              height: windowLen * normalize,
              borderColor: 'green',
              borderWidth: 2
            }),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 972
            }
          }),
          React.createElement(View, {
            style: babelHelpers.extends({}, baseStyle, {
              left: 0,
              top: visTop * normalize,
              height: visLen * normalize,
              borderColor: 'red',
              borderWidth: 2
            }),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 982
            }
          })
        );
      }
    }, {
      key: "_selectLength",
      value: function _selectLength(metrics) {
        return !this.props.horizontal ? metrics.height : metrics.width;
      }
    }, {
      key: "_selectOffset",
      value: function _selectOffset(metrics) {
        return !this.props.horizontal ? metrics.y : metrics.x;
      }
    }, {
      key: "_maybeCallOnEndReached",
      value: function _maybeCallOnEndReached() {
        var _props6 = this.props,
            data = _props6.data,
            getItemCount = _props6.getItemCount,
            onEndReached = _props6.onEndReached,
            onEndReachedThreshold = _props6.onEndReachedThreshold;
        var _scrollMetrics = this._scrollMetrics,
            contentLength = _scrollMetrics.contentLength,
            visibleLength = _scrollMetrics.visibleLength,
            offset = _scrollMetrics.offset;
        var distanceFromEnd = contentLength - visibleLength - offset;

        if (onEndReached && this.state.last === getItemCount(data) - 1 && distanceFromEnd < onEndReachedThreshold * visibleLength && (this._hasDataChangedSinceEndReached || this._scrollMetrics.contentLength !== this._sentEndForContentLength)) {
          this._hasDataChangedSinceEndReached = false;
          this._sentEndForContentLength = this._scrollMetrics.contentLength;
          onEndReached({
            distanceFromEnd: distanceFromEnd
          });
        }
      }
    }, {
      key: "_scheduleCellsToRenderUpdate",
      value: function _scheduleCellsToRenderUpdate() {
        var _state2 = this.state,
            first = _state2.first,
            last = _state2.last;
        var _scrollMetrics2 = this._scrollMetrics,
            offset = _scrollMetrics2.offset,
            visibleLength = _scrollMetrics2.visibleLength,
            velocity = _scrollMetrics2.velocity;
        var itemCount = this.props.getItemCount(this.props.data);
        var hiPri = false;

        if (first > 0 || last < itemCount - 1) {
          var distTop = offset - this._getFrameMetricsApprox(first).offset;

          var distBottom = this._getFrameMetricsApprox(last).offset - (offset + visibleLength);
          var scrollingThreshold = this.props.onEndReachedThreshold * visibleLength / 2;
          hiPri = Math.min(distTop, distBottom) < 0 || velocity < -2 && distTop < scrollingThreshold || velocity > 2 && distBottom < scrollingThreshold;
        }

        if (hiPri && this._averageCellLength) {
          this._updateCellsToRenderBatcher.dispose({
            abort: true
          });

          this._updateCellsToRender();

          return;
        } else {
          this._updateCellsToRenderBatcher.schedule();
        }
      }
    }, {
      key: "_updateViewableItems",
      value: function _updateViewableItems(data) {
        var _this4 = this;

        var getItemCount = this.props.getItemCount;

        this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.onUpdate(getItemCount(data), _this4._scrollMetrics.offset, _this4._scrollMetrics.visibleLength, _this4._getFrameMetrics, _this4._createViewToken, tuple.onViewableItemsChanged, _this4.state);
        });
      }
    }]);
    return VirtualizedList;
  }(React.PureComponent);

  VirtualizedList.defaultProps = {
    disableVirtualization: false,
    horizontal: false,
    initialNumToRender: 10,
    keyExtractor: function keyExtractor(item, index) {
      if (item.key != null) {
        return item.key;
      }

      _usedIndexForKey = true;
      return String(index);
    },
    maxToRenderPerBatch: 10,
    onEndReachedThreshold: 2,
    scrollEventThrottle: 50,
    updateCellsBatchingPeriod: 50,
    windowSize: 21
  };
  VirtualizedList.contextTypes = {
    virtualizedList: PropTypes.shape({
      horizontal: PropTypes.bool
    })
  };
  VirtualizedList.childContextTypes = {
    virtualizedList: PropTypes.shape({
      horizontal: PropTypes.bool
    })
  };

  var _initialiseProps = function _initialiseProps() {
    var _this6 = this;

    this._onUpdateSeparators = function (keys, newProps) {
      keys.forEach(function (key) {
        var ref = key != null && _this6._cellRefs[key];
        ref && ref.updateSeparatorProps(newProps);
      });
    };

    this._averageCellLength = 0;
    this._cellRefs = {};
    this._hasDataChangedSinceEndReached = true;
    this._hasWarned = {};
    this._highestMeasuredFrameIndex = 0;
    this._headerLength = 0;
    this._initialScrollIndexTimeout = 0;
    this._frames = {};
    this._footerLength = 0;
    this._scrollMetrics = {
      contentLength: 0,
      dOffset: 0,
      dt: 10,
      offset: 0,
      timestamp: 0,
      velocity: 0,
      visibleLength: 0
    };
    this._scrollRef = null;
    this._sentEndForContentLength = 0;
    this._totalCellLength = 0;
    this._totalCellsMeasured = 0;
    this._viewabilityTuples = [];

    this._captureScrollRef = function (ref) {
      _this6._scrollRef = ref;
    };

    this._defaultRenderScrollComponent = function (props) {
      if (_this6._isNestedWithSameOrientation()) {
        return React.createElement(View, babelHelpers.extends({}, props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 847
          }
        }));
      } else if (props.onRefresh) {
        invariant(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify(props.refreshing) + '`');
        return React.createElement(ScrollView, babelHelpers.extends({}, props, {
          refreshControl: React.createElement(RefreshControl, {
            refreshing: props.refreshing,
            onRefresh: props.onRefresh,
            progressViewOffset: props.progressViewOffset,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 862
            }
          }),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 856
          }
        }));
      } else {
        return React.createElement(ScrollView, babelHelpers.extends({}, props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 871
          }
        }));
      }
    };

    this._onCellUnmount = function (cellKey) {
      var curr = _this6._frames[cellKey];

      if (curr) {
        _this6._frames[cellKey] = babelHelpers.extends({}, curr, {
          inLayout: false
        });
      }
    };

    this._onLayout = function (e) {
      _this6._scrollMetrics.visibleLength = _this6._selectLength(e.nativeEvent.layout);
      _this6.props.onLayout && _this6.props.onLayout(e);

      _this6._scheduleCellsToRenderUpdate();

      _this6._maybeCallOnEndReached();
    };

    this._onLayoutEmpty = function (e) {
      _this6.props.onLayout && _this6.props.onLayout(e);
    };

    this._onLayoutFooter = function (e) {
      _this6._footerLength = _this6._selectLength(e.nativeEvent.layout);
    };

    this._onLayoutHeader = function (e) {
      _this6._headerLength = _this6._selectLength(e.nativeEvent.layout);
    };

    this._onContentSizeChange = function (width, height) {
      if (_this6.props.onContentSizeChange) {
        _this6.props.onContentSizeChange(width, height);
      }

      _this6._scrollMetrics.contentLength = _this6._selectLength({
        height: height,
        width: width
      });

      _this6._scheduleCellsToRenderUpdate();

      _this6._maybeCallOnEndReached();
    };

    this._onScroll = function (e) {
      if (_this6.props.onScroll) {
        _this6.props.onScroll(e);
      }

      var timestamp = e.timeStamp;

      var visibleLength = _this6._selectLength(e.nativeEvent.layoutMeasurement);

      var contentLength = _this6._selectLength(e.nativeEvent.contentSize);

      var offset = _this6._selectOffset(e.nativeEvent.contentOffset);

      var dt = _this6._scrollMetrics.timestamp ? Math.max(1, timestamp - _this6._scrollMetrics.timestamp) : 1;

      if (dt > 500 && _this6._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !_this6._hasWarned.perf) {
        infoLog('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {
          dt: dt,
          prevDt: _this6._scrollMetrics.dt,
          contentLength: contentLength
        });
        _this6._hasWarned.perf = true;
      }

      var dOffset = offset - _this6._scrollMetrics.offset;
      var velocity = dOffset / dt;
      _this6._scrollMetrics = {
        contentLength: contentLength,
        dt: dt,
        dOffset: dOffset,
        offset: offset,
        timestamp: timestamp,
        velocity: velocity,
        visibleLength: visibleLength
      };

      _this6._updateViewableItems(_this6.props.data);

      if (!_this6.props) {
        return;
      }

      _this6._maybeCallOnEndReached();

      if (velocity !== 0) {
        _this6._fillRateHelper.activate();
      }

      _this6._computeBlankness();

      _this6._scheduleCellsToRenderUpdate();
    };

    this._onScrollBeginDrag = function (e) {
      _this6._viewabilityTuples.forEach(function (tuple) {
        tuple.viewabilityHelper.recordInteraction();
      });

      _this6.props.onScrollBeginDrag && _this6.props.onScrollBeginDrag(e);
    };

    this._onScrollEndDrag = function (e) {
      var velocity = e.nativeEvent.velocity;

      if (velocity) {
        _this6._scrollMetrics.velocity = _this6._selectOffset(velocity);
      }

      _this6._computeBlankness();

      _this6.props.onScrollEndDrag && _this6.props.onScrollEndDrag(e);
    };

    this._onMomentumScrollEnd = function (e) {
      _this6._scrollMetrics.velocity = 0;

      _this6._computeBlankness();

      _this6.props.onMomentumScrollEnd && _this6.props.onMomentumScrollEnd(e);
    };

    this._updateCellsToRender = function () {
      var _props8 = _this6.props,
          data = _props8.data,
          getItemCount = _props8.getItemCount,
          onEndReachedThreshold = _props8.onEndReachedThreshold;

      var isVirtualizationDisabled = _this6._isVirtualizationDisabled();

      _this6._updateViewableItems(data);

      if (!data) {
        return;
      }

      _this6.setState(function (state) {
        var newState = void 0;

        if (!isVirtualizationDisabled) {
          if (_this6._scrollMetrics.visibleLength) {
            if (!_this6.props.initialScrollIndex || _this6._scrollMetrics.offset) {
              newState = computeWindowedRenderLimits(_this6.props, state, _this6._getFrameMetricsApprox, _this6._scrollMetrics);
            }
          }
        } else {
          var _scrollMetrics3 = _this6._scrollMetrics,
              contentLength = _scrollMetrics3.contentLength,
              _offset = _scrollMetrics3.offset,
              visibleLength = _scrollMetrics3.visibleLength;

          var _distanceFromEnd = contentLength - visibleLength - _offset;

          var renderAhead = _distanceFromEnd < onEndReachedThreshold * visibleLength ? _this6.props.maxToRenderPerBatch : 0;
          newState = {
            first: 0,
            last: Math.min(state.last + renderAhead, getItemCount(data) - 1)
          };
        }

        return newState;
      });
    };

    this._createViewToken = function (index, isViewable) {
      var _props9 = _this6.props,
          data = _props9.data,
          getItem = _props9.getItem,
          keyExtractor = _props9.keyExtractor;
      var item = getItem(data, index);
      return {
        index: index,
        item: item,
        key: keyExtractor(item, index),
        isViewable: isViewable
      };
    };

    this._getFrameMetricsApprox = function (index) {
      var frame = _this6._getFrameMetrics(index);

      if (frame && frame.index === index) {
        return frame;
      } else {
        var _getItemLayout = _this6.props.getItemLayout;
        invariant(!_getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');
        return {
          length: _this6._averageCellLength,
          offset: _this6._averageCellLength * index
        };
      }
    };

    this._getFrameMetrics = function (index) {
      var _props10 = _this6.props,
          data = _props10.data,
          getItem = _props10.getItem,
          getItemCount = _props10.getItemCount,
          getItemLayout = _props10.getItemLayout,
          keyExtractor = _props10.keyExtractor;
      invariant(getItemCount(data) > index, 'Tried to get frame for out of range index ' + index);
      var item = getItem(data, index);

      var frame = item && _this6._frames[keyExtractor(item, index)];

      if (!frame || frame.index !== index) {
        if (getItemLayout) {
          frame = getItemLayout(data, index);

          if (__DEV__) {
            var frameType = PropTypes.shape({
              length: PropTypes.number.isRequired,
              offset: PropTypes.number.isRequired,
              index: PropTypes.number.isRequired
            }).isRequired;
            PropTypes.checkPropTypes({
              frame: frameType
            }, {
              frame: frame
            }, 'frame', 'VirtualizedList.getItemLayout');
          }
        }
      }

      return frame;
    };
  };

  var CellRenderer = function (_React$Component) {
    babelHelpers.inherits(CellRenderer, _React$Component);

    function CellRenderer() {
      var _ref6;

      var _temp, _this5, _ret2;

      babelHelpers.classCallCheck(this, CellRenderer);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret2 = (_temp = (_this5 = babelHelpers.possibleConstructorReturn(this, (_ref6 = CellRenderer.__proto__ || Object.getPrototypeOf(CellRenderer)).call.apply(_ref6, [this].concat(args))), _this5), _this5.state = {
        separatorProps: {
          highlighted: false,
          leadingItem: _this5.props.item
        }
      }, _this5._separators = {
        highlight: function highlight() {
          var _this5$props = _this5.props,
              cellKey = _this5$props.cellKey,
              prevCellKey = _this5$props.prevCellKey;

          _this5.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: true
          });
        },
        unhighlight: function unhighlight() {
          var _this5$props2 = _this5.props,
              cellKey = _this5$props2.cellKey,
              prevCellKey = _this5$props2.prevCellKey;

          _this5.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: false
          });
        },
        updateProps: function updateProps(select, newProps) {
          var _this5$props3 = _this5.props,
              cellKey = _this5$props3.cellKey,
              prevCellKey = _this5$props3.prevCellKey;

          _this5.props.onUpdateSeparators([select === 'leading' ? prevCellKey : cellKey], newProps);
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this5, _ret2);
    }

    babelHelpers.createClass(CellRenderer, [{
      key: "updateSeparatorProps",
      value: function updateSeparatorProps(newProps) {
        this.setState(function (state) {
          return {
            separatorProps: babelHelpers.extends({}, state.separatorProps, newProps)
          };
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.props.onUnmount(this.props.cellKey);
      }
    }, {
      key: "render",
      value: function render() {
        var _props7 = this.props,
            CellRendererComponent = _props7.CellRendererComponent,
            ItemSeparatorComponent = _props7.ItemSeparatorComponent,
            fillRateHelper = _props7.fillRateHelper,
            horizontal = _props7.horizontal,
            item = _props7.item,
            index = _props7.index,
            inversionStyle = _props7.inversionStyle,
            parentProps = _props7.parentProps;
        var renderItem = parentProps.renderItem,
            getItemLayout = parentProps.getItemLayout;
        invariant(renderItem, 'no renderItem!');
        var element = renderItem({
          item: item,
          index: index,
          separators: this._separators
        });
        var onLayout = getItemLayout && !parentProps.debug && !fillRateHelper.enabled() ? undefined : this.props.onLayout;
        var itemSeparator = ItemSeparatorComponent && React.createElement(ItemSeparatorComponent, babelHelpers.extends({}, this.state.separatorProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 1354
          }
        }));
        var cellStyle = inversionStyle ? horizontal ? [{
          flexDirection: 'row-reverse'
        }, inversionStyle] : [{
          flexDirection: 'column-reverse'
        }, inversionStyle] : horizontal ? [{
          flexDirection: 'row'
        }, inversionStyle] : inversionStyle;

        if (!CellRendererComponent) {
          return React.createElement(
            View,
            {
              style: cellStyle,
              onLayout: onLayout,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 1363
              }
            },
            element,
            itemSeparator
          );
        }

        return React.createElement(
          CellRendererComponent,
          babelHelpers.extends({}, this.props, {
            style: cellStyle,
            onLayout: onLayout,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 1370
            }
          }),
          element,
          itemSeparator
        );
      }
    }]);
    return CellRenderer;
  }(React.Component);

  var styles = StyleSheet.create({
    verticallyInverted: {
      transform: [{
        scaleY: -1
      }]
    },
    horizontallyInverted: {
      transform: [{
        scaleX: -1
      }]
    }
  });
  module.exports = VirtualizedList;
},288,[289,290,24,171,74,287,265,209,211,291,152,145,18,19,292],"VirtualizedList");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var InteractionManager = require(_dependencyMap[0], 'InteractionManager');

  var Batchinator = function () {
    function Batchinator(callback, delayMS) {
      babelHelpers.classCallCheck(this, Batchinator);
      this._delay = delayMS;
      this._callback = callback;
    }

    babelHelpers.createClass(Batchinator, [{
      key: "dispose",
      value: function dispose() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          abort: false
        };

        if (this._taskHandle) {
          this._taskHandle.cancel();

          if (!options.abort) {
            this._callback();
          }

          this._taskHandle = null;
        }
      }
    }, {
      key: "schedule",
      value: function schedule() {
        var _this = this;

        if (this._taskHandle) {
          return;
        }

        var timeoutHandle = setTimeout(function () {
          _this._taskHandle = InteractionManager.runAfterInteractions(function () {
            _this._taskHandle = null;

            _this._callback();
          });
        }, this._delay);
        this._taskHandle = {
          cancel: function cancel() {
            return clearTimeout(timeoutHandle);
          }
        };
      }
    }]);
    return Batchinator;
  }();

  module.exports = Batchinator;
},289,[243],"Batchinator");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var performanceNow = require(_dependencyMap[0], 'fbjs/lib/performanceNow');

  var warning = require(_dependencyMap[1], 'fbjs/lib/warning');

  var Info = function Info() {
    babelHelpers.classCallCheck(this, Info);
    this.any_blank_count = 0;
    this.any_blank_ms = 0;
    this.any_blank_speed_sum = 0;
    this.mostly_blank_count = 0;
    this.mostly_blank_ms = 0;
    this.pixels_blank = 0;
    this.pixels_sampled = 0;
    this.pixels_scrolled = 0;
    this.total_time_spent = 0;
    this.sample_count = 0;
  };

  var DEBUG = false;
  var _listeners = [];
  var _minSampleCount = 10;

  var _sampleRate = DEBUG ? 1 : null;

  var FillRateHelper = function () {
    babelHelpers.createClass(FillRateHelper, null, [{
      key: "addListener",
      value: function addListener(callback) {
        warning(_sampleRate !== null, 'Call `FillRateHelper.setSampleRate` before `addListener`.');

        _listeners.push(callback);

        return {
          remove: function remove() {
            _listeners = _listeners.filter(function (listener) {
              return callback !== listener;
            });
          }
        };
      }
    }, {
      key: "setSampleRate",
      value: function setSampleRate(sampleRate) {
        _sampleRate = sampleRate;
      }
    }, {
      key: "setMinSampleCount",
      value: function setMinSampleCount(minSampleCount) {
        _minSampleCount = minSampleCount;
      }
    }]);

    function FillRateHelper(getFrameMetrics) {
      babelHelpers.classCallCheck(this, FillRateHelper);
      this._anyBlankStartTime = null;
      this._enabled = false;
      this._info = new Info();
      this._mostlyBlankStartTime = null;
      this._samplesStartTime = null;
      this._getFrameMetrics = getFrameMetrics;
      this._enabled = (_sampleRate || 0) > Math.random();

      this._resetData();
    }

    babelHelpers.createClass(FillRateHelper, [{
      key: "activate",
      value: function activate() {
        if (this._enabled && this._samplesStartTime == null) {
          DEBUG && console.debug('FillRateHelper: activate');
          this._samplesStartTime = performanceNow();
        }
      }
    }, {
      key: "deactivateAndFlush",
      value: function deactivateAndFlush() {
        if (!this._enabled) {
          return;
        }

        var start = this._samplesStartTime;

        if (start == null) {
          DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');
          return;
        }

        if (this._info.sample_count < _minSampleCount) {
          this._resetData();

          return;
        }

        var total_time_spent = performanceNow() - start;
        var info = babelHelpers.extends({}, this._info, {
          total_time_spent: total_time_spent
        });

        if (DEBUG) {
          var derived = {
            avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,
            avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),
            avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,
            any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),
            any_blank_time_frac: this._info.any_blank_ms / total_time_spent,
            mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),
            mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent
          };

          for (var key in derived) {
            derived[key] = Math.round(1000 * derived[key]) / 1000;
          }

          console.debug('FillRateHelper deactivateAndFlush: ', {
            derived: derived,
            info: info
          });
        }

        _listeners.forEach(function (listener) {
          return listener(info);
        });

        this._resetData();
      }
    }, {
      key: "computeBlankness",
      value: function computeBlankness(props, state, scrollMetrics) {
        if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {
          return 0;
        }

        var dOffset = scrollMetrics.dOffset,
            offset = scrollMetrics.offset,
            velocity = scrollMetrics.velocity,
            visibleLength = scrollMetrics.visibleLength;
        this._info.sample_count++;
        this._info.pixels_sampled += Math.round(visibleLength);
        this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
        var scrollSpeed = Math.round(Math.abs(velocity) * 1000);
        var now = performanceNow();

        if (this._anyBlankStartTime != null) {
          this._info.any_blank_ms += now - this._anyBlankStartTime;
        }

        this._anyBlankStartTime = null;

        if (this._mostlyBlankStartTime != null) {
          this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
        }

        this._mostlyBlankStartTime = null;
        var blankTop = 0;
        var first = state.first;

        var firstFrame = this._getFrameMetrics(first);

        while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {
          firstFrame = this._getFrameMetrics(first);
          first++;
        }

        if (firstFrame && first > 0) {
          blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
        }

        var blankBottom = 0;
        var last = state.last;

        var lastFrame = this._getFrameMetrics(last);

        while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {
          lastFrame = this._getFrameMetrics(last);
          last--;
        }

        if (lastFrame && last < props.getItemCount(props.data) - 1) {
          var bottomEdge = lastFrame.offset + lastFrame.length;
          blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
        }

        var pixels_blank = Math.round(blankTop + blankBottom);
        var blankness = pixels_blank / visibleLength;

        if (blankness > 0) {
          this._anyBlankStartTime = now;
          this._info.any_blank_speed_sum += scrollSpeed;
          this._info.any_blank_count++;
          this._info.pixels_blank += pixels_blank;

          if (blankness > 0.5) {
            this._mostlyBlankStartTime = now;
            this._info.mostly_blank_count++;
          }
        } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
          this.deactivateAndFlush();
        }

        return blankness;
      }
    }, {
      key: "enabled",
      value: function enabled() {
        return this._enabled;
      }
    }, {
      key: "_resetData",
      value: function _resetData() {
        this._anyBlankStartTime = null;
        this._info = new Info();
        this._mostlyBlankStartTime = null;
        this._samplesStartTime = null;
      }
    }]);
    return FillRateHelper;
  }();

  module.exports = FillRateHelper;
},290,[106,19],"FillRateHelper");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var ViewabilityHelper = function () {
    function ViewabilityHelper() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        viewAreaCoveragePercentThreshold: 0
      };
      babelHelpers.classCallCheck(this, ViewabilityHelper);
      this._hasInteracted = false;
      this._timers = new Set();
      this._viewableIndices = [];
      this._viewableItems = new Map();
      this._config = config;
    }

    babelHelpers.createClass(ViewabilityHelper, [{
      key: "dispose",
      value: function dispose() {
        this._timers.forEach(clearTimeout);
      }
    }, {
      key: "computeViewableItems",
      value: function computeViewableItems(itemCount, scrollOffset, viewportHeight, getFrameMetrics, renderRange) {
        var _config = this._config,
            itemVisiblePercentThreshold = _config.itemVisiblePercentThreshold,
            viewAreaCoveragePercentThreshold = _config.viewAreaCoveragePercentThreshold;
        var viewAreaMode = viewAreaCoveragePercentThreshold != null;
        var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
        invariant(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');
        var viewableIndices = [];

        if (itemCount === 0) {
          return viewableIndices;
        }

        var firstVisible = -1;

        var _ref = renderRange || {
          first: 0,
          last: itemCount - 1
        },
            first = _ref.first,
            last = _ref.last;

        invariant(last < itemCount, 'Invalid render range ' + JSON.stringify({
          renderRange: renderRange,
          itemCount: itemCount
        }));

        for (var idx = first; idx <= last; idx++) {
          var metrics = getFrameMetrics(idx);

          if (!metrics) {
            continue;
          }

          var top = metrics.offset - scrollOffset;
          var bottom = top + metrics.length;

          if (top < viewportHeight && bottom > 0) {
            firstVisible = idx;

            if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
              viewableIndices.push(idx);
            }
          } else if (firstVisible >= 0) {
            break;
          }
        }

        return viewableIndices;
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(itemCount, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged, renderRange) {
        var _this = this;

        if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0)) {
          return;
        }

        var viewableIndices = [];

        if (itemCount) {
          viewableIndices = this.computeViewableItems(itemCount, scrollOffset, viewportHeight, getFrameMetrics, renderRange);
        }

        if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every(function (v, ii) {
          return v === viewableIndices[ii];
        })) {
          return;
        }

        this._viewableIndices = viewableIndices;

        if (this._config.minimumViewTime) {
          var handle = setTimeout(function () {
            _this._timers.delete(handle);

            _this._onUpdateSync(viewableIndices, onViewableItemsChanged, createViewToken);
          }, this._config.minimumViewTime);

          this._timers.add(handle);
        } else {
          this._onUpdateSync(viewableIndices, onViewableItemsChanged, createViewToken);
        }
      }
    }, {
      key: "resetViewableIndices",
      value: function resetViewableIndices() {
        this._viewableIndices = [];
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        this._hasInteracted = true;
      }
    }, {
      key: "_onUpdateSync",
      value: function _onUpdateSync(viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
        var _this2 = this;

        viewableIndicesToCheck = viewableIndicesToCheck.filter(function (ii) {
          return _this2._viewableIndices.includes(ii);
        });
        var prevItems = this._viewableItems;
        var nextItems = new Map(viewableIndicesToCheck.map(function (ii) {
          var viewable = createViewToken(ii, true);
          return [viewable.key, viewable];
        }));
        var changed = [];

        for (var _iterator = nextItems, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref4;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref4 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref4 = _i.value;
          }

          var _ref2 = _ref4;

          var _ref3 = babelHelpers.slicedToArray(_ref2, 2);

          var _key = _ref3[0];
          var viewable = _ref3[1];

          if (!prevItems.has(_key)) {
            changed.push(viewable);
          }
        }

        for (var _iterator2 = prevItems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref7;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref7 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref7 = _i2.value;
          }

          var _ref5 = _ref7;

          var _ref6 = babelHelpers.slicedToArray(_ref5, 2);

          var _key2 = _ref6[0];
          var _viewable = _ref6[1];

          if (!nextItems.has(_key2)) {
            changed.push(babelHelpers.extends({}, _viewable, {
              isViewable: false
            }));
          }
        }

        if (changed.length > 0) {
          this._viewableItems = nextItems;
          onViewableItemsChanged({
            viewableItems: Array.from(nextItems.values()),
            changed: changed,
            viewabilityConfig: this._config
          });
        }
      }
    }]);
    return ViewabilityHelper;
  }();

  function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
    if (_isEntirelyVisible(top, bottom, viewportHeight)) {
      return true;
    } else {
      var pixels = _getPixelsVisible(top, bottom, viewportHeight);

      var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
      return percent >= viewablePercentThreshold;
    }
  }

  function _getPixelsVisible(top, bottom, viewportHeight) {
    var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
    return Math.max(0, visibleHeight);
  }

  function _isEntirelyVisible(top, bottom, viewportHeight) {
    return top >= 0 && bottom <= viewportHeight && bottom > top;
  }

  module.exports = ViewabilityHelper;
},291,[18],"ViewabilityHelper");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  function elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {
    var out = [];

    for (var ii = 0; ii < itemCount; ii++) {
      var frame = getFrameMetrics(ii);
      var trailingOffset = frame.offset + frame.length;

      for (var kk = 0; kk < offsets.length; kk++) {
        if (out[kk] == null && trailingOffset >= offsets[kk]) {
          out[kk] = ii;

          if (kk === offsets.length - 1) {
            invariant(out.length === offsets.length, 'bad offsets input, should be in increasing order ' + JSON.stringify(offsets));
            return out;
          }
        }
      }
    }

    return out;
  }

  function newRangeCount(prev, next) {
    return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
  }

  function computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {
    var data = props.data,
        getItemCount = props.getItemCount,
        maxToRenderPerBatch = props.maxToRenderPerBatch,
        windowSize = props.windowSize;
    var itemCount = getItemCount(data);

    if (itemCount === 0) {
      return prev;
    }

    var offset = scrollMetrics.offset,
        velocity = scrollMetrics.velocity,
        visibleLength = scrollMetrics.visibleLength;
    var visibleBegin = Math.max(0, offset);
    var visibleEnd = visibleBegin + visibleLength;
    var overscanLength = (windowSize - 1) * visibleLength;
    var leadFactor = 0.5;
    var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
    var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);
    var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);

    var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),
        _elementsThatOverlapO2 = babelHelpers.slicedToArray(_elementsThatOverlapO, 4),
        overscanFirst = _elementsThatOverlapO2[0],
        first = _elementsThatOverlapO2[1],
        last = _elementsThatOverlapO2[2],
        overscanLast = _elementsThatOverlapO2[3];

    overscanFirst = overscanFirst == null ? 0 : overscanFirst;
    first = first == null ? Math.max(0, overscanFirst) : first;
    overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
    last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
    var visible = {
      first: first,
      last: last
    };
    var newCellCount = newRangeCount(prev, visible);

    while (true) {
      if (first <= overscanFirst && last >= overscanLast) {
        break;
      }

      var maxNewCells = newCellCount >= maxToRenderPerBatch;
      var firstWillAddMore = first <= prev.first || first > prev.last;
      var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
      var lastWillAddMore = last >= prev.last || last < prev.first;
      var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);

      if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
        break;
      }

      if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
        if (firstWillAddMore) {
          newCellCount++;
        }

        first--;
      }

      if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
        if (lastWillAddMore) {
          newCellCount++;
        }

        last++;
      }
    }

    if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
      throw new Error('Bad window calculation ' + JSON.stringify({
        first: first,
        last: last,
        itemCount: itemCount,
        overscanFirst: overscanFirst,
        overscanLast: overscanLast,
        visible: visible
      }));
    }

    return {
      first: first,
      last: last
    };
  }

  var VirtualizeUtils = {
    computeWindowedRenderLimits: computeWindowedRenderLimits,
    elementsThatOverlapOffsets: elementsThatOverlapOffsets,
    newRangeCount: newRangeCount
  };
  module.exports = VirtualizeUtils;
},292,[18],"VirtualizeUtils");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Image/ImageBackground.js";

  var Image = require(_dependencyMap[0], 'Image');

  var React = require(_dependencyMap[1], 'React');

  var StyleSheet = require(_dependencyMap[2], 'StyleSheet');

  var View = require(_dependencyMap[3], 'View');

  var ensureComponentIsNative = require(_dependencyMap[4], 'ensureComponentIsNative');

  var ImageBackground = function (_React$Component) {
    babelHelpers.inherits(ImageBackground, _React$Component);

    function ImageBackground() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, ImageBackground);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = ImageBackground.__proto__ || Object.getPrototypeOf(ImageBackground)).call.apply(_ref, [this].concat(args))), _this), _this._viewRef = null, _this._captureRef = function (ref) {
        _this._viewRef = ref;
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(ImageBackground, [{
      key: "setNativeProps",
      value: function setNativeProps(props) {
        var viewRef = this._viewRef;

        if (viewRef) {
          ensureComponentIsNative(viewRef);
          viewRef.setNativeProps(props);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            children = _props.children,
            style = _props.style,
            imageStyle = _props.imageStyle,
            imageRef = _props.imageRef,
            props = babelHelpers.objectWithoutProperties(_props, ["children", "style", "imageStyle", "imageRef"]);
        return React.createElement(
          View,
          {
            style: style,
            ref: this._captureRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 68
            }
          },
          React.createElement(Image, babelHelpers.extends({}, props, {
            style: [StyleSheet.absoluteFill, {
              width: style.width,
              height: style.height
            }, imageStyle],
            ref: imageRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 69
            }
          })),
          children
        );
      }
    }]);
    return ImageBackground;
  }(React.Component);

  module.exports = ImageBackground;
},293,[263,171,209,211,294],"ImageBackground");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var ensureComponentIsNative = function ensureComponentIsNative(component) {
    invariant(component && typeof component.setNativeProps === 'function', 'Touchable child must either be native or forward setNativeProps to a ' + 'native component');
  };

  module.exports = ensureComponentIsNative;
},294,[18],"ensureComponentIsNative");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTImageEditingManager = require(_dependencyMap[0], 'NativeModules').ImageEditingManager;

  var ImageEditor = function () {
    function ImageEditor() {
      babelHelpers.classCallCheck(this, ImageEditor);
    }

    babelHelpers.createClass(ImageEditor, null, [{
      key: "cropImage",
      value: function cropImage(uri, cropData, success, failure) {
        RCTImageEditingManager.cropImage(uri, cropData, success, failure);
      }
    }]);
    return ImageEditor;
  }();

  module.exports = ImageEditor;
},295,[68],"ImageEditor");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTImageStoreManager = require(_dependencyMap[0], 'NativeModules').ImageStoreManager;

  var ImageStore = function () {
    function ImageStore() {
      babelHelpers.classCallCheck(this, ImageStore);
    }

    babelHelpers.createClass(ImageStore, null, [{
      key: "hasImageForTag",
      value: function hasImageForTag(uri, callback) {
        if (RCTImageStoreManager.hasImageForTag) {
          RCTImageStoreManager.hasImageForTag(uri, callback);
        } else {
          console.warn('hasImageForTag() not implemented');
        }
      }
    }, {
      key: "removeImageForTag",
      value: function removeImageForTag(uri) {
        if (RCTImageStoreManager.removeImageForTag) {
          RCTImageStoreManager.removeImageForTag(uri);
        } else {
          console.warn('removeImageForTag() not implemented');
        }
      }
    }, {
      key: "addImageFromBase64",
      value: function addImageFromBase64(base64ImageData, success, failure) {
        RCTImageStoreManager.addImageFromBase64(base64ImageData, success, failure);
      }
    }, {
      key: "getBase64ForTag",
      value: function getBase64ForTag(uri, success, failure) {
        RCTImageStoreManager.getBase64ForTag(uri, success, failure);
      }
    }]);
    return ImageStore;
  }();

  module.exports = ImageStore;
},296,[68],"ImageStore");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/Keyboard/KeyboardAvoidingView.js";

  var createReactClass = require(_dependencyMap[0], 'create-react-class');

  var Keyboard = require(_dependencyMap[1], 'Keyboard');

  var LayoutAnimation = require(_dependencyMap[2], 'LayoutAnimation');

  var Platform = require(_dependencyMap[3], 'Platform');

  var PropTypes = require(_dependencyMap[4], 'prop-types');

  var React = require(_dependencyMap[5], 'React');

  var TimerMixin = require(_dependencyMap[6], 'react-timer-mixin');

  var View = require(_dependencyMap[7], 'View');

  var ViewPropTypes = require(_dependencyMap[8], 'ViewPropTypes');

  var viewRef = 'VIEW';
  var KeyboardAvoidingView = createReactClass({
    displayName: 'KeyboardAvoidingView',
    mixins: [TimerMixin],
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      behavior: PropTypes.oneOf(['height', 'position', 'padding']),
      contentContainerStyle: ViewPropTypes.style,
      keyboardVerticalOffset: PropTypes.number.isRequired
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        keyboardVerticalOffset: 0
      };
    },
    getInitialState: function getInitialState() {
      return {
        bottom: 0
      };
    },
    subscriptions: [],
    frame: null,
    _relativeKeyboardHeight: function _relativeKeyboardHeight(keyboardFrame) {
      var frame = this.frame;

      if (!frame || !keyboardFrame) {
        return 0;
      }

      var keyboardY = keyboardFrame.screenY - this.props.keyboardVerticalOffset;
      return Math.max(frame.y + frame.height - keyboardY, 0);
    },
    _onKeyboardChange: function _onKeyboardChange(event) {
      if (!event) {
        this.setState({
          bottom: 0
        });
        return;
      }

      var duration = event.duration,
          easing = event.easing,
          endCoordinates = event.endCoordinates;

      var height = this._relativeKeyboardHeight(endCoordinates);

      if (this.state.bottom === height) {
        return;
      }

      if (duration && easing) {
        LayoutAnimation.configureNext({
          duration: duration,
          update: {
            duration: duration,
            type: LayoutAnimation.Types[easing] || 'keyboard'
          }
        });
      }

      this.setState({
        bottom: height
      });
    },
    _onLayout: function _onLayout(event) {
      this.frame = event.nativeEvent.layout;
    },
    componentWillUpdate: function componentWillUpdate(nextProps, nextState, nextContext) {
      if (nextState.bottom === this.state.bottom && this.props.behavior === 'height' && nextProps.behavior === 'height') {
        nextState.bottom = 0;
      }
    },
    componentWillMount: function componentWillMount() {
      if (Platform.OS === 'ios') {
        this.subscriptions = [Keyboard.addListener('keyboardWillChangeFrame', this._onKeyboardChange)];
      } else {
        this.subscriptions = [Keyboard.addListener('keyboardDidHide', this._onKeyboardChange), Keyboard.addListener('keyboardDidShow', this._onKeyboardChange)];
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      this.subscriptions.forEach(function (sub) {
        return sub.remove();
      });
    },
    render: function render() {
      var _props = this.props,
          behavior = _props.behavior,
          children = _props.children,
          style = _props.style,
          props = babelHelpers.objectWithoutProperties(_props, ["behavior", "children", "style"]);

      switch (behavior) {
        case 'height':
          var heightStyle = void 0;

          if (this.frame) {
            heightStyle = {
              height: this.frame.height - this.state.bottom,
              flex: 0
            };
          }

          return React.createElement(
            View,
            babelHelpers.extends({
              ref: viewRef,
              style: [style, heightStyle],
              onLayout: this._onLayout
            }, props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 172
              }
            }),
            children
          );

        case 'position':
          var positionStyle = {
            bottom: this.state.bottom
          };
          var contentContainerStyle = this.props.contentContainerStyle;
          return React.createElement(
            View,
            babelHelpers.extends({
              ref: viewRef,
              style: style,
              onLayout: this._onLayout
            }, props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 182
              }
            }),
            React.createElement(
              View,
              {
                style: [contentContainerStyle, positionStyle],
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 183
                }
              },
              children
            )
          );

        case 'padding':
          var paddingStyle = {
            paddingBottom: this.state.bottom
          };
          return React.createElement(
            View,
            babelHelpers.extends({
              ref: viewRef,
              style: [style, paddingStyle],
              onLayout: this._onLayout
            }, props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 192
              }
            }),
            children
          );

        default:
          return React.createElement(
            View,
            babelHelpers.extends({
              ref: viewRef,
              onLayout: this._onLayout,
              style: style
            }, props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 199
              }
            }),
            children
          );
      }
    }
  });
  module.exports = KeyboardAvoidingView;
},297,[213,269,298,105,24,171,232,211,172],"KeyboardAvoidingView");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var PropTypes = require(_dependencyMap[0], 'prop-types');

  var UIManager = require(_dependencyMap[1], 'UIManager');

  var keyMirror = require(_dependencyMap[2], 'fbjs/lib/keyMirror');

  var checkPropTypes = PropTypes.checkPropTypes;
  var TypesEnum = {
    spring: true,
    linear: true,
    easeInEaseOut: true,
    easeIn: true,
    easeOut: true,
    keyboard: true
  };
  var Types = keyMirror(TypesEnum);
  var PropertiesEnum = {
    opacity: true,
    scaleXY: true
  };
  var Properties = keyMirror(PropertiesEnum);
  var animType = PropTypes.shape({
    duration: PropTypes.number,
    delay: PropTypes.number,
    springDamping: PropTypes.number,
    initialVelocity: PropTypes.number,
    type: PropTypes.oneOf(Object.keys(Types)).isRequired,
    property: PropTypes.oneOf(Object.keys(Properties))
  });
  var configType = PropTypes.shape({
    duration: PropTypes.number.isRequired,
    create: animType,
    update: animType,
    delete: animType
  });

  function checkConfig(config, location, name) {
    checkPropTypes({
      config: configType
    }, {
      config: config
    }, location, name);
  }

  function configureNext(config, onAnimationDidEnd) {
    if (__DEV__) {
      checkConfig(config, 'config', 'LayoutAnimation.configureNext');
    }

    UIManager.configureNextLayoutAnimation(config, onAnimationDidEnd || function () {}, function () {});
  }

  function create(duration, type, creationProp) {
    return {
      duration: duration,
      create: {
        type: type,
        property: creationProp
      },
      update: {
        type: type
      },
      delete: {
        type: type,
        property: creationProp
      }
    };
  }

  var Presets = {
    easeInEaseOut: create(300, Types.easeInEaseOut, Properties.opacity),
    linear: create(500, Types.linear, Properties.opacity),
    spring: {
      duration: 700,
      create: {
        type: Types.linear,
        property: Properties.opacity
      },
      update: {
        type: Types.spring,
        springDamping: 0.4
      },
      delete: {
        type: Types.linear,
        property: Properties.opacity
      }
    }
  };
  var LayoutAnimation = {
    configureNext: configureNext,
    create: create,
    Types: Types,
    Properties: Properties,
    checkConfig: checkConfig,
    Presets: Presets,
    easeInEaseOut: configureNext.bind(null, Presets.easeInEaseOut),
    linear: configureNext.bind(null, Presets.linear),
    spring: configureNext.bind(null, Presets.spring)
  };
  module.exports = LayoutAnimation;
},298,[24,158,191],"LayoutAnimation");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  module.exports = require(_dependencyMap[0], 'UnimplementedView');
},299,[300],"MaskedViewIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/UnimplementedViews/UnimplementedView.js";

  var React = require(_dependencyMap[0], 'React');

  var StyleSheet = require(_dependencyMap[1], 'StyleSheet');

  var UnimplementedView = function (_React$Component) {
    babelHelpers.inherits(UnimplementedView, _React$Component);

    function UnimplementedView() {
      babelHelpers.classCallCheck(this, UnimplementedView);
      return babelHelpers.possibleConstructorReturn(this, (UnimplementedView.__proto__ || Object.getPrototypeOf(UnimplementedView)).apply(this, arguments));
    }

    babelHelpers.createClass(UnimplementedView, [{
      key: "setNativeProps",
      value: function setNativeProps() {}
    }, {
      key: "render",
      value: function render() {
        var View = require(_dependencyMap[2], 'View');

        return React.createElement(
          View,
          {
            style: [styles.unimplementedView, this.props.style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 33
            }
          },
          this.props.children
        );
      }
    }]);
    return UnimplementedView;
  }(React.Component);

  var styles = StyleSheet.create({
    unimplementedView: __DEV__ ? {
      alignSelf: 'flex-start',
      borderColor: 'red',
      borderWidth: 1
    } : {}
  });
  module.exports = UnimplementedView;
},300,[171,209,211],"UnimplementedView");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Modal/Modal.js",
      _container;

  var AppContainer = require(_dependencyMap[0], 'AppContainer');

  var I18nManager = require(_dependencyMap[1], 'I18nManager');

  var NativeEventEmitter = require(_dependencyMap[2], 'NativeEventEmitter');

  var NativeModules = require(_dependencyMap[3], 'NativeModules');

  var Platform = require(_dependencyMap[4], 'Platform');

  var React = require(_dependencyMap[5], 'React');

  var PropTypes = require(_dependencyMap[6], 'prop-types');

  var StyleSheet = require(_dependencyMap[7], 'StyleSheet');

  var View = require(_dependencyMap[8], 'View');

  var deprecatedPropType = require(_dependencyMap[9], 'deprecatedPropType');

  var requireNativeComponent = require(_dependencyMap[10], 'requireNativeComponent');

  var RCTModalHostView = requireNativeComponent('RCTModalHostView', null);
  var ModalEventEmitter = Platform.OS === 'ios' && NativeModules.ModalManager ? new NativeEventEmitter(NativeModules.ModalManager) : null;
  var uniqueModalIdentifier = 0;

  var Modal = function (_React$Component) {
    babelHelpers.inherits(Modal, _React$Component);

    function Modal(props) {
      babelHelpers.classCallCheck(this, Modal);

      var _this = babelHelpers.possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, props));

      Modal._confirmProps(props);

      _this._identifier = uniqueModalIdentifier++;
      return _this;
    }

    babelHelpers.createClass(Modal, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        if (ModalEventEmitter) {
          this._eventSubscription = ModalEventEmitter.addListener('modalDismissed', function (event) {
            if (event.modalID === _this2._identifier && _this2.props.onDismiss) {
              _this2.props.onDismiss();
            }
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._eventSubscription) {
          this._eventSubscription.remove();
        }
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        Modal._confirmProps(nextProps);
      }
    }, {
      key: "render",
      value: function render() {
        if (this.props.visible === false) {
          return null;
        }

        var containerStyles = {
          backgroundColor: this.props.transparent ? 'transparent' : 'white'
        };
        var animationType = this.props.animationType;

        if (!animationType) {
          animationType = 'none';

          if (this.props.animated) {
            animationType = 'slide';
          }
        }

        var presentationStyle = this.props.presentationStyle;

        if (!presentationStyle) {
          presentationStyle = 'fullScreen';

          if (this.props.transparent) {
            presentationStyle = 'overFullScreen';
          }
        }

        var innerChildren = __DEV__ ? React.createElement(
          AppContainer,
          {
            rootTag: this.context.rootTag,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 238
            }
          },
          this.props.children
        ) : this.props.children;
        return React.createElement(
          RCTModalHostView,
          {
            animationType: animationType,
            presentationStyle: presentationStyle,
            transparent: this.props.transparent,
            hardwareAccelerated: this.props.hardwareAccelerated,
            onRequestClose: this.props.onRequestClose,
            onShow: this.props.onShow,
            identifier: this._identifier,
            style: styles.modal,
            onStartShouldSetResponder: this._shouldSetResponder,
            supportedOrientations: this.props.supportedOrientations,
            onOrientationChange: this.props.onOrientationChange,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 244
            }
          },
          React.createElement(
            View,
            {
              style: [styles.container, containerStyles],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 257
              }
            },
            innerChildren
          )
        );
      }
    }, {
      key: "_shouldSetResponder",
      value: function _shouldSetResponder() {
        return true;
      }
    }], [{
      key: "_confirmProps",
      value: function _confirmProps(props) {
        if (props.presentationStyle && props.presentationStyle !== 'overFullScreen' && props.transparent) {
          console.warn("Modal with '" + props.presentationStyle + "' presentation style and 'transparent' value is not supported.");
        }
      }
    }]);
    return Modal;
  }(React.Component);

  Modal.propTypes = {
    animationType: PropTypes.oneOf(['none', 'slide', 'fade']),
    presentationStyle: PropTypes.oneOf(['fullScreen', 'pageSheet', 'formSheet', 'overFullScreen']),
    transparent: PropTypes.bool,
    hardwareAccelerated: PropTypes.bool,
    visible: PropTypes.bool,
    onRequestClose: Platform.isTVOS || Platform.OS === 'android' ? PropTypes.func.isRequired : PropTypes.func,
    onShow: PropTypes.func,
    onDismiss: PropTypes.func,
    animated: deprecatedPropType(PropTypes.bool, 'Use the `animationType` prop instead.'),
    supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf(['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right'])),
    onOrientationChange: PropTypes.func
  };
  Modal.defaultProps = {
    visible: true,
    hardwareAccelerated: false
  };
  Modal.contextTypes = {
    rootTag: PropTypes.number
  };
  var side = I18nManager.isRTL ? 'right' : 'left';
  var styles = StyleSheet.create({
    modal: {
      position: 'absolute'
    },
    container: (_container = {
      position: 'absolute'
    }, babelHelpers.defineProperty(_container, side, 0), babelHelpers.defineProperty(_container, "top", 0), _container)
  });
  module.exports = Modal;
},301,[302,321,120,68,105,171,24,209,211,184,186],"Modal");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/ReactNative/AppContainer.js";

  var EmitterSubscription = require(_dependencyMap[0], 'EmitterSubscription');

  var PropTypes = require(_dependencyMap[1], 'prop-types');

  var RCTDeviceEventEmitter = require(_dependencyMap[2], 'RCTDeviceEventEmitter');

  var React = require(_dependencyMap[3], 'React');

  var ReactNative = require(_dependencyMap[4], 'ReactNative');

  var StyleSheet = require(_dependencyMap[5], 'StyleSheet');

  var View = require(_dependencyMap[6], 'View');

  var AppContainer = function (_React$Component) {
    babelHelpers.inherits(AppContainer, _React$Component);

    function AppContainer() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, AppContainer);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = AppContainer.__proto__ || Object.getPrototypeOf(AppContainer)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        inspector: null,
        mainKey: 1
      }, _this._subscription = null, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(AppContainer, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          rootTag: this.props.rootTag
        };
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        if (__DEV__) {
          if (!global.__RCTProfileIsProfiling) {
            this._subscription = RCTDeviceEventEmitter.addListener('toggleElementInspector', function () {
              var Inspector = require(_dependencyMap[7], 'Inspector');

              var inspector = _this2.state.inspector ? null : React.createElement(Inspector, {
                inspectedViewTag: ReactNative.findNodeHandle(_this2._mainRef),
                onRequestRerenderApp: function onRequestRerenderApp(updateInspectedViewTag) {
                  _this2.setState(function (s) {
                    return {
                      mainKey: s.mainKey + 1
                    };
                  }, function () {
                    return updateInspectedViewTag(ReactNative.findNodeHandle(_this2._mainRef));
                  });
                },
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 66
                }
              });

              _this2.setState({
                inspector: inspector
              });
            });
          }
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._subscription) {
          this._subscription.remove();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var yellowBox = null;

        if (__DEV__) {
          if (!global.__RCTProfileIsProfiling) {
            var YellowBox = require(_dependencyMap[8], 'YellowBox');

            yellowBox = React.createElement(YellowBox, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 97
              }
            });
          }
        }

        var innerView = React.createElement(
          View,
          {
            collapsable: !this.state.inspector,
            key: this.state.mainKey,
            pointerEvents: "box-none",
            style: styles.appContainer,
            ref: function ref(_ref2) {
              _this3._mainRef = _ref2;
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 102
            }
          },
          this.props.children
        );
        var Wrapper = this.props.WrapperComponent;

        if (Wrapper) {
          innerView = React.createElement(
            Wrapper,
            {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 119
              }
            },
            innerView
          );
        }

        return React.createElement(
          View,
          {
            style: styles.appContainer,
            pointerEvents: "box-none",
            __source: {
              fileName: _jsxFileName,
              lineNumber: 122
            }
          },
          innerView,
          yellowBox,
          this.state.inspector
        );
      }
    }]);
    return AppContainer;
  }(React.Component);

  AppContainer.childContextTypes = {
    rootTag: PropTypes.number
  };
  var styles = StyleSheet.create({
    appContainer: {
      flex: 1
    }
  });
  module.exports = AppContainer;
},302,[116,24,121,171,74,209,211,303,319],"AppContainer");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/Inspector.js";

  var Dimensions = require(_dependencyMap[0], 'Dimensions');

  var InspectorOverlay = require(_dependencyMap[1], 'InspectorOverlay');

  var InspectorPanel = require(_dependencyMap[2], 'InspectorPanel');

  var Platform = require(_dependencyMap[3], 'Platform');

  var React = require(_dependencyMap[4], 'React');

  var ReactNative = require(_dependencyMap[5], 'ReactNative');

  var StyleSheet = require(_dependencyMap[6], 'StyleSheet');

  var Touchable = require(_dependencyMap[7], 'Touchable');

  var UIManager = require(_dependencyMap[8], 'UIManager');

  var View = require(_dependencyMap[9], 'View');

  var emptyObject = require(_dependencyMap[10], 'fbjs/lib/emptyObject');

  var invariant = require(_dependencyMap[11], 'fbjs/lib/invariant');

  var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  var renderer = findRenderer();
  hook.resolveRNStyle = require(_dependencyMap[12], 'flattenStyle');

  function findRenderer() {
    var renderers = hook._renderers;
    var keys = Object.keys(renderers);
    invariant(keys.length === 1, 'Expected to find exactly one React Native renderer on DevTools hook.');
    return renderers[keys[0]];
  }

  var Inspector = function (_React$Component) {
    babelHelpers.inherits(Inspector, _React$Component);

    function Inspector(props) {
      babelHelpers.classCallCheck(this, Inspector);

      var _this = babelHelpers.possibleConstructorReturn(this, (Inspector.__proto__ || Object.getPrototypeOf(Inspector)).call(this, props));

      _initialiseProps.call(_this);

      _this.state = {
        devtoolsAgent: null,
        hierarchy: null,
        panelPos: 'bottom',
        inspecting: true,
        perfing: false,
        inspected: null,
        selection: null,
        inspectedViewTag: _this.props.inspectedViewTag,
        networking: false
      };
      return _this;
    }

    babelHelpers.createClass(Inspector, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        hook.on('react-devtools', this.attachToDevtools);

        if (hook.reactDevtoolsAgent) {
          this.attachToDevtools(hook.reactDevtoolsAgent);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._subs) {
          this._subs.map(function (fn) {
            return fn();
          });
        }

        hook.off('react-devtools', this.attachToDevtools);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(newProps) {
        this.setState({
          inspectedViewTag: newProps.inspectedViewTag
        });
      }
    }, {
      key: "setSelection",
      value: function setSelection(i) {
        var _this2 = this;

        var hierarchyItem = this.state.hierarchy[i];

        var _hierarchyItem$getIns = hierarchyItem.getInspectorData(ReactNative.findNodeHandle),
            measure = _hierarchyItem$getIns.measure,
            props = _hierarchyItem$getIns.props,
            source = _hierarchyItem$getIns.source;

        measure(function (x, y, width, height, left, top) {
          _this2.setState({
            inspected: {
              frame: {
                left: left,
                top: top,
                width: width,
                height: height
              },
              style: props.style,
              source: source
            },
            selection: i
          });
        });
      }
    }, {
      key: "onTouchViewTag",
      value: function onTouchViewTag(touchedViewTag, frame, pointerY) {
        var _renderer$getInspecto = renderer.getInspectorDataForViewTag(touchedViewTag),
            hierarchy = _renderer$getInspecto.hierarchy,
            props = _renderer$getInspecto.props,
            selection = _renderer$getInspecto.selection,
            source = _renderer$getInspecto.source;

        if (this.state.devtoolsAgent) {
          var offsetFromLeaf = hierarchy.length - 1 - selection;
          this.state.devtoolsAgent.selectFromDOMNode(touchedViewTag, true, offsetFromLeaf);
        }

        this.setState({
          panelPos: pointerY > Dimensions.get('window').height / 2 ? 'top' : 'bottom',
          selection: selection,
          hierarchy: hierarchy,
          inspected: {
            style: props.style,
            frame: frame,
            source: source
          }
        });
      }
    }, {
      key: "setPerfing",
      value: function setPerfing(val) {
        this.setState({
          perfing: val,
          inspecting: false,
          inspected: null,
          networking: false
        });
      }
    }, {
      key: "setInspecting",
      value: function setInspecting(val) {
        this.setState({
          inspecting: val,
          inspected: null
        });
      }
    }, {
      key: "setTouchTargetting",
      value: function setTouchTargetting(val) {
        var _this3 = this;

        Touchable.TOUCH_TARGET_DEBUG = val;
        this.props.onRequestRerenderApp(function (inspectedViewTag) {
          _this3.setState({
            inspectedViewTag: inspectedViewTag
          });
        });
      }
    }, {
      key: "setNetworking",
      value: function setNetworking(val) {
        this.setState({
          networking: val,
          perfing: false,
          inspecting: false,
          inspected: null
        });
      }
    }, {
      key: "render",
      value: function render() {
        var panelContainerStyle = this.state.panelPos === 'bottom' ? {
          bottom: 0
        } : {
          top: Platform.OS === 'ios' ? 20 : 0
        };
        return React.createElement(
          View,
          {
            style: styles.container,
            pointerEvents: "box-none",
            __source: {
              fileName: _jsxFileName,
              lineNumber: 231
            }
          },
          this.state.inspecting && React.createElement(InspectorOverlay, {
            inspected: this.state.inspected,
            inspectedViewTag: this.state.inspectedViewTag,
            onTouchViewTag: this.onTouchViewTag.bind(this),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 233
            }
          }),
          React.createElement(
            View,
            {
              style: [styles.panelContainer, panelContainerStyle],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 238
              }
            },
            React.createElement(InspectorPanel, {
              devtoolsIsOpen: !!this.state.devtoolsAgent,
              inspecting: this.state.inspecting,
              perfing: this.state.perfing,
              setPerfing: this.setPerfing.bind(this),
              setInspecting: this.setInspecting.bind(this),
              inspected: this.state.inspected,
              hierarchy: this.state.hierarchy,
              selection: this.state.selection,
              setSelection: this.setSelection.bind(this),
              touchTargetting: Touchable.TOUCH_TARGET_DEBUG,
              setTouchTargetting: this.setTouchTargetting.bind(this),
              networking: this.state.networking,
              setNetworking: this.setNetworking.bind(this),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 239
              }
            })
          )
        );
      }
    }]);
    return Inspector;
  }(React.Component);

  var _initialiseProps = function _initialiseProps() {
    var _this4 = this;

    this.attachToDevtools = function (agent) {
      var _hideWait = null;
      var hlSub = agent.sub('highlight', function (_ref) {
        var node = _ref.node,
            name = _ref.name,
            props = _ref.props;
        clearTimeout(_hideWait);

        if (typeof node !== 'number') {
          node = ReactNative.findNodeHandle(node);
        }

        UIManager.measure(node, function (x, y, width, height, left, top) {
          _this4.setState({
            hierarchy: [],
            inspected: {
              frame: {
                left: left,
                top: top,
                width: width,
                height: height
              },
              style: props ? props.style : emptyObject
            }
          });
        });
      });
      var hideSub = agent.sub('hideHighlight', function () {
        if (_this4.state.inspected === null) {
          return;
        }

        _hideWait = setTimeout(function () {
          _this4.setState({
            inspected: null
          });
        }, 100);
      });
      _this4._subs = [hlSub, hideSub];
      agent.on('shutdown', function () {
        _this4.setState({
          devtoolsAgent: null
        });

        _this4._subs = null;
      });

      _this4.setState({
        devtoolsAgent: agent
      });
    };
  };

  var styles = StyleSheet.create({
    container: {
      position: 'absolute',
      backgroundColor: 'transparent',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    panelContainer: {
      position: 'absolute',
      left: 0,
      right: 0
    }
  });
  module.exports = Inspector;
},303,[205,304,308,105,171,74,209,223,158,211,15,18,152],"Inspector");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/InspectorOverlay.js";

  var Dimensions = require(_dependencyMap[0], 'Dimensions');

  var ElementBox = require(_dependencyMap[1], 'ElementBox');

  var PropTypes = require(_dependencyMap[2], 'prop-types');

  var React = require(_dependencyMap[3], 'React');

  var StyleSheet = require(_dependencyMap[4], 'StyleSheet');

  var UIManager = require(_dependencyMap[5], 'UIManager');

  var View = require(_dependencyMap[6], 'View');

  var InspectorOverlay = function (_React$Component) {
    babelHelpers.inherits(InspectorOverlay, _React$Component);

    function InspectorOverlay() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, InspectorOverlay);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = InspectorOverlay.__proto__ || Object.getPrototypeOf(InspectorOverlay)).call.apply(_ref, [this].concat(args))), _this), _this.findViewForTouchEvent = function (e) {
        var _e$nativeEvent$touche = e.nativeEvent.touches[0],
            locationX = _e$nativeEvent$touche.locationX,
            locationY = _e$nativeEvent$touche.locationY;
        UIManager.findSubviewIn(_this.props.inspectedViewTag, [locationX, locationY], function (nativeViewTag, left, top, width, height) {
          _this.props.onTouchViewTag(nativeViewTag, {
            left: left,
            top: top,
            width: width,
            height: height
          }, locationY);
        });
      }, _this.shouldSetResponser = function (e) {
        _this.findViewForTouchEvent(e);

        return true;
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(InspectorOverlay, [{
      key: "render",
      value: function render() {
        var content = null;

        if (this.props.inspected) {
          content = React.createElement(ElementBox, {
            frame: this.props.inspected.frame,
            style: this.props.inspected.style,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 62
            }
          });
        }

        return React.createElement(
          View,
          {
            onStartShouldSetResponder: this.shouldSetResponser,
            onResponderMove: this.findViewForTouchEvent,
            style: [styles.inspector, {
              height: Dimensions.get('window').height
            }],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 66
            }
          },
          content
        );
      }
    }]);
    return InspectorOverlay;
  }(React.Component);

  InspectorOverlay.propTypes = {
    inspected: PropTypes.shape({
      frame: PropTypes.object,
      style: PropTypes.any
    }),
    inspectedViewTag: PropTypes.number,
    onTouchViewTag: PropTypes.func.isRequired
  };
  var styles = StyleSheet.create({
    inspector: {
      backgroundColor: 'transparent',
      position: 'absolute',
      left: 0,
      top: 0,
      right: 0
    }
  });
  module.exports = InspectorOverlay;
},304,[205,305,24,171,209,158,211],"InspectorOverlay");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/ElementBox.js";

  var React = require(_dependencyMap[0], 'React');

  var View = require(_dependencyMap[1], 'View');

  var StyleSheet = require(_dependencyMap[2], 'StyleSheet');

  var BorderBox = require(_dependencyMap[3], 'BorderBox');

  var resolveBoxStyle = require(_dependencyMap[4], 'resolveBoxStyle');

  var flattenStyle = require(_dependencyMap[5], 'flattenStyle');

  var ElementBox = function (_React$Component) {
    babelHelpers.inherits(ElementBox, _React$Component);

    function ElementBox() {
      babelHelpers.classCallCheck(this, ElementBox);
      return babelHelpers.possibleConstructorReturn(this, (ElementBox.__proto__ || Object.getPrototypeOf(ElementBox)).apply(this, arguments));
    }

    babelHelpers.createClass(ElementBox, [{
      key: "render",
      value: function render() {
        var style = flattenStyle(this.props.style) || {};
        var margin = resolveBoxStyle('margin', style);
        var padding = resolveBoxStyle('padding', style);
        var frameStyle = this.props.frame;

        if (margin) {
          frameStyle = {
            top: frameStyle.top - margin.top,
            left: frameStyle.left - margin.left,
            height: frameStyle.height + margin.top + margin.bottom,
            width: frameStyle.width + margin.left + margin.right
          };
        }

        var contentStyle = {
          width: this.props.frame.width,
          height: this.props.frame.height
        };

        if (padding) {
          contentStyle = {
            width: contentStyle.width - padding.left - padding.right,
            height: contentStyle.height - padding.top - padding.bottom
          };
        }

        return React.createElement(
          View,
          {
            style: [styles.frame, frameStyle],
            pointerEvents: "none",
            __source: {
              fileName: _jsxFileName,
              lineNumber: 47
            }
          },
          React.createElement(
            BorderBox,
            {
              box: margin,
              style: styles.margin,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 48
              }
            },
            React.createElement(
              BorderBox,
              {
                box: padding,
                style: styles.padding,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 49
                }
              },
              React.createElement(View, {
                style: [styles.content, contentStyle],
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 50
                }
              })
            )
          )
        );
      }
    }]);
    return ElementBox;
  }(React.Component);

  var styles = StyleSheet.create({
    frame: {
      position: 'absolute'
    },
    content: {
      backgroundColor: 'rgba(200, 230, 255, 0.8)'
    },
    padding: {
      borderColor: 'rgba(77, 255, 0, 0.3)'
    },
    margin: {
      borderColor: 'rgba(255, 132, 0, 0.3)'
    }
  });
  module.exports = ElementBox;
},305,[171,211,209,306,307,152],"ElementBox");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/BorderBox.js";

  var React = require(_dependencyMap[0], 'React');

  var View = require(_dependencyMap[1], 'View');

  var BorderBox = function (_React$Component) {
    babelHelpers.inherits(BorderBox, _React$Component);

    function BorderBox() {
      babelHelpers.classCallCheck(this, BorderBox);
      return babelHelpers.possibleConstructorReturn(this, (BorderBox.__proto__ || Object.getPrototypeOf(BorderBox)).apply(this, arguments));
    }

    babelHelpers.createClass(BorderBox, [{
      key: "render",
      value: function render() {
        var box = this.props.box;

        if (!box) {
          return this.props.children;
        }

        var style = {
          borderTopWidth: box.top,
          borderBottomWidth: box.bottom,
          borderLeftWidth: box.left,
          borderRightWidth: box.right
        };
        return React.createElement(
          View,
          {
            style: [style, this.props.style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 30
            }
          },
          this.props.children
        );
      }
    }]);
    return BorderBox;
  }(React.Component);

  module.exports = BorderBox;
},306,[171,211],"BorderBox");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function resolveBoxStyle(prefix, style) {
    var res = {};
    var subs = ['top', 'left', 'bottom', 'right'];
    var set = false;
    subs.forEach(function (sub) {
      res[sub] = style[prefix] || 0;
    });

    if (style[prefix]) {
      set = true;
    }

    if (style[prefix + 'Vertical']) {
      res.top = res.bottom = style[prefix + 'Vertical'];
      set = true;
    }

    if (style[prefix + 'Horizontal']) {
      res.left = res.right = style[prefix + 'Horizontal'];
      set = true;
    }

    subs.forEach(function (sub) {
      var val = style[prefix + capFirst(sub)];

      if (val) {
        res[sub] = val;
        set = true;
      }
    });

    if (!set) {
      return;
    }

    return res;
  }

  function capFirst(text) {
    return text[0].toUpperCase() + text.slice(1);
  }

  module.exports = resolveBoxStyle;
},307,[],"resolveBoxStyle");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/InspectorPanel.js";

  var ElementProperties = require(_dependencyMap[0], 'ElementProperties');

  var NetworkOverlay = require(_dependencyMap[1], 'NetworkOverlay');

  var PerformanceOverlay = require(_dependencyMap[2], 'PerformanceOverlay');

  var React = require(_dependencyMap[3], 'React');

  var PropTypes = require(_dependencyMap[4], 'prop-types');

  var ScrollView = require(_dependencyMap[5], 'ScrollView');

  var StyleSheet = require(_dependencyMap[6], 'StyleSheet');

  var Text = require(_dependencyMap[7], 'Text');

  var TouchableHighlight = require(_dependencyMap[8], 'TouchableHighlight');

  var View = require(_dependencyMap[9], 'View');

  var InspectorPanel = function (_React$Component) {
    babelHelpers.inherits(InspectorPanel, _React$Component);

    function InspectorPanel() {
      babelHelpers.classCallCheck(this, InspectorPanel);
      return babelHelpers.possibleConstructorReturn(this, (InspectorPanel.__proto__ || Object.getPrototypeOf(InspectorPanel)).apply(this, arguments));
    }

    babelHelpers.createClass(InspectorPanel, [{
      key: "renderWaiting",
      value: function renderWaiting() {
        if (this.props.inspecting) {
          return React.createElement(
            Text,
            {
              style: styles.waitingText,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 29
              }
            },
            "Tap something to inspect it"
          );
        }

        return React.createElement(
          Text,
          {
            style: styles.waitingText,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 34
            }
          },
          "Nothing is inspected"
        );
      }
    }, {
      key: "render",
      value: function render() {
        var contents = void 0;

        if (this.props.inspected) {
          contents = React.createElement(
            ScrollView,
            {
              style: styles.properties,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 41
              }
            },
            React.createElement(ElementProperties, {
              style: this.props.inspected.style,
              frame: this.props.inspected.frame,
              source: this.props.inspected.source,
              hierarchy: this.props.hierarchy,
              selection: this.props.selection,
              setSelection: this.props.setSelection,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 42
              }
            })
          );
        } else if (this.props.perfing) {
          contents = React.createElement(PerformanceOverlay, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 54
            }
          });
        } else if (this.props.networking) {
          contents = React.createElement(NetworkOverlay, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 58
            }
          });
        } else {
          contents = React.createElement(
            View,
            {
              style: styles.waiting,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 62
              }
            },
            this.renderWaiting()
          );
        }

        return React.createElement(
          View,
          {
            style: styles.container,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 68
            }
          },
          !this.props.devtoolsIsOpen && contents,
          React.createElement(
            View,
            {
              style: styles.buttonRow,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 70
              }
            },
            React.createElement(Button, {
              title: 'Inspect',
              pressed: this.props.inspecting,
              onClick: this.props.setInspecting,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 71
              }
            }),
            React.createElement(Button, {
              title: 'Perf',
              pressed: this.props.perfing,
              onClick: this.props.setPerfing,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 76
              }
            }),
            React.createElement(Button, {
              title: 'Network',
              pressed: this.props.networking,
              onClick: this.props.setNetworking,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 80
              }
            }),
            React.createElement(Button, {
              title: 'Touchables',
              pressed: this.props.touchTargetting,
              onClick: this.props.setTouchTargetting,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 84
              }
            })
          )
        );
      }
    }]);
    return InspectorPanel;
  }(React.Component);

  InspectorPanel.propTypes = {
    devtoolsIsOpen: PropTypes.bool,
    inspecting: PropTypes.bool,
    setInspecting: PropTypes.func,
    inspected: PropTypes.object,
    perfing: PropTypes.bool,
    setPerfing: PropTypes.func,
    touchTargetting: PropTypes.bool,
    setTouchTargetting: PropTypes.func,
    networking: PropTypes.bool,
    setNetworking: PropTypes.func
  };

  var Button = function (_React$Component2) {
    babelHelpers.inherits(Button, _React$Component2);

    function Button() {
      babelHelpers.classCallCheck(this, Button);
      return babelHelpers.possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).apply(this, arguments));
    }

    babelHelpers.createClass(Button, [{
      key: "render",
      value: function render() {
        var _this3 = this;

        return React.createElement(
          TouchableHighlight,
          {
            onPress: function onPress() {
              return _this3.props.onClick(!_this3.props.pressed);
            },
            style: [styles.button, this.props.pressed && styles.buttonPressed],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 110
            }
          },
          React.createElement(
            Text,
            {
              style: styles.buttonText,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 114
              }
            },
            this.props.title
          )
        );
      }
    }]);
    return Button;
  }(React.Component);

  var styles = StyleSheet.create({
    buttonRow: {
      flexDirection: 'row'
    },
    button: {
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      margin: 2,
      height: 30,
      justifyContent: 'center',
      alignItems: 'center'
    },
    buttonPressed: {
      backgroundColor: 'rgba(255, 255, 255, 0.3)'
    },
    buttonText: {
      textAlign: 'center',
      color: 'white',
      margin: 5
    },
    container: {
      backgroundColor: 'rgba(0, 0, 0, 0.7)'
    },
    properties: {
      height: 200
    },
    waiting: {
      height: 100
    },
    waitingText: {
      fontSize: 20,
      textAlign: 'center',
      marginVertical: 20,
      color: 'white'
    }
  });
  module.exports = InspectorPanel;
},308,[309,315,318,171,24,265,209,222,312,211],"InspectorPanel");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/ElementProperties.js";

  var BoxInspector = require(_dependencyMap[0], 'BoxInspector');

  var PropTypes = require(_dependencyMap[1], 'prop-types');

  var React = require(_dependencyMap[2], 'React');

  var StyleInspector = require(_dependencyMap[3], 'StyleInspector');

  var StyleSheet = require(_dependencyMap[4], 'StyleSheet');

  var Text = require(_dependencyMap[5], 'Text');

  var TouchableHighlight = require(_dependencyMap[6], 'TouchableHighlight');

  var TouchableWithoutFeedback = require(_dependencyMap[7], 'TouchableWithoutFeedback');

  var View = require(_dependencyMap[8], 'View');

  var flattenStyle = require(_dependencyMap[9], 'flattenStyle');

  var mapWithSeparator = require(_dependencyMap[10], 'mapWithSeparator');

  var openFileInEditor = require(_dependencyMap[11], 'openFileInEditor');

  var ElementProperties = function (_React$Component) {
    babelHelpers.inherits(ElementProperties, _React$Component);

    function ElementProperties() {
      babelHelpers.classCallCheck(this, ElementProperties);
      return babelHelpers.possibleConstructorReturn(this, (ElementProperties.__proto__ || Object.getPrototypeOf(ElementProperties)).apply(this, arguments));
    }

    babelHelpers.createClass(ElementProperties, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var style = flattenStyle(this.props.style);
        var selection = this.props.selection;
        var openFileButton = void 0;
        var source = this.props.source;

        var _ref = source || {},
            fileName = _ref.fileName,
            lineNumber = _ref.lineNumber;

        if (fileName && lineNumber) {
          var parts = fileName.split('/');
          var fileNameShort = parts[parts.length - 1];
          openFileButton = React.createElement(
            TouchableHighlight,
            {
              style: styles.openButton,
              onPress: openFileInEditor.bind(null, fileName, lineNumber),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 62
              }
            },
            React.createElement(
              Text,
              {
                style: styles.openButtonTitle,
                numberOfLines: 1,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 65
                }
              },
              fileNameShort,
              ":",
              lineNumber
            )
          );
        }

        return React.createElement(
          TouchableWithoutFeedback,
          {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 74
            }
          },
          React.createElement(
            View,
            {
              style: styles.info,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 75
              }
            },
            React.createElement(
              View,
              {
                style: styles.breadcrumb,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 76
                }
              },
              mapWithSeparator(this.props.hierarchy, function (hierarchyItem, i) {
                return React.createElement(
                  TouchableHighlight,
                  {
                    key: 'item-' + i,
                    style: [styles.breadItem, i === selection && styles.selected],
                    onPress: function onPress() {
                      return _this2.props.setSelection(i);
                    },
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 80
                    }
                  },
                  React.createElement(
                    Text,
                    {
                      style: styles.breadItemText,
                      __source: {
                        fileName: _jsxFileName,
                        lineNumber: 85
                      }
                    },
                    hierarchyItem.name
                  )
                );
              }, function (i) {
                return React.createElement(
                  Text,
                  {
                    key: 'sep-' + i,
                    style: styles.breadSep,
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 91
                    }
                  },
                  "\u25B8"
                );
              })
            ),
            React.createElement(
              View,
              {
                style: styles.row,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 97
                }
              },
              React.createElement(
                View,
                {
                  style: styles.col,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 98
                  }
                },
                React.createElement(StyleInspector, {
                  style: style,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 99
                  }
                }),
                openFileButton
              ),
              React.createElement(BoxInspector, {
                style: style,
                frame: this.props.frame,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 104
                }
              })
            )
          )
        );
      }
    }]);
    return ElementProperties;
  }(React.Component);

  ElementProperties.propTypes = {
    hierarchy: PropTypes.array.isRequired,
    style: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.number]),
    source: PropTypes.shape({
      fileName: PropTypes.string,
      lineNumber: PropTypes.number
    })
  };
  var styles = StyleSheet.create({
    breadSep: {
      fontSize: 8,
      color: 'white'
    },
    breadcrumb: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      alignItems: 'flex-start',
      marginBottom: 5
    },
    selected: {
      borderColor: 'white',
      borderRadius: 5
    },
    breadItem: {
      borderWidth: 1,
      borderColor: 'transparent',
      marginHorizontal: 2
    },
    breadItemText: {
      fontSize: 10,
      color: 'white',
      marginHorizontal: 5
    },
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between'
    },
    col: {
      flex: 1
    },
    info: {
      padding: 10
    },
    openButton: {
      padding: 10,
      backgroundColor: '#000',
      marginVertical: 5,
      marginRight: 5,
      borderRadius: 2
    },
    openButtonTitle: {
      color: 'white',
      fontSize: 8
    }
  });
  module.exports = ElementProperties;
},309,[310,24,171,311,209,222,312,231,211,152,313,314],"ElementProperties");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/BoxInspector.js";

  var React = require(_dependencyMap[0], 'React');

  var StyleSheet = require(_dependencyMap[1], 'StyleSheet');

  var Text = require(_dependencyMap[2], 'Text');

  var View = require(_dependencyMap[3], 'View');

  var resolveBoxStyle = require(_dependencyMap[4], 'resolveBoxStyle');

  var blank = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };

  var BoxInspector = function (_React$Component) {
    babelHelpers.inherits(BoxInspector, _React$Component);

    function BoxInspector() {
      babelHelpers.classCallCheck(this, BoxInspector);
      return babelHelpers.possibleConstructorReturn(this, (BoxInspector.__proto__ || Object.getPrototypeOf(BoxInspector)).apply(this, arguments));
    }

    babelHelpers.createClass(BoxInspector, [{
      key: "render",
      value: function render() {
        var frame = this.props.frame;
        var style = this.props.style;
        var margin = style && resolveBoxStyle('margin', style) || blank;
        var padding = style && resolveBoxStyle('padding', style) || blank;
        return React.createElement(
          BoxContainer,
          {
            title: "margin",
            titleStyle: styles.marginLabel,
            box: margin,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 34
            }
          },
          React.createElement(
            BoxContainer,
            {
              title: "padding",
              box: padding,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 35
              }
            },
            React.createElement(
              View,
              {
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 36
                }
              },
              React.createElement(
                Text,
                {
                  style: styles.innerText,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 37
                  }
                },
                "(",
                (frame.left || 0).toFixed(1),
                ", ",
                (frame.top || 0).toFixed(1),
                ")"
              ),
              React.createElement(
                Text,
                {
                  style: styles.innerText,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 40
                  }
                },
                (frame.width || 0).toFixed(1),
                " \xD7 ",
                (frame.height || 0).toFixed(1)
              )
            )
          )
        );
      }
    }]);
    return BoxInspector;
  }(React.Component);

  var BoxContainer = function (_React$Component2) {
    babelHelpers.inherits(BoxContainer, _React$Component2);

    function BoxContainer() {
      babelHelpers.classCallCheck(this, BoxContainer);
      return babelHelpers.possibleConstructorReturn(this, (BoxContainer.__proto__ || Object.getPrototypeOf(BoxContainer)).apply(this, arguments));
    }

    babelHelpers.createClass(BoxContainer, [{
      key: "render",
      value: function render() {
        var box = this.props.box;
        return React.createElement(
          View,
          {
            style: styles.box,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 54
            }
          },
          React.createElement(
            View,
            {
              style: styles.row,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 55
              }
            },
            React.createElement(
              Text,
              {
                style: [this.props.titleStyle, styles.label],
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 58
                }
              },
              this.props.title
            ),
            React.createElement(
              Text,
              {
                style: styles.boxText,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 59
                }
              },
              box.top
            )
          ),
          React.createElement(
            View,
            {
              style: styles.row,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 61
              }
            },
            React.createElement(
              Text,
              {
                style: styles.boxText,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 62
                }
              },
              box.left
            ),
            this.props.children,
            React.createElement(
              Text,
              {
                style: styles.boxText,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 64
                }
              },
              box.right
            )
          ),
          React.createElement(
            Text,
            {
              style: styles.boxText,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 66
              }
            },
            box.bottom
          )
        );
      }
    }]);
    return BoxContainer;
  }(React.Component);

  var styles = StyleSheet.create({
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-around'
    },
    marginLabel: {
      width: 60
    },
    label: {
      fontSize: 10,
      color: 'rgb(255,100,0)',
      marginLeft: 5,
      flex: 1,
      textAlign: 'left',
      top: -3
    },
    buffer: {
      fontSize: 10,
      color: 'yellow',
      flex: 1,
      textAlign: 'center'
    },
    innerText: {
      color: 'yellow',
      fontSize: 12,
      textAlign: 'center',
      width: 70
    },
    box: {
      borderWidth: 1,
      borderColor: 'grey'
    },
    boxText: {
      color: 'white',
      fontSize: 12,
      marginHorizontal: 3,
      marginVertical: 2,
      textAlign: 'center'
    }
  });
  module.exports = BoxInspector;
},310,[171,209,222,211,307],"BoxInspector");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/StyleInspector.js";

  var React = require(_dependencyMap[0], 'React');

  var StyleSheet = require(_dependencyMap[1], 'StyleSheet');

  var Text = require(_dependencyMap[2], 'Text');

  var View = require(_dependencyMap[3], 'View');

  var StyleInspector = function (_React$Component) {
    babelHelpers.inherits(StyleInspector, _React$Component);

    function StyleInspector() {
      babelHelpers.classCallCheck(this, StyleInspector);
      return babelHelpers.possibleConstructorReturn(this, (StyleInspector.__proto__ || Object.getPrototypeOf(StyleInspector)).apply(this, arguments));
    }

    babelHelpers.createClass(StyleInspector, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        if (!this.props.style) {
          return React.createElement(
            Text,
            {
              style: styles.noStyle,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 22
              }
            },
            "No style"
          );
        }

        var names = Object.keys(this.props.style);
        return React.createElement(
          View,
          {
            style: styles.container,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 26
            }
          },
          React.createElement(
            View,
            {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 27
              }
            },
            names.map(function (name) {
              return React.createElement(
                Text,
                {
                  key: name,
                  style: styles.attr,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 28
                  }
                },
                name,
                ":"
              );
            })
          ),
          React.createElement(
            View,
            {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 31
              }
            },
            names.map(function (name) {
              var value = typeof _this2.props.style[name] === 'object' ? JSON.stringify(_this2.props.style[name]) : _this2.props.style[name];
              return React.createElement(
                Text,
                {
                  key: name,
                  style: styles.value,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 34
                  }
                },
                value
              );
            })
          )
        );
      }
    }]);
    return StyleInspector;
  }(React.Component);

  var styles = StyleSheet.create({
    container: {
      flexDirection: 'row'
    },
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-around'
    },
    attr: {
      fontSize: 10,
      color: '#ccc'
    },
    value: {
      fontSize: 10,
      color: 'white',
      marginLeft: 10
    },
    noStyle: {
      color: 'white',
      fontSize: 10
    }
  });
  module.exports = StyleInspector;
},311,[171,209,222,211],"StyleInspector");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/Touchable/TouchableHighlight.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var NativeMethodsMixin = require(_dependencyMap[1], 'NativeMethodsMixin');

  var PropTypes = require(_dependencyMap[2], 'prop-types');

  var React = require(_dependencyMap[3], 'React');

  var ReactNativeViewAttributes = require(_dependencyMap[4], 'ReactNativeViewAttributes');

  var StyleSheet = require(_dependencyMap[5], 'StyleSheet');

  var Touchable = require(_dependencyMap[6], 'Touchable');

  var TouchableWithoutFeedback = require(_dependencyMap[7], 'TouchableWithoutFeedback');

  var View = require(_dependencyMap[8], 'View');

  var ViewPropTypes = require(_dependencyMap[9], 'ViewPropTypes');

  var createReactClass = require(_dependencyMap[10], 'create-react-class');

  var ensurePositiveDelayProps = require(_dependencyMap[11], 'ensurePositiveDelayProps');

  var DEFAULT_PROPS = {
    activeOpacity: 0.85,
    delayPressOut: 100,
    underlayColor: 'black'
  };
  var PRESS_RETENTION_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var TouchableHighlight = createReactClass({
    displayName: 'TouchableHighlight',
    propTypes: babelHelpers.extends({}, TouchableWithoutFeedback.propTypes, {
      activeOpacity: PropTypes.number,
      underlayColor: ColorPropType,
      style: ViewPropTypes.style,
      onShowUnderlay: PropTypes.func,
      onHideUnderlay: PropTypes.func,
      hasTVPreferredFocus: PropTypes.bool,
      tvParallaxProperties: PropTypes.object
    }),
    mixins: [NativeMethodsMixin, Touchable.Mixin],
    getDefaultProps: function getDefaultProps() {
      return DEFAULT_PROPS;
    },
    getInitialState: function getInitialState() {
      this._isMounted = false;
      return babelHelpers.extends({}, this.touchableGetInitialState(), {
        extraChildStyle: null,
        extraUnderlayStyle: null
      });
    },
    componentDidMount: function componentDidMount() {
      this._isMounted = true;
      ensurePositiveDelayProps(this.props);
    },
    componentWillUnmount: function componentWillUnmount() {
      this._isMounted = false;
      clearTimeout(this._hideTimeout);
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      ensurePositiveDelayProps(nextProps);
    },
    viewConfig: {
      uiViewClassName: 'RCTView',
      validAttributes: ReactNativeViewAttributes.RCTView
    },
    touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
      clearTimeout(this._hideTimeout);
      this._hideTimeout = null;

      this._showUnderlay();

      this.props.onPressIn && this.props.onPressIn(e);
    },
    touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
      if (!this._hideTimeout) {
        this._hideUnderlay();
      }

      this.props.onPressOut && this.props.onPressOut(e);
    },
    touchableHandlePress: function touchableHandlePress(e) {
      clearTimeout(this._hideTimeout);

      this._showUnderlay();

      this._hideTimeout = setTimeout(this._hideUnderlay, this.props.delayPressOut);
      this.props.onPress && this.props.onPress(e);
    },
    touchableHandleLongPress: function touchableHandleLongPress(e) {
      this.props.onLongPress && this.props.onLongPress(e);
    },
    touchableGetPressRectOffset: function touchableGetPressRectOffset() {
      return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
    },
    touchableGetHitSlop: function touchableGetHitSlop() {
      return this.props.hitSlop;
    },
    touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
      return this.props.delayPressIn;
    },
    touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
      return this.props.delayLongPress;
    },
    touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
      return this.props.delayPressOut;
    },
    _showUnderlay: function _showUnderlay() {
      if (!this._isMounted || !this._hasPressHandler()) {
        return;
      }

      this.setState({
        extraChildStyle: {
          opacity: this.props.activeOpacity
        },
        extraUnderlayStyle: {
          backgroundColor: this.props.underlayColor
        }
      });
      this.props.onShowUnderlay && this.props.onShowUnderlay();
    },
    _hideUnderlay: function _hideUnderlay() {
      clearTimeout(this._hideTimeout);
      this._hideTimeout = null;

      if (this._hasPressHandler()) {
        this.setState({
          extraChildStyle: null,
          extraUnderlayStyle: null
        });
        this.props.onHideUnderlay && this.props.onHideUnderlay();
      }
    },
    _hasPressHandler: function _hasPressHandler() {
      return !!(this.props.onPress || this.props.onPressIn || this.props.onPressOut || this.props.onLongPress);
    },
    render: function render() {
      var child = React.Children.only(this.props.children);
      return React.createElement(
        View,
        {
          accessible: this.props.accessible !== false,
          accessibilityLabel: this.props.accessibilityLabel,
          accessibilityComponentType: this.props.accessibilityComponentType,
          accessibilityTraits: this.props.accessibilityTraits,
          style: StyleSheet.compose(this.props.style, this.state.extraUnderlayStyle),
          onLayout: this.props.onLayout,
          hitSlop: this.props.hitSlop,
          isTVSelectable: true,
          tvParallaxProperties: this.props.tvParallaxProperties,
          hasTVPreferredFocus: this.props.hasTVPreferredFocus,
          onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
          onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
          onResponderGrant: this.touchableHandleResponderGrant,
          onResponderMove: this.touchableHandleResponderMove,
          onResponderRelease: this.touchableHandleResponderRelease,
          onResponderTerminate: this.touchableHandleResponderTerminate,
          nativeID: this.props.nativeID,
          testID: this.props.testID,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 306
          }
        },
        React.cloneElement(child, {
          style: StyleSheet.compose(child.props.style, this.state.extraChildStyle)
        }),
        Touchable.renderDebugView({
          color: 'green',
          hitSlop: this.props.hitSlop
        })
      );
    }
  });
  module.exports = TouchableHighlight;
},312,[167,169,24,171,212,209,223,231,211,172,213,233],"TouchableHighlight");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function mapWithSeparator(items, itemRenderer, spacerRenderer) {
    var mapped = [];

    if (items.length > 0) {
      mapped.push(itemRenderer(items[0], 0, items));

      for (var ii = 1; ii < items.length; ii++) {
        mapped.push(spacerRenderer(ii - 1), itemRenderer(items[ii], ii, items));
      }
    }

    return mapped;
  }

  module.exports = mapWithSeparator;
},313,[],"mapWithSeparator");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var getDevServer = require(_dependencyMap[0], 'getDevServer');

  function openFileInEditor(file, lineNumber) {
    fetch(getDevServer().url + 'open-stack-frame', {
      method: 'POST',
      body: JSON.stringify({
        file: file,
        lineNumber: lineNumber
      })
    });
  }

  module.exports = openFileInEditor;
},314,[89],"openFileInEditor");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/NetworkOverlay.js";

  var ListView = require(_dependencyMap[0], 'ListView');

  var React = require(_dependencyMap[1], 'React');

  var ScrollView = require(_dependencyMap[2], 'ScrollView');

  var StyleSheet = require(_dependencyMap[3], 'StyleSheet');

  var Text = require(_dependencyMap[4], 'Text');

  var TouchableHighlight = require(_dependencyMap[5], 'TouchableHighlight');

  var View = require(_dependencyMap[6], 'View');

  var WebSocketInterceptor = require(_dependencyMap[7], 'WebSocketInterceptor');

  var XHRInterceptor = require(_dependencyMap[8], 'XHRInterceptor');

  var LISTVIEW_CELL_HEIGHT = 15;
  var SEPARATOR_THICKNESS = 2;
  var nextXHRId = 0;

  var NetworkOverlay = function (_React$Component) {
    babelHelpers.inherits(NetworkOverlay, _React$Component);

    function NetworkOverlay(props) {
      babelHelpers.classCallCheck(this, NetworkOverlay);

      var _this = babelHelpers.possibleConstructorReturn(this, (NetworkOverlay.__proto__ || Object.getPrototypeOf(NetworkOverlay)).call(this, props));

      _this._requests = [];
      _this._detailViewItems = [];
      _this._listViewDataSource = new ListView.DataSource({
        rowHasChanged: function rowHasChanged(r1, r2) {
          return r1 !== r2;
        }
      });
      _this.state = {
        dataSource: _this._listViewDataSource.cloneWithRows([]),
        newDetailInfo: false,
        detailRowID: null
      };
      _this._listViewHighlighted = false;
      _this._listViewHeight = 0;
      _this._captureRequestListView = _this._captureRequestListView.bind(_this);
      _this._captureDetailScrollView = _this._captureDetailScrollView.bind(_this);
      _this._listViewOnLayout = _this._listViewOnLayout.bind(_this);
      _this._renderRow = _this._renderRow.bind(_this);
      _this._closeButtonClicked = _this._closeButtonClicked.bind(_this);
      _this._socketIdMap = {};
      _this._xhrIdMap = {};
      return _this;
    }

    babelHelpers.createClass(NetworkOverlay, [{
      key: "_enableXHRInterception",
      value: function _enableXHRInterception() {
        var _this2 = this;

        if (XHRInterceptor.isInterceptorEnabled()) {
          return;
        }

        XHRInterceptor.setOpenCallback(function (method, url, xhr) {
          xhr._index = nextXHRId++;
          var xhrIndex = _this2._requests.length;
          _this2._xhrIdMap[xhr._index] = xhrIndex;
          var _xhr = {
            'type': 'XMLHttpRequest',
            'method': method,
            'url': url
          };

          _this2._requests.push(_xhr);

          _this2._detailViewItems.push([]);

          _this2._genDetailViewItem(xhrIndex);

          _this2.setState({
            dataSource: _this2._listViewDataSource.cloneWithRows(_this2._requests)
          }, _this2._scrollToBottom());
        });
        XHRInterceptor.setRequestHeaderCallback(function (header, value, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          var networkInfo = _this2._requests[xhrIndex];

          if (!networkInfo.requestHeaders) {
            networkInfo.requestHeaders = {};
          }

          networkInfo.requestHeaders[header] = value;

          _this2._genDetailViewItem(xhrIndex);
        });
        XHRInterceptor.setSendCallback(function (data, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          _this2._requests[xhrIndex].dataSent = data;

          _this2._genDetailViewItem(xhrIndex);
        });
        XHRInterceptor.setHeaderReceivedCallback(function (type, size, responseHeaders, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          var networkInfo = _this2._requests[xhrIndex];
          networkInfo.responseContentType = type;
          networkInfo.responseSize = size;
          networkInfo.responseHeaders = responseHeaders;

          _this2._genDetailViewItem(xhrIndex);
        });
        XHRInterceptor.setResponseCallback(function (status, timeout, response, responseURL, responseType, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          var networkInfo = _this2._requests[xhrIndex];
          networkInfo.status = status;
          networkInfo.timeout = timeout;
          networkInfo.response = response;
          networkInfo.responseURL = responseURL;
          networkInfo.responseType = responseType;

          _this2._genDetailViewItem(xhrIndex);
        });
        XHRInterceptor.enableInterception();
      }
    }, {
      key: "_enableWebSocketInterception",
      value: function _enableWebSocketInterception() {
        var _this3 = this;

        if (WebSocketInterceptor.isInterceptorEnabled()) {
          return;
        }

        WebSocketInterceptor.setConnectCallback(function (url, protocols, options, socketId) {
          var socketIndex = _this3._requests.length;
          _this3._socketIdMap[socketId] = socketIndex;
          var _webSocket = {
            'type': 'WebSocket',
            'url': url,
            'protocols': protocols
          };

          _this3._requests.push(_webSocket);

          _this3._detailViewItems.push([]);

          _this3._genDetailViewItem(socketIndex);

          _this3.setState({
            dataSource: _this3._listViewDataSource.cloneWithRows(_this3._requests)
          }, _this3._scrollToBottom());
        });
        WebSocketInterceptor.setCloseCallback(function (statusCode, closeReason, socketId) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          if (statusCode !== null && closeReason !== null) {
            _this3._requests[socketIndex].status = statusCode;
            _this3._requests[socketIndex].closeReason = closeReason;
          }

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.setSendCallback(function (data, socketId) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          if (!_this3._requests[socketIndex].messages) {
            _this3._requests[socketIndex].messages = '';
          }

          _this3._requests[socketIndex].messages += 'Sent: ' + JSON.stringify(data) + '\n';

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.setOnMessageCallback(function (socketId, message) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          if (!_this3._requests[socketIndex].messages) {
            _this3._requests[socketIndex].messages = '';
          }

          _this3._requests[socketIndex].messages += 'Received: ' + JSON.stringify(message) + '\n';

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.setOnCloseCallback(function (socketId, message) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          _this3._requests[socketIndex].serverClose = message;

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.setOnErrorCallback(function (socketId, message) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          _this3._requests[socketIndex].serverError = message;

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.enableInterception();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._enableXHRInterception();

        this._enableWebSocketInterception();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        XHRInterceptor.disableInterception();
        WebSocketInterceptor.disableInterception();
      }
    }, {
      key: "_renderRow",
      value: function _renderRow(rowData, sectionID, rowID, highlightRow) {
        var _this4 = this;

        var urlCellViewStyle = styles.urlEvenCellView;
        var methodCellViewStyle = styles.methodEvenCellView;

        if (rowID % 2 === 1) {
          urlCellViewStyle = styles.urlOddCellView;
          methodCellViewStyle = styles.methodOddCellView;
        }

        return React.createElement(
          TouchableHighlight,
          {
            onPress: function onPress() {
              _this4._pressRow(rowID);

              highlightRow(sectionID, rowID);
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 300
            }
          },
          React.createElement(
            View,
            {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 304
              }
            },
            React.createElement(
              View,
              {
                style: styles.tableRow,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 305
                }
              },
              React.createElement(
                View,
                {
                  style: urlCellViewStyle,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 306
                  }
                },
                React.createElement(
                  Text,
                  {
                    style: styles.cellText,
                    numberOfLines: 1,
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 307
                    }
                  },
                  rowData.url
                )
              ),
              React.createElement(
                View,
                {
                  style: methodCellViewStyle,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 311
                  }
                },
                React.createElement(
                  Text,
                  {
                    style: styles.cellText,
                    numberOfLines: 1,
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 312
                    }
                  },
                  this._getTypeShortName(rowData.type)
                )
              )
            )
          )
        );
      }
    }, {
      key: "_renderSeperator",
      value: function _renderSeperator(sectionID, rowID, adjacentRowHighlighted) {
        return React.createElement(View, {
          key: sectionID + "-" + rowID,
          style: {
            height: adjacentRowHighlighted ? SEPARATOR_THICKNESS : 0,
            backgroundColor: adjacentRowHighlighted ? '#3B5998' : '#CCCCCC'
          },
          __source: {
            fileName: _jsxFileName,
            lineNumber: 327
          }
        });
      }
    }, {
      key: "_scrollToBottom",
      value: function _scrollToBottom() {
        if (this._listView) {
          var scrollResponder = this._listView.getScrollResponder();

          if (scrollResponder) {
            var scrollY = Math.max(this._requests.length * LISTVIEW_CELL_HEIGHT + (this._listViewHighlighted ? 2 * SEPARATOR_THICKNESS : 0) - this._listViewHeight, 0);
            scrollResponder.scrollResponderScrollTo({
              x: 0,
              y: scrollY,
              animated: true
            });
          }
        }
      }
    }, {
      key: "_captureRequestListView",
      value: function _captureRequestListView(listRef) {
        this._listView = listRef;
      }
    }, {
      key: "_listViewOnLayout",
      value: function _listViewOnLayout(event) {
        var height = event.nativeEvent.layout.height;
        this._listViewHeight = height;
      }
    }, {
      key: "_pressRow",
      value: function _pressRow(rowID) {
        this._listViewHighlighted = true;
        this.setState({
          detailRowID: rowID
        }, this._scrollToTop());
      }
    }, {
      key: "_scrollToTop",
      value: function _scrollToTop() {
        if (this._scrollView) {
          this._scrollView.scrollTo({
            y: 0,
            animated: false
          });
        }
      }
    }, {
      key: "_captureDetailScrollView",
      value: function _captureDetailScrollView(scrollRef) {
        this._scrollView = scrollRef;
      }
    }, {
      key: "_closeButtonClicked",
      value: function _closeButtonClicked() {
        this.setState({
          detailRowID: null
        });
      }
    }, {
      key: "_getStringByValue",
      value: function _getStringByValue(value) {
        if (value === undefined) {
          return 'undefined';
        }

        if (typeof value === 'object') {
          return JSON.stringify(value);
        }

        if (typeof value === 'string' && value.length > 500) {
          return String(value).substr(0, 500).concat('\n***TRUNCATED TO 500 CHARACTERS***');
        }

        return value;
      }
    }, {
      key: "_getRequestIndexByXHRID",
      value: function _getRequestIndexByXHRID(index) {
        if (index === undefined) {
          return -1;
        }

        var xhrIndex = this._xhrIdMap[index];

        if (xhrIndex === undefined) {
          return -1;
        } else {
          return xhrIndex;
        }
      }
    }, {
      key: "_getTypeShortName",
      value: function _getTypeShortName(type) {
        if (type === 'XMLHttpRequest') {
          return 'XHR';
        } else if (type === 'WebSocket') {
          return 'WS';
        }

        return '';
      }
    }, {
      key: "_genDetailViewItem",
      value: function _genDetailViewItem(index) {
        this._detailViewItems[index] = [];
        var detailViewItem = this._detailViewItems[index];
        var requestItem = this._requests[index];

        for (var _key in requestItem) {
          detailViewItem.push(React.createElement(
            View,
            {
              style: styles.detailViewRow,
              key: _key,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 442
              }
            },
            React.createElement(
              Text,
              {
                style: [styles.detailViewText, styles.detailKeyCellView],
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 443
                }
              },
              _key
            ),
            React.createElement(
              Text,
              {
                style: [styles.detailViewText, styles.detailValueCellView],
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 446
                }
              },
              this._getStringByValue(requestItem[_key])
            )
          ));
        }

        if (this.state.detailRowID != null && Number(this.state.detailRowID) === index) {
          this.setState({
            newDetailInfo: true
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        return React.createElement(
          View,
          {
            style: styles.container,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 461
            }
          },
          this.state.detailRowID != null && React.createElement(
            TouchableHighlight,
            {
              style: styles.closeButton,
              onPress: this._closeButtonClicked,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 463
              }
            },
            React.createElement(
              View,
              {
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 466
                }
              },
              React.createElement(
                Text,
                {
                  style: styles.clostButtonText,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 467
                  }
                },
                "v"
              )
            )
          ),
          this.state.detailRowID != null && React.createElement(
            ScrollView,
            {
              style: styles.detailScrollView,
              ref: this._captureDetailScrollView,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 471
              }
            },
            this._detailViewItems[this.state.detailRowID]
          ),
          React.createElement(
            View,
            {
              style: styles.listViewTitle,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 476
              }
            },
            this._requests.length > 0 && React.createElement(
              View,
              {
                style: styles.tableRow,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 478
                }
              },
              React.createElement(
                View,
                {
                  style: styles.urlTitleCellView,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 479
                  }
                },
                React.createElement(
                  Text,
                  {
                    style: styles.cellText,
                    numberOfLines: 1,
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 480
                    }
                  },
                  "URL"
                )
              ),
              React.createElement(
                View,
                {
                  style: styles.methodTitleCellView,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 482
                  }
                },
                React.createElement(
                  Text,
                  {
                    style: styles.cellText,
                    numberOfLines: 1,
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 483
                    }
                  },
                  "Type"
                )
              )
            )
          ),
          React.createElement(ListView, {
            style: styles.listView,
            ref: this._captureRequestListView,
            dataSource: this.state.dataSource,
            renderRow: this._renderRow,
            enableEmptySections: true,
            renderSeparator: this._renderSeperator,
            onLayout: this._listViewOnLayout,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 487
            }
          })
        );
      }
    }]);
    return NetworkOverlay;
  }(React.Component);

  var styles = StyleSheet.create({
    container: {
      paddingTop: 10,
      paddingBottom: 10,
      paddingLeft: 5,
      paddingRight: 5
    },
    listViewTitle: {
      height: 20
    },
    listView: {
      flex: 1,
      height: 60
    },
    tableRow: {
      flexDirection: 'row',
      flex: 1
    },
    cellText: {
      color: 'white',
      fontSize: 12
    },
    methodTitleCellView: {
      height: 18,
      borderColor: '#DCD7CD',
      borderTopWidth: 1,
      borderBottomWidth: 1,
      borderRightWidth: 1,
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#444',
      flex: 1
    },
    urlTitleCellView: {
      height: 18,
      borderColor: '#DCD7CD',
      borderTopWidth: 1,
      borderBottomWidth: 1,
      borderLeftWidth: 1,
      borderRightWidth: 1,
      justifyContent: 'center',
      backgroundColor: '#444',
      flex: 5,
      paddingLeft: 3
    },
    methodOddCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderRightWidth: 1,
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#000',
      flex: 1
    },
    urlOddCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderLeftWidth: 1,
      borderRightWidth: 1,
      justifyContent: 'center',
      backgroundColor: '#000',
      flex: 5,
      paddingLeft: 3
    },
    methodEvenCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderRightWidth: 1,
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#888',
      flex: 1
    },
    urlEvenCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderLeftWidth: 1,
      borderRightWidth: 1,
      justifyContent: 'center',
      backgroundColor: '#888',
      flex: 5,
      paddingLeft: 3
    },
    detailScrollView: {
      flex: 1,
      height: 180,
      marginTop: 5,
      marginBottom: 5
    },
    detailKeyCellView: {
      flex: 1.3
    },
    detailValueCellView: {
      flex: 2
    },
    detailViewRow: {
      flexDirection: 'row',
      paddingHorizontal: 3
    },
    detailViewText: {
      color: 'white',
      fontSize: 11
    },
    clostButtonText: {
      color: 'white',
      fontSize: 10
    },
    closeButton: {
      marginTop: 5,
      backgroundColor: '#888',
      justifyContent: 'center',
      alignItems: 'center'
    }
  });
  module.exports = NetworkOverlay;
},315,[282,171,265,209,222,312,211,316,317],"NetworkOverlay");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTWebSocketModule = require(_dependencyMap[0], 'NativeModules').WebSocketModule;

  var NativeEventEmitter = require(_dependencyMap[1], 'NativeEventEmitter');

  var base64 = require(_dependencyMap[2], 'base64-js');

  var originalRCTWebSocketConnect = RCTWebSocketModule.connect;
  var originalRCTWebSocketSend = RCTWebSocketModule.send;
  var originalRCTWebSocketSendBinary = RCTWebSocketModule.sendBinary;
  var originalRCTWebSocketClose = RCTWebSocketModule.close;
  var eventEmitter = void 0;
  var subscriptions = void 0;
  var closeCallback = void 0;
  var sendCallback = void 0;
  var connectCallback = void 0;
  var onOpenCallback = void 0;
  var onMessageCallback = void 0;
  var onErrorCallback = void 0;
  var onCloseCallback = void 0;
  var _isInterceptorEnabled = false;
  var WebSocketInterceptor = {
    setCloseCallback: function setCloseCallback(callback) {
      closeCallback = callback;
    },
    setSendCallback: function setSendCallback(callback) {
      sendCallback = callback;
    },
    setConnectCallback: function setConnectCallback(callback) {
      connectCallback = callback;
    },
    setOnOpenCallback: function setOnOpenCallback(callback) {
      onOpenCallback = callback;
    },
    setOnMessageCallback: function setOnMessageCallback(callback) {
      onMessageCallback = callback;
    },
    setOnErrorCallback: function setOnErrorCallback(callback) {
      onErrorCallback = callback;
    },
    setOnCloseCallback: function setOnCloseCallback(callback) {
      onCloseCallback = callback;
    },
    isInterceptorEnabled: function isInterceptorEnabled() {
      return _isInterceptorEnabled;
    },
    _unregisterEvents: function _unregisterEvents() {
      subscriptions.forEach(function (e) {
        return e.remove();
      });
      subscriptions = [];
    },
    _registerEvents: function _registerEvents() {
      subscriptions = [eventEmitter.addListener('websocketMessage', function (ev) {
        if (onMessageCallback) {
          onMessageCallback(ev.id, ev.type === 'binary' ? WebSocketInterceptor._arrayBufferToString(ev.data) : ev.data);
        }
      }), eventEmitter.addListener('websocketOpen', function (ev) {
        if (onOpenCallback) {
          onOpenCallback(ev.id);
        }
      }), eventEmitter.addListener('websocketClosed', function (ev) {
        if (onCloseCallback) {
          onCloseCallback(ev.id, {
            code: ev.code,
            reason: ev.reason
          });
        }
      }), eventEmitter.addListener('websocketFailed', function (ev) {
        if (onErrorCallback) {
          onErrorCallback(ev.id, {
            message: ev.message
          });
        }
      })];
    },
    enableInterception: function enableInterception() {
      if (_isInterceptorEnabled) {
        return;
      }

      eventEmitter = new NativeEventEmitter(RCTWebSocketModule);

      WebSocketInterceptor._registerEvents();

      RCTWebSocketModule.connect = function (url, protocols, options, socketId) {
        if (connectCallback) {
          connectCallback(url, protocols, options, socketId);
        }

        originalRCTWebSocketConnect.apply(this, arguments);
      };

      RCTWebSocketModule.send = function (data, socketId) {
        if (sendCallback) {
          sendCallback(data, socketId);
        }

        originalRCTWebSocketSend.apply(this, arguments);
      };

      RCTWebSocketModule.sendBinary = function (data, socketId) {
        if (sendCallback) {
          sendCallback(WebSocketInterceptor._arrayBufferToString(data), socketId);
        }

        originalRCTWebSocketSendBinary.apply(this, arguments);
      };

      RCTWebSocketModule.close = function () {
        if (closeCallback) {
          if (arguments.length === 3) {
            closeCallback(arguments[0], arguments[1], arguments[2]);
          } else {
            closeCallback(null, null, arguments[0]);
          }
        }

        originalRCTWebSocketClose.apply(this, arguments);
      };

      _isInterceptorEnabled = true;
    },
    _arrayBufferToString: function _arrayBufferToString(data) {
      var value = base64.toByteArray(data).buffer;

      if (value === undefined || value === null) {
        return '(no value)';
      }

      if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && value instanceof ArrayBuffer) {
        return "ArrayBuffer {" + String(Array.from(new Uint8Array(value))) + "}";
      }

      return value;
    },
    disableInterception: function disableInterception() {
      if (!_isInterceptorEnabled) {
        return;
      }

      _isInterceptorEnabled = false;
      RCTWebSocketModule.send = originalRCTWebSocketSend;
      RCTWebSocketModule.sendBinary = originalRCTWebSocketSendBinary;
      RCTWebSocketModule.close = originalRCTWebSocketClose;
      RCTWebSocketModule.connect = originalRCTWebSocketConnect;
      connectCallback = null;
      closeCallback = null;
      sendCallback = null;
      onOpenCallback = null;
      onMessageCallback = null;
      onCloseCallback = null;
      onErrorCallback = null;

      WebSocketInterceptor._unregisterEvents();
    }
  };
  module.exports = WebSocketInterceptor;
},316,[68,120,124],"WebSocketInterceptor");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var XMLHttpRequest = require(_dependencyMap[0], 'XMLHttpRequest');

  var originalXHROpen = XMLHttpRequest.prototype.open;
  var originalXHRSend = XMLHttpRequest.prototype.send;
  var originalXHRSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
  var openCallback;
  var sendCallback;
  var requestHeaderCallback;
  var headerReceivedCallback;
  var responseCallback;
  var _isInterceptorEnabled = false;
  var XHRInterceptor = {
    setOpenCallback: function setOpenCallback(callback) {
      openCallback = callback;
    },
    setSendCallback: function setSendCallback(callback) {
      sendCallback = callback;
    },
    setHeaderReceivedCallback: function setHeaderReceivedCallback(callback) {
      headerReceivedCallback = callback;
    },
    setResponseCallback: function setResponseCallback(callback) {
      responseCallback = callback;
    },
    setRequestHeaderCallback: function setRequestHeaderCallback(callback) {
      requestHeaderCallback = callback;
    },
    isInterceptorEnabled: function isInterceptorEnabled() {
      return _isInterceptorEnabled;
    },
    enableInterception: function enableInterception() {
      if (_isInterceptorEnabled) {
        return;
      }

      XMLHttpRequest.prototype.open = function (method, url) {
        if (openCallback) {
          openCallback(method, url, this);
        }

        originalXHROpen.apply(this, arguments);
      };

      XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
        if (requestHeaderCallback) {
          requestHeaderCallback(header, value, this);
        }

        originalXHRSetRequestHeader.apply(this, arguments);
      };

      XMLHttpRequest.prototype.send = function (data) {
        var _this = this;

        if (sendCallback) {
          sendCallback(data, this);
        }

        if (this.addEventListener) {
          this.addEventListener('readystatechange', function () {
            if (!_isInterceptorEnabled) {
              return;
            }

            if (_this.readyState === _this.HEADERS_RECEIVED) {
              var contentTypeString = _this.getResponseHeader('Content-Type');

              var contentLengthString = _this.getResponseHeader('Content-Length');

              var responseContentType = void 0,
                  responseSize = void 0;

              if (contentTypeString) {
                responseContentType = contentTypeString.split(';')[0];
              }

              if (contentLengthString) {
                responseSize = parseInt(contentLengthString, 10);
              }

              if (headerReceivedCallback) {
                headerReceivedCallback(responseContentType, responseSize, _this.getAllResponseHeaders(), _this);
              }
            }

            if (_this.readyState === _this.DONE) {
              if (responseCallback) {
                responseCallback(_this.status, _this.timeout, _this.response, _this.responseURL, _this.responseType, _this);
              }
            }
          }, false);
        }

        originalXHRSend.apply(this, arguments);
      };

      _isInterceptorEnabled = true;
    },
    disableInterception: function disableInterception() {
      if (!_isInterceptorEnabled) {
        return;
      }

      _isInterceptorEnabled = false;
      XMLHttpRequest.prototype.send = originalXHRSend;
      XMLHttpRequest.prototype.open = originalXHROpen;
      XMLHttpRequest.prototype.setRequestHeader = originalXHRSetRequestHeader;
      responseCallback = null;
      openCallback = null;
      sendCallback = null;
      headerReceivedCallback = null;
      requestHeaderCallback = null;
    }
  };
  module.exports = XHRInterceptor;
},317,[109],"XHRInterceptor");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Inspector/PerformanceOverlay.js";

  var PerformanceLogger = require(_dependencyMap[0], 'PerformanceLogger');

  var React = require(_dependencyMap[1], 'React');

  var StyleSheet = require(_dependencyMap[2], 'StyleSheet');

  var Text = require(_dependencyMap[3], 'Text');

  var View = require(_dependencyMap[4], 'View');

  var PerformanceOverlay = function (_React$Component) {
    babelHelpers.inherits(PerformanceOverlay, _React$Component);

    function PerformanceOverlay() {
      babelHelpers.classCallCheck(this, PerformanceOverlay);
      return babelHelpers.possibleConstructorReturn(this, (PerformanceOverlay.__proto__ || Object.getPrototypeOf(PerformanceOverlay)).apply(this, arguments));
    }

    babelHelpers.createClass(PerformanceOverlay, [{
      key: "render",
      value: function render() {
        var perfLogs = PerformanceLogger.getTimespans();
        var items = [];

        for (var key in perfLogs) {
          if (perfLogs[key].totalTime) {
            var unit = key === 'BundleSize' ? 'b' : 'ms';
            items.push(React.createElement(
              View,
              {
                style: styles.row,
                key: key,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 29
                }
              },
              React.createElement(
                Text,
                {
                  style: [styles.text, styles.label],
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 30
                  }
                },
                key
              ),
              React.createElement(
                Text,
                {
                  style: [styles.text, styles.totalTime],
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 31
                  }
                },
                perfLogs[key].totalTime + unit
              )
            ));
          }
        }

        return React.createElement(
          View,
          {
            style: styles.container,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 40
            }
          },
          items
        );
      }
    }]);
    return PerformanceOverlay;
  }(React.Component);

  var styles = StyleSheet.create({
    container: {
      height: 100,
      paddingTop: 10
    },
    label: {
      flex: 1
    },
    row: {
      flexDirection: 'row',
      paddingHorizontal: 10
    },
    text: {
      color: 'white',
      fontSize: 12
    },
    totalTime: {
      paddingRight: 100
    }
  });
  module.exports = PerformanceOverlay;
},318,[144,171,209,222,211],"PerformanceOverlay");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/ReactNative/YellowBox.js";

  var EventEmitter = require(_dependencyMap[0], 'EventEmitter');

  var Platform = require(_dependencyMap[1], 'Platform');

  var React = require(_dependencyMap[2], 'React');

  var SafeAreaView = require(_dependencyMap[3], 'SafeAreaView');

  var StyleSheet = require(_dependencyMap[4], 'StyleSheet');

  var RCTLog = require(_dependencyMap[5], 'RCTLog');

  var infoLog = require(_dependencyMap[6], 'infoLog');

  var openFileInEditor = require(_dependencyMap[7], 'openFileInEditor');

  var parseErrorStack = require(_dependencyMap[8], 'parseErrorStack');

  var stringifySafe = require(_dependencyMap[9], 'stringifySafe');

  var symbolicateStackTrace = require(_dependencyMap[10], 'symbolicateStackTrace');

  var _warningEmitter = new EventEmitter();

  var _warningMap = new Map();

  var IGNORED_WARNINGS = [];

  if (__DEV__) {
    var _console = console,
        error = _console.error,
        warn = _console.warn;

    console.error = function () {
      error.apply(console, arguments);

      if (typeof arguments[0] === 'string' && arguments[0].startsWith('Warning: ')) {
        updateWarningMap.apply(null, arguments);
      }
    };

    console.warn = function () {
      warn.apply(console, arguments);
      updateWarningMap.apply(null, arguments);
    };

    if (Platform.isTesting) {
      console.disableYellowBox = true;
    }

    RCTLog.setWarningHandler(function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      updateWarningMap.apply(null, args);
    });
  }

  function sprintf(format) {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    var index = 0;
    return format.replace(/%s/g, function (match) {
      return args[index++];
    });
  }

  function updateWarningMap() {
    if (console.disableYellowBox) {
      return;
    }

    var warning = void 0;

    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    if (typeof args[0] === 'string') {
      var format = args[0],
          formatArgs = args.slice(1);
      var argCount = (format.match(/%s/g) || []).length;
      warning = [sprintf.apply(undefined, [format].concat(babelHelpers.toConsumableArray(formatArgs.slice(0, argCount).map(stringifySafe))))].concat(babelHelpers.toConsumableArray(formatArgs.slice(argCount).map(stringifySafe))).join(' ');
    } else {
      warning = args.map(stringifySafe).join(' ');
    }

    if (warning.startsWith('(ADVICE)')) {
      return;
    }

    var warningInfo = _warningMap.get(warning);

    if (warningInfo) {
      warningInfo.count += 1;
    } else {
      var _error = new Error();

      _error.framesToPop = 2;

      _warningMap.set(warning, {
        count: 1,
        stacktrace: parseErrorStack(_error),
        symbolicated: false
      });
    }

    _warningEmitter.emit('warning', _warningMap);
  }

  function ensureSymbolicatedWarning(warning) {
    var prevWarningInfo = _warningMap.get(warning);

    if (!prevWarningInfo || prevWarningInfo.symbolicated) {
      return;
    }

    prevWarningInfo.symbolicated = true;
    symbolicateStackTrace(prevWarningInfo.stacktrace).then(function (stack) {
      var nextWarningInfo = _warningMap.get(warning);

      if (nextWarningInfo) {
        nextWarningInfo.stacktrace = stack;

        _warningEmitter.emit('warning', _warningMap);
      }
    }, function (error) {
      var nextWarningInfo = _warningMap.get(warning);

      if (nextWarningInfo) {
        infoLog('Failed to symbolicate warning, "%s":', warning, error);

        _warningEmitter.emit('warning', _warningMap);
      }
    });
  }

  function isWarningIgnored(warning) {
    var isIgnored = IGNORED_WARNINGS.some(function (ignoredWarning) {
      return warning.startsWith(ignoredWarning);
    });

    if (isIgnored) {
      return true;
    }

    return Array.isArray(console.ignoredYellowBox) && console.ignoredYellowBox.some(function (ignorePrefix) {
      return warning.startsWith(String(ignorePrefix));
    });
  }

  var WarningRow = function WarningRow(_ref) {
    var count = _ref.count,
        warning = _ref.warning,
        onPress = _ref.onPress;

    var Text = require(_dependencyMap[11], 'Text');

    var TouchableHighlight = require(_dependencyMap[12], 'TouchableHighlight');

    var View = require(_dependencyMap[13], 'View');

    var countText = count > 1 ? React.createElement(
      Text,
      {
        style: styles.listRowCount,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 197
        }
      },
      '(' + count + ') '
    ) : null;
    return React.createElement(
      View,
      {
        style: styles.listRow,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 201
        }
      },
      React.createElement(
        TouchableHighlight,
        {
          activeOpacity: 0.5,
          onPress: onPress,
          style: styles.listRowContent,
          underlayColor: "transparent",
          __source: {
            fileName: _jsxFileName,
            lineNumber: 202
          }
        },
        React.createElement(
          Text,
          {
            style: styles.listRowText,
            numberOfLines: 2,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 207
            }
          },
          countText,
          warning
        )
      )
    );
  };

  var StackRow = function StackRow(_ref2) {
    var frame = _ref2.frame;

    var Text = require(_dependencyMap[11], 'Text');

    var TouchableHighlight = require(_dependencyMap[12], 'TouchableHighlight');

    var file = frame.file,
        lineNumber = frame.lineNumber;
    var fileName = void 0;

    if (file) {
      var fileParts = file.split('/');
      fileName = fileParts[fileParts.length - 1];
    } else {
      fileName = '<unknown file>';
    }

    return React.createElement(
      TouchableHighlight,
      {
        activeOpacity: 0.5,
        style: styles.openInEditorButton,
        underlayColor: "transparent",
        onPress: openFileInEditor.bind(null, file, lineNumber),
        __source: {
          fileName: _jsxFileName,
          lineNumber: 230
        }
      },
      React.createElement(
        Text,
        {
          style: styles.inspectorCountText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 235
          }
        },
        fileName,
        ":",
        lineNumber
      )
    );
  };

  var WarningInspector = function WarningInspector(_ref3) {
    var warningInfo = _ref3.warningInfo,
        warning = _ref3.warning,
        stacktraceVisible = _ref3.stacktraceVisible,
        onDismiss = _ref3.onDismiss,
        onDismissAll = _ref3.onDismissAll,
        onMinimize = _ref3.onMinimize,
        toggleStacktrace = _ref3.toggleStacktrace;

    var ScrollView = require(_dependencyMap[14], 'ScrollView');

    var Text = require(_dependencyMap[11], 'Text');

    var TouchableHighlight = require(_dependencyMap[12], 'TouchableHighlight');

    var View = require(_dependencyMap[13], 'View');

    var _ref4 = warningInfo || {},
        count = _ref4.count,
        stacktrace = _ref4.stacktrace;

    var countSentence = 'Warning encountered ' + count + ' time' + (count - 1 ? 's' : '') + '.';
    var stacktraceList = void 0;

    if (stacktraceVisible && stacktrace) {
      stacktraceList = React.createElement(
        View,
        {
          style: styles.stacktraceList,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 263
          }
        },
        stacktrace.map(function (frame, ii) {
          return React.createElement(StackRow, {
            frame: frame,
            key: ii,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 264
            }
          });
        })
      );
    }

    return React.createElement(
      View,
      {
        style: styles.inspector,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 270
        }
      },
      React.createElement(
        SafeAreaView,
        {
          style: styles.safeArea,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 271
          }
        },
        React.createElement(
          View,
          {
            style: styles.inspectorCount,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 272
            }
          },
          React.createElement(
            Text,
            {
              style: styles.inspectorCountText,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 273
              }
            },
            countSentence
          ),
          React.createElement(
            TouchableHighlight,
            {
              onPress: toggleStacktrace,
              underlayColor: "transparent",
              __source: {
                fileName: _jsxFileName,
                lineNumber: 274
              }
            },
            React.createElement(
              Text,
              {
                style: styles.inspectorButtonText,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 277
                }
              },
              stacktraceVisible ? "\u25BC" : "\u25B6",
              " Stacktrace"
            )
          )
        ),
        React.createElement(
          ScrollView,
          {
            style: styles.inspectorWarning,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 282
            }
          },
          stacktraceList,
          React.createElement(
            Text,
            {
              style: styles.inspectorWarningText,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 284
              }
            },
            warning
          )
        ),
        React.createElement(
          View,
          {
            style: styles.inspectorButtons,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 286
            }
          },
          React.createElement(
            TouchableHighlight,
            {
              activeOpacity: 0.5,
              onPress: onMinimize,
              style: styles.inspectorButton,
              underlayColor: "transparent",
              __source: {
                fileName: _jsxFileName,
                lineNumber: 287
              }
            },
            React.createElement(
              Text,
              {
                style: styles.inspectorButtonText,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 292
                }
              },
              "Minimize"
            )
          ),
          React.createElement(
            TouchableHighlight,
            {
              activeOpacity: 0.5,
              onPress: onDismiss,
              style: styles.inspectorButton,
              underlayColor: "transparent",
              __source: {
                fileName: _jsxFileName,
                lineNumber: 294
              }
            },
            React.createElement(
              Text,
              {
                style: styles.inspectorButtonText,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 299
                }
              },
              "Dismiss"
            )
          ),
          React.createElement(
            TouchableHighlight,
            {
              activeOpacity: 0.5,
              onPress: onDismissAll,
              style: styles.inspectorButton,
              underlayColor: "transparent",
              __source: {
                fileName: _jsxFileName,
                lineNumber: 301
              }
            },
            React.createElement(
              Text,
              {
                style: styles.inspectorButtonText,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 306
                }
              },
              "Dismiss All"
            )
          )
        )
      )
    );
  };

  var YellowBox = function (_React$Component) {
    babelHelpers.inherits(YellowBox, _React$Component);

    function YellowBox(props, context) {
      babelHelpers.classCallCheck(this, YellowBox);

      var _this = babelHelpers.possibleConstructorReturn(this, (YellowBox.__proto__ || Object.getPrototypeOf(YellowBox)).call(this, props, context));

      _this.state = {
        inspecting: null,
        stacktraceVisible: false,
        warningMap: _warningMap
      };

      _this.dismissWarning = function (warning) {
        var _this$state = _this.state,
            inspecting = _this$state.inspecting,
            warningMap = _this$state.warningMap;

        if (warning) {
          warningMap.delete(warning);
        } else {
          warningMap.clear();
        }

        _this.setState({
          inspecting: warning && inspecting !== warning ? inspecting : null,
          warningMap: warningMap
        });
      };

      return _this;
    }

    babelHelpers.createClass(YellowBox, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        var scheduled = null;
        this._listener = _warningEmitter.addListener('warning', function (warningMap) {
          scheduled = scheduled || setImmediate(function () {
            scheduled = null;

            _this2.setState({
              warningMap: warningMap
            });
          });
        });
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var inspecting = this.state.inspecting;

        if (inspecting != null) {
          ensureSymbolicatedWarning(inspecting);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._listener) {
          this._listener.remove();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        if (console.disableYellowBox || this.state.warningMap.size === 0) {
          return null;
        }

        var ScrollView = require(_dependencyMap[14], 'ScrollView');

        var View = require(_dependencyMap[13], 'View');

        var _state = this.state,
            inspecting = _state.inspecting,
            stacktraceVisible = _state.stacktraceVisible;
        var inspector = inspecting !== null ? React.createElement(WarningInspector, {
          warningInfo: this.state.warningMap.get(inspecting),
          warning: inspecting,
          stacktraceVisible: stacktraceVisible,
          onDismiss: function onDismiss() {
            return _this3.dismissWarning(inspecting);
          },
          onDismissAll: function onDismissAll() {
            return _this3.dismissWarning(null);
          },
          onMinimize: function onMinimize() {
            return _this3.setState({
              inspecting: null
            });
          },
          toggleStacktrace: function toggleStacktrace() {
            return _this3.setState({
              stacktraceVisible: !stacktraceVisible
            });
          },
          __source: {
            fileName: _jsxFileName,
            lineNumber: 393
          }
        }) : null;
        var rows = [];
        this.state.warningMap.forEach(function (warningInfo, warning) {
          if (!isWarningIgnored(warning)) {
            rows.push(React.createElement(WarningRow, {
              key: warning,
              count: warningInfo.count,
              warning: warning,
              onPress: function onPress() {
                return _this3.setState({
                  inspecting: warning
                });
              },
              onDismiss: function onDismiss() {
                return _this3.dismissWarning(warning);
              },
              __source: {
                fileName: _jsxFileName,
                lineNumber: 409
              }
            }));
          }
        });
        var listStyle = [styles.list, {
          height: Math.min(rows.length, 4.4) * (rowGutter + rowHeight)
        }];
        return React.createElement(
          View,
          {
            style: inspector ? styles.fullScreen : listStyle,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 426
            }
          },
          React.createElement(
            ScrollView,
            {
              style: listStyle,
              scrollsToTop: false,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 427
              }
            },
            rows
          ),
          inspector
        );
      }
    }], [{
      key: "ignoreWarnings",
      value: function ignoreWarnings(warnings) {
        warnings.forEach(function (warning) {
          if (IGNORED_WARNINGS.indexOf(warning) === -1) {
            IGNORED_WARNINGS.push(warning);
          }
        });
      }
    }]);
    return YellowBox;
  }(React.Component);

  var backgroundColor = function backgroundColor(opacity) {
    return 'rgba(250, 186, 48, ' + opacity + ')';
  };

  var textColor = 'white';
  var rowGutter = 1;
  var rowHeight = 46;
  var elevation = Platform.OS === 'android' ? Number.MAX_SAFE_INTEGER : undefined;
  var styles = StyleSheet.create({
    fullScreen: {
      height: '100%',
      width: '100%',
      elevation: elevation,
      position: 'absolute'
    },
    inspector: {
      backgroundColor: backgroundColor(0.95),
      height: '100%',
      paddingTop: 5,
      elevation: elevation
    },
    inspectorButtons: {
      flexDirection: 'row'
    },
    inspectorButton: {
      flex: 1,
      paddingVertical: 22,
      backgroundColor: backgroundColor(1)
    },
    safeArea: {
      flex: 1
    },
    stacktraceList: {
      paddingBottom: 5
    },
    inspectorButtonText: {
      color: textColor,
      fontSize: 14,
      opacity: 0.8,
      textAlign: 'center'
    },
    openInEditorButton: {
      paddingTop: 5,
      paddingBottom: 5
    },
    inspectorCount: {
      padding: 15,
      paddingBottom: 0,
      flexDirection: 'row',
      justifyContent: 'space-between'
    },
    inspectorCountText: {
      color: textColor,
      fontSize: 14
    },
    inspectorWarning: {
      flex: 1,
      paddingHorizontal: 15
    },
    inspectorWarningText: {
      color: textColor,
      fontSize: 16,
      fontWeight: '600'
    },
    list: {
      backgroundColor: 'transparent',
      position: 'absolute',
      left: 0,
      right: 0,
      bottom: 0,
      elevation: elevation
    },
    listRow: {
      backgroundColor: backgroundColor(0.95),
      height: rowHeight,
      marginTop: rowGutter
    },
    listRowContent: {
      flex: 1
    },
    listRowCount: {
      color: 'rgba(255, 255, 255, 0.5)'
    },
    listRowText: {
      color: textColor,
      position: 'absolute',
      left: 0,
      top: Platform.OS === 'android' ? 5 : 7,
      marginLeft: 15,
      marginRight: 15
    }
  });
  module.exports = YellowBox;
},319,[118,105,171,320,209,142,145,314,85,92,88,222,312,211,265],"YellowBox");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  module.exports = require(_dependencyMap[0], 'View');
},320,[211],"SafeAreaView");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var I18nManager = require(_dependencyMap[0], 'NativeModules').I18nManager || {
    isRTL: false,
    doLeftAndRightSwapInRTL: true,
    allowRTL: function allowRTL() {},
    forceRTL: function forceRTL() {},
    swapLeftAndRightInRTL: function swapLeftAndRightInRTL() {}
  };
  module.exports = I18nManager;
},321,[68],"I18nManager");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  module.exports = require(_dependencyMap[0], 'UnimplementedView');
},322,[300],"NavigatorIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/Picker/Picker.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var PickerIOS = require(_dependencyMap[1], 'PickerIOS');

  var PickerAndroid = require(_dependencyMap[2], 'PickerAndroid');

  var Platform = require(_dependencyMap[3], 'Platform');

  var React = require(_dependencyMap[4], 'React');

  var PropTypes = require(_dependencyMap[5], 'prop-types');

  var StyleSheetPropType = require(_dependencyMap[6], 'StyleSheetPropType');

  var TextStylePropTypes = require(_dependencyMap[7], 'TextStylePropTypes');

  var UnimplementedView = require(_dependencyMap[8], 'UnimplementedView');

  var ViewPropTypes = require(_dependencyMap[9], 'ViewPropTypes');

  var ViewStylePropTypes = require(_dependencyMap[10], 'ViewStylePropTypes');

  var itemStylePropType = StyleSheetPropType(TextStylePropTypes);
  var pickerStyleType = StyleSheetPropType(babelHelpers.extends({}, ViewStylePropTypes, {
    color: ColorPropType
  }));
  var MODE_DIALOG = 'dialog';
  var MODE_DROPDOWN = 'dropdown';

  var PickerItem = function (_React$Component) {
    babelHelpers.inherits(PickerItem, _React$Component);

    function PickerItem() {
      babelHelpers.classCallCheck(this, PickerItem);
      return babelHelpers.possibleConstructorReturn(this, (PickerItem.__proto__ || Object.getPrototypeOf(PickerItem)).apply(this, arguments));
    }

    babelHelpers.createClass(PickerItem, [{
      key: "render",
      value: function render() {
        throw null;
      }
    }]);
    return PickerItem;
  }(React.Component);

  PickerItem.propTypes = {
    label: PropTypes.string.isRequired,
    value: PropTypes.any,
    color: ColorPropType,
    testID: PropTypes.string
  };

  var Picker = function (_React$Component2) {
    babelHelpers.inherits(Picker, _React$Component2);

    function Picker() {
      babelHelpers.classCallCheck(this, Picker);
      return babelHelpers.possibleConstructorReturn(this, (Picker.__proto__ || Object.getPrototypeOf(Picker)).apply(this, arguments));
    }

    babelHelpers.createClass(Picker, [{
      key: "render",
      value: function render() {
        if (Platform.OS === 'ios') {
          return React.createElement(
            PickerIOS,
            babelHelpers.extends({}, this.props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 157
              }
            }),
            this.props.children
          );
        } else if (Platform.OS === 'android') {
          return React.createElement(
            PickerAndroid,
            babelHelpers.extends({}, this.props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 160
              }
            }),
            this.props.children
          );
        } else {
          return React.createElement(UnimplementedView, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 162
            }
          });
        }
      }
    }]);
    return Picker;
  }(React.Component);

  Picker.MODE_DIALOG = MODE_DIALOG;
  Picker.MODE_DROPDOWN = MODE_DROPDOWN;
  Picker.Item = PickerItem;
  Picker.defaultProps = {
    mode: MODE_DIALOG
  };
  Picker.propTypes = babelHelpers.extends({}, ViewPropTypes, {
    style: pickerStyleType,
    selectedValue: PropTypes.any,
    onValueChange: PropTypes.func,
    enabled: PropTypes.bool,
    mode: PropTypes.oneOf(['dialog', 'dropdown']),
    itemStyle: itemStylePropType,
    prompt: PropTypes.string,
    testID: PropTypes.string
  });
  module.exports = Picker;
},323,[167,324,325,105,171,24,179,192,300,172,180],"Picker");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  module.exports = require(_dependencyMap[0], 'UnimplementedView');
},324,[300],"PickerIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/Picker/PickerAndroid.android.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var React = require(_dependencyMap[1], 'React');

  var ReactPropTypes = require(_dependencyMap[2], 'prop-types');

  var StyleSheet = require(_dependencyMap[3], 'StyleSheet');

  var StyleSheetPropType = require(_dependencyMap[4], 'StyleSheetPropType');

  var ViewPropTypes = require(_dependencyMap[5], 'ViewPropTypes');

  var ViewStylePropTypes = require(_dependencyMap[6], 'ViewStylePropTypes');

  var processColor = require(_dependencyMap[7], 'processColor');

  var requireNativeComponent = require(_dependencyMap[8], 'requireNativeComponent');

  var REF_PICKER = 'picker';
  var MODE_DROPDOWN = 'dropdown';
  var pickerStyleType = StyleSheetPropType(babelHelpers.extends({}, ViewStylePropTypes, {
    color: ColorPropType
  }));

  var PickerAndroid = function (_React$Component) {
    babelHelpers.inherits(PickerAndroid, _React$Component);

    function PickerAndroid(props, context) {
      babelHelpers.classCallCheck(this, PickerAndroid);

      var _this = babelHelpers.possibleConstructorReturn(this, (PickerAndroid.__proto__ || Object.getPrototypeOf(PickerAndroid)).call(this, props, context));

      _initialiseProps.call(_this);

      var state = _this._stateFromProps(props);

      _this.state = babelHelpers.extends({}, state, {
        initialSelectedIndex: state.selectedIndex
      });
      return _this;
    }

    babelHelpers.createClass(PickerAndroid, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        this.setState(this._stateFromProps(nextProps));
      }
    }, {
      key: "render",
      value: function render() {
        var Picker = this.props.mode === MODE_DROPDOWN ? DropdownPicker : DialogPicker;
        var nativeProps = {
          enabled: this.props.enabled,
          items: this.state.items,
          mode: this.props.mode,
          onSelect: this._onChange,
          prompt: this.props.prompt,
          selected: this.state.initialSelectedIndex,
          testID: this.props.testID,
          style: [styles.pickerAndroid, this.props.style],
          accessibilityLabel: this.props.accessibilityLabel
        };
        return React.createElement(Picker, babelHelpers.extends({
          ref: REF_PICKER
        }, nativeProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 107
          }
        }));
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._lastNativePosition = this.state.initialSelectedIndex;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (this.refs[REF_PICKER] && this.state.selectedIndex !== this._lastNativePosition) {
          this.refs[REF_PICKER].setNativeProps({
            selected: this.state.selectedIndex
          });
          this._lastNativePosition = this.state.selectedIndex;
        }
      }
    }]);
    return PickerAndroid;
  }(React.Component);

  PickerAndroid.propTypes = babelHelpers.extends({}, ViewPropTypes, {
    style: pickerStyleType,
    selectedValue: ReactPropTypes.any,
    enabled: ReactPropTypes.bool,
    mode: ReactPropTypes.oneOf(['dialog', 'dropdown']),
    onValueChange: ReactPropTypes.func,
    prompt: ReactPropTypes.string,
    testID: ReactPropTypes.string
  });

  var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this._stateFromProps = function (props) {
      var selectedIndex = 0;
      var items = React.Children.map(props.children, function (child, index) {
        if (child.props.value === props.selectedValue) {
          selectedIndex = index;
        }

        var childProps = {
          value: child.props.value,
          label: child.props.label
        };

        if (child.props.color) {
          childProps.color = processColor(child.props.color);
        }

        return childProps;
      });
      return {
        selectedIndex: selectedIndex,
        items: items
      };
    };

    this._onChange = function (event) {
      if (_this2.props.onValueChange) {
        var position = event.nativeEvent.position;

        if (position >= 0) {
          var children = React.Children.toArray(_this2.props.children);
          var value = children[position].props.value;

          _this2.props.onValueChange(value, position);
        } else {
          _this2.props.onValueChange(null, position);
        }
      }

      _this2._lastNativePosition = event.nativeEvent.position;

      _this2.forceUpdate();
    };
  };

  var styles = StyleSheet.create({
    pickerAndroid: {
      height: 50
    }
  });
  var cfg = {
    nativeOnly: {
      items: true,
      selected: true
    }
  };
  var DropdownPicker = requireNativeComponent('AndroidDropdownPicker', PickerAndroid, cfg);
  var DialogPicker = requireNativeComponent('AndroidDialogPicker', PickerAndroid, cfg);
  module.exports = PickerAndroid;
},325,[167,171,24,209,179,172,180,193,186],"PickerAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/ProgressViewIOS/ProgressViewIOS.android.js";

  var React = require(_dependencyMap[0], 'React');

  var StyleSheet = require(_dependencyMap[1], 'StyleSheet');

  var Text = require(_dependencyMap[2], 'Text');

  var View = require(_dependencyMap[3], 'View');

  var DummyProgressViewIOS = function (_React$Component) {
    babelHelpers.inherits(DummyProgressViewIOS, _React$Component);

    function DummyProgressViewIOS() {
      babelHelpers.classCallCheck(this, DummyProgressViewIOS);
      return babelHelpers.possibleConstructorReturn(this, (DummyProgressViewIOS.__proto__ || Object.getPrototypeOf(DummyProgressViewIOS)).apply(this, arguments));
    }

    babelHelpers.createClass(DummyProgressViewIOS, [{
      key: "render",
      value: function render() {
        return React.createElement(
          View,
          {
            style: [styles.dummy, this.props.style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 23
            }
          },
          React.createElement(
            Text,
            {
              style: styles.text,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 24
              }
            },
            "ProgressViewIOS is not supported on this platform!"
          )
        );
      }
    }]);
    return DummyProgressViewIOS;
  }(React.Component);

  var styles = StyleSheet.create({
    dummy: {
      width: 120,
      height: 20,
      backgroundColor: '#ffbcbc',
      borderWidth: 1,
      borderColor: 'red',
      alignItems: 'center',
      justifyContent: 'center'
    },
    text: {
      color: '#333333',
      margin: 5,
      fontSize: 10
    }
  });
  module.exports = DummyProgressViewIOS;
},326,[171,209,222,211],"ProgressViewIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Lists/SectionList.js";

  var MetroListView = require(_dependencyMap[0], 'MetroListView');

  var Platform = require(_dependencyMap[1], 'Platform');

  var React = require(_dependencyMap[2], 'React');

  var ScrollView = require(_dependencyMap[3], 'ScrollView');

  var VirtualizedSectionList = require(_dependencyMap[4], 'VirtualizedSectionList');

  var defaultProps = babelHelpers.extends({}, VirtualizedSectionList.defaultProps, {
    stickySectionHeadersEnabled: Platform.OS === 'ios'
  });

  var SectionList = function (_React$PureComponent) {
    babelHelpers.inherits(SectionList, _React$PureComponent);

    function SectionList() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, SectionList);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = SectionList.__proto__ || Object.getPrototypeOf(SectionList)).call.apply(_ref, [this].concat(args))), _this), _this._captureRef = function (ref) {
        _this._wrapperListRef = ref;
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(SectionList, [{
      key: "scrollToLocation",
      value: function scrollToLocation(params) {
        this._wrapperListRef.scrollToLocation(params);
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        listRef && listRef.recordInteraction();
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        listRef && listRef.flashScrollIndicators();
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        if (listRef) {
          return listRef.getScrollResponder();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        if (listRef) {
          return listRef.getScrollableNode();
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        if (listRef) {
          listRef.setNativeProps(props);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var List = this.props.legacyImplementation ? MetroListView : VirtualizedSectionList;
        return React.createElement(List, babelHelpers.extends({}, this.props, {
          ref: this._captureRef,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 331
          }
        }));
      }
    }]);
    return SectionList;
  }(React.PureComponent);

  SectionList.defaultProps = defaultProps;
  module.exports = SectionList;
},327,[281,105,171,265,328],"SectionList");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Lists/VirtualizedSectionList.js";

  var React = require(_dependencyMap[0], 'React');

  var View = require(_dependencyMap[1], 'View');

  var VirtualizedList = require(_dependencyMap[2], 'VirtualizedList');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var VirtualizedSectionList = function (_React$PureComponent) {
    babelHelpers.inherits(VirtualizedSectionList, _React$PureComponent);
    babelHelpers.createClass(VirtualizedSectionList, [{
      key: "scrollToLocation",
      value: function scrollToLocation(params) {
        var index = params.itemIndex + 1;

        for (var ii = 0; ii < params.sectionIndex; ii++) {
          index += this.props.sections[ii].data.length + 2;
        }

        var toIndexParams = babelHelpers.extends({}, params, {
          index: index
        });

        this._listRef.scrollToIndex(toIndexParams);
      }
    }, {
      key: "getListRef",
      value: function getListRef() {
        return this._listRef;
      }
    }, {
      key: "_subExtractor",
      value: function _subExtractor(index) {
        var itemIndex = index;
        var defaultKeyExtractor = this.props.keyExtractor;

        for (var ii = 0; ii < this.props.sections.length; ii++) {
          var _section = this.props.sections[ii];

          var _key = _section.key || String(ii);

          itemIndex -= 1;

          if (itemIndex >= _section.data.length + 1) {
            itemIndex -= _section.data.length + 1;
          } else if (itemIndex === -1) {
            return {
              section: _section,
              key: _key + ':header',
              index: null,
              header: true,
              trailingSection: this.props.sections[ii + 1]
            };
          } else if (itemIndex === _section.data.length) {
            return {
              section: _section,
              key: _key + ':footer',
              index: null,
              header: false,
              trailingSection: this.props.sections[ii + 1]
            };
          } else {
            var _keyExtractor = _section.keyExtractor || defaultKeyExtractor;

            return {
              section: _section,
              key: _key + ':' + _keyExtractor(_section.data[itemIndex], itemIndex),
              index: itemIndex,
              leadingItem: _section.data[itemIndex - 1],
              leadingSection: this.props.sections[ii - 1],
              trailingItem: _section.data[itemIndex + 1],
              trailingSection: this.props.sections[ii + 1]
            };
          }
        }
      }
    }, {
      key: "_getSeparatorComponent",
      value: function _getSeparatorComponent(index, info) {
        info = info || this._subExtractor(index);

        if (!info) {
          return null;
        }

        var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
        var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
        var isLastItemInList = index === this.state.childProps.getItemCount() - 1;
        var isLastItemInSection = info.index === info.section.data.length - 1;

        if (SectionSeparatorComponent && isLastItemInSection) {
          return SectionSeparatorComponent;
        }

        if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
          return ItemSeparatorComponent;
        }

        return null;
      }
    }, {
      key: "_computeState",
      value: function _computeState(props) {
        var offset = props.ListHeaderComponent ? 1 : 0;
        var stickyHeaderIndices = [];
        var itemCount = props.sections.reduce(function (v, section) {
          stickyHeaderIndices.push(v + offset);
          return v + section.data.length + 2;
        }, 0);
        return {
          childProps: babelHelpers.extends({}, props, {
            renderItem: this._renderItem,
            ItemSeparatorComponent: undefined,
            data: props.sections,
            getItemCount: function getItemCount() {
              return itemCount;
            },
            getItem: getItem,
            keyExtractor: this._keyExtractor,
            onViewableItemsChanged: props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
            stickyHeaderIndices: props.stickySectionHeadersEnabled ? stickyHeaderIndices : undefined
          })
        };
      }
    }]);

    function VirtualizedSectionList(props, context) {
      babelHelpers.classCallCheck(this, VirtualizedSectionList);

      var _this = babelHelpers.possibleConstructorReturn(this, (VirtualizedSectionList.__proto__ || Object.getPrototypeOf(VirtualizedSectionList)).call(this, props, context));

      _this._keyExtractor = function (item, index) {
        var info = _this._subExtractor(index);

        return info && info.key || String(index);
      };

      _this._convertViewable = function (viewable) {
        invariant(viewable.index != null, 'Received a broken ViewToken');

        var info = _this._subExtractor(viewable.index);

        if (!info) {
          return null;
        }

        var keyExtractor = info.section.keyExtractor || _this.props.keyExtractor;
        return babelHelpers.extends({}, viewable, {
          index: info.index,
          key: keyExtractor(viewable.item, info.index),
          section: info.section
        });
      };

      _this._onViewableItemsChanged = function (_ref) {
        var viewableItems = _ref.viewableItems,
            changed = _ref.changed;

        if (_this.props.onViewableItemsChanged) {
          _this.props.onViewableItemsChanged({
            viewableItems: viewableItems.map(_this._convertViewable, _this).filter(Boolean),
            changed: changed.map(_this._convertViewable, _this).filter(Boolean)
          });
        }
      };

      _this._renderItem = function (_ref2) {
        var item = _ref2.item,
            index = _ref2.index;

        var info = _this._subExtractor(index);

        if (!info) {
          return null;
        }

        var infoIndex = info.index;

        if (infoIndex == null) {
          var _section2 = info.section;

          if (info.header === true) {
            var _renderSectionHeader = _this.props.renderSectionHeader;
            return _renderSectionHeader ? _renderSectionHeader({
              section: _section2
            }) : null;
          } else {
            var _renderSectionFooter = _this.props.renderSectionFooter;
            return _renderSectionFooter ? _renderSectionFooter({
              section: _section2
            }) : null;
          }
        } else {
          var _renderItem = info.section.renderItem || _this.props.renderItem;

          var _SeparatorComponent = _this._getSeparatorComponent(index, info);

          invariant(_renderItem, 'no renderItem!');
          return React.createElement(ItemWithSeparator, {
            SeparatorComponent: _SeparatorComponent,
            LeadingSeparatorComponent: infoIndex === 0 ? _this.props.SectionSeparatorComponent : undefined,
            cellKey: info.key,
            index: infoIndex,
            item: item,
            leadingItem: info.leadingItem,
            leadingSection: info.leadingSection,
            onUpdateSeparator: _this._onUpdateSeparator,
            prevCellKey: (_this._subExtractor(index - 1) || {}).key,
            ref: function ref(_ref3) {
              _this._cellRefs[info.key] = _ref3;
            },
            renderItem: _renderItem,
            section: info.section,
            trailingItem: info.trailingItem,
            trailingSection: info.trailingSection,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 278
            }
          });
        }
      };

      _this._onUpdateSeparator = function (key, newProps) {
        var ref = _this._cellRefs[key];
        ref && ref.updateSeparatorProps(newProps);
      };

      _this._cellRefs = {};

      _this._captureRef = function (ref) {
        _this._listRef = ref;
      };

      _this.state = _this._computeState(props);
      return _this;
    }

    babelHelpers.createClass(VirtualizedSectionList, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        this.setState(this._computeState(nextProps));
      }
    }, {
      key: "render",
      value: function render() {
        return React.createElement(VirtualizedList, babelHelpers.extends({}, this.state.childProps, {
          ref: this._captureRef,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 367
          }
        }));
      }
    }]);
    return VirtualizedSectionList;
  }(React.PureComponent);

  VirtualizedSectionList.defaultProps = babelHelpers.extends({}, VirtualizedList.defaultProps, {
    data: []
  });

  var ItemWithSeparator = function (_React$Component) {
    babelHelpers.inherits(ItemWithSeparator, _React$Component);

    function ItemWithSeparator() {
      var _ref4;

      var _temp, _this2, _ret;

      babelHelpers.classCallCheck(this, ItemWithSeparator);

      for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _ret = (_temp = (_this2 = babelHelpers.possibleConstructorReturn(this, (_ref4 = ItemWithSeparator.__proto__ || Object.getPrototypeOf(ItemWithSeparator)).call.apply(_ref4, [this].concat(args))), _this2), _this2.state = {
        separatorProps: {
          highlighted: false,
          leadingItem: _this2.props.item,
          leadingSection: _this2.props.leadingSection,
          section: _this2.props.section,
          trailingItem: _this2.props.trailingItem,
          trailingSection: _this2.props.trailingSection
        },
        leadingSeparatorProps: {
          highlighted: false,
          leadingItem: _this2.props.leadingItem,
          leadingSection: _this2.props.leadingSection,
          section: _this2.props.section,
          trailingItem: _this2.props.item,
          trailingSection: _this2.props.trailingSection
        }
      }, _this2._separators = {
        highlight: function highlight() {
          ['leading', 'trailing'].forEach(function (s) {
            return _this2._separators.updateProps(s, {
              highlighted: true
            });
          });
        },
        unhighlight: function unhighlight() {
          ['leading', 'trailing'].forEach(function (s) {
            return _this2._separators.updateProps(s, {
              highlighted: false
            });
          });
        },
        updateProps: function updateProps(select, newProps) {
          var _this2$props = _this2.props,
              LeadingSeparatorComponent = _this2$props.LeadingSeparatorComponent,
              cellKey = _this2$props.cellKey,
              prevCellKey = _this2$props.prevCellKey;

          if (select === 'leading' && LeadingSeparatorComponent) {
            _this2.setState(function (state) {
              return {
                leadingSeparatorProps: babelHelpers.extends({}, state.leadingSeparatorProps, newProps)
              };
            });
          } else {
            _this2.props.onUpdateSeparator(select === 'leading' && prevCellKey || cellKey, newProps);
          }
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this2, _ret);
    }

    babelHelpers.createClass(ItemWithSeparator, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(props) {
        var _this3 = this;

        this.setState(function (state) {
          return {
            separatorProps: babelHelpers.extends({}, _this3.state.separatorProps, {
              leadingItem: props.item,
              leadingSection: props.leadingSection,
              section: props.section,
              trailingItem: props.trailingItem,
              trailingSection: props.trailingSection
            }),
            leadingSeparatorProps: babelHelpers.extends({}, _this3.state.leadingSeparatorProps, {
              leadingItem: props.leadingItem,
              leadingSection: props.leadingSection,
              section: props.section,
              trailingItem: props.item,
              trailingSection: props.trailingSection
            })
          };
        });
      }
    }, {
      key: "updateSeparatorProps",
      value: function updateSeparatorProps(newProps) {
        this.setState(function (state) {
          return {
            separatorProps: babelHelpers.extends({}, state.separatorProps, newProps)
          };
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            LeadingSeparatorComponent = _props.LeadingSeparatorComponent,
            SeparatorComponent = _props.SeparatorComponent,
            item = _props.item,
            index = _props.index,
            section = _props.section;
        var element = this.props.renderItem({
          item: item,
          index: index,
          section: section,
          separators: this._separators
        });
        var leadingSeparator = LeadingSeparatorComponent && React.createElement(LeadingSeparatorComponent, babelHelpers.extends({}, this.state.leadingSeparatorProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 488
          }
        }));
        var separator = SeparatorComponent && React.createElement(SeparatorComponent, babelHelpers.extends({}, this.state.separatorProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 491
          }
        }));
        return leadingSeparator || separator ? React.createElement(
          View,
          {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 494
            }
          },
          leadingSeparator,
          element,
          separator
        ) : element;
      }
    }]);
    return ItemWithSeparator;
  }(React.Component);

  function getItem(sections, index) {
    if (!sections) {
      return null;
    }

    var itemIdx = index - 1;

    for (var ii = 0; ii < sections.length; ii++) {
      if (itemIdx === -1 || itemIdx === sections[ii].data.length) {
        return sections[ii];
      } else if (itemIdx < sections[ii].data.length) {
        return sections[ii].data[itemIdx];
      } else {
        itemIdx -= sections[ii].data.length + 2;
      }
    }

    return null;
  }

  module.exports = VirtualizedSectionList;
},328,[171,211,288,18],"VirtualizedSectionList");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/SegmentedControlIOS/SegmentedControlIOS.android.js";

  var React = require(_dependencyMap[0], 'React');

  var StyleSheet = require(_dependencyMap[1], 'StyleSheet');

  var Text = require(_dependencyMap[2], 'Text');

  var View = require(_dependencyMap[3], 'View');

  var DummySegmentedControlIOS = function (_React$Component) {
    babelHelpers.inherits(DummySegmentedControlIOS, _React$Component);

    function DummySegmentedControlIOS() {
      babelHelpers.classCallCheck(this, DummySegmentedControlIOS);
      return babelHelpers.possibleConstructorReturn(this, (DummySegmentedControlIOS.__proto__ || Object.getPrototypeOf(DummySegmentedControlIOS)).apply(this, arguments));
    }

    babelHelpers.createClass(DummySegmentedControlIOS, [{
      key: "render",
      value: function render() {
        return React.createElement(
          View,
          {
            style: [styles.dummy, this.props.style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 23
            }
          },
          React.createElement(
            Text,
            {
              style: styles.text,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 24
              }
            },
            "SegmentedControlIOS is not supported on this platform!"
          )
        );
      }
    }]);
    return DummySegmentedControlIOS;
  }(React.Component);

  var styles = StyleSheet.create({
    dummy: {
      width: 120,
      height: 50,
      backgroundColor: '#ffbcbc',
      borderWidth: 1,
      borderColor: 'red',
      alignItems: 'center',
      justifyContent: 'center'
    },
    text: {
      color: '#333333',
      margin: 5,
      fontSize: 10
    }
  });
  module.exports = DummySegmentedControlIOS;
},329,[171,209,222,211],"SegmentedControlIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/Slider/Slider.js";

  var Image = require(_dependencyMap[0], 'Image');

  var ColorPropType = require(_dependencyMap[1], 'ColorPropType');

  var NativeMethodsMixin = require(_dependencyMap[2], 'NativeMethodsMixin');

  var ReactNativeViewAttributes = require(_dependencyMap[3], 'ReactNativeViewAttributes');

  var Platform = require(_dependencyMap[4], 'Platform');

  var React = require(_dependencyMap[5], 'React');

  var PropTypes = require(_dependencyMap[6], 'prop-types');

  var StyleSheet = require(_dependencyMap[7], 'StyleSheet');

  var ViewPropTypes = require(_dependencyMap[8], 'ViewPropTypes');

  var createReactClass = require(_dependencyMap[9], 'create-react-class');

  var requireNativeComponent = require(_dependencyMap[10], 'requireNativeComponent');

  var Slider = createReactClass({
    displayName: 'Slider',
    mixins: [NativeMethodsMixin],
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      style: ViewPropTypes.style,
      value: PropTypes.number,
      step: PropTypes.number,
      minimumValue: PropTypes.number,
      maximumValue: PropTypes.number,
      minimumTrackTintColor: ColorPropType,
      maximumTrackTintColor: ColorPropType,
      disabled: PropTypes.bool,
      trackImage: Image.propTypes.source,
      minimumTrackImage: Image.propTypes.source,
      maximumTrackImage: Image.propTypes.source,
      thumbImage: Image.propTypes.source,
      thumbTintColor: ColorPropType,
      onValueChange: PropTypes.func,
      onSlidingComplete: PropTypes.func,
      testID: PropTypes.string
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        disabled: false,
        value: 0,
        minimumValue: 0,
        maximumValue: 1,
        step: 0
      };
    },
    viewConfig: {
      uiViewClassName: 'RCTSlider',
      validAttributes: babelHelpers.extends({}, ReactNativeViewAttributes.RCTView, {
        value: true
      })
    },
    render: function render() {
      var _props = this.props,
          style = _props.style,
          onValueChange = _props.onValueChange,
          onSlidingComplete = _props.onSlidingComplete,
          props = babelHelpers.objectWithoutProperties(_props, ["style", "onValueChange", "onSlidingComplete"]);
      props.style = [styles.slider, style];

      props.onValueChange = onValueChange && function (event) {
        var userEvent = true;

        if (Platform.OS === 'android') {
          userEvent = event.nativeEvent.fromUser;
        }

        onValueChange && userEvent && onValueChange(event.nativeEvent.value);
      };

      props.onChange = props.onValueChange;

      props.onSlidingComplete = onSlidingComplete && function (event) {
        onSlidingComplete && onSlidingComplete(event.nativeEvent.value);
      };

      return React.createElement(RCTSlider, babelHelpers.extends({}, props, {
        enabled: !this.props.disabled,
        onStartShouldSetResponder: function onStartShouldSetResponder() {
          return true;
        },
        onResponderTerminationRequest: function onResponderTerminationRequest() {
          return false;
        },
        __source: {
          fileName: _jsxFileName,
          lineNumber: 248
        }
      }));
    }
  });
  var styles = void 0;

  if (Platform.OS === 'ios') {
    styles = StyleSheet.create({
      slider: {
        height: 40
      }
    });
  } else {
    styles = StyleSheet.create({
      slider: {}
    });
  }

  var options = {};

  if (Platform.OS === 'android') {
    options = {
      nativeOnly: {
        enabled: true
      }
    };
  }

  var RCTSlider = requireNativeComponent('RCTSlider', Slider, options);
  module.exports = Slider;
},330,[263,167,169,212,105,171,24,209,172,213,186],"Slider");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  module.exports = require(_dependencyMap[0], 'UnimplementedView');
},331,[300],"SnapshotViewIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/Switch/Switch.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var NativeMethodsMixin = require(_dependencyMap[1], 'NativeMethodsMixin');

  var Platform = require(_dependencyMap[2], 'Platform');

  var React = require(_dependencyMap[3], 'React');

  var PropTypes = require(_dependencyMap[4], 'prop-types');

  var StyleSheet = require(_dependencyMap[5], 'StyleSheet');

  var ViewPropTypes = require(_dependencyMap[6], 'ViewPropTypes');

  var createReactClass = require(_dependencyMap[7], 'create-react-class');

  var requireNativeComponent = require(_dependencyMap[8], 'requireNativeComponent');

  var Switch = createReactClass({
    displayName: 'Switch',
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      value: PropTypes.bool,
      disabled: PropTypes.bool,
      onValueChange: PropTypes.func,
      testID: PropTypes.string,
      tintColor: ColorPropType,
      onTintColor: ColorPropType,
      thumbTintColor: ColorPropType
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        value: false,
        disabled: false
      };
    },
    mixins: [NativeMethodsMixin],
    _rctSwitch: {},
    _onChange: function _onChange(event) {
      if (Platform.OS === 'android') {
        this._rctSwitch.setNativeProps({
          on: this.props.value
        });
      } else {
        this._rctSwitch.setNativeProps({
          value: this.props.value
        });
      }

      this.props.onChange && this.props.onChange(event);
      this.props.onValueChange && this.props.onValueChange(event.nativeEvent.value);
    },
    render: function render() {
      var _this = this;

      var props = babelHelpers.extends({}, this.props);

      props.onStartShouldSetResponder = function () {
        return true;
      };

      props.onResponderTerminationRequest = function () {
        return false;
      };

      if (Platform.OS === 'android') {
        props.enabled = !this.props.disabled;
        props.on = this.props.value;
        props.style = this.props.style;
        props.trackTintColor = this.props.value ? this.props.onTintColor : this.props.tintColor;
      } else if (Platform.OS === 'ios') {
        props.style = [styles.rctSwitchIOS, this.props.style];
      }

      return React.createElement(RCTSwitch, babelHelpers.extends({}, props, {
        ref: function ref(_ref) {
          _this._rctSwitch = _ref;
        },
        onChange: this._onChange,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 115
        }
      }));
    }
  });
  var styles = StyleSheet.create({
    rctSwitchIOS: {
      height: 31,
      width: 51
    }
  });

  if (Platform.OS === 'android') {
    var RCTSwitch = requireNativeComponent('AndroidSwitch', Switch, {
      nativeOnly: {
        onChange: true,
        on: true,
        enabled: true,
        trackTintColor: true
      }
    });
  } else {
    var RCTSwitch = requireNativeComponent('RCTSwitch', Switch, {
      nativeOnly: {
        onChange: true
      }
    });
  }

  module.exports = Switch;
},332,[167,169,105,171,24,209,172,213,186],"Switch");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Experimental/SwipeableRow/SwipeableFlatList.js";

  var PropTypes = require(_dependencyMap[0], 'prop-types');

  var React = require(_dependencyMap[1], 'React');

  var SwipeableRow = require(_dependencyMap[2], 'SwipeableRow');

  var FlatList = require(_dependencyMap[3], 'FlatList');

  var SwipeableFlatList = function (_React$Component) {
    babelHelpers.inherits(SwipeableFlatList, _React$Component);

    function SwipeableFlatList(props, context) {
      babelHelpers.classCallCheck(this, SwipeableFlatList);

      var _this = babelHelpers.possibleConstructorReturn(this, (SwipeableFlatList.__proto__ || Object.getPrototypeOf(SwipeableFlatList)).call(this, props, context));

      _this._flatListRef = null;
      _this._shouldBounceFirstRowOnMount = false;

      _this._onScroll = function (e) {
        if (_this.state.openRowKey) {
          _this.setState({
            openRowKey: null
          });
        }

        _this.props.onScroll && _this.props.onScroll(e);
      };

      _this._renderItem = function (info) {
        var slideoutView = _this.props.renderQuickActions(info);

        var key = _this.props.keyExtractor(info.item, info.index);

        if (!slideoutView) {
          return _this.props.renderItem(info);
        }

        var shouldBounceOnMount = false;

        if (_this._shouldBounceFirstRowOnMount) {
          _this._shouldBounceFirstRowOnMount = false;
          shouldBounceOnMount = true;
        }

        return React.createElement(
          SwipeableRow,
          {
            slideoutView: slideoutView,
            isOpen: key === _this.state.openRowKey,
            maxSwipeDistance: _this._getMaxSwipeDistance(info),
            onOpen: function onOpen() {
              return _this._onOpen(key);
            },
            onClose: function onClose() {
              return _this._onClose(key);
            },
            shouldBounceOnMount: shouldBounceOnMount,
            onSwipeEnd: _this._setListViewScrollable,
            onSwipeStart: _this._setListViewNotScrollable,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 137
            }
          },
          _this.props.renderItem(info)
        );
      };

      _this._setListViewScrollable = function () {
        _this._setListViewScrollableTo(true);
      };

      _this._setListViewNotScrollable = function () {
        _this._setListViewScrollableTo(false);
      };

      _this.state = {
        openRowKey: null
      };
      _this._shouldBounceFirstRowOnMount = _this.props.bounceFirstRowOnMount;
      return _this;
    }

    babelHelpers.createClass(SwipeableFlatList, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        return React.createElement(FlatList, babelHelpers.extends({}, this.props, {
          ref: function ref(_ref) {
            _this2._flatListRef = _ref;
          },
          onScroll: this._onScroll,
          renderItem: this._renderItem,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 99
          }
        }));
      }
    }, {
      key: "_getMaxSwipeDistance",
      value: function _getMaxSwipeDistance(info) {
        if (typeof this.props.maxSwipeDistance === 'function') {
          return this.props.maxSwipeDistance(info);
        }

        return this.props.maxSwipeDistance;
      }
    }, {
      key: "_setListViewScrollableTo",
      value: function _setListViewScrollableTo(value) {
        if (this._flatListRef) {
          this._flatListRef.setNativeProps({
            scrollEnabled: value
          });
        }
      }
    }, {
      key: "_onOpen",
      value: function _onOpen(key) {
        this.setState({
          openRowKey: key
        });
      }
    }, {
      key: "_onClose",
      value: function _onClose(key) {
        this.setState({
          openRowKey: null
        });
      }
    }]);
    return SwipeableFlatList;
  }(React.Component);

  SwipeableFlatList.propTypes = babelHelpers.extends({}, FlatList.propTypes, {
    bounceFirstRowOnMount: PropTypes.bool.isRequired,
    maxSwipeDistance: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,
    renderQuickActions: PropTypes.func.isRequired
  });
  SwipeableFlatList.defaultProps = babelHelpers.extends({}, FlatList.defaultProps, {
    bounceFirstRowOnMount: true,
    renderQuickActions: function renderQuickActions() {
      return null;
    }
  });
  module.exports = SwipeableFlatList;
},333,[24,171,334,280],"SwipeableFlatList");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Experimental/SwipeableRow/SwipeableRow.js";

  var Animated = require(_dependencyMap[0], 'Animated');

  var I18nManager = require(_dependencyMap[1], 'I18nManager');

  var PanResponder = require(_dependencyMap[2], 'PanResponder');

  var React = require(_dependencyMap[3], 'React');

  var PropTypes = require(_dependencyMap[4], 'prop-types');

  var StyleSheet = require(_dependencyMap[5], 'StyleSheet');

  var TimerMixin = require(_dependencyMap[6], 'react-timer-mixin');

  var View = require(_dependencyMap[7], 'View');

  var createReactClass = require(_dependencyMap[8], 'create-react-class');

  var emptyFunction = require(_dependencyMap[9], 'fbjs/lib/emptyFunction');

  var IS_RTL = I18nManager.isRTL;
  var CLOSED_LEFT_POSITION = 0;
  var HORIZONTAL_SWIPE_DISTANCE_THRESHOLD = 10;
  var HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD = 0.3;
  var SLOW_SPEED_SWIPE_FACTOR = 4;
  var SWIPE_DURATION = 300;
  var ON_MOUNT_BOUNCE_DELAY = 700;
  var ON_MOUNT_BOUNCE_DURATION = 400;
  var RIGHT_SWIPE_BOUNCE_BACK_DISTANCE = 30;
  var RIGHT_SWIPE_BOUNCE_BACK_DURATION = 300;
  var RIGHT_SWIPE_THRESHOLD = 30 * SLOW_SPEED_SWIPE_FACTOR;
  var SwipeableRow = createReactClass({
    displayName: 'SwipeableRow',
    _panResponder: {},
    _previousLeft: CLOSED_LEFT_POSITION,
    mixins: [TimerMixin],
    propTypes: {
      children: PropTypes.any,
      isOpen: PropTypes.bool,
      preventSwipeRight: PropTypes.bool,
      maxSwipeDistance: PropTypes.number.isRequired,
      onOpen: PropTypes.func.isRequired,
      onClose: PropTypes.func.isRequired,
      onSwipeEnd: PropTypes.func.isRequired,
      onSwipeStart: PropTypes.func.isRequired,
      shouldBounceOnMount: PropTypes.bool,
      slideoutView: PropTypes.node.isRequired,
      swipeThreshold: PropTypes.number.isRequired
    },
    getInitialState: function getInitialState() {
      return {
        currentLeft: new Animated.Value(this._previousLeft),
        isSwipeableViewRendered: false,
        rowHeight: null
      };
    },
    getDefaultProps: function getDefaultProps() {
      return {
        isOpen: false,
        preventSwipeRight: false,
        maxSwipeDistance: 0,
        onOpen: emptyFunction,
        onClose: emptyFunction,
        onSwipeEnd: emptyFunction,
        onSwipeStart: emptyFunction,
        swipeThreshold: 30
      };
    },
    componentWillMount: function componentWillMount() {
      this._panResponder = PanResponder.create({
        onMoveShouldSetPanResponderCapture: this._handleMoveShouldSetPanResponderCapture,
        onPanResponderGrant: this._handlePanResponderGrant,
        onPanResponderMove: this._handlePanResponderMove,
        onPanResponderRelease: this._handlePanResponderEnd,
        onPanResponderTerminationRequest: this._onPanResponderTerminationRequest,
        onPanResponderTerminate: this._handlePanResponderEnd,
        onShouldBlockNativeResponder: function onShouldBlockNativeResponder(event, gestureState) {
          return false;
        }
      });
    },
    componentDidMount: function componentDidMount() {
      var _this = this;

      if (this.props.shouldBounceOnMount) {
        this.setTimeout(function () {
          _this._animateBounceBack(ON_MOUNT_BOUNCE_DURATION);
        }, ON_MOUNT_BOUNCE_DELAY);
      }
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      if (this.props.isOpen && !nextProps.isOpen) {
        this._animateToClosedPosition();
      }
    },
    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
      if (this.props.shouldBounceOnMount && !nextProps.shouldBounceOnMount) {
        return false;
      }

      return true;
    },
    render: function render() {
      var slideOutView = void 0;

      if (this.state.isSwipeableViewRendered && this.state.rowHeight) {
        slideOutView = React.createElement(
          View,
          {
            style: [styles.slideOutContainer, {
              height: this.state.rowHeight
            }],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 176
            }
          },
          this.props.slideoutView
        );
      }

      var swipeableView = React.createElement(
        Animated.View,
        {
          onLayout: this._onSwipeableViewLayout,
          style: {
            transform: [{
              translateX: this.state.currentLeft
            }]
          },
          __source: {
            fileName: _jsxFileName,
            lineNumber: 187
          }
        },
        this.props.children
      );
      return React.createElement(
        View,
        babelHelpers.extends({}, this._panResponder.panHandlers, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 195
          }
        }),
        slideOutView,
        swipeableView
      );
    },
    close: function close() {
      this.props.onClose();

      this._animateToClosedPosition();
    },
    _onSwipeableViewLayout: function _onSwipeableViewLayout(event) {
      this.setState({
        isSwipeableViewRendered: true,
        rowHeight: event.nativeEvent.layout.height
      });
    },
    _handleMoveShouldSetPanResponderCapture: function _handleMoveShouldSetPanResponderCapture(event, gestureState) {
      return gestureState.dy < 10 && this._isValidSwipe(gestureState);
    },
    _handlePanResponderGrant: function _handlePanResponderGrant(event, gestureState) {},
    _handlePanResponderMove: function _handlePanResponderMove(event, gestureState) {
      if (this._isSwipingExcessivelyRightFromClosedPosition(gestureState)) {
        return;
      }

      this.props.onSwipeStart();

      if (this._isSwipingRightFromClosed(gestureState)) {
        this._swipeSlowSpeed(gestureState);
      } else {
        this._swipeFullSpeed(gestureState);
      }
    },
    _isSwipingRightFromClosed: function _isSwipingRightFromClosed(gestureState) {
      var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;
      return this._previousLeft === CLOSED_LEFT_POSITION && gestureStateDx > 0;
    },
    _swipeFullSpeed: function _swipeFullSpeed(gestureState) {
      this.state.currentLeft.setValue(this._previousLeft + gestureState.dx);
    },
    _swipeSlowSpeed: function _swipeSlowSpeed(gestureState) {
      this.state.currentLeft.setValue(this._previousLeft + gestureState.dx / SLOW_SPEED_SWIPE_FACTOR);
    },
    _isSwipingExcessivelyRightFromClosedPosition: function _isSwipingExcessivelyRightFromClosedPosition(gestureState) {
      var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;
      return this._isSwipingRightFromClosed(gestureState) && gestureStateDx > RIGHT_SWIPE_THRESHOLD;
    },
    _onPanResponderTerminationRequest: function _onPanResponderTerminationRequest(event, gestureState) {
      return false;
    },
    _animateTo: function _animateTo(toValue) {
      var _this2 = this;

      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SWIPE_DURATION;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : emptyFunction;
      Animated.timing(this.state.currentLeft, {
        duration: duration,
        toValue: toValue,
        useNativeDriver: true
      }).start(function () {
        _this2._previousLeft = toValue;
        callback();
      });
    },
    _animateToOpenPosition: function _animateToOpenPosition() {
      var maxSwipeDistance = IS_RTL ? -this.props.maxSwipeDistance : this.props.maxSwipeDistance;

      this._animateTo(-maxSwipeDistance);
    },
    _animateToOpenPositionWith: function _animateToOpenPositionWith(speed, distMoved) {
      speed = speed > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD ? speed : HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;
      var duration = Math.abs((this.props.maxSwipeDistance - Math.abs(distMoved)) / speed);
      var maxSwipeDistance = IS_RTL ? -this.props.maxSwipeDistance : this.props.maxSwipeDistance;

      this._animateTo(-maxSwipeDistance, duration);
    },
    _animateToClosedPosition: function _animateToClosedPosition() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SWIPE_DURATION;

      this._animateTo(CLOSED_LEFT_POSITION, duration);
    },
    _animateToClosedPositionDuringBounce: function _animateToClosedPositionDuringBounce() {
      this._animateToClosedPosition(RIGHT_SWIPE_BOUNCE_BACK_DURATION);
    },
    _animateBounceBack: function _animateBounceBack(duration) {
      var swipeBounceBackDistance = IS_RTL ? -RIGHT_SWIPE_BOUNCE_BACK_DISTANCE : RIGHT_SWIPE_BOUNCE_BACK_DISTANCE;

      this._animateTo(-swipeBounceBackDistance, duration, this._animateToClosedPositionDuringBounce);
    },
    _isValidSwipe: function _isValidSwipe(gestureState) {
      if (this.props.preventSwipeRight && this._previousLeft === CLOSED_LEFT_POSITION && gestureState.dx > 0) {
        return false;
      }

      return Math.abs(gestureState.dx) > HORIZONTAL_SWIPE_DISTANCE_THRESHOLD;
    },
    _shouldAnimateRemainder: function _shouldAnimateRemainder(gestureState) {
      return Math.abs(gestureState.dx) > this.props.swipeThreshold || gestureState.vx > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;
    },
    _handlePanResponderEnd: function _handlePanResponderEnd(event, gestureState) {
      var horizontalDistance = IS_RTL ? -gestureState.dx : gestureState.dx;

      if (this._isSwipingRightFromClosed(gestureState)) {
        this.props.onOpen();

        this._animateBounceBack(RIGHT_SWIPE_BOUNCE_BACK_DURATION);
      } else if (this._shouldAnimateRemainder(gestureState)) {
        if (horizontalDistance < 0) {
          this.props.onOpen();

          this._animateToOpenPositionWith(gestureState.vx, horizontalDistance);
        } else {
          this.props.onClose();

          this._animateToClosedPosition();
        }
      } else {
        if (this._previousLeft === CLOSED_LEFT_POSITION) {
          this._animateToClosedPosition();
        } else {
          this._animateToOpenPosition();
        }
      }

      this.props.onSwipeEnd();
    }
  });
  var styles = StyleSheet.create({
    slideOutContainer: {
      bottom: 0,
      left: 0,
      position: 'absolute',
      right: 0,
      top: 0
    }
  });
  module.exports = SwipeableRow;
},334,[235,321,335,171,24,209,232,211,213,16],"SwipeableRow");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var InteractionManager = require(_dependencyMap[0], './InteractionManager');

  var TouchHistoryMath = require(_dependencyMap[1], 'TouchHistoryMath');

  var currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter;
  var currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter;
  var previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter;
  var previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;
  var currentCentroidX = TouchHistoryMath.currentCentroidX;
  var currentCentroidY = TouchHistoryMath.currentCentroidY;
  var PanResponder = {
    _initializeGestureState: function _initializeGestureState(gestureState) {
      gestureState.moveX = 0;
      gestureState.moveY = 0;
      gestureState.x0 = 0;
      gestureState.y0 = 0;
      gestureState.dx = 0;
      gestureState.dy = 0;
      gestureState.vx = 0;
      gestureState.vy = 0;
      gestureState.numberActiveTouches = 0;
      gestureState._accountsForMovesUpTo = 0;
    },
    _updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {
      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
      gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      var movedAfter = gestureState._accountsForMovesUpTo;
      var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var nextDX = gestureState.dx + (x - prevX);
      var nextDY = gestureState.dy + (y - prevY);
      var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
      gestureState.vx = (nextDX - gestureState.dx) / dt;
      gestureState.vy = (nextDY - gestureState.dy) / dt;
      gestureState.dx = nextDX;
      gestureState.dy = nextDY;
      gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
    },
    create: function create(config) {
      var interactionState = {
        handle: null
      };
      var gestureState = {
        stateID: Math.random()
      };

      PanResponder._initializeGestureState(gestureState);

      var panHandlers = {
        onStartShouldSetResponder: function onStartShouldSetResponder(e) {
          return config.onStartShouldSetPanResponder === undefined ? false : config.onStartShouldSetPanResponder(e, gestureState);
        },
        onMoveShouldSetResponder: function onMoveShouldSetResponder(e) {
          return config.onMoveShouldSetPanResponder === undefined ? false : config.onMoveShouldSetPanResponder(e, gestureState);
        },
        onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(e) {
          if (e.nativeEvent.touches.length === 1) {
            PanResponder._initializeGestureState(gestureState);
          }

          gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;
          return config.onStartShouldSetPanResponderCapture !== undefined ? config.onStartShouldSetPanResponderCapture(e, gestureState) : false;
        },
        onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(e) {
          var touchHistory = e.touchHistory;

          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return false;
          }

          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);

          return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(e, gestureState) : false;
        },
        onResponderGrant: function onResponderGrant(e) {
          if (!interactionState.handle) {
            interactionState.handle = InteractionManager.createInteractionHandle();
          }

          gestureState.x0 = currentCentroidX(e.touchHistory);
          gestureState.y0 = currentCentroidY(e.touchHistory);
          gestureState.dx = 0;
          gestureState.dy = 0;

          if (config.onPanResponderGrant) {
            config.onPanResponderGrant(e, gestureState);
          }

          return config.onShouldBlockNativeResponder === undefined ? true : config.onShouldBlockNativeResponder();
        },
        onResponderReject: function onResponderReject(e) {
          clearInteractionHandle(interactionState, config.onPanResponderReject, e, gestureState);
        },
        onResponderRelease: function onResponderRelease(e) {
          clearInteractionHandle(interactionState, config.onPanResponderRelease, e, gestureState);

          PanResponder._initializeGestureState(gestureState);
        },
        onResponderStart: function onResponderStart(e) {
          var touchHistory = e.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;

          if (config.onPanResponderStart) {
            config.onPanResponderStart(e, gestureState);
          }
        },
        onResponderMove: function onResponderMove(e) {
          var touchHistory = e.touchHistory;

          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return;
          }

          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);

          if (config.onPanResponderMove) {
            config.onPanResponderMove(e, gestureState);
          }
        },
        onResponderEnd: function onResponderEnd(e) {
          var touchHistory = e.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
          clearInteractionHandle(interactionState, config.onPanResponderEnd, e, gestureState);
        },
        onResponderTerminate: function onResponderTerminate(e) {
          clearInteractionHandle(interactionState, config.onPanResponderTerminate, e, gestureState);

          PanResponder._initializeGestureState(gestureState);
        },
        onResponderTerminationRequest: function onResponderTerminationRequest(e) {
          return config.onPanResponderTerminationRequest === undefined ? true : config.onPanResponderTerminationRequest(e, gestureState);
        }
      };
      return {
        panHandlers: panHandlers,
        getInteractionHandle: function getInteractionHandle() {
          return interactionState.handle;
        }
      };
    }
  };

  function clearInteractionHandle(interactionState, callback, event, gestureState) {
    if (interactionState.handle) {
      InteractionManager.clearInteractionHandle(interactionState.handle);
      interactionState.handle = null;
    }

    if (callback) {
      callback(event, gestureState);
    }
  }

  module.exports = PanResponder;
},335,[243,336],"PanResponder");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'ReactNative'),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  module.exports = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.TouchHistoryMath;
},336,[74],"TouchHistoryMath");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Experimental/SwipeableRow/SwipeableListView.js";

  var ListView = require(_dependencyMap[0], 'ListView');

  var PropTypes = require(_dependencyMap[1], 'prop-types');

  var React = require(_dependencyMap[2], 'React');

  var SwipeableListViewDataSource = require(_dependencyMap[3], 'SwipeableListViewDataSource');

  var SwipeableRow = require(_dependencyMap[4], 'SwipeableRow');

  var SwipeableListView = function (_React$Component) {
    babelHelpers.inherits(SwipeableListView, _React$Component);
    babelHelpers.createClass(SwipeableListView, null, [{
      key: "getNewDataSource",
      value: function getNewDataSource() {
        return new SwipeableListViewDataSource({
          getRowData: function getRowData(data, sectionID, rowID) {
            return data[sectionID][rowID];
          },
          getSectionHeaderData: function getSectionHeaderData(data, sectionID) {
            return data[sectionID];
          },
          rowHasChanged: function rowHasChanged(row1, row2) {
            return row1 !== row2;
          },
          sectionHeaderHasChanged: function sectionHeaderHasChanged(s1, s2) {
            return s1 !== s2;
          }
        });
      }
    }]);

    function SwipeableListView(props, context) {
      babelHelpers.classCallCheck(this, SwipeableListView);

      var _this = babelHelpers.possibleConstructorReturn(this, (SwipeableListView.__proto__ || Object.getPrototypeOf(SwipeableListView)).call(this, props, context));

      _this._listViewRef = null;
      _this._shouldBounceFirstRowOnMount = false;

      _this._onScroll = function (e) {
        if (_this.props.dataSource.getOpenRowID()) {
          _this.setState({
            dataSource: _this.state.dataSource.setOpenRowID(null)
          });
        }

        _this.props.onScroll && _this.props.onScroll(e);
      };

      _this._renderRow = function (rowData, sectionID, rowID) {
        var slideoutView = _this.props.renderQuickActions(rowData, sectionID, rowID);

        if (!slideoutView) {
          return _this.props.renderRow(rowData, sectionID, rowID);
        }

        var shouldBounceOnMount = false;

        if (_this._shouldBounceFirstRowOnMount) {
          _this._shouldBounceFirstRowOnMount = false;
          shouldBounceOnMount = rowID === _this.props.dataSource.getFirstRowID();
        }

        return React.createElement(
          SwipeableRow,
          {
            slideoutView: slideoutView,
            isOpen: rowData.id === _this.props.dataSource.getOpenRowID(),
            maxSwipeDistance: _this._getMaxSwipeDistance(rowData, sectionID, rowID),
            key: rowID,
            onOpen: function onOpen() {
              return _this._onOpen(rowData.id);
            },
            onClose: function onClose() {
              return _this._onClose(rowData.id);
            },
            onSwipeEnd: function onSwipeEnd() {
              return _this._setListViewScrollable(true);
            },
            onSwipeStart: function onSwipeStart() {
              return _this._setListViewScrollable(false);
            },
            shouldBounceOnMount: shouldBounceOnMount,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 185
            }
          },
          _this.props.renderRow(rowData, sectionID, rowID)
        );
      };

      _this._shouldBounceFirstRowOnMount = _this.props.bounceFirstRowOnMount;
      _this.state = {
        dataSource: _this.props.dataSource
      };
      return _this;
    }

    babelHelpers.createClass(SwipeableListView, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (this.state.dataSource.getDataSource() !== nextProps.dataSource.getDataSource()) {
          this.setState({
            dataSource: nextProps.dataSource
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        return React.createElement(ListView, babelHelpers.extends({}, this.props, {
          ref: function ref(_ref) {
            _this2._listViewRef = _ref;
          },
          dataSource: this.state.dataSource.getDataSource(),
          onScroll: this._onScroll,
          renderRow: this._renderRow,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 118
          }
        }));
      }
    }, {
      key: "_setListViewScrollable",
      value: function _setListViewScrollable(value) {
        if (this._listViewRef && typeof this._listViewRef.setNativeProps === 'function') {
          this._listViewRef.setNativeProps({
            scrollEnabled: value
          });
        }
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        if (this._listViewRef && typeof this._listViewRef.getScrollResponder === 'function') {
          return this._listViewRef.getScrollResponder();
        }
      }
    }, {
      key: "_getMaxSwipeDistance",
      value: function _getMaxSwipeDistance(rowData, sectionID, rowID) {
        if (typeof this.props.maxSwipeDistance === 'function') {
          return this.props.maxSwipeDistance(rowData, sectionID, rowID);
        }

        return this.props.maxSwipeDistance;
      }
    }, {
      key: "_onOpen",
      value: function _onOpen(rowID) {
        this.setState({
          dataSource: this.state.dataSource.setOpenRowID(rowID)
        });
      }
    }, {
      key: "_onClose",
      value: function _onClose(rowID) {
        this.setState({
          dataSource: this.state.dataSource.setOpenRowID(null)
        });
      }
    }]);
    return SwipeableListView;
  }(React.Component);

  SwipeableListView.propTypes = {
    bounceFirstRowOnMount: PropTypes.bool.isRequired,
    dataSource: PropTypes.instanceOf(SwipeableListViewDataSource).isRequired,
    maxSwipeDistance: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,
    renderRow: PropTypes.func.isRequired,
    renderQuickActions: PropTypes.func.isRequired
  };
  SwipeableListView.defaultProps = {
    bounceFirstRowOnMount: false,
    renderQuickActions: function renderQuickActions() {
      return null;
    }
  };
  module.exports = SwipeableListView;
},337,[282,24,171,338,334],"SwipeableListView");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var ListViewDataSource = require(_dependencyMap[0], 'ListViewDataSource');

  var SwipeableListViewDataSource = function () {
    function SwipeableListViewDataSource(params) {
      var _this = this;

      babelHelpers.classCallCheck(this, SwipeableListViewDataSource);
      this._dataSource = new ListViewDataSource({
        getRowData: params.getRowData,
        getSectionHeaderData: params.getSectionHeaderData,
        rowHasChanged: function rowHasChanged(row1, row2) {
          return row1.id !== _this._previousOpenRowID && row2.id === _this._openRowID || row1.id === _this._previousOpenRowID && row2.id !== _this._openRowID || params.rowHasChanged(row1, row2);
        },
        sectionHeaderHasChanged: params.sectionHeaderHasChanged
      });
    }

    babelHelpers.createClass(SwipeableListViewDataSource, [{
      key: "cloneWithRowsAndSections",
      value: function cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities) {
        this._dataSource = this._dataSource.cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities);
        this._dataBlob = dataBlob;
        this.rowIdentities = this._dataSource.rowIdentities;
        this.sectionIdentities = this._dataSource.sectionIdentities;
        return this;
      }
    }, {
      key: "getDataSource",
      value: function getDataSource() {
        return this._dataSource;
      }
    }, {
      key: "getOpenRowID",
      value: function getOpenRowID() {
        return this._openRowID;
      }
    }, {
      key: "getFirstRowID",
      value: function getFirstRowID() {
        if (this.rowIdentities) {
          return this.rowIdentities[0] && this.rowIdentities[0][0];
        }

        return Object.keys(this._dataBlob)[0];
      }
    }, {
      key: "getLastRowID",
      value: function getLastRowID() {
        if (this.rowIdentities && this.rowIdentities.length) {
          var lastSection = this.rowIdentities[this.rowIdentities.length - 1];

          if (lastSection && lastSection.length) {
            return lastSection[lastSection.length - 1];
          }
        }

        return Object.keys(this._dataBlob)[this._dataBlob.length - 1];
      }
    }, {
      key: "setOpenRowID",
      value: function setOpenRowID(rowID) {
        this._previousOpenRowID = this._openRowID;
        this._openRowID = rowID;
        this._dataSource = this._dataSource.cloneWithRowsAndSections(this._dataBlob, this.sectionIdentities, this.rowIdentities);
        return this;
      }
    }]);
    return SwipeableListViewDataSource;
  }();

  module.exports = SwipeableListViewDataSource;
},338,[283],"SwipeableListViewDataSource");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/TabBarIOS/TabBarIOS.android.js";

  var React = require(_dependencyMap[0], 'React');

  var StyleSheet = require(_dependencyMap[1], 'StyleSheet');

  var TabBarItemIOS = require(_dependencyMap[2], 'TabBarItemIOS');

  var View = require(_dependencyMap[3], 'View');

  var DummyTabBarIOS = function (_React$Component) {
    babelHelpers.inherits(DummyTabBarIOS, _React$Component);

    function DummyTabBarIOS() {
      babelHelpers.classCallCheck(this, DummyTabBarIOS);
      return babelHelpers.possibleConstructorReturn(this, (DummyTabBarIOS.__proto__ || Object.getPrototypeOf(DummyTabBarIOS)).apply(this, arguments));
    }

    babelHelpers.createClass(DummyTabBarIOS, [{
      key: "render",
      value: function render() {
        return React.createElement(
          View,
          {
            style: [this.props.style, styles.tabGroup],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 25
            }
          },
          this.props.children
        );
      }
    }]);
    return DummyTabBarIOS;
  }(React.Component);

  DummyTabBarIOS.Item = TabBarItemIOS;
  var styles = StyleSheet.create({
    tabGroup: {
      flex: 1
    }
  });
  module.exports = DummyTabBarIOS;
},339,[171,209,340,211],"TabBarIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/TabBarIOS/TabBarItemIOS.android.js";

  var React = require(_dependencyMap[0], 'React');

  var View = require(_dependencyMap[1], 'View');

  var StyleSheet = require(_dependencyMap[2], 'StyleSheet');

  var DummyTab = function (_React$Component) {
    babelHelpers.inherits(DummyTab, _React$Component);

    function DummyTab() {
      babelHelpers.classCallCheck(this, DummyTab);
      return babelHelpers.possibleConstructorReturn(this, (DummyTab.__proto__ || Object.getPrototypeOf(DummyTab)).apply(this, arguments));
    }

    babelHelpers.createClass(DummyTab, [{
      key: "render",
      value: function render() {
        if (!this.props.selected) {
          return React.createElement(View, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 21
            }
          });
        }

        return React.createElement(
          View,
          {
            style: [this.props.style, styles.tab],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 24
            }
          },
          this.props.children
        );
      }
    }]);
    return DummyTab;
  }(React.Component);

  var styles = StyleSheet.create({
    tab: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      borderColor: 'red',
      borderWidth: 1
    }
  });
  module.exports = DummyTab;
},340,[171,211,209],"TabBarItemIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/TextInput/TextInput.js";

  var ColorPropType = require(_dependencyMap[0], 'ColorPropType');

  var DocumentSelectionState = require(_dependencyMap[1], 'DocumentSelectionState');

  var EventEmitter = require(_dependencyMap[2], 'EventEmitter');

  var NativeMethodsMixin = require(_dependencyMap[3], 'NativeMethodsMixin');

  var Platform = require(_dependencyMap[4], 'Platform');

  var React = require(_dependencyMap[5], 'React');

  var createReactClass = require(_dependencyMap[6], 'create-react-class');

  var PropTypes = require(_dependencyMap[7], 'prop-types');

  var ReactNative = require(_dependencyMap[8], 'ReactNative');

  var StyleSheet = require(_dependencyMap[9], 'StyleSheet');

  var Text = require(_dependencyMap[10], 'Text');

  var TextInputState = require(_dependencyMap[11], 'TextInputState');

  var TimerMixin = require(_dependencyMap[12], 'react-timer-mixin');

  var TouchableWithoutFeedback = require(_dependencyMap[13], 'TouchableWithoutFeedback');

  var UIManager = require(_dependencyMap[14], 'UIManager');

  var ViewPropTypes = require(_dependencyMap[15], 'ViewPropTypes');

  var emptyFunction = require(_dependencyMap[16], 'fbjs/lib/emptyFunction');

  var invariant = require(_dependencyMap[17], 'fbjs/lib/invariant');

  var requireNativeComponent = require(_dependencyMap[18], 'requireNativeComponent');

  var warning = require(_dependencyMap[19], 'fbjs/lib/warning');

  var onlyMultiline = {
    onTextInput: true,
    children: true
  };

  if (Platform.OS === 'android') {
    var AndroidTextInput = requireNativeComponent('AndroidTextInput', null);
  } else if (Platform.OS === 'ios') {
    var RCTTextView = requireNativeComponent('RCTTextView', null);
    var RCTTextField = requireNativeComponent('RCTTextField', null);
  }

  var DataDetectorTypes = ['phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all'];
  var TextInput = createReactClass({
    displayName: 'TextInput',
    statics: {
      State: TextInputState
    },
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      autoCapitalize: PropTypes.oneOf(['none', 'sentences', 'words', 'characters']),
      autoCorrect: PropTypes.bool,
      spellCheck: PropTypes.bool,
      autoFocus: PropTypes.bool,
      autoGrow: PropTypes.bool,
      allowFontScaling: PropTypes.bool,
      editable: PropTypes.bool,
      keyboardType: PropTypes.oneOf(['default', 'email-address', 'numeric', 'phone-pad', 'ascii-capable', 'numbers-and-punctuation', 'url', 'number-pad', 'name-phone-pad', 'decimal-pad', 'twitter', 'web-search', 'visible-password']),
      keyboardAppearance: PropTypes.oneOf(['default', 'light', 'dark']),
      returnKeyType: PropTypes.oneOf(['done', 'go', 'next', 'search', 'send', 'none', 'previous', 'default', 'emergency-call', 'google', 'join', 'route', 'yahoo']),
      returnKeyLabel: PropTypes.string,
      maxLength: PropTypes.number,
      maxHeight: PropTypes.number,
      numberOfLines: PropTypes.number,
      disableFullscreenUI: PropTypes.bool,
      enablesReturnKeyAutomatically: PropTypes.bool,
      multiline: PropTypes.bool,
      textBreakStrategy: PropTypes.oneOf(['simple', 'highQuality', 'balanced']),
      onBlur: PropTypes.func,
      onFocus: PropTypes.func,
      onChange: PropTypes.func,
      onChangeText: PropTypes.func,
      onContentSizeChange: PropTypes.func,
      onEndEditing: PropTypes.func,
      onSelectionChange: PropTypes.func,
      onSubmitEditing: PropTypes.func,
      onKeyPress: PropTypes.func,
      onLayout: PropTypes.func,
      onScroll: PropTypes.func,
      placeholder: PropTypes.string,
      placeholderTextColor: ColorPropType,
      secureTextEntry: PropTypes.bool,
      selectionColor: ColorPropType,
      selectionState: PropTypes.instanceOf(DocumentSelectionState),
      selection: PropTypes.shape({
        start: PropTypes.number.isRequired,
        end: PropTypes.number
      }),
      value: PropTypes.string,
      defaultValue: PropTypes.string,
      clearButtonMode: PropTypes.oneOf(['never', 'while-editing', 'unless-editing', 'always']),
      clearTextOnFocus: PropTypes.bool,
      selectTextOnFocus: PropTypes.bool,
      blurOnSubmit: PropTypes.bool,
      style: Text.propTypes.style,
      underlineColorAndroid: ColorPropType,
      inlineImageLeft: PropTypes.string,
      inlineImagePadding: PropTypes.number,
      dataDetectorTypes: PropTypes.oneOfType([PropTypes.oneOf(DataDetectorTypes), PropTypes.arrayOf(PropTypes.oneOf(DataDetectorTypes))]),
      caretHidden: PropTypes.bool
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        allowFontScaling: true
      };
    },
    mixins: [NativeMethodsMixin, TimerMixin],
    getInitialState: function getInitialState() {
      return {
        layoutHeight: this._layoutHeight
      };
    },
    isFocused: function isFocused() {
      return TextInputState.currentlyFocusedField() === ReactNative.findNodeHandle(this._inputRef);
    },
    contextTypes: {
      onFocusRequested: PropTypes.func,
      focusEmitter: PropTypes.instanceOf(EventEmitter)
    },
    _inputRef: undefined,
    _focusSubscription: undefined,
    _lastNativeText: undefined,
    _lastNativeSelection: undefined,
    _layoutHeight: -1,
    componentDidMount: function componentDidMount() {
      var _this = this;

      this._lastNativeText = this.props.value;

      if (!this.context.focusEmitter) {
        if (this.props.autoFocus) {
          this.requestAnimationFrame(this.focus);
        }

        return;
      }

      this._focusSubscription = this.context.focusEmitter.addListener('focus', function (el) {
        if (_this === el) {
          _this.requestAnimationFrame(_this.focus);
        } else if (_this.isFocused()) {
          _this.blur();
        }
      });

      if (this.props.autoFocus) {
        this.context.onFocusRequested(this);
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      this._focusSubscription && this._focusSubscription.remove();

      if (this.isFocused()) {
        this.blur();
      }
    },
    getChildContext: function getChildContext() {
      return {
        isInAParentText: true
      };
    },
    childContextTypes: {
      isInAParentText: PropTypes.bool
    },
    clear: function clear() {
      this.setNativeProps({
        text: ''
      });
    },
    render: function render() {
      if (Platform.OS === 'ios') {
        return this._renderIOS();
      } else if (Platform.OS === 'android') {
        return this._renderAndroid();
      }
    },
    _getText: function _getText() {
      return typeof this.props.value === 'string' ? this.props.value : typeof this.props.defaultValue === 'string' ? this.props.defaultValue : '';
    },
    _setNativeRef: function _setNativeRef(ref) {
      this._inputRef = ref;
    },
    _renderIOS: function _renderIOS() {
      var textContainer;
      var props = babelHelpers.extends({}, this.props);
      props.style = [this.props.style];

      if (props.selection && props.selection.end == null) {
        props.selection = {
          start: props.selection.start,
          end: props.selection.start
        };
      }

      if (!props.multiline) {
        if (__DEV__) {
          for (var propKey in onlyMultiline) {
            if (props[propKey]) {
              var error = new Error('TextInput prop `' + propKey + '` is only supported with multiline.');
              warning(false, '%s', error.stack);
            }
          }
        }

        textContainer = React.createElement(RCTTextField, babelHelpers.extends({
          ref: this._setNativeRef
        }, props, {
          onFocus: this._onFocus,
          onBlur: this._onBlur,
          onChange: this._onChange,
          onSelectionChange: this._onSelectionChange,
          onSelectionChangeShouldSetResponder: emptyFunction.thatReturnsTrue,
          text: this._getText(),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 727
          }
        }));
      } else {
        var children = props.children;
        var childCount = 0;
        React.Children.forEach(children, function () {
          return ++childCount;
        });
        invariant(!(props.value && childCount), 'Cannot specify both value and children.');

        if (childCount >= 1) {
          children = React.createElement(
            Text,
            {
              style: props.style,
              allowFontScaling: props.allowFontScaling,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 746
              }
            },
            children
          );
        }

        if (props.inputView) {
          children = [children, props.inputView];
        }

        props.style.unshift(styles.multilineInput);
        textContainer = React.createElement(RCTTextView, babelHelpers.extends({
          ref: this._setNativeRef
        }, props, {
          children: children,
          onFocus: this._onFocus,
          onBlur: this._onBlur,
          onChange: this._onChange,
          onContentSizeChange: this.props.onContentSizeChange,
          onSelectionChange: this._onSelectionChange,
          onTextInput: this._onTextInput,
          onSelectionChangeShouldSetResponder: emptyFunction.thatReturnsTrue,
          text: this._getText(),
          dataDetectorTypes: this.props.dataDetectorTypes,
          onScroll: this._onScroll,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 753
          }
        }));
      }

      return React.createElement(
        TouchableWithoutFeedback,
        {
          onLayout: props.onLayout,
          onPress: this._onPress,
          rejectResponderTermination: true,
          accessible: props.accessible,
          accessibilityLabel: props.accessibilityLabel,
          accessibilityTraits: props.accessibilityTraits,
          nativeID: this.props.nativeID,
          testID: props.testID,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 770
          }
        },
        textContainer
      );
    },
    _renderAndroid: function _renderAndroid() {
      var props = babelHelpers.extends({}, this.props);
      props.style = this.props.style;

      if (this.state.layoutHeight >= 0) {
        props.style = [props.style, {
          height: this.state.layoutHeight
        }];
      }

      props.autoCapitalize = UIManager.AndroidTextInput.Constants.AutoCapitalizationType[props.autoCapitalize || 'sentences'];
      var children = this.props.children;
      var childCount = 0;
      React.Children.forEach(children, function () {
        return ++childCount;
      });
      invariant(!(this.props.value && childCount), 'Cannot specify both value and children.');

      if (childCount > 1) {
        children = React.createElement(
          Text,
          {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 805
            }
          },
          children
        );
      }

      if (props.selection && props.selection.end == null) {
        props.selection = {
          start: props.selection.start,
          end: props.selection.start
        };
      }

      var textContainer = React.createElement(AndroidTextInput, babelHelpers.extends({
        ref: this._setNativeRef
      }, props, {
        mostRecentEventCount: 0,
        onFocus: this._onFocus,
        onBlur: this._onBlur,
        onChange: this._onChange,
        onContentSizeChange: this._onContentSizeChange,
        onSelectionChange: this._onSelectionChange,
        onTextInput: this._onTextInput,
        text: this._getText(),
        children: children,
        disableFullscreenUI: this.props.disableFullscreenUI,
        textBreakStrategy: this.props.textBreakStrategy,
        onScroll: this._onScroll,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 811
        }
      }));
      return React.createElement(
        TouchableWithoutFeedback,
        {
          onLayout: this._onLayout,
          onPress: this._onPress,
          accessible: this.props.accessible,
          accessibilityLabel: this.props.accessibilityLabel,
          accessibilityComponentType: this.props.accessibilityComponentType,
          nativeID: this.props.nativeID,
          testID: this.props.testID,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 829
          }
        },
        textContainer
      );
    },
    _onFocus: function _onFocus(event) {
      if (this.props.onFocus) {
        this.props.onFocus(event);
      }

      if (this.props.selectionState) {
        this.props.selectionState.focus();
      }
    },
    _onPress: function _onPress(event) {
      if (this.props.editable || this.props.editable === undefined) {
        this.focus();
      }
    },
    _onChange: function _onChange(event) {
      if (this._inputRef) {
        this._inputRef.setNativeProps({
          mostRecentEventCount: event.nativeEvent.eventCount
        });
      }

      var text = event.nativeEvent.text;
      this.props.onChange && this.props.onChange(event);
      this.props.onChangeText && this.props.onChangeText(text);

      if (!this._inputRef) {
        return;
      }

      this._lastNativeText = text;
      this.forceUpdate();
    },
    _onContentSizeChange: function _onContentSizeChange(event) {
      var contentHeight = event.nativeEvent.contentSize.height;

      if (this.props.autoGrow) {
        if (this.props.maxHeight) {
          contentHeight = Math.min(this.props.maxHeight, contentHeight);
        }

        this.setState({
          layoutHeight: Math.max(this._layoutHeight, contentHeight)
        });
      }

      this.props.onContentSizeChange && this.props.onContentSizeChange(event);
    },
    _onLayout: function _onLayout(event) {
      var height = event.nativeEvent.layout.height;

      if (height) {
        this._layoutHeight = event.nativeEvent.layout.height;
      }

      this.props.onLayout && this.props.onLayout(event);
    },
    _onSelectionChange: function _onSelectionChange(event) {
      this.props.onSelectionChange && this.props.onSelectionChange(event);

      if (!this._inputRef) {
        return;
      }

      this._lastNativeSelection = event.nativeEvent.selection;

      if (this.props.selection || this.props.selectionState) {
        this.forceUpdate();
      }
    },
    componentDidUpdate: function componentDidUpdate() {
      var nativeProps = {};

      if (this._lastNativeText !== this.props.value && typeof this.props.value === 'string') {
        nativeProps.text = this.props.value;
      }

      var selection = this.props.selection;

      if (this._lastNativeSelection && selection && (this._lastNativeSelection.start !== selection.start || this._lastNativeSelection.end !== selection.end)) {
        nativeProps.selection = this.props.selection;
      }

      if (Object.keys(nativeProps).length > 0 && this._inputRef) {
        this._inputRef.setNativeProps(nativeProps);
      }

      if (this.props.selectionState && selection) {
        this.props.selectionState.update(selection.start, selection.end);
      }
    },
    _onBlur: function _onBlur(event) {
      this.blur();

      if (this.props.onBlur) {
        this.props.onBlur(event);
      }

      if (this.props.selectionState) {
        this.props.selectionState.blur();
      }
    },
    _onTextInput: function _onTextInput(event) {
      this.props.onTextInput && this.props.onTextInput(event);
    },
    _onScroll: function _onScroll(event) {
      this.props.onScroll && this.props.onScroll(event);
    }
  });
  var styles = StyleSheet.create({
    multilineInput: {
      paddingTop: 5
    }
  });
  module.exports = TextInput;
},341,[167,342,118,169,105,171,213,24,74,209,222,159,232,231,158,172,16,18,186,19],"TextInput");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var mixInEventEmitter = require(_dependencyMap[0], 'mixInEventEmitter');

  var DocumentSelectionState = function () {
    function DocumentSelectionState(anchor, focus) {
      babelHelpers.classCallCheck(this, DocumentSelectionState);
      this._anchorOffset = anchor;
      this._focusOffset = focus;
      this._hasFocus = false;
    }

    babelHelpers.createClass(DocumentSelectionState, [{
      key: "update",
      value: function update(anchor, focus) {
        if (this._anchorOffset !== anchor || this._focusOffset !== focus) {
          this._anchorOffset = anchor;
          this._focusOffset = focus;
          this.emit('update');
        }
      }
    }, {
      key: "constrainLength",
      value: function constrainLength(maxLength) {
        this.update(Math.min(this._anchorOffset, maxLength), Math.min(this._focusOffset, maxLength));
      }
    }, {
      key: "focus",
      value: function focus() {
        if (!this._hasFocus) {
          this._hasFocus = true;
          this.emit('focus');
        }
      }
    }, {
      key: "blur",
      value: function blur() {
        if (this._hasFocus) {
          this._hasFocus = false;
          this.emit('blur');
        }
      }
    }, {
      key: "hasFocus",
      value: function hasFocus() {
        return this._hasFocus;
      }
    }, {
      key: "isCollapsed",
      value: function isCollapsed() {
        return this._anchorOffset === this._focusOffset;
      }
    }, {
      key: "isBackward",
      value: function isBackward() {
        return this._anchorOffset > this._focusOffset;
      }
    }, {
      key: "getAnchorOffset",
      value: function getAnchorOffset() {
        return this._hasFocus ? this._anchorOffset : null;
      }
    }, {
      key: "getFocusOffset",
      value: function getFocusOffset() {
        return this._hasFocus ? this._focusOffset : null;
      }
    }, {
      key: "getStartOffset",
      value: function getStartOffset() {
        return this._hasFocus ? Math.min(this._anchorOffset, this._focusOffset) : null;
      }
    }, {
      key: "getEndOffset",
      value: function getEndOffset() {
        return this._hasFocus ? Math.max(this._anchorOffset, this._focusOffset) : null;
      }
    }, {
      key: "overlaps",
      value: function overlaps(start, end) {
        return this.hasFocus() && this.getStartOffset() <= end && start <= this.getEndOffset();
      }
    }]);
    return DocumentSelectionState;
  }();

  mixInEventEmitter(DocumentSelectionState, {
    'blur': true,
    'focus': true,
    'update': true
  });
  module.exports = DocumentSelectionState;
},342,[343],"DocumentSelectionState");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EventEmitter = require(_dependencyMap[0], 'EventEmitter');

  var EventEmitterWithHolding = require(_dependencyMap[1], 'EventEmitterWithHolding');

  var EventHolder = require(_dependencyMap[2], 'EventHolder');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var keyOf = require(_dependencyMap[4], 'fbjs/lib/keyOf');

  var TYPES_KEY = keyOf({
    __types: true
  });

  function mixInEventEmitter(cls, types) {
    invariant(types, 'Must supply set of valid event types');
    var target = cls.prototype || cls;
    invariant(!target.__eventEmitter, 'An active emitter is already mixed in');
    var ctor = cls.constructor;

    if (ctor) {
      invariant(ctor === Object || ctor === Function, 'Mix EventEmitter into a class, not an instance');
    }

    if (target.hasOwnProperty(TYPES_KEY)) {
      babelHelpers.extends(target.__types, types);
    } else if (target.__types) {
      target.__types = babelHelpers.extends({}, target.__types, types);
    } else {
      target.__types = types;
    }

    babelHelpers.extends(target, EventEmitterMixin);
  }

  var EventEmitterMixin = {
    emit: function emit(eventType, a, b, c, d, e, _) {
      return this.__getEventEmitter().emit(eventType, a, b, c, d, e, _);
    },
    emitAndHold: function emitAndHold(eventType, a, b, c, d, e, _) {
      return this.__getEventEmitter().emitAndHold(eventType, a, b, c, d, e, _);
    },
    addListener: function addListener(eventType, listener, context) {
      return this.__getEventEmitter().addListener(eventType, listener, context);
    },
    once: function once(eventType, listener, context) {
      return this.__getEventEmitter().once(eventType, listener, context);
    },
    addRetroactiveListener: function addRetroactiveListener(eventType, listener, context) {
      return this.__getEventEmitter().addRetroactiveListener(eventType, listener, context);
    },
    addListenerMap: function addListenerMap(listenerMap, context) {
      return this.__getEventEmitter().addListenerMap(listenerMap, context);
    },
    addRetroactiveListenerMap: function addRetroactiveListenerMap(listenerMap, context) {
      return this.__getEventEmitter().addListenerMap(listenerMap, context);
    },
    removeAllListeners: function removeAllListeners() {
      this.__getEventEmitter().removeAllListeners();
    },
    removeCurrentListener: function removeCurrentListener() {
      this.__getEventEmitter().removeCurrentListener();
    },
    releaseHeldEventType: function releaseHeldEventType(eventType) {
      this.__getEventEmitter().releaseHeldEventType(eventType);
    },
    __getEventEmitter: function __getEventEmitter() {
      if (!this.__eventEmitter) {
        var emitter = new EventEmitter();

        if (__DEV__) {
          var EventValidator = require(_dependencyMap[5], 'EventValidator');

          emitter = EventValidator.addValidation(emitter, this.__types);
        }

        var holder = new EventHolder();
        this.__eventEmitter = new EventEmitterWithHolding(emitter, holder);
      }

      return this.__eventEmitter;
    }
  };
  module.exports = mixInEventEmitter;
},343,[118,344,345,18,346,347],"mixInEventEmitter");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EventEmitterWithHolding = function () {
    function EventEmitterWithHolding(emitter, holder) {
      babelHelpers.classCallCheck(this, EventEmitterWithHolding);
      this._emitter = emitter;
      this._eventHolder = holder;
      this._currentEventToken = null;
      this._emittingHeldEvents = false;
    }

    babelHelpers.createClass(EventEmitterWithHolding, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        return this._emitter.addListener(eventType, listener, context);
      }
    }, {
      key: "once",
      value: function once(eventType, listener, context) {
        return this._emitter.once(eventType, listener, context);
      }
    }, {
      key: "addRetroactiveListener",
      value: function addRetroactiveListener(eventType, listener, context) {
        var subscription = this._emitter.addListener(eventType, listener, context);

        this._emittingHeldEvents = true;

        this._eventHolder.emitToListener(eventType, listener, context);

        this._emittingHeldEvents = false;
        return subscription;
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        this._emitter.removeAllListeners(eventType);
      }
    }, {
      key: "removeCurrentListener",
      value: function removeCurrentListener() {
        this._emitter.removeCurrentListener();
      }
    }, {
      key: "listeners",
      value: function listeners(eventType) {
        return this._emitter.listeners(eventType);
      }
    }, {
      key: "emit",
      value: function emit(eventType) {
        var _emitter;

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        (_emitter = this._emitter).emit.apply(_emitter, [eventType].concat(babelHelpers.toConsumableArray(args)));
      }
    }, {
      key: "emitAndHold",
      value: function emitAndHold(eventType) {
        var _eventHolder, _emitter2;

        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        this._currentEventToken = (_eventHolder = this._eventHolder).holdEvent.apply(_eventHolder, [eventType].concat(babelHelpers.toConsumableArray(args)));

        (_emitter2 = this._emitter).emit.apply(_emitter2, [eventType].concat(babelHelpers.toConsumableArray(args)));

        this._currentEventToken = null;
      }
    }, {
      key: "releaseCurrentEvent",
      value: function releaseCurrentEvent() {
        if (this._currentEventToken) {
          this._eventHolder.releaseEvent(this._currentEventToken);
        } else if (this._emittingHeldEvents) {
          this._eventHolder.releaseCurrentEvent();
        }
      }
    }, {
      key: "releaseHeldEventType",
      value: function releaseHeldEventType(eventType) {
        this._eventHolder.releaseEventType(eventType);
      }
    }]);
    return EventEmitterWithHolding;
  }();

  module.exports = EventEmitterWithHolding;
},344,[],"EventEmitterWithHolding");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var invariant = require(_dependencyMap[0], 'fbjs/lib/invariant');

  var EventHolder = function () {
    function EventHolder() {
      babelHelpers.classCallCheck(this, EventHolder);
      this._heldEvents = {};
      this._currentEventKey = null;
    }

    babelHelpers.createClass(EventHolder, [{
      key: "holdEvent",
      value: function holdEvent(eventType) {
        this._heldEvents[eventType] = this._heldEvents[eventType] || [];
        var eventsOfType = this._heldEvents[eventType];
        var key = {
          eventType: eventType,
          index: eventsOfType.length
        };

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        eventsOfType.push(args);
        return key;
      }
    }, {
      key: "emitToListener",
      value: function emitToListener(eventType, listener, context) {
        var _this = this;

        var eventsOfType = this._heldEvents[eventType];

        if (!eventsOfType) {
          return;
        }

        var origEventKey = this._currentEventKey;
        eventsOfType.forEach(function (eventHeld, index) {
          if (!eventHeld) {
            return;
          }

          _this._currentEventKey = {
            eventType: eventType,
            index: index
          };
          listener.apply(context, eventHeld);
        });
        this._currentEventKey = origEventKey;
      }
    }, {
      key: "releaseCurrentEvent",
      value: function releaseCurrentEvent() {
        invariant(this._currentEventKey !== null, 'Not in an emitting cycle; there is no current event');
        this._currentEventKey && this.releaseEvent(this._currentEventKey);
      }
    }, {
      key: "releaseEvent",
      value: function releaseEvent(token) {
        delete this._heldEvents[token.eventType][token.index];
      }
    }, {
      key: "releaseEventType",
      value: function releaseEventType(type) {
        this._heldEvents[type] = [];
      }
    }]);
    return EventHolder;
  }();

  module.exports = EventHolder;
},345,[18],"EventHolder");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  var keyOf = function keyOf(oneKeyObj) {
    var key;

    for (key in oneKeyObj) {
      if (!oneKeyObj.hasOwnProperty(key)) {
        continue;
      }

      return key;
    }

    return null;
  };

  module.exports = keyOf;
},346,[],"fbjs/lib/keyOf.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var EventValidator = {
    addValidation: function addValidation(emitter, types) {
      var eventTypes = Object.keys(types);
      var emitterWithValidation = Object.create(emitter);
      babelHelpers.extends(emitterWithValidation, {
        emit: function emit(type, a, b, c, d, e, _) {
          assertAllowsEventType(type, eventTypes);
          return emitter.emit.call(this, type, a, b, c, d, e, _);
        }
      });
      return emitterWithValidation;
    }
  };

  function assertAllowsEventType(type, allowedTypes) {
    if (allowedTypes.indexOf(type) === -1) {
      throw new TypeError(errorMessageFor(type, allowedTypes));
    }
  }

  function errorMessageFor(type, allowedTypes) {
    var message = 'Unknown event type "' + type + '". ';

    if (__DEV__) {
      message += recommendationFor(type, allowedTypes);
    }

    message += 'Known event types: ' + allowedTypes.join(', ') + '.';
    return message;
  }

  if (__DEV__) {
    var recommendationFor = function recommendationFor(type, allowedTypes) {
      var closestTypeRecommendation = closestTypeFor(type, allowedTypes);

      if (isCloseEnough(closestTypeRecommendation, type)) {
        return 'Did you mean "' + closestTypeRecommendation.type + '"? ';
      } else {
        return '';
      }
    };

    var closestTypeFor = function closestTypeFor(type, allowedTypes) {
      var typeRecommendations = allowedTypes.map(typeRecommendationFor.bind(this, type));
      return typeRecommendations.sort(recommendationSort)[0];
    };

    var typeRecommendationFor = function typeRecommendationFor(type, recomendedType) {
      return {
        type: recomendedType,
        distance: damerauLevenshteinDistance(type, recomendedType)
      };
    };

    var recommendationSort = function recommendationSort(recommendationA, recommendationB) {
      if (recommendationA.distance < recommendationB.distance) {
        return -1;
      } else if (recommendationA.distance > recommendationB.distance) {
        return 1;
      } else {
        return 0;
      }
    };

    var isCloseEnough = function isCloseEnough(closestType, actualType) {
      return closestType.distance / actualType.length < 0.334;
    };

    var damerauLevenshteinDistance = function damerauLevenshteinDistance(a, b) {
      var i = void 0,
          j = void 0;
      var d = [];

      for (i = 0; i <= a.length; i++) {
        d[i] = [i];
      }

      for (j = 1; j <= b.length; j++) {
        d[0][j] = j;
      }

      for (i = 1; i <= a.length; i++) {
        for (j = 1; j <= b.length; j++) {
          var cost = a.charAt(i - 1) === b.charAt(j - 1) ? 0 : 1;
          d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);

          if (i > 1 && j > 1 && a.charAt(i - 1) === b.charAt(j - 2) && a.charAt(i - 2) === b.charAt(j - 1)) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
          }
        }
      }

      return d[a.length][b.length];
    };
  }

  module.exports = EventValidator;
},347,[],"EventValidator");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/ToolbarAndroid/ToolbarAndroid.android.js";

  var Image = require(_dependencyMap[0], 'Image');

  var NativeMethodsMixin = require(_dependencyMap[1], 'NativeMethodsMixin');

  var React = require(_dependencyMap[2], 'React');

  var PropTypes = require(_dependencyMap[3], 'prop-types');

  var ReactNativeViewAttributes = require(_dependencyMap[4], 'ReactNativeViewAttributes');

  var UIManager = require(_dependencyMap[5], 'UIManager');

  var ViewPropTypes = require(_dependencyMap[6], 'ViewPropTypes');

  var ColorPropType = require(_dependencyMap[7], 'ColorPropType');

  var createReactClass = require(_dependencyMap[8], 'create-react-class');

  var requireNativeComponent = require(_dependencyMap[9], 'requireNativeComponent');

  var resolveAssetSource = require(_dependencyMap[10], 'resolveAssetSource');

  var optionalImageSource = PropTypes.oneOfType([Image.propTypes.source, PropTypes.oneOf([])]);
  var ToolbarAndroid = createReactClass({
    displayName: 'ToolbarAndroid',
    mixins: [NativeMethodsMixin],
    propTypes: babelHelpers.extends({}, ViewPropTypes, {
      actions: PropTypes.arrayOf(PropTypes.shape({
        title: PropTypes.string.isRequired,
        icon: optionalImageSource,
        show: PropTypes.oneOf(['always', 'ifRoom', 'never']),
        showWithText: PropTypes.bool
      })),
      logo: optionalImageSource,
      navIcon: optionalImageSource,
      onActionSelected: PropTypes.func,
      onIconClicked: PropTypes.func,
      overflowIcon: optionalImageSource,
      subtitle: PropTypes.string,
      subtitleColor: ColorPropType,
      title: PropTypes.string,
      titleColor: ColorPropType,
      contentInsetStart: PropTypes.number,
      contentInsetEnd: PropTypes.number,
      rtl: PropTypes.bool,
      testID: PropTypes.string
    }),
    render: function render() {
      var nativeProps = babelHelpers.extends({}, this.props);

      if (this.props.logo) {
        nativeProps.logo = resolveAssetSource(this.props.logo);
      }

      if (this.props.navIcon) {
        nativeProps.navIcon = resolveAssetSource(this.props.navIcon);
      }

      if (this.props.overflowIcon) {
        nativeProps.overflowIcon = resolveAssetSource(this.props.overflowIcon);
      }

      if (this.props.actions) {
        var nativeActions = [];

        for (var i = 0; i < this.props.actions.length; i++) {
          var action = babelHelpers.extends({}, this.props.actions[i]);

          if (action.icon) {
            action.icon = resolveAssetSource(action.icon);
          }

          if (action.show) {
            action.show = UIManager.ToolbarAndroid.Constants.ShowAsAction[action.show];
          }

          nativeActions.push(action);
        }

        nativeProps.nativeActions = nativeActions;
      }

      return React.createElement(NativeToolbar, babelHelpers.extends({
        onSelect: this._onSelect
      }, nativeProps, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 196
        }
      }));
    },
    _onSelect: function _onSelect(event) {
      var position = event.nativeEvent.position;

      if (position === -1) {
        this.props.onIconClicked && this.props.onIconClicked();
      } else {
        this.props.onActionSelected && this.props.onActionSelected(position);
      }
    }
  });
  var NativeToolbar = requireNativeComponent('ToolbarAndroid', ToolbarAndroid, {
    nativeOnly: {
      nativeActions: true
    }
  });
  module.exports = ToolbarAndroid;
},348,[263,169,171,24,212,158,172,167,213,186,201],"ToolbarAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/ViewPager/ViewPagerAndroid.android.js";

  var React = require(_dependencyMap[0], 'React');

  var PropTypes = require(_dependencyMap[1], 'prop-types');

  var ReactNative = require(_dependencyMap[2], 'ReactNative');

  var UIManager = require(_dependencyMap[3], 'UIManager');

  var ViewPropTypes = require(_dependencyMap[4], 'ViewPropTypes');

  var dismissKeyboard = require(_dependencyMap[5], 'dismissKeyboard');

  var requireNativeComponent = require(_dependencyMap[6], 'requireNativeComponent');

  var VIEWPAGER_REF = 'viewPager';

  var ViewPagerAndroid = function (_React$Component) {
    babelHelpers.inherits(ViewPagerAndroid, _React$Component);

    function ViewPagerAndroid() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, ViewPagerAndroid);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = ViewPagerAndroid.__proto__ || Object.getPrototypeOf(ViewPagerAndroid)).call.apply(_ref, [this].concat(args))), _this), _this.getInnerViewNode = function () {
        return _this.refs[VIEWPAGER_REF].getInnerViewNode();
      }, _this._childrenWithOverridenStyle = function () {
        return React.Children.map(_this.props.children, function (child) {
          if (!child) {
            return null;
          }

          var newProps = babelHelpers.extends({}, child.props, {
            style: [child.props.style, {
              position: 'absolute',
              left: 0,
              top: 0,
              right: 0,
              bottom: 0,
              width: undefined,
              height: undefined
            }],
            collapsable: false
          });

          if (child.type && child.type.displayName && child.type.displayName !== 'RCTView' && child.type.displayName !== 'View') {
            console.warn('Each ViewPager child must be a <View>. Was ' + child.type.displayName);
          }

          return React.createElement(child.type, newProps);
        });
      }, _this._onPageScroll = function (e) {
        if (_this.props.onPageScroll) {
          _this.props.onPageScroll(e);
        }

        if (_this.props.keyboardDismissMode === 'on-drag') {
          dismissKeyboard();
        }
      }, _this._onPageScrollStateChanged = function (e) {
        if (_this.props.onPageScrollStateChanged) {
          _this.props.onPageScrollStateChanged(e.nativeEvent.pageScrollState);
        }
      }, _this._onPageSelected = function (e) {
        if (_this.props.onPageSelected) {
          _this.props.onPageSelected(e);
        }
      }, _this.setPage = function (selectedPage) {
        UIManager.dispatchViewManagerCommand(ReactNative.findNodeHandle(_this), UIManager.AndroidViewPager.Commands.setPage, [selectedPage]);
      }, _this.setPageWithoutAnimation = function (selectedPage) {
        UIManager.dispatchViewManagerCommand(ReactNative.findNodeHandle(_this), UIManager.AndroidViewPager.Commands.setPageWithoutAnimation, [selectedPage]);
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(ViewPagerAndroid, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this.props.initialPage != null) {
          this.setPageWithoutAnimation(this.props.initialPage);
        }
      }
    }, {
      key: "render",
      value: function render() {
        return React.createElement(NativeAndroidViewPager, babelHelpers.extends({}, this.props, {
          ref: VIEWPAGER_REF,
          style: this.props.style,
          onPageScroll: this._onPageScroll,
          onPageScrollStateChanged: this._onPageScrollStateChanged,
          onPageSelected: this._onPageSelected,
          children: this._childrenWithOverridenStyle(),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 238
          }
        }));
      }
    }]);
    return ViewPagerAndroid;
  }(React.Component);

  ViewPagerAndroid.propTypes = babelHelpers.extends({}, ViewPropTypes, {
    initialPage: PropTypes.number,
    onPageScroll: PropTypes.func,
    onPageScrollStateChanged: PropTypes.func,
    onPageSelected: PropTypes.func,
    pageMargin: PropTypes.number,
    keyboardDismissMode: PropTypes.oneOf(['none', 'on-drag']),
    scrollEnabled: PropTypes.bool,
    peekEnabled: PropTypes.bool
  });
  var NativeAndroidViewPager = requireNativeComponent('AndroidViewPager', ViewPagerAndroid);
  module.exports = ViewPagerAndroid;
},349,[171,24,74,158,172,270,186],"ViewPagerAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/Components/WebView/WebView.android.js";

  var EdgeInsetsPropType = require(_dependencyMap[0], 'EdgeInsetsPropType');

  var ActivityIndicator = require(_dependencyMap[1], 'ActivityIndicator');

  var React = require(_dependencyMap[2], 'React');

  var PropTypes = require(_dependencyMap[3], 'prop-types');

  var ReactNative = require(_dependencyMap[4], 'ReactNative');

  var StyleSheet = require(_dependencyMap[5], 'StyleSheet');

  var UIManager = require(_dependencyMap[6], 'UIManager');

  var View = require(_dependencyMap[7], 'View');

  var ViewPropTypes = require(_dependencyMap[8], 'ViewPropTypes');

  var deprecatedPropType = require(_dependencyMap[9], 'deprecatedPropType');

  var keyMirror = require(_dependencyMap[10], 'fbjs/lib/keyMirror');

  var requireNativeComponent = require(_dependencyMap[11], 'requireNativeComponent');

  var resolveAssetSource = require(_dependencyMap[12], 'resolveAssetSource');

  var RCT_WEBVIEW_REF = 'webview';
  var WebViewState = keyMirror({
    IDLE: null,
    LOADING: null,
    ERROR: null
  });

  var defaultRenderLoading = function defaultRenderLoading() {
    return React.createElement(
      View,
      {
        style: styles.loadingView,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 37
        }
      },
      React.createElement(ActivityIndicator, {
        style: styles.loadingProgressBar,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 38
        }
      })
    );
  };

  var WebView = function (_React$Component) {
    babelHelpers.inherits(WebView, _React$Component);

    function WebView() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, WebView);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = WebView.__proto__ || Object.getPrototypeOf(WebView)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        viewState: WebViewState.IDLE,
        lastErrorEvent: null,
        startInLoadingState: true
      }, _this.goForward = function () {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.goForward, null);
      }, _this.goBack = function () {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.goBack, null);
      }, _this.reload = function () {
        _this.setState({
          viewState: WebViewState.LOADING
        });

        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.reload, null);
      }, _this.stopLoading = function () {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.stopLoading, null);
      }, _this.postMessage = function (data) {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.postMessage, [String(data)]);
      }, _this.injectJavaScript = function (data) {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.injectJavaScript, [data]);
      }, _this.updateNavigationState = function (event) {
        if (_this.props.onNavigationStateChange) {
          _this.props.onNavigationStateChange(event.nativeEvent);
        }
      }, _this.getWebViewHandle = function () {
        return ReactNative.findNodeHandle(_this.refs[RCT_WEBVIEW_REF]);
      }, _this.onLoadingStart = function (event) {
        var onLoadStart = _this.props.onLoadStart;
        onLoadStart && onLoadStart(event);

        _this.updateNavigationState(event);
      }, _this.onLoadingError = function (event) {
        event.persist();
        var _this$props = _this.props,
            onError = _this$props.onError,
            onLoadEnd = _this$props.onLoadEnd;
        onError && onError(event);
        onLoadEnd && onLoadEnd(event);
        console.warn('Encountered an error loading page', event.nativeEvent);

        _this.setState({
          lastErrorEvent: event.nativeEvent,
          viewState: WebViewState.ERROR
        });
      }, _this.onLoadingFinish = function (event) {
        var _this$props2 = _this.props,
            onLoad = _this$props2.onLoad,
            onLoadEnd = _this$props2.onLoadEnd;
        onLoad && onLoad(event);
        onLoadEnd && onLoadEnd(event);

        _this.setState({
          viewState: WebViewState.IDLE
        });

        _this.updateNavigationState(event);
      }, _this.onMessage = function (event) {
        var onMessage = _this.props.onMessage;
        onMessage && onMessage(event);
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(WebView, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        if (this.props.startInLoadingState) {
          this.setState({
            viewState: WebViewState.LOADING
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var otherView = null;

        if (this.state.viewState === WebViewState.LOADING) {
          otherView = (this.props.renderLoading || defaultRenderLoading)();
        } else if (this.state.viewState === WebViewState.ERROR) {
          var errorEvent = this.state.lastErrorEvent;
          otherView = this.props.renderError && this.props.renderError(errorEvent.domain, errorEvent.code, errorEvent.description);
        } else if (this.state.viewState !== WebViewState.IDLE) {
          console.error('RCTWebView invalid state encountered: ' + this.state.loading);
        }

        var webViewStyles = [styles.container, this.props.style];

        if (this.state.viewState === WebViewState.LOADING || this.state.viewState === WebViewState.ERROR) {
          webViewStyles.push(styles.hidden);
        }

        var source = this.props.source || {};

        if (this.props.html) {
          source.html = this.props.html;
        } else if (this.props.url) {
          source.uri = this.props.url;
        }

        if (source.method === 'POST' && source.headers) {
          console.warn('WebView: `source.headers` is not supported when using POST.');
        } else if (source.method === 'GET' && source.body) {
          console.warn('WebView: `source.body` is not supported when using GET.');
        }

        var nativeConfig = this.props.nativeConfig || {};
        var NativeWebView = nativeConfig.component || RCTWebView;
        var webView = React.createElement(NativeWebView, babelHelpers.extends({
          ref: RCT_WEBVIEW_REF,
          key: "webViewKey",
          style: webViewStyles,
          source: resolveAssetSource(source),
          scalesPageToFit: this.props.scalesPageToFit,
          injectedJavaScript: this.props.injectedJavaScript,
          userAgent: this.props.userAgent,
          javaScriptEnabled: this.props.javaScriptEnabled,
          thirdPartyCookiesEnabled: this.props.thirdPartyCookiesEnabled,
          domStorageEnabled: this.props.domStorageEnabled,
          messagingEnabled: typeof this.props.onMessage === 'function',
          onMessage: this.onMessage,
          contentInset: this.props.contentInset,
          automaticallyAdjustContentInsets: this.props.automaticallyAdjustContentInsets,
          onContentSizeChange: this.props.onContentSizeChange,
          onLoadingStart: this.onLoadingStart,
          onLoadingFinish: this.onLoadingFinish,
          onLoadingError: this.onLoadingError,
          testID: this.props.testID,
          mediaPlaybackRequiresUserAction: this.props.mediaPlaybackRequiresUserAction,
          allowUniversalAccessFromFileURLs: this.props.allowUniversalAccessFromFileURLs,
          mixedContentMode: this.props.mixedContentMode,
          saveFormDataDisabled: this.props.saveFormDataDisabled,
          urlPrefixesForDefaultIntent: this.props.urlPrefixesForDefaultIntent
        }, nativeConfig.props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 296
          }
        }));
        return React.createElement(
          View,
          {
            style: styles.container,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 325
            }
          },
          webView,
          otherView
        );
      }
    }], [{
      key: "extraNativeComponentConfig",
      get: function get() {
        return {
          nativeOnly: {
            messagingEnabled: PropTypes.bool
          }
        };
      }
    }]);
    return WebView;
  }(React.Component);

  WebView.propTypes = babelHelpers.extends({}, ViewPropTypes, {
    renderError: PropTypes.func,
    renderLoading: PropTypes.func,
    onLoad: PropTypes.func,
    onLoadEnd: PropTypes.func,
    onLoadStart: PropTypes.func,
    onError: PropTypes.func,
    automaticallyAdjustContentInsets: PropTypes.bool,
    contentInset: EdgeInsetsPropType,
    onNavigationStateChange: PropTypes.func,
    onMessage: PropTypes.func,
    onContentSizeChange: PropTypes.func,
    startInLoadingState: PropTypes.bool,
    style: ViewPropTypes.style,
    html: deprecatedPropType(PropTypes.string, 'Use the `source` prop instead.'),
    url: deprecatedPropType(PropTypes.string, 'Use the `source` prop instead.'),
    source: PropTypes.oneOfType([PropTypes.shape({
      uri: PropTypes.string,
      method: PropTypes.oneOf(['GET', 'POST']),
      headers: PropTypes.object,
      body: PropTypes.string
    }), PropTypes.shape({
      html: PropTypes.string,
      baseUrl: PropTypes.string
    }), PropTypes.number]),
    javaScriptEnabled: PropTypes.bool,
    thirdPartyCookiesEnabled: PropTypes.bool,
    domStorageEnabled: PropTypes.bool,
    injectedJavaScript: PropTypes.string,
    scalesPageToFit: PropTypes.bool,
    userAgent: PropTypes.string,
    testID: PropTypes.string,
    mediaPlaybackRequiresUserAction: PropTypes.bool,
    allowUniversalAccessFromFileURLs: PropTypes.bool,
    injectJavaScript: PropTypes.func,
    mixedContentMode: PropTypes.oneOf(['never', 'always', 'compatibility']),
    saveFormDataDisabled: PropTypes.bool,
    nativeConfig: PropTypes.shape({
      component: PropTypes.any,
      props: PropTypes.object,
      viewManager: PropTypes.object
    }),
    urlPrefixesForDefaultIntent: PropTypes.arrayOf(PropTypes.string)
  });
  WebView.defaultProps = {
    javaScriptEnabled: true,
    thirdPartyCookiesEnabled: true,
    scalesPageToFit: true,
    saveFormDataDisabled: false
  };
  var RCTWebView = requireNativeComponent('RCTWebView', WebView, WebView.extraNativeComponentConfig);
  var styles = StyleSheet.create({
    container: {
      flex: 1
    },
    hidden: {
      height: 0,
      flex: 0
    },
    loadingView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center'
    },
    loadingProgressBar: {
      height: 20
    }
  });
  module.exports = WebView;
},350,[173,166,171,24,74,209,158,211,172,184,191,186,201],"WebView");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTActionSheetManager = require(_dependencyMap[0], 'NativeModules').ActionSheetManager;

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  var processColor = require(_dependencyMap[2], 'processColor');

  var ActionSheetIOS = {
    showActionSheetWithOptions: function showActionSheetWithOptions(options, callback) {
      invariant(typeof options === 'object' && options !== null, 'Options must be a valid object');
      invariant(typeof callback === 'function', 'Must provide a valid callback');
      RCTActionSheetManager.showActionSheetWithOptions(babelHelpers.extends({}, options, {
        tintColor: processColor(options.tintColor)
      }), callback);
    },
    showShareActionSheetWithOptions: function showShareActionSheetWithOptions(options, failureCallback, successCallback) {
      invariant(typeof options === 'object' && options !== null, 'Options must be a valid object');
      invariant(typeof failureCallback === 'function', 'Must provide a valid failureCallback');
      invariant(typeof successCallback === 'function', 'Must provide a valid successCallback');
      RCTActionSheetManager.showShareActionSheetWithOptions(babelHelpers.extends({}, options, {
        tintColor: processColor(options.tintColor)
      }), failureCallback, successCallback);
    }
  };
  module.exports = ActionSheetIOS;
},351,[68,18,193],"ActionSheetIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var BatchedBridge = require(_dependencyMap[0], 'BatchedBridge');

  var BugReporting = require(_dependencyMap[1], 'BugReporting');

  var NativeModules = require(_dependencyMap[2], 'NativeModules');

  var ReactNative = require(_dependencyMap[3], 'ReactNative');

  var SceneTracker = require(_dependencyMap[4], 'SceneTracker');

  var infoLog = require(_dependencyMap[5], 'infoLog');

  var invariant = require(_dependencyMap[6], 'fbjs/lib/invariant');

  var renderApplication = require(_dependencyMap[7], 'renderApplication');

  var runnables = {};
  var runCount = 1;
  var sections = {};
  var tasks = new Map();

  var componentProviderInstrumentationHook = function componentProviderInstrumentationHook(component) {
    return component();
  };

  var wrapperComponentProvider = void 0;
  var AppRegistry = {
    setWrapperComponentProvider: function setWrapperComponentProvider(provider) {
      wrapperComponentProvider = provider;
    },
    registerConfig: function registerConfig(config) {
      config.forEach(function (appConfig) {
        if (appConfig.run) {
          AppRegistry.registerRunnable(appConfig.appKey, appConfig.run);
        } else {
          invariant(appConfig.component != null, 'AppRegistry.registerConfig(...): Every config is expected to set ' + 'either `run` or `component`, but `%s` has neither.', appConfig.appKey);
          AppRegistry.registerComponent(appConfig.appKey, appConfig.component, appConfig.section);
        }
      });
    },
    registerComponent: function registerComponent(appKey, componentProvider, section) {
      runnables[appKey] = {
        componentProvider: componentProvider,
        run: function run(appParameters) {
          return renderApplication(componentProviderInstrumentationHook(componentProvider), appParameters.initialProps, appParameters.rootTag, wrapperComponentProvider && wrapperComponentProvider(appParameters));
        }
      };

      if (section) {
        sections[appKey] = runnables[appKey];
      }

      return appKey;
    },
    registerRunnable: function registerRunnable(appKey, run) {
      runnables[appKey] = {
        run: run
      };
      return appKey;
    },
    registerSection: function registerSection(appKey, component) {
      AppRegistry.registerComponent(appKey, component, true);
    },
    getAppKeys: function getAppKeys() {
      return Object.keys(runnables);
    },
    getSectionKeys: function getSectionKeys() {
      return Object.keys(sections);
    },
    getSections: function getSections() {
      return babelHelpers.extends({}, sections);
    },
    getRunnable: function getRunnable(appKey) {
      return runnables[appKey];
    },
    getRegistry: function getRegistry() {
      return {
        sections: AppRegistry.getSectionKeys(),
        runnables: babelHelpers.extends({}, runnables)
      };
    },
    setComponentProviderInstrumentationHook: function setComponentProviderInstrumentationHook(hook) {
      componentProviderInstrumentationHook = hook;
    },
    runApplication: function runApplication(appKey, appParameters) {
      var msg = 'Running application "' + appKey + '" with appParams: ' + JSON.stringify(appParameters) + '. ' + '__DEV__ === ' + String(__DEV__) + ', development-level warning are ' + (__DEV__ ? 'ON' : 'OFF') + ', performance optimizations are ' + (__DEV__ ? 'OFF' : 'ON');
      infoLog(msg);
      BugReporting.addSource('AppRegistry.runApplication' + runCount++, function () {
        return msg;
      });
      invariant(runnables[appKey] && runnables[appKey].run, 'Application ' + appKey + ' has not been registered.\n\n' + "Hint: This error often happens when you're running the packager " + '(local dev server) from a wrong folder. For example you have ' + 'multiple apps and the packager is still running for the app you ' + 'were working on before.\nIf this is the case, simply kill the old ' + 'packager instance (e.g. close the packager terminal window) ' + 'and start the packager in the correct app folder (e.g. cd into app ' + "folder and run 'npm start').\n\n" + 'This error can also happen due to a require() error during ' + 'initialization or failure to call AppRegistry.registerComponent.\n\n');
      SceneTracker.setActiveScene({
        name: appKey
      });
      runnables[appKey].run(appParameters);
    },
    unmountApplicationComponentAtRootTag: function unmountApplicationComponentAtRootTag(rootTag) {
      ReactNative.unmountComponentAtNodeAndRemoveContainer(rootTag);
    },
    registerHeadlessTask: function registerHeadlessTask(taskKey, task) {
      if (tasks.has(taskKey)) {
        console.warn("registerHeadlessTask called multiple times for same key '" + taskKey + "'");
      }

      tasks.set(taskKey, task);
    },
    startHeadlessTask: function startHeadlessTask(taskId, taskKey, data) {
      var taskProvider = tasks.get(taskKey);

      if (!taskProvider) {
        throw new Error("No task registered for key " + taskKey);
      }

      taskProvider()(data).then(function () {
        return NativeModules.HeadlessJsTaskSupport.notifyTaskFinished(taskId);
      }).catch(function (reason) {
        console.error(reason);
        NativeModules.HeadlessJsTaskSupport.notifyTaskFinished(taskId);
      });
    }
  };
  BatchedBridge.registerCallableModule('AppRegistry', AppRegistry);
  module.exports = AppRegistry;
},352,[69,353,68,74,355,145,18,356],"AppRegistry");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTDeviceEventEmitter = require(_dependencyMap[0], 'RCTDeviceEventEmitter');

  var Map = require(_dependencyMap[1], 'Map');

  var infoLog = require(_dependencyMap[2], 'infoLog');

  function defaultExtras() {
    BugReporting.addFileSource('react_hierarchy.txt', function () {
      return require(_dependencyMap[3], 'dumpReactTree')();
    });
  }

  var BugReporting = function () {
    function BugReporting() {
      babelHelpers.classCallCheck(this, BugReporting);
    }

    babelHelpers.createClass(BugReporting, null, [{
      key: "_maybeInit",
      value: function _maybeInit() {
        if (!BugReporting._subscription) {
          BugReporting._subscription = RCTDeviceEventEmitter.addListener('collectBugExtraData', BugReporting.collectExtraData, null);
          defaultExtras();
        }
      }
    }, {
      key: "addSource",
      value: function addSource(key, callback) {
        return this._addSource(key, callback, BugReporting._extraSources);
      }
    }, {
      key: "addFileSource",
      value: function addFileSource(key, callback) {
        return this._addSource(key, callback, BugReporting._fileSources);
      }
    }, {
      key: "_addSource",
      value: function _addSource(key, callback, source) {
        BugReporting._maybeInit();

        if (source.has(key)) {
          console.warn("BugReporting.add* called multiple times for same key '" + key + "'");
        }

        source.set(key, callback);
        return {
          remove: function remove() {
            source.delete(key);
          }
        };
      }
    }, {
      key: "collectExtraData",
      value: function collectExtraData() {
        var extraData = {};

        for (var _iterator = BugReporting._extraSources, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref3;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref3 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref3 = _i.value;
          }

          var _ref = _ref3;

          var _ref2 = babelHelpers.slicedToArray(_ref, 2);

          var _key = _ref2[0];
          var callback = _ref2[1];
          extraData[_key] = callback();
        }

        var fileData = {};

        for (var _iterator2 = BugReporting._fileSources, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref6;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref6 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref6 = _i2.value;
          }

          var _ref4 = _ref6;

          var _ref5 = babelHelpers.slicedToArray(_ref4, 2);

          var _key2 = _ref5[0];
          var _callback = _ref5[1];
          fileData[_key2] = _callback();
        }

        infoLog('BugReporting extraData:', extraData);

        var BugReportingNativeModule = require(_dependencyMap[4], 'NativeModules').BugReporting;

        BugReportingNativeModule && BugReportingNativeModule.setExtraData && BugReportingNativeModule.setExtraData(extraData, fileData);
        return {
          extras: extraData,
          files: fileData
        };
      }
    }]);
    return BugReporting;
  }();

  BugReporting._extraSources = new Map();
  BugReporting._fileSources = new Map();
  BugReporting._subscription = null;
  module.exports = BugReporting;
},353,[121,79,145,354,68],"BugReporting");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  function dumpReactTree() {
    try {
      return getReactTree();
    } catch (e) {
      return 'Failed to dump react tree: ' + e;
    }
  }

  function getReactTree() {
    return 'React tree dumps have been temporarily disabled while React is ' + 'upgraded to Fiber.';
  }

  module.exports = dumpReactTree;
},354,[],"dumpReactTree");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _listeners = [];
  var _activeScene = {
    name: 'default'
  };
  var SceneTracker = {
    setActiveScene: function setActiveScene(scene) {
      _activeScene = scene;

      _listeners.forEach(function (listener) {
        return listener(_activeScene);
      });
    },
    getActiveScene: function getActiveScene() {
      return _activeScene;
    },
    addActiveSceneChangedListener: function addActiveSceneChangedListener(callback) {
      _listeners.push(callback);

      return {
        remove: function remove() {
          _listeners = _listeners.filter(function (listener) {
            return callback !== listener;
          });
        }
      };
    }
  };
  module.exports = SceneTracker;
},355,[],"SceneTracker");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native/Libraries/ReactNative/renderApplication.js";

  var AppContainer = require(_dependencyMap[0], 'AppContainer');

  var React = require(_dependencyMap[1], 'React');

  var ReactNative = require(_dependencyMap[2], 'ReactNative');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  require(_dependencyMap[4], 'BackHandler');

  function renderApplication(RootComponent, initialProps, rootTag, WrapperComponent) {
    invariant(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);
    var renderable = React.createElement(
      AppContainer,
      {
        rootTag: rootTag,
        WrapperComponent: WrapperComponent,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 34
        }
      },
      React.createElement(RootComponent, babelHelpers.extends({}, initialProps, {
        rootTag: rootTag,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 35
        }
      }))
    );

    if (RootComponent.prototype != null && RootComponent.prototype.unstable_isAsyncReactComponent === true) {
      var AppContainerAsyncWrapper = function (_React$unstable_Async) {
        babelHelpers.inherits(AppContainerAsyncWrapper, _React$unstable_Async);

        function AppContainerAsyncWrapper() {
          babelHelpers.classCallCheck(this, AppContainerAsyncWrapper);
          return babelHelpers.possibleConstructorReturn(this, (AppContainerAsyncWrapper.__proto__ || Object.getPrototypeOf(AppContainerAsyncWrapper)).apply(this, arguments));
        }

        babelHelpers.createClass(AppContainerAsyncWrapper, [{
          key: "render",
          value: function render() {
            return this.props.children;
          }
        }]);
        return AppContainerAsyncWrapper;
      }(React.unstable_AsyncComponent);

      renderable = React.createElement(
        AppContainerAsyncWrapper,
        {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 54
          }
        },
        renderable
      );
    }

    ReactNative.render(renderable, rootTag);
  }

  module.exports = renderApplication;
},356,[302,171,74,18,357],"renderApplication");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var DeviceEventManager = require(_dependencyMap[0], 'NativeModules').DeviceEventManager;

  var RCTDeviceEventEmitter = require(_dependencyMap[1], 'RCTDeviceEventEmitter');

  var DEVICE_BACK_EVENT = 'hardwareBackPress';

  var _backPressSubscriptions = new Set();

  RCTDeviceEventEmitter.addListener(DEVICE_BACK_EVENT, function () {
    var invokeDefault = true;
    var subscriptions = Array.from(_backPressSubscriptions.values()).reverse();

    for (var i = 0; i < subscriptions.length; ++i) {
      if (subscriptions[i]()) {
        invokeDefault = false;
        break;
      }
    }

    if (invokeDefault) {
      BackHandler.exitApp();
    }
  });
  var BackHandler = {
    exitApp: function exitApp() {
      DeviceEventManager.invokeDefaultBackPressHandler();
    },
    addEventListener: function addEventListener(eventName, handler) {
      _backPressSubscriptions.add(handler);

      return {
        remove: function remove() {
          return BackHandler.removeEventListener(eventName, handler);
        }
      };
    },
    removeEventListener: function removeEventListener(eventName, handler) {
      _backPressSubscriptions.delete(handler);
    }
  };
  module.exports = BackHandler;
},357,[68,121],"BackHandler");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = require(_dependencyMap[0], 'NativeModules');

  var RCTAsyncStorage = NativeModules.AsyncRocksDBStorage || NativeModules.AsyncSQLiteDBStorage || NativeModules.AsyncLocalStorage;
  var AsyncStorage = {
    _getRequests: [],
    _getKeys: [],
    _immediate: null,
    getItem: function getItem(key, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiGet([key], function (errors, result) {
          var value = result && result[0] && result[0][1] ? result[0][1] : null;
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0], value);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve(value);
          }
        });
      });
    },
    setItem: function setItem(key, value, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiSet([[key, value]], function (errors) {
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0]);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve(null);
          }
        });
      });
    },
    removeItem: function removeItem(key, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiRemove([key], function (errors) {
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0]);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve(null);
          }
        });
      });
    },
    mergeItem: function mergeItem(key, value, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiMerge([[key, value]], function (errors) {
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0]);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve(null);
          }
        });
      });
    },
    clear: function clear(callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.clear(function (error) {
          callback && callback(convertError(error));

          if (error && convertError(error)) {
            reject(convertError(error));
          } else {
            resolve(null);
          }
        });
      });
    },
    getAllKeys: function getAllKeys(callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.getAllKeys(function (error, keys) {
          callback && callback(convertError(error), keys);

          if (error) {
            reject(convertError(error));
          } else {
            resolve(keys);
          }
        });
      });
    },
    flushGetRequests: function flushGetRequests() {
      var getRequests = this._getRequests;
      var getKeys = this._getKeys;
      this._getRequests = [];
      this._getKeys = [];
      RCTAsyncStorage.multiGet(getKeys, function (errors, result) {
        var map = {};
        result && result.forEach(function (_ref) {
          var _ref2 = babelHelpers.slicedToArray(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          map[key] = value;
          return value;
        });
        var reqLength = getRequests.length;

        for (var i = 0; i < reqLength; i++) {
          var request = getRequests[i];
          var requestKeys = request.keys;
          var requestResult = requestKeys.map(function (key) {
            return [key, map[key]];
          });
          request.callback && request.callback(null, requestResult);
          request.resolve && request.resolve(requestResult);
        }
      });
    },
    multiGet: function multiGet(keys, callback) {
      var _this = this;

      if (!this._immediate) {
        this._immediate = setImmediate(function () {
          _this._immediate = null;

          _this.flushGetRequests();
        });
      }

      var getRequest = {
        keys: keys,
        callback: callback,
        keyIndex: this._getKeys.length,
        resolve: null,
        reject: null
      };
      var promiseResult = new Promise(function (resolve, reject) {
        getRequest.resolve = resolve;
        getRequest.reject = reject;
      });

      this._getRequests.push(getRequest);

      keys.forEach(function (key) {
        if (_this._getKeys.indexOf(key) === -1) {
          _this._getKeys.push(key);
        }
      });
      return promiseResult;
    },
    multiSet: function multiSet(keyValuePairs, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiSet(keyValuePairs, function (errors) {
          var error = convertErrors(errors);
          callback && callback(error);

          if (error) {
            reject(error);
          } else {
            resolve(null);
          }
        });
      });
    },
    multiRemove: function multiRemove(keys, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiRemove(keys, function (errors) {
          var error = convertErrors(errors);
          callback && callback(error);

          if (error) {
            reject(error);
          } else {
            resolve(null);
          }
        });
      });
    },
    multiMerge: function multiMerge(keyValuePairs, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiMerge(keyValuePairs, function (errors) {
          var error = convertErrors(errors);
          callback && callback(error);

          if (error) {
            reject(error);
          } else {
            resolve(null);
          }
        });
      });
    }
  };

  if (!RCTAsyncStorage.multiMerge) {
    delete AsyncStorage.mergeItem;
    delete AsyncStorage.multiMerge;
  }

  function convertErrors(errs) {
    if (!errs) {
      return null;
    }

    return (Array.isArray(errs) ? errs : [errs]).map(function (e) {
      return convertError(e);
    });
  }

  function convertError(error) {
    if (!error) {
      return null;
    }

    var out = new Error(error.message);
    out.key = error.key;
    return out;
  }

  module.exports = AsyncStorage;
},358,[68],"AsyncStorage");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var BackHandler = require(_dependencyMap[0], 'BackHandler');

  var warning = require(_dependencyMap[1], 'fbjs/lib/warning');

  var BackAndroid = {
    exitApp: function exitApp() {
      warning(false, 'BackAndroid is deprecated.  Please use BackHandler instead.');
      BackHandler.exitApp();
    },
    addEventListener: function addEventListener(eventName, handler) {
      warning(false, 'BackAndroid is deprecated.  Please use BackHandler instead.');
      return BackHandler.addEventListener(eventName, handler);
    },
    removeEventListener: function removeEventListener(eventName, handler) {
      warning(false, 'BackAndroid is deprecated.  Please use BackHandler instead.');
      BackHandler.removeEventListener(eventName, handler);
    }
  };
  module.exports = BackAndroid;
},359,[357,19],"BackAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var PropTypes = require(_dependencyMap[0], 'prop-types');

  var checkPropTypes = PropTypes.checkPropTypes;

  var RCTCameraRollManager = require(_dependencyMap[1], 'NativeModules').CameraRollManager;

  var createStrictShapeTypeChecker = require(_dependencyMap[2], 'createStrictShapeTypeChecker');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var GROUP_TYPES_OPTIONS = {
    Album: 'Album',
    All: 'All',
    Event: 'Event',
    Faces: 'Faces',
    Library: 'Library',
    PhotoStream: 'PhotoStream',
    SavedPhotos: 'SavedPhotos'
  };
  var ASSET_TYPE_OPTIONS = {
    All: 'All',
    Videos: 'Videos',
    Photos: 'Photos'
  };
  var getPhotosParamChecker = createStrictShapeTypeChecker({
    first: PropTypes.number.isRequired,
    after: PropTypes.string,
    groupTypes: PropTypes.oneOf(Object.keys(GROUP_TYPES_OPTIONS)),
    groupName: PropTypes.string,
    assetType: PropTypes.oneOf(Object.keys(ASSET_TYPE_OPTIONS)),
    mimeTypes: PropTypes.arrayOf(PropTypes.string)
  });
  var getPhotosReturnChecker = createStrictShapeTypeChecker({
    edges: PropTypes.arrayOf(createStrictShapeTypeChecker({
      node: createStrictShapeTypeChecker({
        type: PropTypes.string.isRequired,
        group_name: PropTypes.string.isRequired,
        image: createStrictShapeTypeChecker({
          uri: PropTypes.string.isRequired,
          height: PropTypes.number.isRequired,
          width: PropTypes.number.isRequired,
          isStored: PropTypes.bool,
          playableDuration: PropTypes.number.isRequired
        }).isRequired,
        timestamp: PropTypes.number.isRequired,
        location: createStrictShapeTypeChecker({
          latitude: PropTypes.number,
          longitude: PropTypes.number,
          altitude: PropTypes.number,
          heading: PropTypes.number,
          speed: PropTypes.number
        })
      }).isRequired
    })).isRequired,
    page_info: createStrictShapeTypeChecker({
      has_next_page: PropTypes.bool.isRequired,
      start_cursor: PropTypes.string,
      end_cursor: PropTypes.string
    }).isRequired
  });

  var CameraRoll = function () {
    function CameraRoll() {
      babelHelpers.classCallCheck(this, CameraRoll);
    }

    babelHelpers.createClass(CameraRoll, null, [{
      key: "saveImageWithTag",
      value: function saveImageWithTag(tag) {
        console.warn('`CameraRoll.saveImageWithTag()` is deprecated. Use `CameraRoll.saveToCameraRoll()` instead.');
        return this.saveToCameraRoll(tag, 'photo');
      }
    }, {
      key: "deletePhotos",
      value: function deletePhotos(photos) {
        return RCTCameraRollManager.deletePhotos(photos);
      }
    }, {
      key: "saveToCameraRoll",
      value: function saveToCameraRoll(tag, type) {
        invariant(typeof tag === 'string', 'CameraRoll.saveToCameraRoll must be a valid string.');
        invariant(type === 'photo' || type === 'video' || type === undefined, "The second argument to saveToCameraRoll must be 'photo' or 'video'. You passed " + (type || 'unknown'));
        var mediaType = 'photo';

        if (type) {
          mediaType = type;
        } else if (['mov', 'mp4'].indexOf(tag.split('.').slice(-1)[0]) >= 0) {
          mediaType = 'video';
        }

        return RCTCameraRollManager.saveToCameraRoll(tag, mediaType);
      }
    }, {
      key: "getPhotos",
      value: function getPhotos(params) {
        if (__DEV__) {
          checkPropTypes({
            params: getPhotosParamChecker
          }, {
            params: params
          }, 'params', 'CameraRoll.getPhotos');
        }

        if (arguments.length > 1) {
          console.warn('CameraRoll.getPhotos(tag, success, error) is deprecated.  Use the returned Promise instead');
          var successCallback = arguments[1];

          if (__DEV__) {
            var callback = arguments[1];

            successCallback = function successCallback(response) {
              checkPropTypes({
                response: getPhotosReturnChecker
              }, {
                response: response
              }, 'response', 'CameraRoll.getPhotos callback');
              callback(response);
            };
          }

          var errorCallback = arguments[2] || function () {};

          RCTCameraRollManager.getPhotos(params).then(successCallback, errorCallback);
        }

        return RCTCameraRollManager.getPhotos(params);
      }
    }]);
    return CameraRoll;
  }();

  CameraRoll.GroupTypesOptions = GROUP_TYPES_OPTIONS;
  CameraRoll.AssetTypeOptions = ASSET_TYPE_OPTIONS;
  module.exports = CameraRoll;
},360,[24,68,174,18],"CameraRoll");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Clipboard = require(_dependencyMap[0], 'NativeModules').Clipboard;

  module.exports = {
    getString: function getString() {
      return Clipboard.getString();
    },
    setString: function setString(content) {
      Clipboard.setString(content);
    }
  };
},361,[68],"Clipboard");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var DatePickerModule = require(_dependencyMap[0], 'NativeModules').DatePickerAndroid;

  function _toMillis(options, key) {
    var dateVal = options[key];

    if (typeof dateVal === 'object' && typeof dateVal.getMonth === 'function') {
      options[key] = dateVal.getTime();
    }
  }

  var DatePickerAndroid = function () {
    function DatePickerAndroid() {
      babelHelpers.classCallCheck(this, DatePickerAndroid);
    }

    babelHelpers.createClass(DatePickerAndroid, null, [{
      key: "open",
      value: function open(options) {
        var optionsMs;
        return regeneratorRuntime.async(function open$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                optionsMs = options;

                if (optionsMs) {
                  _toMillis(options, 'date');

                  _toMillis(options, 'minDate');

                  _toMillis(options, 'maxDate');
                }

                return _context.abrupt("return", DatePickerModule.open(options));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }
    }, {
      key: "dateSetAction",
      get: function get() {
        return 'dateSetAction';
      }
    }, {
      key: "dismissedAction",
      get: function get() {
        return 'dismissedAction';
      }
    }]);
    return DatePickerAndroid;
  }();

  module.exports = DatePickerAndroid;
},362,[68],"DatePickerAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTImagePicker = require(_dependencyMap[0], 'NativeModules').ImagePickerIOS;

  var ImagePickerIOS = {
    canRecordVideos: function canRecordVideos(callback) {
      return RCTImagePicker.canRecordVideos(callback);
    },
    canUseCamera: function canUseCamera(callback) {
      return RCTImagePicker.canUseCamera(callback);
    },
    openCameraDialog: function openCameraDialog(config, successCallback, cancelCallback) {
      config = babelHelpers.extends({
        videoMode: false
      }, config);
      return RCTImagePicker.openCameraDialog(config, successCallback, cancelCallback);
    },
    openSelectDialog: function openSelectDialog(config, successCallback, cancelCallback) {
      config = babelHelpers.extends({
        showImages: true,
        showVideos: false
      }, config);
      return RCTImagePicker.openSelectDialog(config, successCallback, cancelCallback);
    }
  };
  module.exports = ImagePickerIOS;
},363,[68],"ImagePickerIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeEventEmitter = require(_dependencyMap[0], 'NativeEventEmitter');

  var NativeModules = require(_dependencyMap[1], 'NativeModules');

  var Platform = require(_dependencyMap[2], 'Platform');

  var invariant = require(_dependencyMap[3], 'fbjs/lib/invariant');

  var LinkingManager = Platform.OS === 'android' ? NativeModules.IntentAndroid : NativeModules.LinkingManager;

  var Linking = function (_NativeEventEmitter) {
    babelHelpers.inherits(Linking, _NativeEventEmitter);

    function Linking() {
      babelHelpers.classCallCheck(this, Linking);
      return babelHelpers.possibleConstructorReturn(this, (Linking.__proto__ || Object.getPrototypeOf(Linking)).call(this, LinkingManager));
    }

    babelHelpers.createClass(Linking, [{
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        this.addListener(type, handler);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        this.removeListener(type, handler);
      }
    }, {
      key: "openURL",
      value: function openURL(url) {
        this._validateURL(url);

        return LinkingManager.openURL(url);
      }
    }, {
      key: "canOpenURL",
      value: function canOpenURL(url) {
        this._validateURL(url);

        return LinkingManager.canOpenURL(url);
      }
    }, {
      key: "getInitialURL",
      value: function getInitialURL() {
        return LinkingManager.getInitialURL();
      }
    }, {
      key: "_validateURL",
      value: function _validateURL(url) {
        invariant(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);
        invariant(url, 'Invalid URL: cannot be empty');
      }
    }]);
    return Linking;
  }(NativeEventEmitter);

  module.exports = new Linking();
},364,[120,68,105,18],"Linking");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Map = require(_dependencyMap[0], 'Map');

  var NativeEventEmitter = require(_dependencyMap[1], 'NativeEventEmitter');

  var NativeModules = require(_dependencyMap[2], 'NativeModules');

  var Platform = require(_dependencyMap[3], 'Platform');

  var RCTNetInfo = NativeModules.NetInfo;
  var NetInfoEventEmitter = new NativeEventEmitter(RCTNetInfo);
  var DEVICE_CONNECTIVITY_EVENT = 'networkStatusDidChange';

  var _subscriptions = new Map();

  var _isConnectedDeprecated = void 0;

  if (Platform.OS === 'ios') {
    _isConnectedDeprecated = function _isConnectedDeprecated(reachability) {
      return reachability !== 'none' && reachability !== 'unknown';
    };
  } else if (Platform.OS === 'android') {
    _isConnectedDeprecated = function _isConnectedDeprecated(connectionType) {
      return connectionType !== 'NONE' && connectionType !== 'UNKNOWN';
    };
  }

  function _isConnected(connection) {
    return connection.type !== 'none' && connection.type !== 'unknown';
  }

  var _isConnectedSubscriptions = new Map();

  var NetInfo = {
    addEventListener: function addEventListener(eventName, handler) {
      var listener = void 0;

      if (eventName === 'connectionChange') {
        listener = NetInfoEventEmitter.addListener(DEVICE_CONNECTIVITY_EVENT, function (appStateData) {
          handler({
            type: appStateData.connectionType,
            effectiveType: appStateData.effectiveConnectionType
          });
        });
      } else if (eventName === 'change') {
        console.warn('NetInfo\'s "change" event is deprecated. Listen to the "connectionChange" event instead.');
        listener = NetInfoEventEmitter.addListener(DEVICE_CONNECTIVITY_EVENT, function (appStateData) {
          handler(appStateData.network_info);
        });
      } else {
        console.warn('Trying to subscribe to unknown event: "' + eventName + '"');
        return {
          remove: function remove() {}
        };
      }

      _subscriptions.set(handler, listener);

      return {
        remove: function remove() {
          return NetInfo.removeEventListener(eventName, handler);
        }
      };
    },
    removeEventListener: function removeEventListener(eventName, handler) {
      var listener = _subscriptions.get(handler);

      if (!listener) {
        return;
      }

      listener.remove();

      _subscriptions.delete(handler);
    },
    fetch: function fetch() {
      console.warn('NetInfo.fetch() is deprecated. Use NetInfo.getConnectionInfo() instead.');
      return RCTNetInfo.getCurrentConnectivity().then(function (resp) {
        return resp.network_info;
      });
    },
    getConnectionInfo: function getConnectionInfo() {
      return RCTNetInfo.getCurrentConnectivity().then(function (resp) {
        return {
          type: resp.connectionType,
          effectiveType: resp.effectiveConnectionType
        };
      });
    },
    isConnected: {
      addEventListener: function addEventListener(eventName, handler) {
        var listener = function listener(connection) {
          if (eventName === 'change') {
            handler(_isConnectedDeprecated(connection));
          } else if (eventName === 'connectionChange') {
            handler(_isConnected(connection));
          }
        };

        _isConnectedSubscriptions.set(handler, listener);

        NetInfo.addEventListener(eventName, listener);
        return {
          remove: function remove() {
            return NetInfo.isConnected.removeEventListener(eventName, handler);
          }
        };
      },
      removeEventListener: function removeEventListener(eventName, handler) {
        var listener = _isConnectedSubscriptions.get(handler);

        NetInfo.removeEventListener(eventName, listener);

        _isConnectedSubscriptions.delete(handler);
      },
      fetch: function fetch() {
        return NetInfo.getConnectionInfo().then(_isConnected);
      }
    },
    isConnectionExpensive: function isConnectionExpensive() {
      return Platform.OS === 'android' ? RCTNetInfo.isConnectionMetered() : Promise.reject(new Error('Currently not supported on iOS'));
    }
  };
  module.exports = NetInfo;
},365,[79,120,68,105],"NetInfo");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeEventEmitter = require(_dependencyMap[0], 'NativeEventEmitter');

  var RCTPushNotificationManager = require(_dependencyMap[1], 'NativeModules').PushNotificationManager;

  var invariant = require(_dependencyMap[2], 'fbjs/lib/invariant');

  var PushNotificationEmitter = new NativeEventEmitter(RCTPushNotificationManager);

  var _notifHandlers = new Map();

  var DEVICE_NOTIF_EVENT = 'remoteNotificationReceived';
  var NOTIF_REGISTER_EVENT = 'remoteNotificationsRegistered';
  var NOTIF_REGISTRATION_ERROR_EVENT = 'remoteNotificationRegistrationError';
  var DEVICE_LOCAL_NOTIF_EVENT = 'localNotificationReceived';

  var PushNotificationIOS = function () {
    babelHelpers.createClass(PushNotificationIOS, null, [{
      key: "presentLocalNotification",
      value: function presentLocalNotification(details) {
        RCTPushNotificationManager.presentLocalNotification(details);
      }
    }, {
      key: "scheduleLocalNotification",
      value: function scheduleLocalNotification(details) {
        RCTPushNotificationManager.scheduleLocalNotification(details);
      }
    }, {
      key: "cancelAllLocalNotifications",
      value: function cancelAllLocalNotifications() {
        RCTPushNotificationManager.cancelAllLocalNotifications();
      }
    }, {
      key: "removeAllDeliveredNotifications",
      value: function removeAllDeliveredNotifications() {
        RCTPushNotificationManager.removeAllDeliveredNotifications();
      }
    }, {
      key: "getDeliveredNotifications",
      value: function getDeliveredNotifications(callback) {
        RCTPushNotificationManager.getDeliveredNotifications(callback);
      }
    }, {
      key: "removeDeliveredNotifications",
      value: function removeDeliveredNotifications(identifiers) {
        RCTPushNotificationManager.removeDeliveredNotifications(identifiers);
      }
    }, {
      key: "setApplicationIconBadgeNumber",
      value: function setApplicationIconBadgeNumber(number) {
        RCTPushNotificationManager.setApplicationIconBadgeNumber(number);
      }
    }, {
      key: "getApplicationIconBadgeNumber",
      value: function getApplicationIconBadgeNumber(callback) {
        RCTPushNotificationManager.getApplicationIconBadgeNumber(callback);
      }
    }, {
      key: "cancelLocalNotifications",
      value: function cancelLocalNotifications(userInfo) {
        RCTPushNotificationManager.cancelLocalNotifications(userInfo);
      }
    }, {
      key: "getScheduledLocalNotifications",
      value: function getScheduledLocalNotifications(callback) {
        RCTPushNotificationManager.getScheduledLocalNotifications(callback);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        invariant(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');
        var listener;

        if (type === 'notification') {
          listener = PushNotificationEmitter.addListener(DEVICE_NOTIF_EVENT, function (notifData) {
            handler(new PushNotificationIOS(notifData));
          });
        } else if (type === 'localNotification') {
          listener = PushNotificationEmitter.addListener(DEVICE_LOCAL_NOTIF_EVENT, function (notifData) {
            handler(new PushNotificationIOS(notifData));
          });
        } else if (type === 'register') {
          listener = PushNotificationEmitter.addListener(NOTIF_REGISTER_EVENT, function (registrationInfo) {
            handler(registrationInfo.deviceToken);
          });
        } else if (type === 'registrationError') {
          listener = PushNotificationEmitter.addListener(NOTIF_REGISTRATION_ERROR_EVENT, function (errorInfo) {
            handler(errorInfo);
          });
        }

        _notifHandlers.set(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        invariant(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');

        var listener = _notifHandlers.get(type);

        if (!listener) {
          return;
        }

        listener.remove();

        _notifHandlers.delete(type);
      }
    }, {
      key: "requestPermissions",
      value: function requestPermissions(permissions) {
        var requestedPermissions = {};

        if (permissions) {
          requestedPermissions = {
            alert: !!permissions.alert,
            badge: !!permissions.badge,
            sound: !!permissions.sound
          };
        } else {
          requestedPermissions = {
            alert: true,
            badge: true,
            sound: true
          };
        }

        return RCTPushNotificationManager.requestPermissions(requestedPermissions);
      }
    }, {
      key: "abandonPermissions",
      value: function abandonPermissions() {
        RCTPushNotificationManager.abandonPermissions();
      }
    }, {
      key: "checkPermissions",
      value: function checkPermissions(callback) {
        invariant(typeof callback === 'function', 'Must provide a valid callback');
        RCTPushNotificationManager.checkPermissions(callback);
      }
    }, {
      key: "getInitialNotification",
      value: function getInitialNotification() {
        return RCTPushNotificationManager.getInitialNotification().then(function (notification) {
          return notification && new PushNotificationIOS(notification);
        });
      }
    }]);

    function PushNotificationIOS(nativeNotif) {
      var _this = this;

      babelHelpers.classCallCheck(this, PushNotificationIOS);
      this._data = {};
      this._remoteNotificationCompleteCallbackCalled = false;
      this._isRemote = nativeNotif.remote;

      if (this._isRemote) {
        this._notificationId = nativeNotif.notificationId;
      }

      if (nativeNotif.remote) {
        Object.keys(nativeNotif).forEach(function (notifKey) {
          var notifVal = nativeNotif[notifKey];

          if (notifKey === 'aps') {
            _this._alert = notifVal.alert;
            _this._sound = notifVal.sound;
            _this._badgeCount = notifVal.badge;
            _this._category = notifVal.category;
            _this._contentAvailable = notifVal['content-available'];
          } else {
            _this._data[notifKey] = notifVal;
          }
        });
      } else {
        this._badgeCount = nativeNotif.applicationIconBadgeNumber;
        this._sound = nativeNotif.soundName;
        this._alert = nativeNotif.alertBody;
        this._data = nativeNotif.userInfo;
        this._category = nativeNotif.category;
      }
    }

    babelHelpers.createClass(PushNotificationIOS, [{
      key: "finish",
      value: function finish(fetchResult) {
        if (!this._isRemote || !this._notificationId || this._remoteNotificationCompleteCallbackCalled) {
          return;
        }

        this._remoteNotificationCompleteCallbackCalled = true;
        RCTPushNotificationManager.onFinishRemoteNotification(this._notificationId, fetchResult);
      }
    }, {
      key: "getMessage",
      value: function getMessage() {
        return this._alert;
      }
    }, {
      key: "getSound",
      value: function getSound() {
        return this._sound;
      }
    }, {
      key: "getCategory",
      value: function getCategory() {
        return this._category;
      }
    }, {
      key: "getAlert",
      value: function getAlert() {
        return this._alert;
      }
    }, {
      key: "getContentAvailable",
      value: function getContentAvailable() {
        return this._contentAvailable;
      }
    }, {
      key: "getBadgeCount",
      value: function getBadgeCount() {
        return this._badgeCount;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }]);
    return PushNotificationIOS;
  }();

  PushNotificationIOS.FetchResult = {
    NewData: 'UIBackgroundFetchResultNewData',
    NoData: 'UIBackgroundFetchResultNoData',
    ResultFailed: 'UIBackgroundFetchResultFailed'
  };
  module.exports = PushNotificationIOS;
},366,[120,68,18],"PushNotificationIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Settings = {
    get: function get(key) {
      console.warn('Settings is not yet supported on Android');
      return null;
    },
    set: function set(settings) {
      console.warn('Settings is not yet supported on Android');
    },
    watchKeys: function watchKeys(keys, callback) {
      console.warn('Settings is not yet supported on Android');
      return -1;
    },
    clearWatch: function clearWatch(watchId) {
      console.warn('Settings is not yet supported on Android');
    }
  };
  module.exports = Settings;
},367,[],"Settings");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var Platform = require(_dependencyMap[0], 'Platform');

  var invariant = require(_dependencyMap[1], 'fbjs/lib/invariant');

  var processColor = require(_dependencyMap[2], 'processColor');

  var _require = require(_dependencyMap[3], 'NativeModules'),
      ActionSheetManager = _require.ActionSheetManager,
      ShareModule = _require.ShareModule;

  var Share = function () {
    function Share() {
      babelHelpers.classCallCheck(this, Share);
    }

    babelHelpers.createClass(Share, null, [{
      key: "share",
      value: function share(content) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        invariant(typeof content === 'object' && content !== null, 'Content to share must be a valid object');
        invariant(typeof content.url === 'string' || typeof content.message === 'string', 'At least one of URL and message is required');
        invariant(typeof options === 'object' && options !== null, 'Options must be a valid object');

        if (Platform.OS === 'android') {
          invariant(!content.title || typeof content.title === 'string', 'Invalid title: title should be a string.');
          return ShareModule.share(content, options.dialogTitle);
        } else if (Platform.OS === 'ios') {
          return new Promise(function (resolve, reject) {
            ActionSheetManager.showShareActionSheetWithOptions(babelHelpers.extends({}, content, options, {
              tintColor: processColor(options.tintColor)
            }), function (error) {
              return reject(error);
            }, function (success, activityType) {
              if (success) {
                resolve({
                  'action': 'sharedAction',
                  'activityType': activityType
                });
              } else {
                resolve({
                  'action': 'dismissedAction'
                });
              }
            });
          });
        } else {
          return Promise.reject(new Error('Unsupported platform'));
        }
      }
    }, {
      key: "sharedAction",
      get: function get() {
        return 'sharedAction';
      }
    }, {
      key: "dismissedAction",
      get: function get() {
        return 'dismissedAction';
      }
    }]);
    return Share;
  }();

  module.exports = Share;
},368,[105,18,193,68],"Share");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var NativeEventEmitter = require(_dependencyMap[0], 'NativeEventEmitter');

  module.exports = new NativeEventEmitter('StatusBarManager');
},369,[120],"StatusBarIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var TimePickerModule = require(_dependencyMap[0], 'NativeModules').TimePickerAndroid;

  var TimePickerAndroid = function () {
    function TimePickerAndroid() {
      babelHelpers.classCallCheck(this, TimePickerAndroid);
    }

    babelHelpers.createClass(TimePickerAndroid, null, [{
      key: "open",
      value: function open(options) {
        return regeneratorRuntime.async(function open$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", TimePickerModule.open(options));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }
    }, {
      key: "timeSetAction",
      get: function get() {
        return 'timeSetAction';
      }
    }, {
      key: "dismissedAction",
      get: function get() {
        return 'dismissedAction';
      }
    }]);
    return TimePickerAndroid;
  }();

  module.exports = TimePickerAndroid;
},370,[68],"TimePickerAndroid");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var RCTVibration = require(_dependencyMap[0], 'NativeModules').Vibration;

  var Platform = require(_dependencyMap[1], 'Platform');

  var _vibrating = false;
  var _id = 0;

  function vibrateByPattern(pattern) {
    var repeat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (_vibrating) {
      return;
    }

    _vibrating = true;

    if (pattern[0] === 0) {
      RCTVibration.vibrate();
      pattern = pattern.slice(1);
    }

    if (pattern.length === 0) {
      _vibrating = false;
      return;
    }

    setTimeout(function () {
      return vibrateScheduler(++_id, pattern, repeat, 1);
    }, pattern[0]);
  }

  function vibrateScheduler(id, pattern, repeat, nextIndex) {
    if (!_vibrating || id !== _id) {
      return;
    }

    RCTVibration.vibrate();

    if (nextIndex >= pattern.length) {
      if (repeat) {
        nextIndex = 0;
      } else {
        _vibrating = false;
        return;
      }
    }

    setTimeout(function () {
      return vibrateScheduler(id, pattern, repeat, nextIndex + 1);
    }, pattern[nextIndex]);
  }

  var Vibration = {
    vibrate: function vibrate() {
      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 400;
      var repeat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (Platform.OS === 'android') {
        if (typeof pattern === 'number') {
          RCTVibration.vibrate(pattern);
        } else if (Array.isArray(pattern)) {
          RCTVibration.vibrateByPattern(pattern, repeat ? 0 : -1);
        } else {
          throw new Error('Vibration pattern should be a number or array');
        }
      } else {
        if (_vibrating) {
          return;
        }

        if (typeof pattern === 'number') {
          RCTVibration.vibrate();
        } else if (Array.isArray(pattern)) {
          vibrateByPattern(pattern, repeat);
        } else {
          throw new Error('Vibration pattern should be a number or array');
        }
      }
    },
    cancel: function cancel() {
      if (Platform.OS === 'ios') {
        _vibrating = false;
      } else {
        RCTVibration.cancel();
      }
    }
  };
  module.exports = Vibration;
},371,[68,105],"Vibration");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var warning = require(_dependencyMap[0], 'fbjs/lib/warning');

  var VibrationIOS = {
    vibrate: function vibrate() {
      warning('VibrationIOS is not supported on this platform!');
    }
  };
  module.exports = VibrationIOS;
},372,[19],"VibrationIOS");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var _require = require(_dependencyMap[0], 'ReactNative'),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  module.exports = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.takeSnapshot;
},373,[74],"takeSnapshot");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactRedux = require(_dependencyMap[0], "react-redux");

  var _lbryRedux = require(_dependencyMap[1], "lbry-redux");

  var _view = require(_dependencyMap[2], "./view");

  var _view2 = babelHelpers.interopRequireDefault(_view);

  var select = function select(state, props) {
    return {
      claim: (0, _lbryRedux.makeSelectClaimForUri)(props.uri)(state),
      fileInfo: (0, _lbryRedux.makeSelectFileInfoForUri)(props.uri)(state),
      metadata: (0, _lbryRedux.makeSelectMetadataForUri)(props.uri)(state),
      rewardedContentClaimIds: (0, _lbryRedux.selectRewardContentClaimIds)(state, props),
      isResolvingUri: (0, _lbryRedux.makeSelectIsUriResolving)(props.uri)(state)
    };
  };

  var perform = function perform(dispatch) {
    return {
      resolveUri: function resolveUri(uri) {
        return dispatch((0, _lbryRedux.doResolveUri)(uri));
      }
    };
  };

  exports.default = (0, _reactRedux.connect)(select, perform)(_view2.default);
},374,[22,62,375],"LBRYApp/src/component/fileItem/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/component/fileItem/view.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _lbryRedux = require(_dependencyMap[1], "lbry-redux");

  var _reactNavigation = require(_dependencyMap[2], "react-navigation");

  var _reactNative = require(_dependencyMap[3], "react-native");

  var _fileItemMedia = require(_dependencyMap[4], "../fileItemMedia");

  var _fileItemMedia2 = babelHelpers.interopRequireDefault(_fileItemMedia);

  var _filePrice = require(_dependencyMap[5], "../filePrice");

  var _filePrice2 = babelHelpers.interopRequireDefault(_filePrice);

  var _discover = require(_dependencyMap[6], "../../styles/discover");

  var _discover2 = babelHelpers.interopRequireDefault(_discover);

  var FileItem = function (_React$PureComponent) {
    babelHelpers.inherits(FileItem, _React$PureComponent);

    function FileItem(props) {
      babelHelpers.classCallCheck(this, FileItem);
      return babelHelpers.possibleConstructorReturn(this, (FileItem.__proto__ || Object.getPrototypeOf(FileItem)).call(this, props));
    }

    babelHelpers.createClass(FileItem, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.resolve(this.props);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        this.resolve(nextProps);
      }
    }, {
      key: "resolve",
      value: function resolve(props) {
        var isResolvingUri = props.isResolvingUri,
            resolveUri = props.resolveUri,
            claim = props.claim,
            uri = props.uri;

        if (!isResolvingUri && claim === undefined && uri) {
          resolveUri(uri);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            claim = _props.claim,
            fileInfo = _props.fileInfo,
            metadata = _props.metadata,
            isResolvingUri = _props.isResolvingUri,
            rewardedContentClaimIds = _props.rewardedContentClaimIds,
            style = _props.style;
        var uri = (0, _lbryRedux.normalizeURI)(this.props.uri);
        var title = metadata && metadata.title ? metadata.title : uri;
        var thumbnail = metadata && metadata.thumbnail ? metadata.thumbnail : null;
        var obscureNsfw = this.props.obscureNsfw && metadata && metadata.nsfw;
        var isRewardContent = claim && rewardedContentClaimIds.includes(claim.claim_id);
        var channelName = claim ? claim.channel_name : null;
        var description = '';

        if (isResolvingUri && !claim) {
          description = 'Loading...';
        } else if (metadata && metadata.description) {
          description = metadata.description;
        } else if (claim === null) {
          description = 'This address contains no content.';
        }

        return _react2.default.createElement(
          _reactNative.TouchableOpacity,
          {
            style: style,
            onPress: function onPress() {
              _this2.props.navigation.navigate('File', {
                uri: uri
              });
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 57
            }
          },
          _react2.default.createElement(_fileItemMedia2.default, {
            title: title,
            thumbnail: thumbnail,
            resizeMode: "cover",
            __source: {
              fileName: _jsxFileName,
              lineNumber: 61
            }
          }),
          _react2.default.createElement(_filePrice2.default, {
            uri: uri,
            style: _discover2.default.filePriceContainer,
            textStyle: _discover2.default.filePriceText,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 62
            }
          }),
          _react2.default.createElement(
            _reactNative.Text,
            {
              style: _discover2.default.fileItemName,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 63
              }
            },
            title
          ),
          channelName && _react2.default.createElement(
            _reactNative.Text,
            {
              style: _discover2.default.channelName,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 65
              }
            },
            channelName
          )
        );
      }
    }]);
    return FileItem;
  }(_react2.default.PureComponent);

  exports.default = FileItem;
},375,[12,62,376,66,449,452,454],"LBRYApp/src/component/fileItem/view.js");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = {
    get createNavigationContainer() {
      return require(_dependencyMap[0], './createNavigationContainer').default;
    },

    get StateUtils() {
      return require(_dependencyMap[1], './StateUtils').default;
    },

    get addNavigationHelpers() {
      return require(_dependencyMap[2], './addNavigationHelpers').default;
    },

    get NavigationActions() {
      return require(_dependencyMap[3], './NavigationActions').default;
    },

    get createNavigator() {
      return require(_dependencyMap[4], './navigators/createNavigator').default;
    },

    get StackNavigator() {
      return require(_dependencyMap[5], './navigators/StackNavigator').default;
    },

    get SwitchNavigator() {
      return require(_dependencyMap[6], './navigators/SwitchNavigator').default;
    },

    get TabNavigator() {
      return require(_dependencyMap[7], './navigators/TabNavigator').default;
    },

    get DrawerNavigator() {
      return require(_dependencyMap[8], './navigators/DrawerNavigator').default;
    },

    get StackRouter() {
      return require(_dependencyMap[9], './routers/StackRouter').default;
    },

    get TabRouter() {
      return require(_dependencyMap[10], './routers/TabRouter').default;
    },

    get SwitchRouter() {
      return require(_dependencyMap[11], './routers/SwitchRouter').default;
    },

    get Transitioner() {
      return require(_dependencyMap[12], './views/Transitioner').default;
    },

    get CardStackTransitioner() {
      return require(_dependencyMap[13], './views/CardStack/CardStackTransitioner').default;
    },

    get CardStack() {
      return require(_dependencyMap[14], './views/CardStack/CardStack').default;
    },

    get Card() {
      return require(_dependencyMap[15], './views/CardStack/Card').default;
    },

    get SafeAreaView() {
      return require(_dependencyMap[16], 'react-native-safe-area-view').default;
    },

    get Header() {
      return require(_dependencyMap[17], './views/Header/Header').default;
    },

    get HeaderTitle() {
      return require(_dependencyMap[18], './views/Header/HeaderTitle').default;
    },

    get HeaderBackButton() {
      return require(_dependencyMap[19], './views/Header/HeaderBackButton').default;
    },

    get DrawerView() {
      return require(_dependencyMap[20], './views/Drawer/DrawerView').default;
    },

    get DrawerItems() {
      return require(_dependencyMap[21], './views/Drawer/DrawerNavigatorItems').default;
    },

    get TabView() {
      return require(_dependencyMap[22], './views/TabView/TabView').default;
    },

    get TabBarTop() {
      return require(_dependencyMap[23], './views/TabView/TabBarTop').default;
    },

    get TabBarBottom() {
      return require(_dependencyMap[24], './views/TabView/TabBarBottom').default;
    },

    get SwitchView() {
      return require(_dependencyMap[25], './views/SwitchView/SwitchView').default;
    },

    get withNavigation() {
      return require(_dependencyMap[26], './views/withNavigation').default;
    },

    get withNavigationFocus() {
      return require(_dependencyMap[27], './views/withNavigationFocus').default;
    }

  };
},376,[377,382,380,379,383,384,420,424,441,411,425,421,408,385,386,388,392,391,394,395,443,446,426,438,440,422,447,448],"react-navigation/src/react-navigation.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/createNavigationContainer.js";
  exports.default = createNavigationContainer;

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _PlatformHelpers = require(_dependencyMap[2], "./PlatformHelpers");

  var _NavigationActions = require(_dependencyMap[3], "./NavigationActions");

  var _NavigationActions2 = babelHelpers.interopRequireDefault(_NavigationActions);

  var _addNavigationHelpers = require(_dependencyMap[4], "./addNavigationHelpers");

  var _addNavigationHelpers2 = babelHelpers.interopRequireDefault(_addNavigationHelpers);

  var _invariant = require(_dependencyMap[5], "./utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  function createNavigationContainer(Component) {
    var NavigationContainer = function (_React$Component) {
      babelHelpers.inherits(NavigationContainer, _React$Component);

      function NavigationContainer(props) {
        babelHelpers.classCallCheck(this, NavigationContainer);

        var _this = babelHelpers.possibleConstructorReturn(this, (NavigationContainer.__proto__ || Object.getPrototypeOf(NavigationContainer)).call(this, props));

        _this.subs = null;
        _this._actionEventSubscribers = new Set();

        _this._handleOpenURL = function (_ref) {
          var url = _ref.url;

          var parsedUrl = _this._urlToPathAndParams(url);

          if (parsedUrl) {
            var path = parsedUrl.path,
                params = parsedUrl.params;
            var action = Component.router.getActionForPathAndParams(path, params);

            if (action) {
              _this.dispatch(action);
            }
          }
        };

        _this.dispatch = function (action) {
          if (!_this._isStateful()) {
            return false;
          }

          _this._nav = _this._nav || _this.state.nav;
          var oldNav = _this._nav;
          (0, _invariant2.default)(oldNav, 'should be set in constructor if stateful');
          var nav = Component.router.getStateForAction(action, oldNav);

          var dispatchActionEvents = function dispatchActionEvents() {
            _this._actionEventSubscribers.forEach(function (subscriber) {
              return subscriber({
                type: 'action',
                action: action,
                state: nav,
                lastState: oldNav
              });
            });
          };

          if (nav && nav !== oldNav) {
            _this._nav = nav;

            _this.setState({
              nav: nav
            }, function () {
              _this._onNavigationStateChange(oldNav, nav, action);

              dispatchActionEvents();
            });

            return true;
          } else {
            dispatchActionEvents();
          }

          return false;
        };

        _this._validateProps(props);

        _this._initialAction = _NavigationActions2.default.init();

        if (_this._isStateful()) {
          _this.subs = _PlatformHelpers.BackHandler.addEventListener('hardwareBackPress', function () {
            if (!_this._isMounted) {
              _this.subs && _this.subs.remove();
            } else {
              return _this.dispatch(_NavigationActions2.default.back());
            }
          });
        }

        _this.state = {
          nav: _this._isStateful() ? Component.router.getStateForAction(_this._initialAction) : null
        };
        return _this;
      }

      babelHelpers.createClass(NavigationContainer, [{
        key: "_isStateful",
        value: function _isStateful() {
          return !this.props.navigation;
        }
      }, {
        key: "_validateProps",
        value: function _validateProps(props) {
          if (this._isStateful()) {
            return;
          }

          var navigation = props.navigation,
              screenProps = props.screenProps,
              containerProps = babelHelpers.objectWithoutProperties(props, ["navigation", "screenProps"]);
          var keys = Object.keys(containerProps);

          if (keys.length !== 0) {
            throw new Error('This navigator has both navigation and container props, so it is ' + ("unclear if it should own its own state. Remove props: \"" + keys.join(', ') + "\" ") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');
          }
        }
      }, {
        key: "_urlToPathAndParams",
        value: function _urlToPathAndParams(url) {
          var params = {};
          var delimiter = this.props.uriPrefix || '://';
          var path = url.split(delimiter)[1];

          if (typeof path === 'undefined') {
            path = url;
          } else if (path === '') {
            path = '/';
          }

          return {
            path: path,
            params: params
          };
        }
      }, {
        key: "_onNavigationStateChange",
        value: function _onNavigationStateChange(prevNav, nav, action) {
          if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {
            if (console.group) {
              console.group('Navigation Dispatch: ');
              console.log('Action: ', action);
              console.log('New State: ', nav);
              console.log('Last State: ', prevNav);
              console.groupEnd();
            } else {
              console.log('Navigation Dispatch: ', {
                action: action,
                newState: nav,
                lastState: prevNav
              });
            }

            return;
          }

          if (typeof this.props.onNavigationStateChange === 'function') {
            this.props.onNavigationStateChange(prevNav, nav, action);
          }
        }
      }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(nextProps) {
          this._validateProps(nextProps);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          if (this._nav === this.state.nav) {
            this._nav = null;
          }
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this2 = this;

          this._isMounted = true;

          if (!this._isStateful()) {
            return;
          }

          _reactNative.Linking.addEventListener('url', this._handleOpenURL);

          _reactNative.Linking.getInitialURL().then(function (url) {
            return url && _this2._handleOpenURL({
              url: url
            });
          });

          this._actionEventSubscribers.forEach(function (subscriber) {
            return subscriber({
              type: 'action',
              action: _this2._initialAction,
              state: _this2.state.nav,
              lastState: null
            });
          });
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this._isMounted = false;

          _reactNative.Linking.removeEventListener('url', this._handleOpenURL);

          this.subs && this.subs.remove();
        }
      }, {
        key: "render",
        value: function render() {
          var _this3 = this;

          var navigation = this.props.navigation;

          if (this._isStateful()) {
            var nav = this.state.nav;
            (0, _invariant2.default)(nav, 'should be set in constructor if stateful');

            if (!this._navigation || this._navigation.state !== nav) {
              this._navigation = (0, _addNavigationHelpers2.default)({
                dispatch: this.dispatch,
                state: nav,
                addListener: function addListener(eventName, handler) {
                  if (eventName !== 'action') {
                    return {
                      remove: function remove() {}
                    };
                  }

                  _this3._actionEventSubscribers.add(handler);

                  return {
                    remove: function remove() {
                      _this3._actionEventSubscribers.delete(handler);
                    }
                  };
                }
              });
            }

            navigation = this._navigation;
          }

          (0, _invariant2.default)(navigation, 'failed to get navigation');
          return _react2.default.createElement(Component, babelHelpers.extends({}, this.props, {
            navigation: navigation,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 226
            }
          }));
        }
      }]);
      return NavigationContainer;
    }(_react2.default.Component);

    NavigationContainer.router = Component.router;
    NavigationContainer.navigationOptions = null;
    return NavigationContainer;
  }
},377,[12,66,378,379,380,381],"react-navigation/src/createNavigationContainer.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MaskedViewIOS = exports.BackHandler = undefined;

  var _reactNative = require(_dependencyMap[0], "react-native");

  var BackHandler = _reactNative.BackHandler || _reactNative.BackAndroid;
  exports.BackHandler = BackHandler;
  exports.MaskedViewIOS = _reactNative.MaskedViewIOS;
},378,[66],"react-navigation/src/PlatformHelpers.native.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var BACK = 'Navigation/BACK';
  var INIT = 'Navigation/INIT';
  var NAVIGATE = 'Navigation/NAVIGATE';
  var POP = 'Navigation/POP';
  var POP_TO_TOP = 'Navigation/POP_TO_TOP';
  var PUSH = 'Navigation/PUSH';
  var RESET = 'Navigation/RESET';
  var REPLACE = 'Navigation/REPLACE';
  var SET_PARAMS = 'Navigation/SET_PARAMS';
  var URI = 'Navigation/URI';
  var COMPLETE_TRANSITION = 'Navigation/COMPLETE_TRANSITION';

  var createAction = function createAction(type, fn) {
    fn.toString = function () {
      return type;
    };

    return fn;
  };

  var back = createAction(BACK, function () {
    var payload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return {
      type: BACK,
      key: payload.key,
      immediate: payload.immediate
    };
  });
  var init = createAction(INIT, function () {
    var payload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = {
      type: INIT
    };

    if (payload.params) {
      action.params = payload.params;
    }

    return action;
  });
  var navigate = createAction(NAVIGATE, function (payload) {
    var action = {
      type: NAVIGATE,
      routeName: payload.routeName
    };

    if (payload.params) {
      action.params = payload.params;
    }

    if (payload.action) {
      action.action = payload.action;
    }

    if (payload.key) {
      action.key = payload.key;
    }

    return action;
  });
  var pop = createAction(POP, function (payload) {
    return {
      type: POP,
      n: payload && payload.n,
      immediate: payload && payload.immediate
    };
  });
  var popToTop = createAction(POP_TO_TOP, function (payload) {
    return {
      type: POP_TO_TOP,
      immediate: payload && payload.immediate,
      key: payload && payload.key
    };
  });
  var push = createAction(PUSH, function (payload) {
    var action = {
      type: PUSH,
      routeName: payload.routeName
    };

    if (payload.params) {
      action.params = payload.params;
    }

    if (payload.action) {
      action.action = payload.action;
    }

    return action;
  });
  var reset = createAction(RESET, function (payload) {
    return {
      type: RESET,
      index: payload.index,
      key: payload.key,
      actions: payload.actions
    };
  });
  var replace = createAction(REPLACE, function (payload) {
    return {
      type: REPLACE,
      key: payload.key,
      newKey: payload.newKey,
      params: payload.params,
      action: payload.action,
      routeName: payload.routeName,
      immediate: payload.immediate
    };
  });
  var setParams = createAction(SET_PARAMS, function (payload) {
    return {
      type: SET_PARAMS,
      key: payload.key,
      params: payload.params
    };
  });
  var uri = createAction(URI, function (payload) {
    return {
      type: URI,
      uri: payload.uri
    };
  });
  var completeTransition = createAction(COMPLETE_TRANSITION, function (payload) {
    return {
      type: COMPLETE_TRANSITION,
      key: payload && payload.key
    };
  });
  exports.default = {
    BACK: BACK,
    INIT: INIT,
    NAVIGATE: NAVIGATE,
    POP: POP,
    POP_TO_TOP: POP_TO_TOP,
    PUSH: PUSH,
    RESET: RESET,
    REPLACE: REPLACE,
    SET_PARAMS: SET_PARAMS,
    URI: URI,
    COMPLETE_TRANSITION: COMPLETE_TRANSITION,
    back: back,
    init: init,
    navigate: navigate,
    pop: pop,
    popToTop: popToTop,
    push: push,
    reset: reset,
    replace: replace,
    setParams: setParams,
    uri: uri,
    completeTransition: completeTransition
  };
},379,[],"react-navigation/src/NavigationActions.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (navigation) {
    return babelHelpers.extends({}, navigation, {
      goBack: function goBack(key) {
        var actualizedKey = key;

        if (key === undefined && navigation.state.key) {
          (0, _invariant2.default)(typeof navigation.state.key === 'string', 'key should be a string');
          actualizedKey = navigation.state.key;
        }

        return navigation.dispatch(_NavigationActions2.default.back({
          key: actualizedKey
        }));
      },
      navigate: function navigate(navigateTo, params, action) {
        if (typeof navigateTo === 'string') {
          return navigation.dispatch(_NavigationActions2.default.navigate({
            routeName: navigateTo,
            params: params,
            action: action
          }));
        }

        (0, _invariant2.default)(typeof navigateTo === 'object', 'Must navigateTo an object or a string');
        (0, _invariant2.default)(params == null, 'Params must not be provided to .navigate() when specifying an object');
        (0, _invariant2.default)(action == null, 'Child action must not be provided to .navigate() when specifying an object');
        return navigation.dispatch(_NavigationActions2.default.navigate(navigateTo));
      },
      pop: function pop(n, params) {
        return navigation.dispatch(_NavigationActions2.default.pop({
          n: n,
          immediate: params && params.immediate
        }));
      },
      popToTop: function popToTop(params) {
        return navigation.dispatch(_NavigationActions2.default.popToTop({
          immediate: params && params.immediate
        }));
      },
      setParams: function setParams(params) {
        (0, _invariant2.default)(navigation.state.key && typeof navigation.state.key === 'string', 'setParams cannot be called by root navigator');
        var key = navigation.state.key;
        return navigation.dispatch(_NavigationActions2.default.setParams({
          params: params,
          key: key
        }));
      },
      getParam: function getParam(paramName, defaultValue) {
        var params = navigation.state.params;

        if (params && paramName in params) {
          return params[paramName];
        }

        return defaultValue;
      },
      push: function push(routeName, params, action) {
        return navigation.dispatch(_NavigationActions2.default.push({
          routeName: routeName,
          params: params,
          action: action
        }));
      },
      replace: function replace(routeName, params, action) {
        return navigation.dispatch(_NavigationActions2.default.replace({
          routeName: routeName,
          params: params,
          action: action,
          key: navigation.state.key
        }));
      }
    });
  };

  var _NavigationActions = require(_dependencyMap[0], "./NavigationActions");

  var _NavigationActions2 = babelHelpers.interopRequireDefault(_NavigationActions);

  var _invariant = require(_dependencyMap[1], "./utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);
},380,[379,381],"react-navigation/src/addNavigationHelpers.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var validateFormat = function validateFormat(format) {};

  if (__DEV__) {
    validateFormat = function validateFormat(format) {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    };
  }

  function invariant(condition, format, a, b, c, d, e, f) {
    validateFormat(format);

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1;
      throw error;
    }
  }

  module.exports = invariant;
},381,[],"react-navigation/src/utils/invariant.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _invariant = require(_dependencyMap[0], "./utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var StateUtils = {
    get: function get(state, key) {
      return state.routes.find(function (route) {
        return route.key === key;
      }) || null;
    },
    indexOf: function indexOf(state, key) {
      return state.routes.map(function (route) {
        return route.key;
      }).indexOf(key);
    },
    has: function has(state, key) {
      return !!state.routes.some(function (route) {
        return route.key === key;
      });
    },
    push: function push(state, route) {
      (0, _invariant2.default)(StateUtils.indexOf(state, route.key) === -1, 'should not push route with duplicated key %s', route.key);
      var routes = state.routes.slice();
      routes.push(route);
      return babelHelpers.extends({}, state, {
        index: routes.length - 1,
        routes: routes
      });
    },
    pop: function pop(state) {
      if (state.index <= 0) {
        return state;
      }

      var routes = state.routes.slice(0, -1);
      return babelHelpers.extends({}, state, {
        index: routes.length - 1,
        routes: routes
      });
    },
    jumpToIndex: function jumpToIndex(state, index) {
      if (index === state.index) {
        return state;
      }

      (0, _invariant2.default)(!!state.routes[index], 'invalid index %s to jump to', index);
      return babelHelpers.extends({}, state, {
        index: index
      });
    },
    jumpTo: function jumpTo(state, key) {
      var index = StateUtils.indexOf(state, key);
      return StateUtils.jumpToIndex(state, index);
    },
    back: function back(state) {
      var index = state.index - 1;
      var route = state.routes[index];
      return route ? StateUtils.jumpToIndex(state, index) : state;
    },
    forward: function forward(state) {
      var index = state.index + 1;
      var route = state.routes[index];
      return route ? StateUtils.jumpToIndex(state, index) : state;
    },
    replaceAt: function replaceAt(state, key, route) {
      var index = StateUtils.indexOf(state, key);
      return StateUtils.replaceAtIndex(state, index, route);
    },
    replaceAtIndex: function replaceAtIndex(state, index, route) {
      (0, _invariant2.default)(!!state.routes[index], 'invalid index %s for replacing route %s', index, route.key);

      if (state.routes[index] === route) {
        return state;
      }

      var routes = state.routes.slice();
      routes[index] = route;
      return babelHelpers.extends({}, state, {
        index: index,
        routes: routes
      });
    },
    reset: function reset(state, routes, index) {
      (0, _invariant2.default)(routes.length && Array.isArray(routes), 'invalid routes to replace');
      var nextIndex = index === undefined ? routes.length - 1 : index;

      if (state.routes.length === routes.length && state.index === nextIndex) {
        var compare = function compare(route, ii) {
          return routes[ii] === route;
        };

        if (state.routes.every(compare)) {
          return state;
        }
      }

      (0, _invariant2.default)(!!routes[nextIndex], 'invalid index %s to reset', nextIndex);
      return babelHelpers.extends({}, state, {
        index: nextIndex,
        routes: routes
      });
    }
  };
  exports.default = StateUtils;
},382,[381],"react-navigation/src/StateUtils.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/navigators/createNavigator.js";
  exports.default = createNavigator;

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  function createNavigator(router, routeConfigs, navigatorConfig) {
    return function (NavigationView) {
      var Navigator = function (_React$Component) {
        babelHelpers.inherits(Navigator, _React$Component);

        function Navigator() {
          babelHelpers.classCallCheck(this, Navigator);
          return babelHelpers.possibleConstructorReturn(this, (Navigator.__proto__ || Object.getPrototypeOf(Navigator)).apply(this, arguments));
        }

        babelHelpers.createClass(Navigator, [{
          key: "render",
          value: function render() {
            return _react2.default.createElement(NavigationView, babelHelpers.extends({}, this.props, {
              router: router,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 13
              }
            }));
          }
        }]);
        return Navigator;
      }(_react2.default.Component);

      Navigator.router = router;
      Navigator.navigationOptions = null;
      return Navigator;
    };
  }
},383,[12],"react-navigation/src/navigators/createNavigator.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/navigators/StackNavigator.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _createNavigationContainer = require(_dependencyMap[1], "../createNavigationContainer");

  var _createNavigationContainer2 = babelHelpers.interopRequireDefault(_createNavigationContainer);

  var _createNavigator = require(_dependencyMap[2], "./createNavigator");

  var _createNavigator2 = babelHelpers.interopRequireDefault(_createNavigator);

  var _CardStackTransitioner = require(_dependencyMap[3], "../views/CardStack/CardStackTransitioner");

  var _CardStackTransitioner2 = babelHelpers.interopRequireDefault(_CardStackTransitioner);

  var _StackRouter = require(_dependencyMap[4], "../routers/StackRouter");

  var _StackRouter2 = babelHelpers.interopRequireDefault(_StackRouter);

  var _NavigationActions = require(_dependencyMap[5], "../NavigationActions");

  var _NavigationActions2 = babelHelpers.interopRequireDefault(_NavigationActions);

  exports.default = function (routeConfigMap) {
    var stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var initialRouteKey = stackConfig.initialRouteKey,
        initialRouteName = stackConfig.initialRouteName,
        initialRouteParams = stackConfig.initialRouteParams,
        paths = stackConfig.paths,
        headerMode = stackConfig.headerMode,
        headerTransitionPreset = stackConfig.headerTransitionPreset,
        mode = stackConfig.mode,
        cardStyle = stackConfig.cardStyle,
        transitionConfig = stackConfig.transitionConfig,
        onTransitionStart = stackConfig.onTransitionStart,
        _onTransitionEnd = stackConfig.onTransitionEnd,
        navigationOptions = stackConfig.navigationOptions;
    var stackRouterConfig = {
      initialRouteKey: initialRouteKey,
      initialRouteName: initialRouteName,
      initialRouteParams: initialRouteParams,
      paths: paths,
      navigationOptions: navigationOptions
    };
    var router = (0, _StackRouter2.default)(routeConfigMap, stackRouterConfig);
    var navigator = (0, _createNavigator2.default)(router, routeConfigMap, stackConfig)(function (props) {
      return _react2.default.createElement(_CardStackTransitioner2.default, babelHelpers.extends({}, props, {
        headerMode: headerMode,
        headerTransitionPreset: headerTransitionPreset,
        mode: mode,
        cardStyle: cardStyle,
        transitionConfig: transitionConfig,
        onTransitionStart: onTransitionStart,
        onTransitionEnd: function onTransitionEnd(lastTransition, transition) {
          var _props$navigation = props.navigation,
              state = _props$navigation.state,
              dispatch = _props$navigation.dispatch;
          dispatch(_NavigationActions2.default.completeTransition({
            key: state.key
          }));
          _onTransitionEnd && _onTransitionEnd();
        },
        __source: {
          fileName: _jsxFileName,
          lineNumber: 41
        }
      }));
    });
    return (0, _createNavigationContainer2.default)(navigator);
  };
},384,[12,377,383,385,411,379],"react-navigation/src/navigators/StackNavigator.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/CardStack/CardStackTransitioner.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _CardStack = require(_dependencyMap[2], "./CardStack");

  var _CardStack2 = babelHelpers.interopRequireDefault(_CardStack);

  var _CardStackStyleInterpolator = require(_dependencyMap[3], "./CardStackStyleInterpolator");

  var _CardStackStyleInterpolator2 = babelHelpers.interopRequireDefault(_CardStackStyleInterpolator);

  var _Transitioner = require(_dependencyMap[4], "../Transitioner");

  var _Transitioner2 = babelHelpers.interopRequireDefault(_Transitioner);

  var _TransitionConfigs = require(_dependencyMap[5], "./TransitionConfigs");

  var _TransitionConfigs2 = babelHelpers.interopRequireDefault(_TransitionConfigs);

  var NativeAnimatedModule = _reactNative.NativeModules && _reactNative.NativeModules.NativeAnimatedModule;

  var CardStackTransitioner = function (_React$Component) {
    babelHelpers.inherits(CardStackTransitioner, _React$Component);

    function CardStackTransitioner() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, CardStackTransitioner);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = CardStackTransitioner.__proto__ || Object.getPrototypeOf(CardStackTransitioner)).call.apply(_ref, [this].concat(args))), _this), _this._configureTransition = function (transitionProps, prevTransitionProps) {
        var isModal = _this.props.mode === 'modal';
        var transitionSpec = babelHelpers.extends({}, _TransitionConfigs2.default.getTransitionConfig(_this.props.transitionConfig, transitionProps, prevTransitionProps, isModal).transitionSpec);

        if (!!NativeAnimatedModule && _CardStackStyleInterpolator2.default.canUseNativeDriver()) {
          transitionSpec.useNativeDriver = true;
        }

        return transitionSpec;
      }, _this._render = function (props, prevProps) {
        var _this$props = _this.props,
            screenProps = _this$props.screenProps,
            headerMode = _this$props.headerMode,
            headerTransitionPreset = _this$props.headerTransitionPreset,
            mode = _this$props.mode,
            router = _this$props.router,
            cardStyle = _this$props.cardStyle,
            transitionConfig = _this$props.transitionConfig;
        return _react2.default.createElement(_CardStack2.default, {
          screenProps: screenProps,
          headerMode: headerMode,
          headerTransitionPreset: headerTransitionPreset,
          mode: mode,
          router: router,
          cardStyle: cardStyle,
          transitionConfig: transitionConfig,
          transitionProps: props,
          prevTransitionProps: prevProps,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67
          }
        });
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(CardStackTransitioner, [{
      key: "render",
      value: function render() {
        return _react2.default.createElement(_Transitioner2.default, {
          configureTransition: this._configureTransition,
          navigation: this.props.navigation,
          render: this._render,
          onTransitionStart: this.props.onTransitionStart,
          onTransitionEnd: this.props.onTransitionEnd,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 19
          }
        });
      }
    }]);
    return CardStackTransitioner;
  }(_react2.default.Component);

  CardStackTransitioner.defaultProps = {
    mode: 'card'
  };
  exports.default = CardStackTransitioner;
},385,[12,66,386,406,408,405],"react-navigation/src/views/CardStack/CardStackTransitioner.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/CardStack/CardStack.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _clamp = require(_dependencyMap[1], "clamp");

  var _clamp2 = babelHelpers.interopRequireDefault(_clamp);

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _Card = require(_dependencyMap[3], "./Card");

  var _Card2 = babelHelpers.interopRequireDefault(_Card);

  var _Header = require(_dependencyMap[4], "../Header/Header");

  var _Header2 = babelHelpers.interopRequireDefault(_Header);

  var _NavigationActions = require(_dependencyMap[5], "../../NavigationActions");

  var _NavigationActions2 = babelHelpers.interopRequireDefault(_NavigationActions);

  var _addNavigationHelpers = require(_dependencyMap[6], "../../addNavigationHelpers");

  var _addNavigationHelpers2 = babelHelpers.interopRequireDefault(_addNavigationHelpers);

  var _getChildEventSubscriber = require(_dependencyMap[7], "../../getChildEventSubscriber");

  var _getChildEventSubscriber2 = babelHelpers.interopRequireDefault(_getChildEventSubscriber);

  var _SceneView = require(_dependencyMap[8], "../SceneView");

  var _SceneView2 = babelHelpers.interopRequireDefault(_SceneView);

  var _TransitionConfigs = require(_dependencyMap[9], "./TransitionConfigs");

  var _TransitionConfigs2 = babelHelpers.interopRequireDefault(_TransitionConfigs);

  var _ReactNativeFeatures = require(_dependencyMap[10], "../../utils/ReactNativeFeatures");

  var ReactNativeFeatures = babelHelpers.interopRequireWildcard(_ReactNativeFeatures);

  var emptyFunction = function emptyFunction() {};

  var EaseInOut = _reactNative.Easing.inOut(_reactNative.Easing.ease);

  var ANIMATION_DURATION = 500;
  var POSITION_THRESHOLD = 1 / 2;
  var RESPOND_THRESHOLD = 20;
  var GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 25;
  var GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;

  var animatedSubscribeValue = function animatedSubscribeValue(animatedValue) {
    if (!animatedValue.__isNative) {
      return;
    }

    if (Object.keys(animatedValue._listeners).length === 0) {
      animatedValue.addListener(emptyFunction);
    }
  };

  var CardStack = function (_React$Component) {
    babelHelpers.inherits(CardStack, _React$Component);

    function CardStack() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, CardStack);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = CardStack.__proto__ || Object.getPrototypeOf(CardStack)).call.apply(_ref, [this].concat(args))), _this), _this._gestureStartValue = 0, _this._isResponding = false, _this._immediateIndex = null, _this._screenDetails = {}, _this._childEventSubscribers = {}, _this._isRouteFocused = function (route) {
        var state = _this.props.navigation.state;
        var focusedRoute = state.routes[state.index];
        return route === focusedRoute;
      }, _this._getScreenDetails = function (scene) {
        var _this$props = _this.props,
            screenProps = _this$props.screenProps,
            navigation = _this$props.transitionProps.navigation,
            router = _this$props.router;
        var screenDetails = _this._screenDetails[scene.key];

        if (!screenDetails || screenDetails.state !== scene.route) {
          if (!_this._childEventSubscribers[scene.route.key]) {
            _this._childEventSubscribers[scene.route.key] = (0, _getChildEventSubscriber2.default)(navigation.addListener, scene.route.key);
          }

          var screenNavigation = (0, _addNavigationHelpers2.default)({
            dispatch: navigation.dispatch,
            state: scene.route,
            isFocused: _this._isRouteFocused.bind(_this, scene.route),
            addListener: _this._childEventSubscribers[scene.route.key]
          });
          screenDetails = {
            state: scene.route,
            navigation: screenNavigation,
            options: router.getScreenOptions(screenNavigation, screenProps)
          };
          _this._screenDetails[scene.key] = screenDetails;
        }

        return screenDetails;
      }, _this._getTransitionConfig = function () {
        var isModal = _this.props.mode === 'modal';
        return _TransitionConfigs2.default.getTransitionConfig(_this.props.transitionConfig, _this.props.transitionProps, _this.props.prevTransitionProps, isModal);
      }, _this._renderCard = function (scene) {
        var _this$_getTransitionC = _this._getTransitionConfig(),
            screenInterpolator = _this$_getTransitionC.screenInterpolator;

        var style = screenInterpolator && screenInterpolator(babelHelpers.extends({}, _this.props.transitionProps, {
          scene: scene
        }));

        var SceneComponent = _this.props.router.getComponentForRouteName(scene.route.routeName);

        var _this$props2 = _this.props,
            transitionProps = _this$props2.transitionProps,
            props = babelHelpers.objectWithoutProperties(_this$props2, ["transitionProps"]);
        return _react2.default.createElement(
          _Card2.default,
          babelHelpers.extends({}, props, transitionProps, {
            key: "card_" + scene.key,
            style: [style, _this.props.cardStyle],
            scene: scene,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 498
            }
          }),
          _this._renderInnerScene(SceneComponent, scene)
        );
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(CardStack, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(props) {
        var _this2 = this;

        if (props.screenProps !== this.props.screenProps) {
          this._screenDetails = {};
        }

        props.transitionProps.scenes.forEach(function (newScene) {
          if (_this2._screenDetails[newScene.key] && _this2._screenDetails[newScene.key].state !== newScene.route) {
            _this2._screenDetails[newScene.key] = null;
          }
        });
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var _this3 = this;

        var activeKeys = this.props.transitionProps.navigation.state.routes.map(function (route) {
          return route.key;
        });
        Object.keys(this._childEventSubscribers).forEach(function (key) {
          if (!activeKeys.includes(key)) {
            delete _this3._childEventSubscribers[key];
          }
        });
      }
    }, {
      key: "_renderHeader",
      value: function _renderHeader(scene, headerMode) {
        var header = this._getScreenDetails(scene).options.header;

        if (typeof header !== 'undefined' && typeof header !== 'function') {
          return header;
        }

        var renderHeader = header || function (props) {
          return _react2.default.createElement(_Header2.default, babelHelpers.extends({}, props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 152
            }
          }));
        };

        var _getTransitionConfig = this._getTransitionConfig(),
            headerLeftInterpolator = _getTransitionConfig.headerLeftInterpolator,
            headerTitleInterpolator = _getTransitionConfig.headerTitleInterpolator,
            headerRightInterpolator = _getTransitionConfig.headerRightInterpolator;

        var _props = this.props,
            mode = _props.mode,
            transitionProps = _props.transitionProps,
            prevTransitionProps = _props.prevTransitionProps,
            passProps = babelHelpers.objectWithoutProperties(_props, ["mode", "transitionProps", "prevTransitionProps"]);
        return renderHeader(babelHelpers.extends({}, passProps, transitionProps, {
          scene: scene,
          mode: headerMode,
          transitionPreset: this._getHeaderTransitionPreset(),
          getScreenDetails: this._getScreenDetails,
          leftInterpolator: headerLeftInterpolator,
          titleInterpolator: headerTitleInterpolator,
          rightInterpolator: headerRightInterpolator
        }));
      }
    }, {
      key: "_animatedSubscribe",
      value: function _animatedSubscribe(props) {
        animatedSubscribeValue(props.transitionProps.layout.width);
        animatedSubscribeValue(props.transitionProps.layout.height);
        animatedSubscribeValue(props.transitionProps.position);
      }
    }, {
      key: "_reset",
      value: function _reset(resetToIndex, duration) {
        if (_reactNative.Platform.OS === 'ios' && ReactNativeFeatures.supportsImprovedSpringAnimation()) {
          _reactNative.Animated.spring(this.props.transitionProps.position, {
            toValue: resetToIndex,
            stiffness: 5000,
            damping: 600,
            mass: 3,
            useNativeDriver: this.props.transitionProps.position.__isNative
          }).start();
        } else {
          _reactNative.Animated.timing(this.props.transitionProps.position, {
            toValue: resetToIndex,
            duration: duration,
            easing: EaseInOut,
            useNativeDriver: this.props.transitionProps.position.__isNative
          }).start();
        }
      }
    }, {
      key: "_goBack",
      value: function _goBack(backFromIndex, duration) {
        var _this4 = this;

        var _props$transitionProp = this.props.transitionProps,
            navigation = _props$transitionProp.navigation,
            position = _props$transitionProp.position,
            scenes = _props$transitionProp.scenes;
        var toValue = Math.max(backFromIndex - 1, 0);
        this._immediateIndex = toValue;

        var onCompleteAnimation = function onCompleteAnimation() {
          _this4._immediateIndex = null;
          var backFromScene = scenes.find(function (s) {
            return s.index === toValue + 1;
          });

          if (!_this4._isResponding && backFromScene) {
            navigation.dispatch(_NavigationActions2.default.back({
              key: backFromScene.route.key,
              immediate: true
            }));
          }
        };

        if (_reactNative.Platform.OS === 'ios' && ReactNativeFeatures.supportsImprovedSpringAnimation()) {
          _reactNative.Animated.spring(position, {
            toValue: toValue,
            stiffness: 5000,
            damping: 600,
            mass: 3,
            useNativeDriver: position.__isNative
          }).start(onCompleteAnimation);
        } else {
          _reactNative.Animated.timing(position, {
            toValue: toValue,
            duration: duration,
            easing: EaseInOut,
            useNativeDriver: position.__isNative
          }).start(onCompleteAnimation);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this5 = this;

        var floatingHeader = null;

        var headerMode = this._getHeaderMode();

        if (headerMode === 'float') {
          floatingHeader = this._renderHeader(this.props.transitionProps.scene, headerMode);
        }

        var _props2 = this.props,
            _props2$transitionPro = _props2.transitionProps,
            navigation = _props2$transitionPro.navigation,
            position = _props2$transitionPro.position,
            layout = _props2$transitionPro.layout,
            scene = _props2$transitionPro.scene,
            scenes = _props2$transitionPro.scenes,
            mode = _props2.mode;
        var index = navigation.state.index;
        var isVertical = mode === 'modal';

        var _getScreenDetails = this._getScreenDetails(scene),
            options = _getScreenDetails.options;

        var gestureDirectionInverted = options.gestureDirection === 'inverted';
        var gesturesEnabled = typeof options.gesturesEnabled === 'boolean' ? options.gesturesEnabled : _reactNative.Platform.OS === 'ios';
        var responder = !gesturesEnabled ? null : _reactNative.PanResponder.create({
          onPanResponderTerminate: function onPanResponderTerminate() {
            _this5._isResponding = false;

            _this5._reset(index, 0);
          },
          onPanResponderGrant: function onPanResponderGrant() {
            position.stopAnimation(function (value) {
              _this5._isResponding = true;
              _this5._gestureStartValue = value;
            });
          },
          onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(event, gesture) {
            if (index !== scene.index) {
              return false;
            }

            var immediateIndex = _this5._immediateIndex == null ? index : _this5._immediateIndex;
            var currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];
            var currentDragPosition = event.nativeEvent[isVertical ? 'pageY' : 'pageX'];
            var axisLength = isVertical ? layout.height.__getValue() : layout.width.__getValue();
            var axisHasBeenMeasured = !!axisLength;
            var screenEdgeDistance = gestureDirectionInverted ? axisLength - (currentDragPosition - currentDragDistance) : currentDragPosition - currentDragDistance;

            var _getScreenDetails$opt = _this5._getScreenDetails(scene).options.gestureResponseDistance,
                userGestureResponseDistance = _getScreenDetails$opt === undefined ? {} : _getScreenDetails$opt;

            var gestureResponseDistance = isVertical ? userGestureResponseDistance.vertical || GESTURE_RESPONSE_DISTANCE_VERTICAL : userGestureResponseDistance.horizontal || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;

            if (screenEdgeDistance > gestureResponseDistance) {
              return false;
            }

            var hasDraggedEnough = Math.abs(currentDragDistance) > RESPOND_THRESHOLD;
            var isOnFirstCard = immediateIndex === 0;
            var shouldSetResponder = hasDraggedEnough && axisHasBeenMeasured && !isOnFirstCard;
            return shouldSetResponder;
          },
          onPanResponderMove: function onPanResponderMove(event, gesture) {
            var startValue = _this5._gestureStartValue;
            var axis = isVertical ? 'dy' : 'dx';
            var axisDistance = isVertical ? layout.height.__getValue() : layout.width.__getValue();
            var currentValue = (_reactNative.I18nManager.isRTL && axis === 'dx') !== gestureDirectionInverted ? startValue + gesture[axis] / axisDistance : startValue - gesture[axis] / axisDistance;
            var value = (0, _clamp2.default)(index - 1, currentValue, index);
            position.setValue(value);
          },
          onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {
            return false;
          },
          onPanResponderRelease: function onPanResponderRelease(event, gesture) {
            if (!_this5._isResponding) {
              return;
            }

            _this5._isResponding = false;
            var immediateIndex = _this5._immediateIndex == null ? index : _this5._immediateIndex;
            var axisDistance = isVertical ? layout.height.__getValue() : layout.width.__getValue();
            var movementDirection = gestureDirectionInverted ? -1 : 1;
            var movedDistance = movementDirection * gesture[isVertical ? 'dy' : 'dx'];
            var gestureVelocity = movementDirection * gesture[isVertical ? 'vy' : 'vx'];
            var defaultVelocity = axisDistance / ANIMATION_DURATION;
            var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);
            var resetDuration = gestureDirectionInverted ? (axisDistance - movedDistance) / velocity : movedDistance / velocity;
            var goBackDuration = gestureDirectionInverted ? movedDistance / velocity : (axisDistance - movedDistance) / velocity;
            position.stopAnimation(function (value) {
              if (gestureVelocity < -0.5) {
                _this5._reset(immediateIndex, resetDuration);

                return;
              }

              if (gestureVelocity > 0.5) {
                _this5._goBack(immediateIndex, goBackDuration);

                return;
              }

              if (value <= index - POSITION_THRESHOLD) {
                _this5._goBack(immediateIndex, goBackDuration);
              } else {
                _this5._reset(immediateIndex, resetDuration);
              }
            });
          }
        });
        var handlers = gesturesEnabled ? responder.panHandlers : {};
        var containerStyle = [styles.container, this._getTransitionConfig().containerStyle];
        return _react2.default.createElement(
          _reactNative.View,
          babelHelpers.extends({}, handlers, {
            style: containerStyle,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 413
            }
          }),
          _react2.default.createElement(
            _reactNative.View,
            {
              style: styles.scenes,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 414
              }
            },
            scenes.map(function (s) {
              return _this5._renderCard(s);
            })
          ),
          floatingHeader
        );
      }
    }, {
      key: "_getHeaderMode",
      value: function _getHeaderMode() {
        if (this.props.headerMode) {
          return this.props.headerMode;
        }

        if (_reactNative.Platform.OS === 'android' || this.props.mode === 'modal') {
          return 'screen';
        }

        return 'float';
      }
    }, {
      key: "_getHeaderTransitionPreset",
      value: function _getHeaderTransitionPreset() {
        if (_reactNative.Platform.OS === 'android' || this._getHeaderMode() === 'screen') {
          return 'fade-in-place';
        }

        if (this.props.headerTransitionPreset) {
          return this.props.headerTransitionPreset;
        } else {
          return 'fade-in-place';
        }
      }
    }, {
      key: "_renderInnerScene",
      value: function _renderInnerScene(SceneComponent, scene) {
        var _getScreenDetails2 = this._getScreenDetails(scene),
            navigation = _getScreenDetails2.navigation;

        var screenProps = this.props.screenProps;

        var headerMode = this._getHeaderMode();

        if (headerMode === 'screen') {
          return _react2.default.createElement(
            _reactNative.View,
            {
              style: styles.container,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 453
              }
            },
            _react2.default.createElement(
              _reactNative.View,
              {
                style: {
                  flex: 1
                },
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 454
                }
              },
              _react2.default.createElement(_SceneView2.default, {
                screenProps: screenProps,
                navigation: navigation,
                component: SceneComponent,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 455
                }
              })
            ),
            this._renderHeader(scene, headerMode)
          );
        }

        return _react2.default.createElement(_SceneView2.default, {
          screenProps: this.props.screenProps,
          navigation: navigation,
          component: SceneComponent,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 466
          }
        });
      }
    }]);
    return CardStack;
  }(_react2.default.Component);

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      flexDirection: 'column-reverse'
    },
    scenes: {
      flex: 1
    }
  });

  exports.default = CardStack;
},386,[12,387,66,388,391,379,380,403,404,405,407],"react-navigation/src/views/CardStack/CardStack.js");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = clamp;

  function clamp(value, min, max) {
    return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
  }
},387,[],"clamp/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/CardStack/Card.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _PointerEventsContainer = require(_dependencyMap[2], "./PointerEventsContainer");

  var _PointerEventsContainer2 = babelHelpers.interopRequireDefault(_PointerEventsContainer);

  var Card = function (_React$Component) {
    babelHelpers.inherits(Card, _React$Component);

    function Card() {
      babelHelpers.classCallCheck(this, Card);
      return babelHelpers.possibleConstructorReturn(this, (Card.__proto__ || Object.getPrototypeOf(Card)).apply(this, arguments));
    }

    babelHelpers.createClass(Card, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            children = _props.children,
            pointerEvents = _props.pointerEvents,
            style = _props.style;
        return _react2.default.createElement(
          _reactNative.Animated.View,
          {
            pointerEvents: pointerEvents,
            ref: this.props.onComponentRef,
            style: [styles.main, style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 12
            }
          },
          children
        );
      }
    }]);
    return Card;
  }(_react2.default.Component);

  var styles = _reactNative.StyleSheet.create({
    main: {
      backgroundColor: '#EFEFF4',
      bottom: 0,
      left: 0,
      position: 'absolute',
      right: 0,
      shadowColor: 'black',
      shadowOffset: {
        width: 0,
        height: 0
      },
      shadowOpacity: 0.2,
      shadowRadius: 5,
      top: 0
    }
  });

  Card = (0, _PointerEventsContainer2.default)(Card);
  exports.default = Card;
},388,[12,66,389],"react-navigation/src/views/CardStack/Card.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/CardStack/PointerEventsContainer.js";
  exports.default = create;

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _invariant = require(_dependencyMap[1], "../../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var _AnimatedValueSubscription = require(_dependencyMap[2], "../AnimatedValueSubscription");

  var _AnimatedValueSubscription2 = babelHelpers.interopRequireDefault(_AnimatedValueSubscription);

  var MIN_POSITION_OFFSET = 0.01;

  function create(Component) {
    var Container = function (_React$Component) {
      babelHelpers.inherits(Container, _React$Component);

      function Container(props, context) {
        babelHelpers.classCallCheck(this, Container);

        var _this = babelHelpers.possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this, props, context));

        _this._pointerEvents = _this._computePointerEvents();
        return _this;
      }

      babelHelpers.createClass(Container, [{
        key: "componentWillMount",
        value: function componentWillMount() {
          this._onPositionChange = this._onPositionChange.bind(this);
          this._onComponentRef = this._onComponentRef.bind(this);
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          this._bindPosition(this.props);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this._positionListener && this._positionListener.remove();
        }
      }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(nextProps) {
          this._bindPosition(nextProps);
        }
      }, {
        key: "render",
        value: function render() {
          this._pointerEvents = this._computePointerEvents();
          return _react2.default.createElement(Component, babelHelpers.extends({}, this.props, {
            pointerEvents: this._pointerEvents,
            onComponentRef: this._onComponentRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 39
            }
          }));
        }
      }, {
        key: "_onComponentRef",
        value: function _onComponentRef(component) {
          this._component = component;

          if (component) {
            (0, _invariant2.default)(typeof component.setNativeProps === 'function', 'component must implement method `setNativeProps`');
          }
        }
      }, {
        key: "_bindPosition",
        value: function _bindPosition(props) {
          this._positionListener && this._positionListener.remove();
          this._positionListener = new _AnimatedValueSubscription2.default(props.position, this._onPositionChange);
        }
      }, {
        key: "_onPositionChange",
        value: function _onPositionChange() {
          if (this._component) {
            var pointerEvents = this._computePointerEvents();

            if (this._pointerEvents !== pointerEvents) {
              this._pointerEvents = pointerEvents;

              this._component.setNativeProps({
                pointerEvents: pointerEvents
              });
            }
          }
        }
      }, {
        key: "_computePointerEvents",
        value: function _computePointerEvents() {
          var _props = this.props,
              navigation = _props.navigation,
              position = _props.position,
              scene = _props.scene;

          if (scene.isStale || navigation.state.index !== scene.index) {
            return scene.index > navigation.state.index ? 'box-only' : 'none';
          }

          var offset = position.__getAnimatedValue() - navigation.state.index;

          if (Math.abs(offset) > MIN_POSITION_OFFSET) {
            return 'box-only';
          }

          return 'auto';
        }
      }]);
      return Container;
    }(_react2.default.Component);

    return Container;
  }
},389,[12,381,390],"react-navigation/src/views/CardStack/PointerEventsContainer.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var AnimatedValueSubscription = function () {
    function AnimatedValueSubscription(value, callback) {
      babelHelpers.classCallCheck(this, AnimatedValueSubscription);
      this._value = value;
      this._token = value.addListener(callback);
    }

    babelHelpers.createClass(AnimatedValueSubscription, [{
      key: "remove",
      value: function remove() {
        this._value.removeListener(this._token);
      }
    }]);
    return AnimatedValueSubscription;
  }();

  exports.default = AnimatedValueSubscription;
},390,[66],"react-navigation/src/views/AnimatedValueSubscription.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/Header/Header.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _PlatformHelpers = require(_dependencyMap[2], "../../PlatformHelpers");

  var _reactNativeSafeAreaView = require(_dependencyMap[3], "react-native-safe-area-view");

  var _reactNativeSafeAreaView2 = babelHelpers.interopRequireDefault(_reactNativeSafeAreaView);

  var _HeaderTitle = require(_dependencyMap[4], "./HeaderTitle");

  var _HeaderTitle2 = babelHelpers.interopRequireDefault(_HeaderTitle);

  var _HeaderBackButton = require(_dependencyMap[5], "./HeaderBackButton");

  var _HeaderBackButton2 = babelHelpers.interopRequireDefault(_HeaderBackButton);

  var _ModularHeaderBackButton = require(_dependencyMap[6], "./ModularHeaderBackButton");

  var _ModularHeaderBackButton2 = babelHelpers.interopRequireDefault(_ModularHeaderBackButton);

  var _HeaderStyleInterpolator = require(_dependencyMap[7], "./HeaderStyleInterpolator");

  var _HeaderStyleInterpolator2 = babelHelpers.interopRequireDefault(_HeaderStyleInterpolator);

  var _withOrientation = require(_dependencyMap[8], "../withOrientation");

  var _withOrientation2 = babelHelpers.interopRequireDefault(_withOrientation);

  var APPBAR_HEIGHT = _reactNative.Platform.OS === 'ios' ? 44 : 56;
  var STATUSBAR_HEIGHT = _reactNative.Platform.OS === 'ios' ? 20 : 0;
  var TITLE_OFFSET = _reactNative.Platform.OS === 'ios' ? 70 : 56;

  var getAppBarHeight = function getAppBarHeight(isLandscape) {
    return _reactNative.Platform.OS === 'ios' ? isLandscape && !_reactNative.Platform.isPad ? 32 : 44 : 56;
  };

  var Header = function (_React$PureComponent) {
    babelHelpers.inherits(Header, _React$PureComponent);

    function Header() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, Header);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = Header.__proto__ || Object.getPrototypeOf(Header)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        widths: {}
      }, _this._navigateBack = function () {
        requestAnimationFrame(function () {
          _this.props.navigation.goBack(_this.props.scene.route.key);
        });
      }, _this._renderTitleComponent = function (props) {
        var details = _this.props.getScreenDetails(props.scene);

        var headerTitle = details.options.headerTitle;

        if (_react2.default.isValidElement(headerTitle)) {
          return headerTitle;
        }

        var titleString = _this._getHeaderTitleString(props.scene);

        var titleStyle = details.options.headerTitleStyle;
        var color = details.options.headerTintColor;
        var allowFontScaling = details.options.headerTitleAllowFontScaling;
        var onLayoutIOS = _reactNative.Platform.OS === 'ios' ? function (e) {
          _this.setState({
            widths: babelHelpers.extends({}, _this.state.widths, babelHelpers.defineProperty({}, props.scene.key, e.nativeEvent.layout.width))
          });
        } : undefined;
        var RenderedHeaderTitle = headerTitle && typeof headerTitle !== 'string' ? headerTitle : _HeaderTitle2.default;
        return _react2.default.createElement(
          RenderedHeaderTitle,
          {
            onLayout: onLayoutIOS,
            allowFontScaling: allowFontScaling == null ? true : allowFontScaling,
            style: [color ? {
              color: color
            } : null, titleStyle],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 119
            }
          },
          titleString
        );
      }, _this._renderLeftComponent = function (props) {
        var _this$props$getScreen = _this.props.getScreenDetails(props.scene),
            options = _this$props$getScreen.options;

        if (_react2.default.isValidElement(options.headerLeft) || options.headerLeft === null) {
          return options.headerLeft;
        }

        if (props.scene.index === 0) {
          return;
        }

        var backButtonTitle = _this._getBackButtonTitleString(props.scene);

        var truncatedBackButtonTitle = _this._getTruncatedBackButtonTitle(props.scene);

        var width = _this.state.widths[props.scene.key] ? (_this.props.layout.initWidth - _this.state.widths[props.scene.key]) / 2 : undefined;
        var RenderedLeftComponent = options.headerLeft || _HeaderBackButton2.default;
        return _react2.default.createElement(RenderedLeftComponent, {
          onPress: _this._navigateBack,
          pressColorAndroid: options.headerPressColorAndroid,
          tintColor: options.headerTintColor,
          buttonImage: options.headerBackImage,
          title: backButtonTitle,
          truncatedTitle: truncatedBackButtonTitle,
          titleStyle: options.headerBackTitleStyle,
          width: width,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 152
          }
        });
      }, _this._renderModularLeftComponent = function (props, ButtonContainerComponent, LabelContainerComponent) {
        var _this$props$getScreen2 = _this.props.getScreenDetails(props.scene),
            options = _this$props$getScreen2.options;

        var backButtonTitle = _this._getBackButtonTitleString(props.scene);

        var truncatedBackButtonTitle = _this._getTruncatedBackButtonTitle(props.scene);

        var width = _this.state.widths[props.scene.key] ? (_this.props.layout.initWidth - _this.state.widths[props.scene.key]) / 2 : undefined;
        return _react2.default.createElement(_ModularHeaderBackButton2.default, {
          onPress: _this._navigateBack,
          ButtonContainerComponent: ButtonContainerComponent,
          LabelContainerComponent: LabelContainerComponent,
          pressColorAndroid: options.headerPressColorAndroid,
          tintColor: options.headerTintColor,
          buttonImage: options.headerBackImage,
          title: backButtonTitle,
          truncatedTitle: truncatedBackButtonTitle,
          titleStyle: options.headerBackTitleStyle,
          width: width,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 180
          }
        });
      }, _this._renderRightComponent = function (props) {
        var details = _this.props.getScreenDetails(props.scene);

        var headerRight = details.options.headerRight;
        return headerRight || null;
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(Header, [{
      key: "_getHeaderTitleString",
      value: function _getHeaderTitleString(scene) {
        var sceneOptions = this.props.getScreenDetails(scene).options;

        if (typeof sceneOptions.headerTitle === 'string') {
          return sceneOptions.headerTitle;
        }

        return sceneOptions.title;
      }
    }, {
      key: "_getLastScene",
      value: function _getLastScene(scene) {
        return this.props.scenes.find(function (s) {
          return s.index === scene.index - 1;
        });
      }
    }, {
      key: "_getBackButtonTitleString",
      value: function _getBackButtonTitleString(scene) {
        var lastScene = this._getLastScene(scene);

        if (!lastScene) {
          return null;
        }

        var headerBackTitle = this.props.getScreenDetails(lastScene).options.headerBackTitle;

        if (headerBackTitle || headerBackTitle === null) {
          return headerBackTitle;
        }

        return this._getHeaderTitleString(lastScene);
      }
    }, {
      key: "_getTruncatedBackButtonTitle",
      value: function _getTruncatedBackButtonTitle(scene) {
        var lastScene = this._getLastScene(scene);

        if (!lastScene) {
          return null;
        }

        return this.props.getScreenDetails(lastScene).options.headerTruncatedBackTitle;
      }
    }, {
      key: "_renderLeft",
      value: function _renderLeft(props) {
        var _props$getScreenDetai = this.props.getScreenDetails(props.scene),
            options = _props$getScreenDetai.options;

        var transitionPreset = this.props.transitionPreset;

        if (transitionPreset !== 'uikit' || options.headerBackImage || options.headerLeft || options.headerLeft === null) {
          return this._renderSubView(props, 'left', this._renderLeftComponent, this.props.leftInterpolator);
        } else {
          return this._renderModularSubView(props, 'left', this._renderModularLeftComponent, this.props.leftLabelInterpolator, this.props.leftButtonInterpolator);
        }
      }
    }, {
      key: "_renderTitle",
      value: function _renderTitle(props, options) {
        var style = {};
        var transitionPreset = this.props.transitionPreset;

        if (_reactNative.Platform.OS === 'android') {
          if (!options.hasLeftComponent) {
            style.left = 0;
          }

          if (!options.hasRightComponent) {
            style.right = 0;
          }
        } else if (_reactNative.Platform.OS === 'ios' && !options.hasLeftComponent && !options.hasRightComponent) {
          style.left = 0;
          style.right = 0;
        }

        return this._renderSubView(babelHelpers.extends({}, props, {
          style: style
        }), 'title', this._renderTitleComponent, transitionPreset === 'uikit' ? this.props.titleFromLeftInterpolator : this.props.titleInterpolator);
      }
    }, {
      key: "_renderRight",
      value: function _renderRight(props) {
        return this._renderSubView(props, 'right', this._renderRightComponent, this.props.rightInterpolator);
      }
    }, {
      key: "_renderModularSubView",
      value: function _renderModularSubView(props, name, renderer, labelStyleInterpolator, buttonStyleInterpolator) {
        var _this2 = this;

        var scene = props.scene;
        var index = scene.index,
            isStale = scene.isStale,
            key = scene.key;

        if (index === 0) {
          return;
        }

        var offset = this.props.navigation.state.index - index;

        if (Math.abs(offset) > 2) {
          return null;
        }

        var ButtonContainer = function ButtonContainer(_ref2) {
          var children = _ref2.children;
          return _react2.default.createElement(
            _reactNative.Animated.View,
            {
              style: [buttonStyleInterpolator(babelHelpers.extends({}, _this2.props, props))],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 294
              }
            },
            children
          );
        };

        var LabelContainer = function LabelContainer(_ref3) {
          var children = _ref3.children;
          return _react2.default.createElement(
            _reactNative.Animated.View,
            {
              style: [labelStyleInterpolator(babelHelpers.extends({}, _this2.props, props))],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 302
              }
            },
            children
          );
        };

        var subView = renderer(props, ButtonContainer, LabelContainer);

        if (subView === null) {
          return subView;
        }

        var pointerEvents = offset !== 0 || isStale ? 'none' : 'box-none';
        return _react2.default.createElement(
          _reactNative.View,
          {
            key: name + "_" + key,
            pointerEvents: pointerEvents,
            style: [styles.item, styles[name], props.style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 318
            }
          },
          subView
        );
      }
    }, {
      key: "_renderSubView",
      value: function _renderSubView(props, name, renderer, styleInterpolator) {
        var scene = props.scene;
        var index = scene.index,
            isStale = scene.isStale,
            key = scene.key;
        var offset = this.props.navigation.state.index - index;

        if (Math.abs(offset) > 2) {
          return null;
        }

        var subView = renderer(props);

        if (subView == null) {
          return null;
        }

        var pointerEvents = offset !== 0 || isStale ? 'none' : 'box-none';
        return _react2.default.createElement(
          _reactNative.Animated.View,
          {
            pointerEvents: pointerEvents,
            key: name + "_" + key,
            style: [styles.item, styles[name], props.style, styleInterpolator(babelHelpers.extends({}, this.props, props))],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 349
            }
          },
          subView
        );
      }
    }, {
      key: "_renderHeader",
      value: function _renderHeader(props) {
        var left = this._renderLeft(props);

        var right = this._renderRight(props);

        var title = this._renderTitle(props, {
          hasLeftComponent: !!left,
          hasRightComponent: !!right
        });

        var _props = this.props,
            isLandscape = _props.isLandscape,
            transitionPreset = _props.transitionPreset;

        var _props$getScreenDetai2 = this.props.getScreenDetails(props.scene),
            options = _props$getScreenDetai2.options;

        var wrapperProps = {
          style: styles.header,
          key: "scene_" + props.scene.key
        };

        if (options.headerLeft || options.headerBackImage || _reactNative.Platform.OS !== 'ios' || transitionPreset !== 'uikit') {
          return _react2.default.createElement(
            _reactNative.View,
            babelHelpers.extends({}, wrapperProps, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 391
              }
            }),
            title,
            left,
            right
          );
        } else {
          return _react2.default.createElement(
            _PlatformHelpers.MaskedViewIOS,
            babelHelpers.extends({}, wrapperProps, {
              maskElement: _react2.default.createElement(
                _reactNative.View,
                {
                  style: styles.iconMaskContainer,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 402
                  }
                },
                _react2.default.createElement(_reactNative.Image, {
                  source: require(_dependencyMap[9], '../assets/back-icon-mask.png'),
                  style: styles.iconMask,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 403
                  }
                }),
                _react2.default.createElement(_reactNative.View, {
                  style: styles.iconMaskFillerRect,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 407
                  }
                })
              ),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 399
              }
            }),
            title,
            left,
            right
          );
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var appBar = void 0;
        var _props2 = this.props,
            mode = _props2.mode,
            scene = _props2.scene,
            isLandscape = _props2.isLandscape;

        if (mode === 'float') {
          var scenesByIndex = {};
          this.props.scenes.forEach(function (scene) {
            scenesByIndex[scene.index] = scene;
          });
          var scenesProps = Object.values(scenesByIndex).map(function (scene) {
            return {
              position: _this3.props.position,
              progress: _this3.props.progress,
              scene: scene
            };
          });
          appBar = scenesProps.map(this._renderHeader, this);
        } else {
          appBar = this._renderHeader({
            position: new _reactNative.Animated.Value(this.props.scene.index),
            progress: new _reactNative.Animated.Value(0),
            scene: this.props.scene
          });
        }

        var _props$getScreenDetai3 = this.props.getScreenDetails(scene),
            options = _props$getScreenDetai3.options;

        var _options$headerStyle = options.headerStyle,
            headerStyle = _options$headerStyle === undefined ? {} : _options$headerStyle;

        var headerStyleObj = _reactNative.StyleSheet.flatten(headerStyle);

        var appBarHeight = getAppBarHeight(isLandscape);
        var alignItems = headerStyleObj.alignItems,
            justifyContent = headerStyleObj.justifyContent,
            flex = headerStyleObj.flex,
            flexDirection = headerStyleObj.flexDirection,
            flexGrow = headerStyleObj.flexGrow,
            flexShrink = headerStyleObj.flexShrink,
            flexBasis = headerStyleObj.flexBasis,
            flexWrap = headerStyleObj.flexWrap,
            safeHeaderStyle = babelHelpers.objectWithoutProperties(headerStyleObj, ["alignItems", "justifyContent", "flex", "flexDirection", "flexGrow", "flexShrink", "flexBasis", "flexWrap"]);

        if (__DEV__) {
          warnIfHeaderStyleDefined(alignItems, 'alignItems');
          warnIfHeaderStyleDefined(justifyContent, 'justifyContent');
          warnIfHeaderStyleDefined(flex, 'flex');
          warnIfHeaderStyleDefined(flexDirection, 'flexDirection');
          warnIfHeaderStyleDefined(flexGrow, 'flexGrow');
          warnIfHeaderStyleDefined(flexShrink, 'flexShrink');
          warnIfHeaderStyleDefined(flexBasis, 'flexBasis');
          warnIfHeaderStyleDefined(flexWrap, 'flexWrap');
        }

        var containerStyles = [options.headerTransparent ? styles.transparentContainer : styles.container, {
          height: appBarHeight
        }, safeHeaderStyle];
        var headerForceInset = options.headerForceInset;
        var forceInset = headerForceInset || {
          top: 'always',
          bottom: 'never'
        };
        return _react2.default.createElement(
          _reactNativeSafeAreaView2.default,
          {
            forceInset: forceInset,
            style: containerStyles,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 483
            }
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: _reactNative.StyleSheet.absoluteFill,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 484
              }
            },
            options.headerBackground
          ),
          _react2.default.createElement(
            _reactNative.View,
            {
              style: {
                flex: 1
              },
              __source: {
                fileName: _jsxFileName,
                lineNumber: 485
              }
            },
            appBar
          )
        );
      }
    }], [{
      key: "HEIGHT",
      get: function get() {
        return APPBAR_HEIGHT + STATUSBAR_HEIGHT;
      }
    }]);
    return Header;
  }(_react2.default.PureComponent);

  Header.defaultProps = {
    leftInterpolator: _HeaderStyleInterpolator2.default.forLeft,
    leftButtonInterpolator: _HeaderStyleInterpolator2.default.forLeftButton,
    leftLabelInterpolator: _HeaderStyleInterpolator2.default.forLeftLabel,
    titleFromLeftInterpolator: _HeaderStyleInterpolator2.default.forCenterFromLeft,
    titleInterpolator: _HeaderStyleInterpolator2.default.forCenter,
    rightInterpolator: _HeaderStyleInterpolator2.default.forRight
  };

  function warnIfHeaderStyleDefined(value, styleProp) {
    if (value !== undefined) {
      console.warn(styleProp + " was given a value of " + value + ", this has no effect on headerStyle.");
    }
  }

  var platformContainerStyles = void 0;

  if (_reactNative.Platform.OS === 'ios') {
    platformContainerStyles = {
      borderBottomWidth: _reactNative.StyleSheet.hairlineWidth,
      borderBottomColor: '#A7A7AA'
    };
  } else {
    platformContainerStyles = {
      shadowColor: 'black',
      shadowOpacity: 0.1,
      shadowRadius: _reactNative.StyleSheet.hairlineWidth,
      shadowOffset: {
        height: _reactNative.StyleSheet.hairlineWidth
      },
      elevation: 4
    };
  }

  var styles = _reactNative.StyleSheet.create({
    container: babelHelpers.extends({
      backgroundColor: _reactNative.Platform.OS === 'ios' ? '#F7F7F7' : '#FFF'
    }, platformContainerStyles),
    transparentContainer: babelHelpers.extends({
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0
    }, platformContainerStyles),
    header: babelHelpers.extends({}, _reactNative.StyleSheet.absoluteFillObject, {
      flexDirection: 'row'
    }),
    item: {
      backgroundColor: 'transparent'
    },
    iconMaskContainer: {
      flex: 1,
      flexDirection: 'row',
      justifyContent: 'center'
    },
    iconMaskFillerRect: {
      flex: 1,
      backgroundColor: '#d8d8d8',
      marginLeft: -3
    },
    iconMask: {
      height: 21,
      width: 12,
      marginLeft: 9,
      marginTop: -0.5,
      alignSelf: 'center',
      resizeMode: 'contain'
    },
    title: {
      bottom: 0,
      top: 0,
      left: TITLE_OFFSET,
      right: TITLE_OFFSET,
      position: 'absolute',
      alignItems: 'center',
      flexDirection: 'row',
      justifyContent: _reactNative.Platform.OS === 'ios' ? 'center' : 'flex-start'
    },
    left: {
      left: 0,
      bottom: 0,
      top: 0,
      position: 'absolute',
      alignItems: 'center',
      flexDirection: 'row'
    },
    right: {
      right: 0,
      bottom: 0,
      top: 0,
      position: 'absolute',
      flexDirection: 'row',
      alignItems: 'center'
    }
  });

  exports.default = (0, _withOrientation2.default)(Header);
},391,[12,66,378,392,394,395,398,399,401,402],"react-navigation/src/views/Header/Header.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-safe-area-view/index.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _withOrientation = require(_dependencyMap[2], "./withOrientation");

  var _withOrientation2 = babelHelpers.interopRequireDefault(_withOrientation);

  var X_WIDTH = 375;
  var X_HEIGHT = 812;
  var PAD_WIDTH = 768;
  var PAD_HEIGHT = 1024;

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      D_HEIGHT = _Dimensions$get.height,
      D_WIDTH = _Dimensions$get.width;

  var _NativeModules$Platfo = _reactNative.NativeModules.PlatformConstants,
      PlatformConstants = _NativeModules$Platfo === undefined ? {} : _NativeModules$Platfo;

  var _ref = PlatformConstants.reactNativeVersion || {},
      _ref$minor = _ref.minor,
      minor = _ref$minor === undefined ? 0 : _ref$minor;

  var isIPhoneX = function () {
    if (_reactNative.Platform.OS === 'web') return false;

    if (minor >= 50) {
      return _reactNative.DeviceInfo.isIPhoneX_deprecated;
    }

    return _reactNative.Platform.OS === 'ios' && (D_HEIGHT === X_HEIGHT && D_WIDTH === X_WIDTH || D_HEIGHT === X_WIDTH && D_WIDTH === X_HEIGHT);
  }();

  var isIPad = function () {
    if (_reactNative.Platform.OS !== 'ios' || isIPhoneX) return false;

    if (D_HEIGHT > D_WIDTH && D_WIDTH < PAD_WIDTH) {
      return false;
    }

    if (D_WIDTH > D_HEIGHT && D_HEIGHT < PAD_WIDTH) {
      return false;
    }

    return true;
  }();

  var _customStatusBarHeight = null;

  var statusBarHeight = function statusBarHeight(isLandscape) {
    if (_customStatusBarHeight !== null) {
      return _customStatusBarHeight;
    }

    if (_reactNative.Platform.OS === 'android') {
      if (global.Expo) {
        return global.Expo.Constants.statusBarHeight;
      } else {
        return 0;
      }
    }

    if (isIPhoneX) {
      return isLandscape ? 0 : 44;
    }

    if (isIPad) {
      return 20;
    }

    return isLandscape ? 0 : 20;
  };

  var doubleFromPercentString = function doubleFromPercentString(percent) {
    if (!percent.includes('%')) {
      return 0;
    }

    var dbl = parseFloat(percent) / 100;
    if (isNaN(dbl)) return 0;
    return dbl;
  };

  var SafeView = function (_Component) {
    babelHelpers.inherits(SafeView, _Component);

    function SafeView() {
      var _ref2;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, SafeView);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref2 = SafeView.__proto__ || Object.getPrototypeOf(SafeView)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {
        touchesTop: true,
        touchesBottom: true,
        touchesLeft: true,
        touchesRight: true,
        orientation: null,
        viewWidth: 0,
        viewHeight: 0
      }, _this._onLayout = function () {
        if (!_this.view) return;
        var isLandscape = _this.props.isLandscape;
        var orientation = _this.state.orientation;
        var newOrientation = isLandscape ? 'landscape' : 'portrait';

        if (orientation && orientation === newOrientation) {
          return;
        }

        var WIDTH = isLandscape ? X_HEIGHT : X_WIDTH;
        var HEIGHT = isLandscape ? X_WIDTH : X_HEIGHT;

        _this.view._component.measureInWindow(function (winX, winY, winWidth, winHeight) {
          var realY = winY;
          var realX = winX;

          if (realY >= HEIGHT) {
            realY = realY % HEIGHT;
          } else if (realY < 0) {
            realY = realY % HEIGHT + HEIGHT;
          }

          if (realX >= WIDTH) {
            realX = realX % WIDTH;
          } else if (realX < 0) {
            realX = realX % WIDTH + WIDTH;
          }

          var touchesTop = realY === 0;
          var touchesBottom = realY + winHeight >= HEIGHT;
          var touchesLeft = realX === 0;
          var touchesRight = realX + winWidth >= WIDTH;

          _this.setState({
            touchesTop: touchesTop,
            touchesBottom: touchesBottom,
            touchesLeft: touchesLeft,
            touchesRight: touchesRight,
            orientation: newOrientation,
            viewWidth: winWidth,
            viewHeight: winHeight
          });
        });
      }, _this._getSafeAreaStyle = function () {
        var _this$state = _this.state,
            touchesTop = _this$state.touchesTop,
            touchesBottom = _this$state.touchesBottom,
            touchesLeft = _this$state.touchesLeft,
            touchesRight = _this$state.touchesRight;
        var _this$props = _this.props,
            forceInset = _this$props.forceInset,
            isLandscape = _this$props.isLandscape;

        var _this$_getViewStyles = _this._getViewStyles(),
            paddingTop = _this$_getViewStyles.paddingTop,
            paddingBottom = _this$_getViewStyles.paddingBottom,
            paddingLeft = _this$_getViewStyles.paddingLeft,
            paddingRight = _this$_getViewStyles.paddingRight,
            viewStyle = _this$_getViewStyles.viewStyle;

        var style = babelHelpers.extends({}, viewStyle, {
          paddingTop: touchesTop ? _this._getInset('top') : 0,
          paddingBottom: touchesBottom ? _this._getInset('bottom') : 0,
          paddingLeft: touchesLeft ? _this._getInset('left') : 0,
          paddingRight: touchesRight ? _this._getInset('right') : 0
        });

        if (forceInset) {
          Object.keys(forceInset).forEach(function (key) {
            var inset = forceInset[key];

            if (inset === 'always') {
              inset = _this._getInset(key);
            }

            if (inset === 'never') {
              inset = 0;
            }

            switch (key) {
              case 'horizontal':
                {
                  style.paddingLeft = inset;
                  style.paddingRight = inset;
                  break;
                }

              case 'vertical':
                {
                  style.paddingTop = inset;
                  style.paddingBottom = inset;
                  break;
                }

              case 'left':
              case 'right':
              case 'top':
              case 'bottom':
                {
                  var padding = "padding" + key[0].toUpperCase() + key.slice(1);
                  style[padding] = inset;
                  break;
                }
            }
          });
        }

        if (style.height && typeof style.height === 'number') {
          style.height += style.paddingTop + style.paddingBottom;
        }

        if (style.width && typeof style.width === 'number') {
          style.width += style.paddingLeft + style.paddingRight;
        }

        style.paddingTop = Math.max(style.paddingTop, paddingTop);
        style.paddingBottom = Math.max(style.paddingBottom, paddingBottom);
        style.paddingLeft = Math.max(style.paddingLeft, paddingLeft);
        style.paddingRight = Math.max(style.paddingRight, paddingRight);
        return style;
      }, _this._getViewStyles = function () {
        var viewWidth = _this.state.viewWidth;

        var _StyleSheet$flatten = _reactNative.StyleSheet.flatten(_this.props.style || {}),
            _StyleSheet$flatten$p = _StyleSheet$flatten.padding,
            padding = _StyleSheet$flatten$p === undefined ? 0 : _StyleSheet$flatten$p,
            _StyleSheet$flatten$p2 = _StyleSheet$flatten.paddingVertical,
            paddingVertical = _StyleSheet$flatten$p2 === undefined ? padding : _StyleSheet$flatten$p2,
            _StyleSheet$flatten$p3 = _StyleSheet$flatten.paddingHorizontal,
            paddingHorizontal = _StyleSheet$flatten$p3 === undefined ? padding : _StyleSheet$flatten$p3,
            _StyleSheet$flatten$p4 = _StyleSheet$flatten.paddingTop,
            paddingTop = _StyleSheet$flatten$p4 === undefined ? paddingVertical : _StyleSheet$flatten$p4,
            _StyleSheet$flatten$p5 = _StyleSheet$flatten.paddingBottom,
            paddingBottom = _StyleSheet$flatten$p5 === undefined ? paddingVertical : _StyleSheet$flatten$p5,
            _StyleSheet$flatten$p6 = _StyleSheet$flatten.paddingLeft,
            paddingLeft = _StyleSheet$flatten$p6 === undefined ? paddingHorizontal : _StyleSheet$flatten$p6,
            _StyleSheet$flatten$p7 = _StyleSheet$flatten.paddingRight,
            paddingRight = _StyleSheet$flatten$p7 === undefined ? paddingHorizontal : _StyleSheet$flatten$p7,
            viewStyle = babelHelpers.objectWithoutProperties(_StyleSheet$flatten, ["padding", "paddingVertical", "paddingHorizontal", "paddingTop", "paddingBottom", "paddingLeft", "paddingRight"]);

        if (typeof paddingTop !== 'number') {
          paddingTop = doubleFromPercentString(paddingTop) * viewWidth;
        }

        if (typeof paddingBottom !== 'number') {
          paddingBottom = doubleFromPercentString(paddingBottom) * viewWidth;
        }

        if (typeof paddingLeft !== 'number') {
          paddingLeft = doubleFromPercentString(paddingLeft) * viewWidth;
        }

        if (typeof paddingRight !== 'number') {
          paddingRight = doubleFromPercentString(paddingRight) * viewWidth;
        }

        return {
          paddingTop: paddingTop,
          paddingBottom: paddingBottom,
          paddingLeft: paddingLeft,
          paddingRight: paddingRight,
          viewStyle: viewStyle
        };
      }, _this._getInset = function (key) {
        var isLandscape = _this.props.isLandscape;

        switch (key) {
          case 'horizontal':
          case 'right':
          case 'left':
            {
              return isLandscape ? isIPhoneX ? 44 : 0 : 0;
            }

          case 'vertical':
          case 'top':
            {
              return statusBarHeight(isLandscape);
            }

          case 'bottom':
            {
              return isIPhoneX ? isLandscape ? 24 : 34 : 0;
            }
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(SafeView, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        _reactNative.InteractionManager.runAfterInteractions(function () {
          _this2._onLayout();
        });
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps() {
        this._onLayout();
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var _props = this.props,
            _props$forceInset = _props.forceInset,
            forceInset = _props$forceInset === undefined ? false : _props$forceInset,
            isLandscape = _props.isLandscape,
            children = _props.children,
            style = _props.style;

        var safeAreaStyle = this._getSafeAreaStyle();

        return _react2.default.createElement(
          _reactNative.Animated.View,
          {
            ref: function ref(c) {
              return _this3.view = c;
            },
            onLayout: this._onLayout,
            style: safeAreaStyle,
            pointerEvents: "box-none",
            __source: {
              fileName: _jsxFileName,
              lineNumber: 128
            }
          },
          this.props.children
        );
      }
    }]);
    return SafeView;
  }(_react.Component);

  SafeView.setStatusBarHeight = function (height) {
    _customStatusBarHeight = height;
  };

  exports.default = (0, _withOrientation2.default)(SafeView);
},392,[12,66,393],"react-native-safe-area-view/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isOrientationLandscape = undefined;
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-safe-area-view/withOrientation.js";

  exports.default = function (WrappedComponent) {
    var withOrientation = function (_React$Component) {
      babelHelpers.inherits(withOrientation, _React$Component);

      function withOrientation() {
        babelHelpers.classCallCheck(this, withOrientation);

        var _this = babelHelpers.possibleConstructorReturn(this, (withOrientation.__proto__ || Object.getPrototypeOf(withOrientation)).call(this));

        _initialiseProps.call(_this);

        var isLandscape = isOrientationLandscape(_reactNative.Dimensions.get('window'));
        _this.state = {
          isLandscape: isLandscape
        };
        return _this;
      }

      babelHelpers.createClass(withOrientation, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          _reactNative.Dimensions.addEventListener('change', this.handleOrientationChange);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          _reactNative.Dimensions.removeEventListener('change', this.handleOrientationChange);
        }
      }, {
        key: "render",
        value: function render() {
          return React.createElement(WrappedComponent, babelHelpers.extends({}, this.props, this.state, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 50
            }
          }));
        }
      }]);
      return withOrientation;
    }(React.Component);

    var _initialiseProps = function _initialiseProps() {
      var _this2 = this;

      this.handleOrientationChange = function (_ref2) {
        var window = _ref2.window;
        var isLandscape = isOrientationLandscape(window);

        _this2.setState({
          isLandscape: isLandscape
        });
      };
    };

    return (0, _hoistNonReactStatics2.default)(withOrientation, WrappedComponent);
  };

  var _react = require(_dependencyMap[0], "react");

  var React = babelHelpers.interopRequireWildcard(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _hoistNonReactStatics = require(_dependencyMap[2], "hoist-non-react-statics");

  var _hoistNonReactStatics2 = babelHelpers.interopRequireDefault(_hoistNonReactStatics);

  var isOrientationLandscape = exports.isOrientationLandscape = function isOrientationLandscape(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width > height;
  };
},393,[12,66,30],"react-native-safe-area-view/withOrientation.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/Header/HeaderTitle.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var AnimatedText = _reactNative.Animated.Text;

  var HeaderTitle = function HeaderTitle(_ref) {
    var style = _ref.style,
        rest = babelHelpers.objectWithoutProperties(_ref, ["style"]);
    return _react2.default.createElement(AnimatedText, babelHelpers.extends({
      numberOfLines: 1
    }, rest, {
      style: [styles.title, style],
      accessibilityTraits: "header",
      __source: {
        fileName: _jsxFileName,
        lineNumber: 7
      }
    }));
  };

  var styles = _reactNative.StyleSheet.create({
    title: {
      fontSize: _reactNative.Platform.OS === 'ios' ? 17 : 20,
      fontWeight: _reactNative.Platform.OS === 'ios' ? '700' : '500',
      color: 'rgba(0, 0, 0, .9)',
      textAlign: _reactNative.Platform.OS === 'ios' ? 'center' : 'left',
      marginHorizontal: 16
    }
  });

  exports.default = HeaderTitle;
},394,[12,66],"react-navigation/src/views/Header/HeaderTitle.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/Header/HeaderBackButton.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _TouchableItem = require(_dependencyMap[2], "../TouchableItem");

  var _TouchableItem2 = babelHelpers.interopRequireDefault(_TouchableItem);

  var HeaderBackButton = function (_React$PureComponent) {
    babelHelpers.inherits(HeaderBackButton, _React$PureComponent);

    function HeaderBackButton() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, HeaderBackButton);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = HeaderBackButton.__proto__ || Object.getPrototypeOf(HeaderBackButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this._onTextLayout = function (e) {
        if (_this.state.initialTextWidth) {
          return;
        }

        _this.setState({
          initialTextWidth: e.nativeEvent.layout.x + e.nativeEvent.layout.width
        });
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(HeaderBackButton, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            buttonImage = _props.buttonImage,
            onPress = _props.onPress,
            pressColorAndroid = _props.pressColorAndroid,
            width = _props.width,
            title = _props.title,
            titleStyle = _props.titleStyle,
            tintColor = _props.tintColor,
            truncatedTitle = _props.truncatedTitle;
        var renderTruncated = this.state.initialTextWidth && width ? this.state.initialTextWidth > width : false;
        var backButtonTitle = renderTruncated ? truncatedTitle : title;
        return _react2.default.createElement(
          _TouchableItem2.default,
          {
            accessibilityComponentType: "button",
            accessibilityLabel: backButtonTitle,
            accessibilityTraits: "button",
            testID: "header-back",
            delayPressIn: 0,
            onPress: onPress,
            pressColor: pressColorAndroid,
            style: styles.container,
            borderless: true,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 55
            }
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: styles.container,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 66
              }
            },
            _react2.default.createElement(_reactNative.Image, {
              style: [styles.icon, !!title && styles.iconWithTitle, !!tintColor && {
                tintColor: tintColor
              }],
              source: buttonImage,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 67
              }
            }),
            _reactNative.Platform.OS === 'ios' && typeof backButtonTitle === 'string' && _react2.default.createElement(
              _reactNative.Text,
              {
                onLayout: this._onTextLayout,
                style: [styles.title, !!tintColor && {
                  color: tintColor
                }, titleStyle],
                numberOfLines: 1,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 77
                }
              },
              backButtonTitle
            )
          )
        );
      }
    }]);
    return HeaderBackButton;
  }(_react2.default.PureComponent);

  HeaderBackButton.defaultProps = {
    pressColorAndroid: 'rgba(0, 0, 0, .32)',
    tintColor: _reactNative.Platform.select({
      ios: '#037aff'
    }),
    truncatedTitle: 'Back',
    buttonImage: require(_dependencyMap[3], '../assets/back-icon.png')
  };

  var styles = _reactNative.StyleSheet.create({
    container: {
      alignItems: 'center',
      flexDirection: 'row',
      backgroundColor: 'transparent'
    },
    title: {
      fontSize: 17,
      paddingRight: 10
    },
    icon: _reactNative.Platform.OS === 'ios' ? {
      height: 21,
      width: 13,
      marginLeft: 9,
      marginRight: 22,
      marginVertical: 12,
      resizeMode: 'contain',
      transform: [{
        scaleX: _reactNative.I18nManager.isRTL ? -1 : 1
      }]
    } : {
      height: 24,
      width: 24,
      margin: 16,
      resizeMode: 'contain',
      transform: [{
        scaleX: _reactNative.I18nManager.isRTL ? -1 : 1
      }]
    },
    iconWithTitle: _reactNative.Platform.OS === 'ios' ? {
      marginRight: 6
    } : {}
  });

  exports.default = HeaderBackButton;
},395,[12,66,396,397],"react-navigation/src/views/Header/HeaderBackButton.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/TouchableItem.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var ANDROID_VERSION_LOLLIPOP = 21;

  var TouchableItem = function (_React$Component) {
    babelHelpers.inherits(TouchableItem, _React$Component);

    function TouchableItem() {
      babelHelpers.classCallCheck(this, TouchableItem);
      return babelHelpers.possibleConstructorReturn(this, (TouchableItem.__proto__ || Object.getPrototypeOf(TouchableItem)).apply(this, arguments));
    }

    babelHelpers.createClass(TouchableItem, [{
      key: "render",
      value: function render() {
        if (_reactNative.Platform.OS === 'android' && _reactNative.Platform.Version >= ANDROID_VERSION_LOLLIPOP) {
          var _props = this.props,
              style = _props.style,
              rest = babelHelpers.objectWithoutProperties(_props, ["style"]);
          return _react2.default.createElement(
            _reactNative.TouchableNativeFeedback,
            babelHelpers.extends({}, rest, {
              style: null,
              background: _reactNative.TouchableNativeFeedback.Ripple(this.props.pressColor, this.props.borderless),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 41
              }
            }),
            _react2.default.createElement(
              _reactNative.View,
              {
                style: style,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 49
                }
              },
              _react2.default.Children.only(this.props.children)
            )
          );
        }

        return _react2.default.createElement(
          _reactNative.TouchableOpacity,
          babelHelpers.extends({}, this.props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 55
            }
          }),
          this.props.children
        );
      }
    }]);
    return TouchableItem;
  }(_react2.default.Component);

  TouchableItem.defaultProps = {
    borderless: false,
    pressColor: 'rgba(0, 0, 0, .32)'
  };
  exports.default = TouchableItem;
},396,[12,66],"react-navigation/src/views/TouchableItem.js");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = require(_dependencyMap[0], "react-native/Libraries/Image/AssetRegistry").registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/react-navigation/src/views/assets",
    "width": 24,
    "height": 24,
    "scales": [1, 1.5, 2, 3, 4],
    "hash": "a364dc7a784101f7c8f6791c7b4514ce",
    "name": "back-icon",
    "type": "png"
  });
},397,[202],"node_modules/react-navigation/src/views/assets/back-icon.png");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/Header/ModularHeaderBackButton.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _TouchableItem = require(_dependencyMap[2], "../TouchableItem");

  var _TouchableItem2 = babelHelpers.interopRequireDefault(_TouchableItem);

  var ModularHeaderBackButton = function (_React$PureComponent) {
    babelHelpers.inherits(ModularHeaderBackButton, _React$PureComponent);

    function ModularHeaderBackButton() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, ModularHeaderBackButton);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = ModularHeaderBackButton.__proto__ || Object.getPrototypeOf(ModularHeaderBackButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this._onTextLayout = function (e) {
        if (_this.state.initialTextWidth) {
          return;
        }

        _this.setState({
          initialTextWidth: e.nativeEvent.layout.x + e.nativeEvent.layout.width
        });
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(ModularHeaderBackButton, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            buttonImage = _props.buttonImage,
            onPress = _props.onPress,
            width = _props.width,
            title = _props.title,
            titleStyle = _props.titleStyle,
            tintColor = _props.tintColor,
            truncatedTitle = _props.truncatedTitle;
        var renderTruncated = this.state.initialTextWidth && width ? this.state.initialTextWidth > width : false;
        var backButtonTitle = renderTruncated ? truncatedTitle : title;

        if (backButtonTitle && backButtonTitle.length > 8) {
          backButtonTitle = truncatedTitle;
        }

        var _props2 = this.props,
            ButtonContainerComponent = _props2.ButtonContainerComponent,
            LabelContainerComponent = _props2.LabelContainerComponent;
        return _react2.default.createElement(
          _TouchableItem2.default,
          {
            accessibilityComponentType: "button",
            accessibilityLabel: backButtonTitle,
            accessibilityTraits: "button",
            testID: "header-back",
            delayPressIn: 0,
            onPress: onPress,
            style: styles.container,
            borderless: true,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 52
            }
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: styles.container,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 62
              }
            },
            _react2.default.createElement(
              ButtonContainerComponent,
              {
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 63
                }
              },
              _react2.default.createElement(_reactNative.Image, {
                style: [styles.icon, !!title && styles.iconWithTitle, !!tintColor && {
                  tintColor: tintColor
                }],
                source: buttonImage,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 64
                }
              })
            ),
            typeof backButtonTitle === 'string' && _react2.default.createElement(
              LabelContainerComponent,
              {
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 74
                }
              },
              _react2.default.createElement(
                _reactNative.Text,
                {
                  onLayout: this._onTextLayout,
                  style: [styles.title, !!tintColor && {
                    color: tintColor
                  }, titleStyle],
                  numberOfLines: 1,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 75
                  }
                },
                backButtonTitle
              )
            )
          )
        );
      }
    }]);
    return ModularHeaderBackButton;
  }(_react2.default.PureComponent);

  ModularHeaderBackButton.defaultProps = {
    tintColor: '#037aff',
    truncatedTitle: 'Back',
    buttonImage: require(_dependencyMap[3], '../assets/back-icon.png')
  };

  var styles = _reactNative.StyleSheet.create({
    container: {
      alignItems: 'center',
      flexDirection: 'row',
      backgroundColor: 'transparent'
    },
    title: {
      fontSize: 17,
      paddingRight: 10
    },
    icon: {
      height: 21,
      width: 12,
      marginLeft: 9,
      marginRight: 22,
      marginVertical: 12,
      resizeMode: 'contain',
      transform: [{
        scaleX: _reactNative.I18nManager.isRTL ? -1 : 1
      }]
    },
    iconWithTitle: {
      marginRight: 3
    }
  });

  exports.default = ModularHeaderBackButton;
},398,[12,66,396,397],"react-navigation/src/views/Header/ModularHeaderBackButton.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var _getSceneIndicesForInterpolationInputRange = require(_dependencyMap[1], "../../utils/getSceneIndicesForInterpolationInputRange");

  var _getSceneIndicesForInterpolationInputRange2 = babelHelpers.interopRequireDefault(_getSceneIndicesForInterpolationInputRange);

  var crossFadeInterpolation = function crossFadeInterpolation(first, index, last) {
    return {
      inputRange: [first, index - 0.9, index - 0.2, index, last],
      outputRange: [0, 0, 0.3, 1, 0]
    };
  };

  function forLeft(props) {
    var position = props.position,
        scene = props.scene,
        scenes = props.scenes;
    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    return {
      opacity: position.interpolate(crossFadeInterpolation(first, index, last))
    };
  }

  function forCenter(props) {
    var position = props.position,
        scene = props.scene;
    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    return {
      opacity: position.interpolate(crossFadeInterpolation(first, index, last))
    };
  }

  function forRight(props) {
    var position = props.position,
        scene = props.scene;
    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    return {
      opacity: position.interpolate(crossFadeInterpolation(first, index, last))
    };
  }

  function forLeftButton(props) {
    var position = props.position,
        scene = props.scene,
        scenes = props.scenes;
    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    return {
      opacity: position.interpolate({
        inputRange: [first, first + Math.abs(index - first) / 2, index, last - Math.abs(last - index) / 2, last],
        outputRange: [0, 0.5, 1, 0.5, 0]
      })
    };
  }

  var LEFT_LABEL_OFFSET = _reactNative.Dimensions.get('window').width / 2 - 70 - 25;

  function forLeftLabel(props) {
    var position = props.position,
        scene = props.scene,
        scenes = props.scenes;
    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    var offset = LEFT_LABEL_OFFSET;
    return {
      opacity: position.interpolate({
        inputRange: [first, index - 0.35, index, index + 0.5, last],
        outputRange: [0, 0, 1, 0.5, 0]
      }),
      transform: [{
        translateX: position.interpolate({
          inputRange: [first, index, last],
          outputRange: _reactNative.I18nManager.isRTL ? [-offset, 0, offset] : [offset, 0, -offset * 1.5]
        })
      }]
    };
  }

  var TITLE_OFFSET_IOS = _reactNative.Dimensions.get('window').width / 2 - 70 + 25;

  function forCenterFromLeft(props) {
    var position = props.position,
        scene = props.scene;
    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    var inputRange = [first, index - 0.5, index, index + 0.5, last];
    var offset = TITLE_OFFSET_IOS;
    return {
      opacity: position.interpolate({
        inputRange: [first, index - 0.5, index, index + 0.7, last],
        outputRange: [0, 0, 1, 0, 0]
      }),
      transform: [{
        translateX: position.interpolate({
          inputRange: [first, index, last],
          outputRange: _reactNative.I18nManager.isRTL ? [-offset, 0, offset] : [offset, 0, -offset]
        })
      }]
    };
  }

  exports.default = {
    forLeft: forLeft,
    forLeftButton: forLeftButton,
    forLeftLabel: forLeftLabel,
    forCenterFromLeft: forCenterFromLeft,
    forCenter: forCenter,
    forRight: forRight
  };
},399,[66,400],"react-navigation/src/views/Header/HeaderStyleInterpolator.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  function getSceneIndicesForInterpolationInputRange(props) {
    var scene = props.scene,
        scenes = props.scenes;
    var index = scene.index;
    var lastSceneIndexInScenes = scenes.length - 1;
    var isBack = !scenes[lastSceneIndexInScenes].isActive;

    if (isBack) {
      var currentSceneIndexInScenes = scenes.findIndex(function (item) {
        return item === scene;
      });
      var targetSceneIndexInScenes = scenes.findIndex(function (item) {
        return item.isActive;
      });
      var targetSceneIndex = scenes[targetSceneIndexInScenes].index;
      var lastSceneIndex = scenes[lastSceneIndexInScenes].index;

      if (index !== targetSceneIndex && currentSceneIndexInScenes === lastSceneIndexInScenes) {
        return {
          first: Math.min(targetSceneIndex, index - 1),
          last: index + 1
        };
      } else if (index === targetSceneIndex && currentSceneIndexInScenes === targetSceneIndexInScenes) {
        return {
          first: index - 1,
          last: Math.max(lastSceneIndex, index + 1)
        };
      } else if (index === targetSceneIndex || currentSceneIndexInScenes > targetSceneIndexInScenes) {
        return null;
      } else {
        return {
          first: index - 1,
          last: index + 1
        };
      }
    } else {
      return {
        first: index - 1,
        last: index + 1
      };
    }
  }

  exports.default = getSceneIndicesForInterpolationInputRange;
},400,[],"react-navigation/src/utils/getSceneIndicesForInterpolationInputRange.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isOrientationLandscape = undefined;
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/withOrientation.js";

  exports.default = function (WrappedComponent) {
    var withOrientation = function (_React$Component) {
      babelHelpers.inherits(withOrientation, _React$Component);

      function withOrientation() {
        babelHelpers.classCallCheck(this, withOrientation);

        var _this = babelHelpers.possibleConstructorReturn(this, (withOrientation.__proto__ || Object.getPrototypeOf(withOrientation)).call(this));

        _initialiseProps.call(_this);

        var isLandscape = isOrientationLandscape(_reactNative.Dimensions.get('window'));
        _this.state = {
          isLandscape: isLandscape
        };
        return _this;
      }

      babelHelpers.createClass(withOrientation, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          _reactNative.Dimensions.addEventListener('change', this.handleOrientationChange);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          _reactNative.Dimensions.removeEventListener('change', this.handleOrientationChange);
        }
      }, {
        key: "render",
        value: function render() {
          return _react2.default.createElement(WrappedComponent, babelHelpers.extends({}, this.props, this.state, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 30
            }
          }));
        }
      }]);
      return withOrientation;
    }(_react2.default.Component);

    var _initialiseProps = function _initialiseProps() {
      var _this2 = this;

      this.handleOrientationChange = function (_ref2) {
        var window = _ref2.window;
        var isLandscape = isOrientationLandscape(window);

        _this2.setState({
          isLandscape: isLandscape
        });
      };
    };

    return (0, _hoistNonReactStatics2.default)(withOrientation, WrappedComponent);
  };

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _hoistNonReactStatics = require(_dependencyMap[2], "hoist-non-react-statics");

  var _hoistNonReactStatics2 = babelHelpers.interopRequireDefault(_hoistNonReactStatics);

  var isOrientationLandscape = exports.isOrientationLandscape = function isOrientationLandscape(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width > height;
  };
},401,[12,66,30],"react-navigation/src/views/withOrientation.js");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = require(_dependencyMap[0], "react-native/Libraries/Image/AssetRegistry").registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/react-navigation/src/views/assets",
    "width": 48,
    "height": 82,
    "scales": [1],
    "hash": "1c7339b1dcf76fbc66536a0728963705",
    "name": "back-icon-mask",
    "type": "png"
  });
},402,[202],"node_modules/react-navigation/src/views/assets/back-icon-mask.png");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getChildEventSubscriber;

  function getChildEventSubscriber(addListener, key) {
    var actionSubscribers = new Set();
    var willFocusSubscribers = new Set();
    var didFocusSubscribers = new Set();
    var willBlurSubscribers = new Set();
    var didBlurSubscribers = new Set();

    var getChildSubscribers = function getChildSubscribers(evtName) {
      switch (evtName) {
        case 'action':
          return actionSubscribers;

        case 'willFocus':
          return willFocusSubscribers;

        case 'didFocus':
          return didFocusSubscribers;

        case 'willBlur':
          return willBlurSubscribers;

        case 'didBlur':
          return didBlurSubscribers;

        default:
          return null;
      }
    };

    var emit = function emit(type, payload) {
      var payloadWithType = babelHelpers.extends({}, payload, {
        type: type
      });
      var subscribers = getChildSubscribers(type);
      subscribers && subscribers.forEach(function (subs) {
        subs(payloadWithType);
      });
    };

    var lastEmittedEvent = 'didBlur';

    var cleanup = function cleanup() {
      upstreamSubscribers.forEach(function (subs) {
        return subs && subs.remove();
      });
    };

    var upstreamEvents = ['willFocus', 'didFocus', 'willBlur', 'didBlur', 'action'];
    var upstreamSubscribers = upstreamEvents.map(function (eventName) {
      return addListener(eventName, function (payload) {
        var state = payload.state,
            lastState = payload.lastState,
            action = payload.action;
        var lastRoutes = lastState && lastState.routes;
        var routes = state && state.routes;
        var lastFocusKey = lastState && lastState.routes && lastState.routes[lastState.index].key;
        var focusKey = routes && routes[state.index].key;
        var isChildFocused = focusKey === key;
        var lastRoute = lastRoutes && lastRoutes.find(function (route) {
          return route.key === key;
        });
        var newRoute = routes && routes.find(function (route) {
          return route.key === key;
        });
        var childPayload = {
          context: key + ":" + action.type + "_" + (payload.context || 'Root'),
          state: newRoute,
          lastState: lastRoute,
          action: action,
          type: eventName
        };
        var isTransitioning = !!state && state.isTransitioning;
        var previouslyLastEmittedEvent = lastEmittedEvent;

        if (lastEmittedEvent === 'didBlur') {
          if (eventName === 'willFocus' && isChildFocused) {
            emit(lastEmittedEvent = 'willFocus', childPayload);
          } else if (eventName === 'action' && isChildFocused) {
            emit(lastEmittedEvent = 'willFocus', childPayload);
          }
        }

        if (lastEmittedEvent === 'willFocus') {
          if (eventName === 'didFocus' && isChildFocused && !isTransitioning) {
            emit(lastEmittedEvent = 'didFocus', childPayload);
          } else if (eventName === 'action' && isChildFocused && !isTransitioning) {
            emit(lastEmittedEvent = 'didFocus', childPayload);
          }
        }

        if (lastEmittedEvent === 'didFocus') {
          if (!isChildFocused) {
            emit(lastEmittedEvent = 'willBlur', childPayload);
          } else if (eventName === 'willBlur') {
            emit(lastEmittedEvent = 'willBlur', childPayload);
          } else if (eventName === 'action' && previouslyLastEmittedEvent === 'didFocus') {
            emit('action', childPayload);
          }
        }

        if (lastEmittedEvent === 'willBlur') {
          if (eventName === 'action' && !isChildFocused && !isTransitioning) {
            emit(lastEmittedEvent = 'didBlur', childPayload);
          } else if (eventName === 'didBlur') {
            emit(lastEmittedEvent = 'didBlur', childPayload);
          }
        }
      });
    });
    return function (eventName, eventHandler) {
      var subscribers = getChildSubscribers(eventName);

      if (!subscribers) {
        throw new Error("Invalid event name \"" + eventName + "\"");
      }

      subscribers.add(eventHandler);

      var remove = function remove() {
        subscribers.delete(eventHandler);
      };

      return {
        remove: remove
      };
    };
  }
},403,[],"react-navigation/src/getChildEventSubscriber.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/SceneView.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var SceneView = function (_React$PureComponent) {
    babelHelpers.inherits(SceneView, _React$PureComponent);

    function SceneView() {
      babelHelpers.classCallCheck(this, SceneView);
      return babelHelpers.possibleConstructorReturn(this, (SceneView.__proto__ || Object.getPrototypeOf(SceneView)).apply(this, arguments));
    }

    babelHelpers.createClass(SceneView, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          navigation: this.props.navigation
        };
      }
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            screenProps = _props.screenProps,
            navigation = _props.navigation,
            Component = _props.component;
        return _react2.default.createElement(Component, {
          screenProps: screenProps,
          navigation: navigation,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 17
          }
        });
      }
    }]);
    return SceneView;
  }(_react2.default.PureComponent);

  SceneView.childContextTypes = {
    navigation: _propTypes2.default.object.isRequired
  };
  exports.default = SceneView;
},404,[12,24],"react-navigation/src/views/SceneView.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var _CardStackStyleInterpolator = require(_dependencyMap[1], "./CardStackStyleInterpolator");

  var _CardStackStyleInterpolator2 = babelHelpers.interopRequireDefault(_CardStackStyleInterpolator);

  var _ReactNativeFeatures = require(_dependencyMap[2], "../../utils/ReactNativeFeatures");

  var ReactNativeFeatures = babelHelpers.interopRequireWildcard(_ReactNativeFeatures);
  var IOSTransitionSpec = void 0;

  if (ReactNativeFeatures.supportsImprovedSpringAnimation()) {
    IOSTransitionSpec = {
      timing: _reactNative.Animated.spring,
      stiffness: 1000,
      damping: 500,
      mass: 3
    };
  } else {
    IOSTransitionSpec = {
      duration: 500,
      easing: _reactNative.Easing.bezier(0.2833, 0.99, 0.31833, 0.99),
      timing: _reactNative.Animated.timing
    };
  }

  var SlideFromRightIOS = {
    transitionSpec: IOSTransitionSpec,
    screenInterpolator: _CardStackStyleInterpolator2.default.forHorizontal,
    containerStyle: {
      backgroundColor: '#000'
    }
  };
  var ModalSlideFromBottomIOS = {
    transitionSpec: IOSTransitionSpec,
    screenInterpolator: _CardStackStyleInterpolator2.default.forVertical,
    containerStyle: {
      backgroundColor: '#000'
    }
  };
  var FadeInFromBottomAndroid = {
    transitionSpec: {
      duration: 350,
      easing: _reactNative.Easing.out(_reactNative.Easing.poly(5)),
      timing: _reactNative.Animated.timing
    },
    screenInterpolator: _CardStackStyleInterpolator2.default.forFadeFromBottomAndroid
  };
  var FadeOutToBottomAndroid = {
    transitionSpec: {
      duration: 230,
      easing: _reactNative.Easing.in(_reactNative.Easing.poly(4)),
      timing: _reactNative.Animated.timing
    },
    screenInterpolator: _CardStackStyleInterpolator2.default.forFadeFromBottomAndroid
  };

  function defaultTransitionConfig(transitionProps, prevTransitionProps, isModal) {
    if (_reactNative.Platform.OS === 'android') {
      if (prevTransitionProps && transitionProps.index < prevTransitionProps.index) {
        return FadeOutToBottomAndroid;
      }

      return FadeInFromBottomAndroid;
    }

    if (isModal) {
      return ModalSlideFromBottomIOS;
    }

    return SlideFromRightIOS;
  }

  function getTransitionConfig(transitionConfigurer, transitionProps, prevTransitionProps, isModal) {
    var defaultConfig = defaultTransitionConfig(transitionProps, prevTransitionProps, isModal);

    if (transitionConfigurer) {
      return babelHelpers.extends({}, defaultConfig, transitionConfigurer(transitionProps, prevTransitionProps, isModal));
    }

    return defaultConfig;
  }

  exports.default = {
    defaultTransitionConfig: defaultTransitionConfig,
    getTransitionConfig: getTransitionConfig
  };
},405,[66,406,407],"react-navigation/src/views/CardStack/TransitionConfigs.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var _getSceneIndicesForInterpolationInputRange = require(_dependencyMap[1], "../../utils/getSceneIndicesForInterpolationInputRange");

  var _getSceneIndicesForInterpolationInputRange2 = babelHelpers.interopRequireDefault(_getSceneIndicesForInterpolationInputRange);

  function forInitial(props) {
    var navigation = props.navigation,
        scene = props.scene;
    var focused = navigation.state.index === scene.index;
    var opacity = focused ? 1 : 0;
    var translate = focused ? 0 : 1000000;
    return {
      opacity: opacity,
      transform: [{
        translateX: translate
      }, {
        translateY: translate
      }]
    };
  }

  function forHorizontal(props) {
    var layout = props.layout,
        position = props.position,
        scene = props.scene;

    if (!layout.isMeasured) {
      return forInitial(props);
    }

    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    var opacity = position.interpolate({
      inputRange: [first, first + 0.01, index, last - 0.01, last],
      outputRange: [0, 1, 1, 0.85, 0]
    });
    var width = layout.initWidth;
    var translateX = position.interpolate({
      inputRange: [first, index, last],
      outputRange: _reactNative.I18nManager.isRTL ? [-width, 0, width * 0.3] : [width, 0, width * -0.3]
    });
    var translateY = 0;
    return {
      opacity: opacity,
      transform: [{
        translateX: translateX
      }, {
        translateY: translateY
      }]
    };
  }

  function forVertical(props) {
    var layout = props.layout,
        position = props.position,
        scene = props.scene;

    if (!layout.isMeasured) {
      return forInitial(props);
    }

    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    var opacity = position.interpolate({
      inputRange: [first, first + 0.01, index, last - 0.01, last],
      outputRange: [0, 1, 1, 0.85, 0]
    });
    var height = layout.initHeight;
    var translateY = position.interpolate({
      inputRange: [first, index, last],
      outputRange: [height, 0, 0]
    });
    var translateX = 0;
    return {
      opacity: opacity,
      transform: [{
        translateX: translateX
      }, {
        translateY: translateY
      }]
    };
  }

  function forFadeFromBottomAndroid(props) {
    var layout = props.layout,
        position = props.position,
        scene = props.scene;

    if (!layout.isMeasured) {
      return forInitial(props);
    }

    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    var inputRange = [first, index, last - 0.01, last];
    var opacity = position.interpolate({
      inputRange: inputRange,
      outputRange: [0, 1, 1, 0]
    });
    var translateY = position.interpolate({
      inputRange: inputRange,
      outputRange: [50, 0, 0, 0]
    });
    var translateX = 0;
    return {
      opacity: opacity,
      transform: [{
        translateX: translateX
      }, {
        translateY: translateY
      }]
    };
  }

  function forFade(props) {
    var layout = props.layout,
        position = props.position,
        scene = props.scene;

    if (!layout.isMeasured) {
      return forInitial(props);
    }

    var interpolate = (0, _getSceneIndicesForInterpolationInputRange2.default)(props);
    if (!interpolate) return {
      opacity: 0
    };
    var first = interpolate.first,
        last = interpolate.last;
    var index = scene.index;
    var opacity = position.interpolate({
      inputRange: [first, index, last],
      outputRange: [0, 1, 1]
    });
    return {
      opacity: opacity
    };
  }

  function canUseNativeDriver() {
    return true;
  }

  exports.default = {
    forHorizontal: forHorizontal,
    forVertical: forVertical,
    forFadeFromBottomAndroid: forFadeFromBottomAndroid,
    forFade: forFade,
    canUseNativeDriver: canUseNativeDriver
  };
},406,[66,400],"react-navigation/src/views/CardStack/CardStackStyleInterpolator.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.supportsImprovedSpringAnimation = undefined;

  var _reactNative = require(_dependencyMap[0], "react-native");

  var PlatformConstants = _reactNative.NativeModules.PlatformConstants;

  var supportsImprovedSpringAnimation = exports.supportsImprovedSpringAnimation = function supportsImprovedSpringAnimation() {
    if (PlatformConstants && PlatformConstants.reactNativeVersion) {
      var _PlatformConstants$re = PlatformConstants.reactNativeVersion,
          major = _PlatformConstants$re.major,
          minor = _PlatformConstants$re.minor;
      return minor >= 50 || major === 0 && minor === 0;
    }

    return false;
  };
},407,[66],"react-navigation/src/utils/ReactNativeFeatures.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/Transitioner.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _invariant = require(_dependencyMap[2], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var _ScenesReducer = require(_dependencyMap[3], "./ScenesReducer");

  var _ScenesReducer2 = babelHelpers.interopRequireDefault(_ScenesReducer);

  var DefaultTransitionSpec = {
    duration: 250,
    easing: _reactNative.Easing.inOut(_reactNative.Easing.ease),
    timing: _reactNative.Animated.timing
  };

  var Transitioner = function (_React$Component) {
    babelHelpers.inherits(Transitioner, _React$Component);

    function Transitioner(props, context) {
      babelHelpers.classCallCheck(this, Transitioner);

      var _this = babelHelpers.possibleConstructorReturn(this, (Transitioner.__proto__ || Object.getPrototypeOf(Transitioner)).call(this, props, context));

      var layout = {
        height: new _reactNative.Animated.Value(0),
        initHeight: 0,
        initWidth: 0,
        isMeasured: false,
        width: new _reactNative.Animated.Value(0)
      };
      _this.state = {
        layout: layout,
        position: new _reactNative.Animated.Value(_this.props.navigation.state.index),
        progress: new _reactNative.Animated.Value(1),
        scenes: (0, _ScenesReducer2.default)([], _this.props.navigation.state)
      };
      _this._prevTransitionProps = null;
      _this._transitionProps = buildTransitionProps(props, _this.state);
      _this._isMounted = false;
      _this._isTransitionRunning = false;
      _this._queuedTransition = null;
      return _this;
    }

    babelHelpers.createClass(Transitioner, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this._onLayout = this._onLayout.bind(this);
        this._onTransitionEnd = this._onTransitionEnd.bind(this);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._isMounted = true;
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._isMounted = false;
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        var nextScenes = (0, _ScenesReducer2.default)(this.state.scenes, nextProps.navigation.state, this.props.navigation.state);

        if (nextScenes === this.state.scenes) {
          return;
        }

        var indexHasChanged = nextProps.navigation.state.index !== this.props.navigation.state.index;

        if (this._isTransitionRunning) {
          this._queuedTransition = {
            nextProps: nextProps,
            nextScenes: nextScenes,
            indexHasChanged: indexHasChanged
          };
          return;
        }

        this._startTransition(nextProps, nextScenes, indexHasChanged);
      }
    }, {
      key: "_startTransition",
      value: function _startTransition(nextProps, nextScenes, indexHasChanged) {
        var _this2 = this;

        var nextState = babelHelpers.extends({}, this.state, {
          scenes: nextScenes
        });
        var position = nextState.position,
            progress = nextState.progress;
        progress.setValue(0);
        this._prevTransitionProps = this._transitionProps;
        this._transitionProps = buildTransitionProps(nextProps, nextState);
        var transitionUserSpec = nextProps.configureTransition ? nextProps.configureTransition(this._transitionProps, this._prevTransitionProps) : null;
        var transitionSpec = babelHelpers.extends({}, DefaultTransitionSpec, transitionUserSpec);
        var timing = transitionSpec.timing;
        delete transitionSpec.timing;
        var toValue = nextProps.navigation.state.index;
        var positionHasChanged = position.__getValue() !== toValue;
        var animations = indexHasChanged && positionHasChanged ? [timing(progress, babelHelpers.extends({}, transitionSpec, {
          toValue: 1
        })), timing(position, babelHelpers.extends({}, transitionSpec, {
          toValue: nextProps.navigation.state.index
        }))] : [];
        this._isTransitionRunning = true;
        this.setState(nextState, function _callee() {
          var result;
          return regeneratorRuntime.async(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!nextProps.onTransitionStart) {
                    _context.next = 5;
                    break;
                  }

                  result = nextProps.onTransitionStart(_this2._transitionProps, _this2._prevTransitionProps);

                  if (!(result instanceof Promise)) {
                    _context.next = 5;
                    break;
                  }

                  _context.next = 5;
                  return regeneratorRuntime.awrap(result);

                case 5:
                  _reactNative.Animated.parallel(animations).start(_this2._onTransitionEnd);

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, null, _this2);
        });
      }
    }, {
      key: "render",
      value: function render() {
        return _react2.default.createElement(
          _reactNative.View,
          {
            onLayout: this._onLayout,
            style: [styles.main],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 142
            }
          },
          this.props.render(this._transitionProps, this._prevTransitionProps)
        );
      }
    }, {
      key: "_onLayout",
      value: function _onLayout(event) {
        var _event$nativeEvent$la = event.nativeEvent.layout,
            height = _event$nativeEvent$la.height,
            width = _event$nativeEvent$la.width;

        if (this.state.layout.initWidth === width && this.state.layout.initHeight === height) {
          return;
        }

        var layout = babelHelpers.extends({}, this.state.layout, {
          initHeight: height,
          initWidth: width,
          isMeasured: true
        });
        layout.height.setValue(height);
        layout.width.setValue(width);
        var nextState = babelHelpers.extends({}, this.state, {
          layout: layout
        });
        this._transitionProps = buildTransitionProps(this.props, nextState);
        this.setState(nextState);
      }
    }, {
      key: "_onTransitionEnd",
      value: function _onTransitionEnd() {
        var _this3 = this;

        if (!this._isMounted) {
          return;
        }

        var prevTransitionProps = this._prevTransitionProps;
        this._prevTransitionProps = null;
        var scenes = this.state.scenes.filter(isSceneNotStale);
        var nextState = babelHelpers.extends({}, this.state, {
          scenes: this.state.scenes.length === scenes.length ? this.state.scenes : scenes
        });
        this._transitionProps = buildTransitionProps(this.props, nextState);
        this.setState(nextState, function _callee2() {
          var result;
          return regeneratorRuntime.async(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!_this3.props.onTransitionEnd) {
                    _context2.next = 5;
                    break;
                  }

                  result = _this3.props.onTransitionEnd(_this3._transitionProps, prevTransitionProps);

                  if (!(result instanceof Promise)) {
                    _context2.next = 5;
                    break;
                  }

                  _context2.next = 5;
                  return regeneratorRuntime.awrap(result);

                case 5:
                  if (_this3._queuedTransition) {
                    _this3._startTransition(_this3._queuedTransition.nextProps, _this3._queuedTransition.nextScenes, _this3._queuedTransition.indexHasChanged);

                    _this3._queuedTransition = null;
                  } else {
                    _this3._isTransitionRunning = false;
                  }

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, null, _this3);
        });
      }
    }]);
    return Transitioner;
  }(_react2.default.Component);

  function buildTransitionProps(props, state) {
    var navigation = props.navigation;
    var layout = state.layout,
        position = state.position,
        progress = state.progress,
        scenes = state.scenes;
    var scene = scenes.find(isSceneActive);
    (0, _invariant2.default)(scene, 'Could not find active scene');
    return {
      layout: layout,
      navigation: navigation,
      position: position,
      progress: progress,
      scenes: scenes,
      scene: scene,
      index: scene.index
    };
  }

  function isSceneNotStale(scene) {
    return !scene.isStale;
  }

  function isSceneActive(scene) {
    return scene.isActive;
  }

  var styles = _reactNative.StyleSheet.create({
    main: {
      flex: 1
    }
  });

  exports.default = Transitioner;
},408,[12,66,381,409],"react-navigation/src/views/Transitioner.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ScenesReducer;

  var _invariant = require(_dependencyMap[0], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var _shallowEqual = require(_dependencyMap[1], "../utils/shallowEqual");

  var _shallowEqual2 = babelHelpers.interopRequireDefault(_shallowEqual);

  var SCENE_KEY_PREFIX = 'scene_';

  function compareKey(one, two) {
    var delta = one.length - two.length;

    if (delta > 0) {
      return 1;
    }

    if (delta < 0) {
      return -1;
    }

    return one > two ? 1 : -1;
  }

  function compareScenes(one, two) {
    if (one.index > two.index) {
      return 1;
    }

    if (one.index < two.index) {
      return -1;
    }

    return compareKey(one.key, two.key);
  }

  function areScenesShallowEqual(one, two) {
    return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);
  }

  function areRoutesShallowEqual(one, two) {
    if (!one || !two) {
      return one === two;
    }

    if (one.key !== two.key) {
      return false;
    }

    return (0, _shallowEqual2.default)(one, two);
  }

  function ScenesReducer(scenes, nextState, prevState) {
    if (prevState === nextState) {
      return scenes;
    }

    var prevScenes = new Map();
    var freshScenes = new Map();
    var staleScenes = new Map();
    scenes.forEach(function (scene) {
      var key = scene.key;

      if (scene.isStale) {
        staleScenes.set(key, scene);
      }

      prevScenes.set(key, scene);
    });
    var nextKeys = new Set();
    nextState.routes.forEach(function (route, index) {
      var key = SCENE_KEY_PREFIX + route.key;
      var scene = {
        index: index,
        isActive: false,
        isStale: false,
        key: key,
        route: route
      };
      (0, _invariant2.default)(!nextKeys.has(key), "navigation.state.routes[" + index + "].key \"" + key + "\" conflicts with " + 'another route!');
      nextKeys.add(key);

      if (staleScenes.has(key)) {
        staleScenes.delete(key);
      }

      freshScenes.set(key, scene);
    });

    if (prevState) {
      prevState.routes.forEach(function (route, index) {
        var key = SCENE_KEY_PREFIX + route.key;

        if (freshScenes.has(key)) {
          return;
        }

        staleScenes.set(key, {
          index: index,
          isActive: false,
          isStale: true,
          key: key,
          route: route
        });
      });
    }

    var nextScenes = [];

    var mergeScene = function mergeScene(nextScene) {
      var key = nextScene.key;
      var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;

      if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {
        nextScenes.push(prevScene);
      } else {
        nextScenes.push(nextScene);
      }
    };

    staleScenes.forEach(mergeScene);
    freshScenes.forEach(mergeScene);
    nextScenes.sort(compareScenes);
    var activeScenesCount = 0;
    nextScenes.forEach(function (scene, ii) {
      var isActive = !scene.isStale && scene.index === nextState.index;

      if (isActive !== scene.isActive) {
        nextScenes[ii] = babelHelpers.extends({}, scene, {
          isActive: isActive
        });
      }

      if (isActive) {
        activeScenesCount++;
      }
    });
    (0, _invariant2.default)(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);

    if (nextScenes.length !== scenes.length) {
      return nextScenes;
    }

    if (nextScenes.some(function (scene, index) {
      return !areScenesShallowEqual(scenes[index], scene);
    })) {
      return nextScenes;
    }

    return scenes;
  }
},409,[381,410],"react-navigation/src/views/ScenesReducer.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function is(x, y) {
    if (x === y) {
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }

  function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
      return true;
    }

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  }

  module.exports = shallowEqual;
},410,[],"react-navigation/src/utils/shallowEqual.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _pathToRegexp = require(_dependencyMap[0], "path-to-regexp");

  var _pathToRegexp2 = babelHelpers.interopRequireDefault(_pathToRegexp);

  var _NavigationActions = require(_dependencyMap[1], "../NavigationActions");

  var _NavigationActions2 = babelHelpers.interopRequireDefault(_NavigationActions);

  var _createConfigGetter = require(_dependencyMap[2], "./createConfigGetter");

  var _createConfigGetter2 = babelHelpers.interopRequireDefault(_createConfigGetter);

  var _getScreenForRouteName = require(_dependencyMap[3], "./getScreenForRouteName");

  var _getScreenForRouteName2 = babelHelpers.interopRequireDefault(_getScreenForRouteName);

  var _StateUtils = require(_dependencyMap[4], "../StateUtils");

  var _StateUtils2 = babelHelpers.interopRequireDefault(_StateUtils);

  var _validateRouteConfigMap = require(_dependencyMap[5], "./validateRouteConfigMap");

  var _validateRouteConfigMap2 = babelHelpers.interopRequireDefault(_validateRouteConfigMap);

  var _getScreenConfigDeprecated = require(_dependencyMap[6], "./getScreenConfigDeprecated");

  var _getScreenConfigDeprecated2 = babelHelpers.interopRequireDefault(_getScreenConfigDeprecated);

  var _invariant = require(_dependencyMap[7], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var _KeyGenerator = require(_dependencyMap[8], "./KeyGenerator");

  function isEmpty(obj) {
    if (!obj) return true;

    for (var key in obj) {
      return false;
    }

    return true;
  }

  function behavesLikePushAction(action) {
    return action.type === _NavigationActions2.default.NAVIGATE || action.type === _NavigationActions2.default.PUSH;
  }

  exports.default = function (routeConfigs) {
    var stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _validateRouteConfigMap2.default)(routeConfigs);
    var childRouters = {};
    var routeNames = Object.keys(routeConfigs);
    routeNames.forEach(function (routeName) {
      var screen = (0, _getScreenForRouteName2.default)(routeConfigs, routeName);

      if (screen && screen.router) {
        childRouters[routeName] = screen.router;
      } else {
        childRouters[routeName] = null;
      }
    });
    var initialRouteParams = stackConfig.initialRouteParams;
    var initialRouteName = stackConfig.initialRouteName || routeNames[0];
    var initialChildRouter = childRouters[initialRouteName];
    var pathsByRouteNames = babelHelpers.extends({}, stackConfig.paths) || {};
    var paths = [];

    function getInitialState(action) {
      var route = {};
      var childRouter = childRouters[action.routeName];

      if (behavesLikePushAction(action) && childRouter !== undefined) {
        var childState = {};

        if (childRouter !== null) {
          var childAction = action.action || _NavigationActions2.default.init({
            params: action.params
          });

          childState = childRouter.getStateForAction(childAction);
        }

        return {
          key: 'StackRouterRoot',
          isTransitioning: false,
          index: 0,
          routes: [babelHelpers.extends({
            params: action.params
          }, childState, {
            key: action.key || (0, _KeyGenerator.generateKey)(),
            routeName: action.routeName
          })]
        };
      }

      if (initialChildRouter) {
        route = initialChildRouter.getStateForAction(_NavigationActions2.default.navigate({
          routeName: initialRouteName,
          params: initialRouteParams
        }));
      }

      var params = (route.params || action.params || initialRouteParams) && babelHelpers.extends({}, route.params || {}, action.params || {}, initialRouteParams || {});
      var initialRouteKey = stackConfig.initialRouteKey;
      route = babelHelpers.extends({}, route, params ? {
        params: params
      } : {}, {
        routeName: initialRouteName,
        key: action.key || initialRouteKey || (0, _KeyGenerator.generateKey)()
      });
      return {
        key: 'StackRouterRoot',
        isTransitioning: false,
        index: 0,
        routes: [route]
      };
    }

    routeNames.forEach(function (routeName) {
      var pathPattern = pathsByRouteNames[routeName] || routeConfigs[routeName].path;
      var matchExact = !!pathPattern && !childRouters[routeName];

      if (pathPattern === undefined) {
        pathPattern = routeName;
      }

      var keys = [];
      var re = void 0,
          toPath = void 0,
          priority = void 0;

      if (typeof pathPattern === 'string') {
        re = (0, _pathToRegexp2.default)(pathPattern, keys);
        toPath = _pathToRegexp2.default.compile(pathPattern);
        priority = 0;
      } else {
        re = (0, _pathToRegexp2.default)('*', keys);

        toPath = function toPath() {
          return '';
        };

        matchExact = true;
        priority = -1;
      }

      if (!matchExact) {
        var wildcardRe = (0, _pathToRegexp2.default)(pathPattern + "/*", keys);
        re = new RegExp("(?:" + re.source + ")|(?:" + wildcardRe.source + ")");
      }

      pathsByRouteNames[routeName] = {
        re: re,
        keys: keys,
        toPath: toPath,
        priority: priority
      };
    });
    paths = Object.entries(pathsByRouteNames);
    paths.sort(function (a, b) {
      return b[1].priority - a[1].priority;
    });
    return {
      getComponentForState: function getComponentForState(state) {
        var activeChildRoute = state.routes[state.index];
        var routeName = activeChildRoute.routeName;

        if (childRouters[routeName]) {
          return childRouters[routeName].getComponentForState(activeChildRoute);
        }

        return (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
      },
      getComponentForRouteName: function getComponentForRouteName(routeName) {
        return (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
      },
      getStateForAction: function getStateForAction(action, state) {
        if (!state) {
          return getInitialState(action);
        }

        if (action.type !== _NavigationActions2.default.RESET || action.key !== null) {
          var keyIndex = action.key ? _StateUtils2.default.indexOf(state, action.key) : -1;
          var childIndex = keyIndex >= 0 ? keyIndex : state.index;
          var childRoute = state.routes[childIndex];
          (0, _invariant2.default)(childRoute, "StateUtils erroneously thought index " + childIndex + " exists");
          var childRouter = childRouters[childRoute.routeName];

          if (childRouter) {
            var route = childRouter.getStateForAction(action, childRoute);

            if (route === null) {
              return state;
            }

            if (route && route !== childRoute) {
              return _StateUtils2.default.replaceAt(state, childRoute.key, route);
            }
          }
        }

        if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined) {
          var _childRouter = childRouters[action.routeName];

          var _route = void 0;

          (0, _invariant2.default)(action.type !== _NavigationActions2.default.PUSH || action.key == null, 'StackRouter does not support key on the push action');

          if (action.key) {
            var lastRouteIndex = state.routes.findIndex(function (r) {
              return r.key === action.key;
            });

            if (lastRouteIndex !== -1) {
              if (state.index === lastRouteIndex && !action.params) {
                return state;
              }

              var routes = state.routes.slice(0, lastRouteIndex + 1);

              if (action.params) {
                var _route2 = state.routes.find(function (r) {
                  return r.key === action.key;
                });

                routes[lastRouteIndex] = babelHelpers.extends({}, _route2, {
                  params: babelHelpers.extends({}, _route2.params, action.params)
                });
              }

              return babelHelpers.extends({}, state, {
                isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : undefined,
                index: lastRouteIndex,
                routes: routes
              });
            }
          }

          if (_childRouter) {
            var childAction = action.action || _NavigationActions2.default.init({
              params: action.params
            });

            _route = babelHelpers.extends({
              params: action.params
            }, _childRouter.getStateForAction(childAction), {
              routeName: action.routeName,
              key: action.key || (0, _KeyGenerator.generateKey)()
            });
          } else {
            _route = {
              params: action.params,
              routeName: action.routeName,
              key: action.key || (0, _KeyGenerator.generateKey)()
            };
          }

          return babelHelpers.extends({}, _StateUtils2.default.push(state, _route), {
            isTransitioning: action.immediate !== true
          });
        } else if (action.type === _NavigationActions2.default.PUSH && childRouters[action.routeName] === undefined) {
          return babelHelpers.extends({}, state);
        }

        if (behavesLikePushAction(action)) {
          var childRouterNames = Object.keys(childRouters);

          for (var i = 0; i < childRouterNames.length; i++) {
            var childRouterName = childRouterNames[i];
            var _childRouter2 = childRouters[childRouterName];

            if (_childRouter2) {
              var initChildRoute = _childRouter2.getStateForAction(_NavigationActions2.default.init());

              var navigatedChildRoute = _childRouter2.getStateForAction(action, initChildRoute);

              var routeToPush = null;

              if (navigatedChildRoute === null) {
                routeToPush = initChildRoute;
              } else if (navigatedChildRoute !== initChildRoute) {
                routeToPush = navigatedChildRoute;
              }

              if (routeToPush) {
                var _route3 = babelHelpers.extends({}, routeToPush, {
                  routeName: childRouterName,
                  key: action.key || (0, _KeyGenerator.generateKey)()
                });

                return _StateUtils2.default.push(state, _route3);
              }
            }
          }
        }

        if (action.type === _NavigationActions2.default.POP_TO_TOP) {
          if (action.key && state.key !== action.key) {
            return state;
          }

          if (state.index === 0) {
            return babelHelpers.extends({}, state);
          } else {
            return babelHelpers.extends({}, state, {
              isTransitioning: action.immediate !== true,
              index: 0,
              routes: [state.routes[0]]
            });
          }

          return state;
        }

        if (action.type === _NavigationActions2.default.REPLACE) {
          var routeIndex = state.routes.findIndex(function (r) {
            return r.key === action.key;
          });

          if (routeIndex !== -1) {
            var _childRouter3 = childRouters[action.routeName];
            var childState = {};

            if (_childRouter3) {
              var _childAction = action.action || _NavigationActions2.default.init({
                params: action.params
              });

              childState = _childRouter3.getStateForAction(_childAction);
            }

            var _routes = [].concat(babelHelpers.toConsumableArray(state.routes));

            _routes[routeIndex] = babelHelpers.extends({
              params: action.params
            }, childState, {
              routeName: action.routeName,
              key: action.newKey || (0, _KeyGenerator.generateKey)()
            });
            return babelHelpers.extends({}, state, {
              routes: _routes
            });
          }
        }

        if (action.type === _NavigationActions2.default.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && state.isTransitioning) {
          return babelHelpers.extends({}, state, {
            isTransitioning: false
          });
        }

        if (action.type === _NavigationActions2.default.SET_PARAMS) {
          var key = action.key;
          var lastRoute = state.routes.find(function (route) {
            return route.key === key;
          });

          if (lastRoute) {
            var params = babelHelpers.extends({}, lastRoute.params, action.params);

            var _routes2 = [].concat(babelHelpers.toConsumableArray(state.routes));

            _routes2[state.routes.indexOf(lastRoute)] = babelHelpers.extends({}, lastRoute, {
              params: params
            });
            return babelHelpers.extends({}, state, {
              routes: _routes2
            });
          }
        }

        if (action.type === _NavigationActions2.default.RESET) {
          if (action.key != null && action.key != state.key) {
            return state;
          }

          var newStackActions = action.actions;
          return babelHelpers.extends({}, state, {
            routes: newStackActions.map(function (newStackAction) {
              var router = childRouters[newStackAction.routeName];
              var childState = {};

              if (router) {
                var _childAction2 = newStackAction.action || _NavigationActions2.default.init({
                  params: newStackAction.params
                });

                childState = router.getStateForAction(_childAction2);
              }

              return babelHelpers.extends({
                params: newStackAction.params
              }, childState, {
                routeName: newStackAction.routeName,
                key: newStackAction.key || (0, _KeyGenerator.generateKey)()
              });
            }),
            index: action.index
          });
        }

        if (action.type === _NavigationActions2.default.BACK || action.type === _NavigationActions2.default.POP) {
          var _key = action.key,
              n = action.n,
              immediate = action.immediate;
          var backRouteIndex = state.index;

          if (action.type === _NavigationActions2.default.POP && n != null) {
            backRouteIndex = Math.max(1, state.index - n + 1);
          } else if (_key) {
            var backRoute = state.routes.find(function (route) {
              return route.key === _key;
            });
            backRouteIndex = state.routes.indexOf(backRoute);
          }

          if (backRouteIndex > 0) {
            return babelHelpers.extends({}, state, {
              routes: state.routes.slice(0, backRouteIndex),
              index: backRouteIndex - 1,
              isTransitioning: immediate !== true
            });
          } else if (backRouteIndex === 0 && action.type === _NavigationActions2.default.POP) {
            return babelHelpers.extends({}, state);
          }
        }

        return state;
      },
      getPathAndParamsForState: function getPathAndParamsForState(state) {
        var route = state.routes[state.index];
        var routeName = route.routeName;
        var screen = (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
        var subPath = pathsByRouteNames[routeName].toPath(route.params);
        var path = subPath;
        var params = route.params;

        if (screen && screen.router) {
          var stateRoute = route;
          var child = screen.router.getPathAndParamsForState(stateRoute);
          path = subPath ? subPath + "/" + child.path : child.path;
          params = child.params ? babelHelpers.extends({}, params, child.params) : params;
        }

        return {
          path: path,
          params: params
        };
      },
      getActionForPathAndParams: function getActionForPathAndParams(pathToResolve, inputParams) {
        if (!pathToResolve) {
          return _NavigationActions2.default.navigate({
            routeName: initialRouteName
          });
        }

        var _pathToResolve$split = pathToResolve.split('?'),
            _pathToResolve$split2 = babelHelpers.slicedToArray(_pathToResolve$split, 2),
            pathNameToResolve = _pathToResolve$split2[0],
            queryString = _pathToResolve$split2[1];

        var matchedRouteName = void 0;
        var pathMatch = void 0;
        var pathMatchKeys = void 0;

        for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref3;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref3 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref3 = _i.value;
          }

          var _ref = _ref3;

          var _ref2 = babelHelpers.slicedToArray(_ref, 2);

          var routeName = _ref2[0];
          var path = _ref2[1];
          var re = path.re,
              keys = path.keys;
          pathMatch = re.exec(pathNameToResolve);

          if (pathMatch && pathMatch.length) {
            pathMatchKeys = keys;
            matchedRouteName = routeName;
            break;
          }
        }

        if (!matchedRouteName) {
          if (!pathToResolve) {
            return _NavigationActions2.default.navigate({
              routeName: initialRouteName
            });
          }

          return null;
        }

        var nestedAction = void 0;
        var nestedQueryString = queryString ? '?' + queryString : '';

        if (childRouters[matchedRouteName]) {
          nestedAction = childRouters[matchedRouteName].getActionForPathAndParams(pathMatch.slice(pathMatchKeys.length).join('/') + nestedQueryString);

          if (!nestedAction) {
            return null;
          }
        }

        var queryParams = !isEmpty(inputParams) ? inputParams : (queryString || '').split('&').reduce(function (result, item) {
          if (item !== '') {
            var nextResult = result || {};

            var _item$split = item.split('='),
                _item$split2 = babelHelpers.slicedToArray(_item$split, 2),
                key = _item$split2[0],
                value = _item$split2[1];

            nextResult[key] = value;
            return nextResult;
          }

          return result;
        }, null);
        var params = pathMatch.slice(1).reduce(function (result, matchResult, i) {
          var key = pathMatchKeys[i];

          if (key.asterisk || !key) {
            return result;
          }

          var nextResult = result || {};
          var paramName = key.name;
          var decodedMatchResult = void 0;

          try {
            decodedMatchResult = decodeURIComponent(matchResult);
          } catch (e) {}

          nextResult[paramName] = decodedMatchResult || matchResult;
          return nextResult;
        }, queryParams);
        return _NavigationActions2.default.navigate(babelHelpers.extends({
          routeName: matchedRouteName
        }, params ? {
          params: params
        } : {}, nestedAction ? {
          action: nestedAction
        } : {}));
      },
      getScreenOptions: (0, _createConfigGetter2.default)(routeConfigs, stackConfig.navigationOptions),
      getScreenConfig: _getScreenConfigDeprecated2.default
    };
  };
},411,[412,379,414,415,382,417,418,381,419],"react-navigation/src/routers/StackRouter.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isarray = require(_dependencyMap[0], 'isarray');

  module.exports = pathToRegexp;
  module.exports.parse = parse;
  module.exports.compile = compile;
  module.exports.tokensToFunction = tokensToFunction;
  module.exports.tokensToRegExp = tokensToRegExp;
  var PATH_REGEXP = new RegExp(['(\\\\.)', '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

  function parse(str, options) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path = '';
    var defaultDelimiter = options && options.delimiter || '/';
    var res;

    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path += str.slice(index, offset);
      index = offset + m.length;

      if (escaped) {
        path += escaped[1];
        continue;
      }

      var next = str[index];
      var prefix = res[2];
      var name = res[3];
      var capture = res[4];
      var group = res[5];
      var modifier = res[6];
      var asterisk = res[7];

      if (path) {
        tokens.push(path);
        path = '';
      }

      var partial = prefix != null && next != null && next !== prefix;
      var repeat = modifier === '+' || modifier === '*';
      var optional = modifier === '?' || modifier === '*';
      var delimiter = res[2] || defaultDelimiter;
      var pattern = capture || group;
      tokens.push({
        name: name || key++,
        prefix: prefix || '',
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        partial: partial,
        asterisk: !!asterisk,
        pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
      });
    }

    if (index < str.length) {
      path += str.substr(index);
    }

    if (path) {
      tokens.push(path);
    }

    return tokens;
  }

  function compile(str, options) {
    return tokensToFunction(parse(str, options));
  }

  function encodeURIComponentPretty(str) {
    return encodeURI(str).replace(/[\/?#]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }

  function encodeAsterisk(str) {
    return encodeURI(str).replace(/[?#]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }

  function tokensToFunction(tokens) {
    var matches = new Array(tokens.length);

    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === 'object') {
        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
      }
    }

    return function (obj, opts) {
      var path = '';
      var data = obj || {};
      var options = opts || {};
      var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (typeof token === 'string') {
          path += token;
          continue;
        }

        var value = data[token.name];
        var segment;

        if (value == null) {
          if (token.optional) {
            if (token.partial) {
              path += token.prefix;
            }

            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to be defined');
          }
        }

        if (isarray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
          }

          if (value.length === 0) {
            if (token.optional) {
              continue;
            } else {
              throw new TypeError('Expected "' + token.name + '" to not be empty');
            }
          }

          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j]);

            if (!matches[i].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
            }

            path += (j === 0 ? token.prefix : token.delimiter) + segment;
          }

          continue;
        }

        segment = token.asterisk ? encodeAsterisk(value) : encode(value);

        if (!matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
        }

        path += token.prefix + segment;
      }

      return path;
    };
  }

  function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
  }

  function escapeGroup(group) {
    return group.replace(/([=!:$\/()])/g, '\\$1');
  }

  function attachKeys(re, keys) {
    re.keys = keys;
    return re;
  }

  function flags(options) {
    return options.sensitive ? '' : 'i';
  }

  function regexpToRegexp(path, keys) {
    var groups = path.source.match(/\((?!\?)/g);

    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          asterisk: false,
          pattern: null
        });
      }
    }

    return attachKeys(path, keys);
  }

  function arrayToRegexp(path, keys, options) {
    var parts = [];

    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source);
    }

    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
    return attachKeys(regexp, keys);
  }

  function stringToRegexp(path, keys, options) {
    return tokensToRegExp(parse(path, options), keys, options);
  }

  function tokensToRegExp(tokens, keys, options) {
    if (!isarray(keys)) {
      options = keys || options;
      keys = [];
    }

    options = options || {};
    var strict = options.strict;
    var end = options.end !== false;
    var route = '';

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        route += escapeString(token);
      } else {
        var prefix = escapeString(token.prefix);
        var capture = '(?:' + token.pattern + ')';
        keys.push(token);

        if (token.repeat) {
          capture += '(?:' + prefix + capture + ')*';
        }

        if (token.optional) {
          if (!token.partial) {
            capture = '(?:' + prefix + '(' + capture + '))?';
          } else {
            capture = prefix + '(' + capture + ')?';
          }
        } else {
          capture = prefix + '(' + capture + ')';
        }

        route += capture;
      }
    }

    var delimiter = escapeString(options.delimiter || '/');
    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

    if (!strict) {
      route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
    }

    if (end) {
      route += '$';
    } else {
      route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
    }

    return attachKeys(new RegExp('^' + route, flags(options)), keys);
  }

  function pathToRegexp(path, keys, options) {
    if (!isarray(keys)) {
      options = keys || options;
      keys = [];
    }

    options = options || {};

    if (path instanceof RegExp) {
      return regexpToRegexp(path, keys);
    }

    if (isarray(path)) {
      return arrayToRegexp(path, keys, options);
    }

    return stringToRegexp(path, keys, options);
  }
},412,[413],"path-to-regexp/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
},413,[],"isarray/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _invariant = require(_dependencyMap[0], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var _getScreenForRouteName = require(_dependencyMap[1], "./getScreenForRouteName");

  var _getScreenForRouteName2 = babelHelpers.interopRequireDefault(_getScreenForRouteName);

  var _addNavigationHelpers = require(_dependencyMap[2], "../addNavigationHelpers");

  var _addNavigationHelpers2 = babelHelpers.interopRequireDefault(_addNavigationHelpers);

  var _validateScreenOptions = require(_dependencyMap[3], "./validateScreenOptions");

  var _validateScreenOptions2 = babelHelpers.interopRequireDefault(_validateScreenOptions);

  var _getChildEventSubscriber = require(_dependencyMap[4], "../getChildEventSubscriber");

  var _getChildEventSubscriber2 = babelHelpers.interopRequireDefault(_getChildEventSubscriber);

  function applyConfig(configurer, navigationOptions, configProps) {
    if (typeof configurer === 'function') {
      return babelHelpers.extends({}, navigationOptions, configurer(babelHelpers.extends({}, configProps, {
        navigationOptions: navigationOptions
      })));
    }

    if (typeof configurer === 'object') {
      return babelHelpers.extends({}, navigationOptions, configurer);
    }

    return navigationOptions;
  }

  exports.default = function (routeConfigs, navigatorScreenConfig) {
    return function (navigation, screenProps) {
      var state = navigation.state,
          dispatch = navigation.dispatch;
      var route = state;
      (0, _invariant2.default)(route.routeName && typeof route.routeName === 'string', 'Cannot get config because the route does not have a routeName.');
      var Component = (0, _getScreenForRouteName2.default)(routeConfigs, route.routeName);
      var outputConfig = {};
      var router = Component.router;

      if (router) {
        var routes = route.routes,
            index = route.index;

        if (!route || !routes || index == null) {
          throw new Error("Expect nav state to have routes and index, " + JSON.stringify(route));
        }

        var childRoute = routes[index];
        var childNavigation = (0, _addNavigationHelpers2.default)({
          state: childRoute,
          dispatch: dispatch,
          addListener: (0, _getChildEventSubscriber2.default)(navigation.addListener, childRoute.key)
        });
        outputConfig = router.getScreenOptions(childNavigation, screenProps);
      }

      var routeConfig = routeConfigs[route.routeName];
      var routeScreenConfig = routeConfig.navigationOptions;
      var componentScreenConfig = Component.navigationOptions;
      var configOptions = {
        navigation: navigation,
        screenProps: screenProps || {}
      };
      outputConfig = applyConfig(navigatorScreenConfig, outputConfig, configOptions);
      outputConfig = applyConfig(componentScreenConfig, outputConfig, configOptions);
      outputConfig = applyConfig(routeScreenConfig, outputConfig, configOptions);
      (0, _validateScreenOptions2.default)(outputConfig, route);
      return outputConfig;
    };
  };
},414,[381,415,380,416,403],"react-navigation/src/routers/createConfigGetter.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getScreenForRouteName;

  var _invariant = require(_dependencyMap[0], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  function getScreenForRouteName(routeConfigs, routeName) {
    var routeConfig = routeConfigs[routeName];

    if (!routeConfig) {
      throw new Error("There is no route defined for key " + routeName + ".\n" + ("Must be one of: " + Object.keys(routeConfigs).map(function (a) {
        return "'" + a + "'";
      }).join(',')));
    }

    if (routeConfig.screen) {
      return routeConfig.screen;
    }

    if (typeof routeConfig.getScreen === 'function') {
      var screen = routeConfig.getScreen();
      (0, _invariant2.default)(typeof screen === 'function', "The getScreen defined for route '" + routeName + " didn't return a valid " + 'screen or navigator.\n\n' + 'Please pass it like this:\n' + (routeName + ": {\n  getScreen: () => require('./MyScreen').default\n}"));
      return screen;
    }

    return routeConfig;
  }
},415,[381],"react-navigation/src/routers/getScreenForRouteName.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var deprecatedKeys = ['tabBar'];

  exports.default = function (screenOptions, route) {
    var keys = Object.keys(screenOptions);
    var deprecatedKey = keys.find(function (key) {
      return deprecatedKeys.includes(key);
    });

    if (typeof screenOptions.title === 'function') {
      throw new Error(["`title` cannot be defined as a function in navigation options for `" + route.routeName + "` screen. \n", 'Try replacing the following:', '{', '    title: ({ state }) => state...', '}', '', 'with:', '({ navigation }) => ({', '    title: navigation.state...', '})'].join('\n'));
    }

    if (deprecatedKey && typeof screenOptions[deprecatedKey] === 'function') {
      throw new Error(["`" + deprecatedKey + "` cannot be defined as a function in navigation options for `" + route.routeName + "` screen. \n", 'Try replacing the following:', '{', "    " + deprecatedKey + ": ({ state }) => ({", '         key: state...', '    })', '}', '', 'with:', '({ navigation }) => ({', "    " + deprecatedKey + "Key: navigation.state...", '})'].join('\n'));
    }

    if (deprecatedKey && typeof screenOptions[deprecatedKey] === 'object') {
      throw new Error(["Invalid key `" + deprecatedKey + "` defined in navigation options for `" + route.routeName + "` screen.", '\n', 'Try replacing the following navigation options:', '{', "    " + deprecatedKey + ": {"].concat(babelHelpers.toConsumableArray(Object.keys(screenOptions[deprecatedKey]).map(function (key) {
        return "        " + key + ": ...,";
      })), ['    },', '}', '\n', 'with:', '{'], babelHelpers.toConsumableArray(Object.keys(screenOptions[deprecatedKey]).map(function (key) {
        return "    " + (deprecatedKey + key[0].toUpperCase() + key.slice(1)) + ": ...,";
      })), ['}']).join('\n'));
    }
  };
},416,[],"react-navigation/src/routers/validateScreenOptions.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _invariant = require(_dependencyMap[0], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  function validateRouteConfigMap(routeConfigs) {
    var routeNames = Object.keys(routeConfigs);
    (0, _invariant2.default)(routeNames.length > 0, 'Please specify at least one route when configuring a navigator.');
    routeNames.forEach(function (routeName) {
      var routeConfig = routeConfigs[routeName];
      var screenComponent = getScreenComponent(routeConfig);

      if (!screenComponent || typeof screenComponent !== 'function' && typeof screenComponent !== 'string' && !routeConfig.getScreen) {
        throw new Error("The component for route '" + routeName + "' must be a " + 'React component. For example:\n\n' + "import MyScreen from './MyScreen';\n" + '...\n' + (routeName + ": MyScreen,\n") + '}\n\n' + 'You can also use a navigator:\n\n' + "import MyNavigator from './MyNavigator';\n" + '...\n' + (routeName + ": MyNavigator,\n") + '}');
      }

      if (routeConfig.screen && routeConfig.getScreen) {
        throw new Error("Route '" + routeName + "' should declare a screen or " + 'a getScreen, not both.');
      }
    });
  }

  function getScreenComponent(routeConfig) {
    if (!routeConfig) {
      return null;
    }

    return routeConfig.screen ? routeConfig.screen : routeConfig;
  }

  exports.default = validateRouteConfigMap;
},417,[381],"react-navigation/src/routers/validateRouteConfigMap.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _invariant = require(_dependencyMap[0], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  exports.default = function () {
    return (0, _invariant2.default)(false, '`getScreenConfig` has been replaced with `getScreenOptions`');
  };
},418,[381],"react-navigation/src/routers/getScreenConfigDeprecated.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._TESTING_ONLY_normalize_keys = _TESTING_ONLY_normalize_keys;
  exports.generateKey = generateKey;
  var uniqueBaseId = "id-" + Date.now();
  var uuidCount = 0;

  function _TESTING_ONLY_normalize_keys() {
    uniqueBaseId = 'id';
    uuidCount = 0;
  }

  function generateKey() {
    return uniqueBaseId + "-" + uuidCount++;
  }
},419,[],"react-navigation/src/routers/KeyGenerator.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/navigators/SwitchNavigator.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _SwitchRouter = require(_dependencyMap[1], "../routers/SwitchRouter");

  var _SwitchRouter2 = babelHelpers.interopRequireDefault(_SwitchRouter);

  var _SwitchView = require(_dependencyMap[2], "../views/SwitchView/SwitchView");

  var _SwitchView2 = babelHelpers.interopRequireDefault(_SwitchView);

  var _createNavigationContainer = require(_dependencyMap[3], "../createNavigationContainer");

  var _createNavigationContainer2 = babelHelpers.interopRequireDefault(_createNavigationContainer);

  var _createNavigator = require(_dependencyMap[4], "../navigators/createNavigator");

  var _createNavigator2 = babelHelpers.interopRequireDefault(_createNavigator);

  exports.default = function (routeConfigMap) {
    var switchConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var router = (0, _SwitchRouter2.default)(routeConfigMap, switchConfig);
    var navigator = (0, _createNavigator2.default)(router, routeConfigMap, switchConfig)(function (props) {
      return _react2.default.createElement(_SwitchView2.default, babelHelpers.extends({}, props, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 11
        }
      }));
    });
    return (0, _createNavigationContainer2.default)(navigator);
  };
},420,[12,421,422,377,383],"react-navigation/src/navigators/SwitchNavigator.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _invariant = require(_dependencyMap[0], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var _getScreenForRouteName = require(_dependencyMap[1], "./getScreenForRouteName");

  var _getScreenForRouteName2 = babelHelpers.interopRequireDefault(_getScreenForRouteName);

  var _createConfigGetter = require(_dependencyMap[2], "./createConfigGetter");

  var _createConfigGetter2 = babelHelpers.interopRequireDefault(_createConfigGetter);

  var _NavigationActions = require(_dependencyMap[3], "../NavigationActions");

  var _NavigationActions2 = babelHelpers.interopRequireDefault(_NavigationActions);

  var _validateRouteConfigMap = require(_dependencyMap[4], "./validateRouteConfigMap");

  var _validateRouteConfigMap2 = babelHelpers.interopRequireDefault(_validateRouteConfigMap);

  var _getScreenConfigDeprecated = require(_dependencyMap[5], "./getScreenConfigDeprecated");

  var _getScreenConfigDeprecated2 = babelHelpers.interopRequireDefault(_getScreenConfigDeprecated);

  function childrenUpdateWithoutSwitchingIndex(actionType) {
    return [_NavigationActions2.default.SET_PARAMS, _NavigationActions2.default.COMPLETE_TRANSITION].includes(actionType);
  }

  exports.default = function (routeConfigs) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _validateRouteConfigMap2.default)(routeConfigs);
    var order = config.order || Object.keys(routeConfigs);
    var paths = config.paths || {};
    var initialRouteParams = config.initialRouteParams;
    var initialRouteName = config.initialRouteName || order[0];
    var backBehavior = config.backBehavior || 'none';
    var shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';
    var resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;
    var initialRouteIndex = order.indexOf(initialRouteName);
    var childRouters = {};
    order.forEach(function (routeName) {
      var routeConfig = routeConfigs[routeName];
      paths[routeName] = typeof routeConfig.path === 'string' ? routeConfig.path : routeName;
      childRouters[routeName] = null;
      var screen = (0, _getScreenForRouteName2.default)(routeConfigs, routeName);

      if (screen.router) {
        childRouters[routeName] = screen.router;
      }
    });

    if (initialRouteIndex === -1) {
      throw new Error("Invalid initialRouteName '" + initialRouteName + "'." + ("Should be one of " + order.map(function (n) {
        return "\"" + n + "\"";
      }).join(', ')));
    }

    function resetChildRoute(routeName) {
      var params = routeName === initialRouteName ? initialRouteParams : undefined;
      var childRouter = childRouters[routeName];

      if (childRouter) {
        var childAction = _NavigationActions2.default.init();

        return babelHelpers.extends({}, childRouter.getStateForAction(childAction), {
          key: routeName,
          routeName: routeName,
          params: params
        });
      }

      return {
        key: routeName,
        routeName: routeName,
        params: params
      };
    }

    return {
      getInitialState: function getInitialState() {
        var routes = order.map(resetChildRoute);
        return {
          routes: routes,
          index: initialRouteIndex,
          isTransitioning: false
        };
      },
      getNextState: function getNextState(prevState, possibleNextState) {
        var nextState = void 0;

        if (prevState.index !== possibleNextState.index && resetOnBlur) {
          var prevRouteName = prevState.routes[prevState.index].routeName;
          var nextRoutes = [].concat(babelHelpers.toConsumableArray(possibleNextState.routes));
          nextRoutes[prevState.index] = resetChildRoute(prevRouteName);
          return babelHelpers.extends({}, possibleNextState, {
            routes: nextRoutes
          });
        } else {
          nextState = possibleNextState;
        }

        return nextState;
      },
      getStateForAction: function getStateForAction(action, inputState) {
        var prevState = inputState ? babelHelpers.extends({}, inputState) : inputState;
        var state = inputState || this.getInitialState();
        var activeChildIndex = state.index;

        if (action.type === _NavigationActions2.default.INIT) {
          var params = action.params;

          if (params) {
            state.routes = state.routes.map(function (route) {
              return babelHelpers.extends({}, route, {
                params: babelHelpers.extends({}, route.params, params, route.routeName === initialRouteName ? initialRouteParams : null)
              });
            });
          }
        }

        var activeChildLastState = state.routes[state.index];
        var activeChildRouter = childRouters[order[state.index]];

        if (activeChildRouter) {
          var activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);

          if (!activeChildState && inputState) {
            return null;
          }

          if (activeChildState && activeChildState !== activeChildLastState) {
            var _routes = [].concat(babelHelpers.toConsumableArray(state.routes));

            _routes[state.index] = activeChildState;
            return this.getNextState(prevState, babelHelpers.extends({}, state, {
              routes: _routes
            }));
          }
        }

        if (backBehavior !== 'none') {
          var isBackEligible = action.key == null || action.key === activeChildLastState.key;

          if (action.type === _NavigationActions2.default.BACK) {
            if (isBackEligible && shouldBackNavigateToInitialRoute) {
              activeChildIndex = initialRouteIndex;
            } else {
              return state;
            }
          }
        }

        var didNavigate = false;

        if (action.type === _NavigationActions2.default.NAVIGATE) {
          var navigateAction = action;
          didNavigate = !!order.find(function (childId, i) {
            if (childId === navigateAction.routeName) {
              activeChildIndex = i;
              return true;
            }

            return false;
          });

          if (didNavigate) {
            var childState = state.routes[activeChildIndex];
            var newChildState = void 0;
            var childRouter = childRouters[action.routeName];

            if (action.action) {
              newChildState = childRouter ? childRouter.getStateForAction(action.action, childState) : null;
            } else if (!childRouter && action.params) {
              newChildState = babelHelpers.extends({}, childState, {
                params: babelHelpers.extends({}, childState.params || {}, action.params)
              });
            }

            if (newChildState && newChildState !== childState) {
              var _routes2 = [].concat(babelHelpers.toConsumableArray(state.routes));

              _routes2[activeChildIndex] = newChildState;
              return this.getNextState(prevState, babelHelpers.extends({}, state, {
                routes: _routes2,
                index: activeChildIndex
              }));
            }
          }
        }

        if (action.type === _NavigationActions2.default.SET_PARAMS) {
          var key = action.key;
          var lastRoute = state.routes.find(function (route) {
            return route.key === key;
          });

          if (lastRoute) {
            var _params = babelHelpers.extends({}, lastRoute.params, action.params);

            var _routes3 = [].concat(babelHelpers.toConsumableArray(state.routes));

            _routes3[state.routes.indexOf(lastRoute)] = babelHelpers.extends({}, lastRoute, {
              params: _params
            });
            return this.getNextState(prevState, babelHelpers.extends({}, state, {
              routes: _routes3
            }));
          }
        }

        if (activeChildIndex !== state.index) {
          return this.getNextState(prevState, babelHelpers.extends({}, state, {
            index: activeChildIndex
          }));
        } else if (didNavigate && !inputState) {
          return state;
        } else if (didNavigate) {
          return null;
        }

        var index = state.index;
        var routes = state.routes;
        order.find(function (childId, i) {
          var childRouter = childRouters[childId];

          if (i === index) {
            return false;
          }

          var childState = routes[i];

          if (childRouter) {
            childState = childRouter.getStateForAction(action, childState);
          }

          if (!childState) {
            index = i;
            return true;
          }

          if (childState !== routes[i]) {
            routes = [].concat(babelHelpers.toConsumableArray(routes));
            routes[i] = childState;
            index = i;
            return true;
          }

          return false;
        });

        if (childrenUpdateWithoutSwitchingIndex(action.type)) {
          index = state.index;
        }

        if (index !== state.index || routes !== state.routes) {
          return this.getNextState(prevState, babelHelpers.extends({}, state, {
            index: index,
            routes: routes
          }));
        }

        return state;
      },
      getComponentForState: function getComponentForState(state) {
        var routeName = state.routes[state.index].routeName;
        (0, _invariant2.default)(routeName, "There is no route defined for index " + state.index + ". Check that\n        that you passed in a navigation state with a valid tab/screen index.");
        var childRouter = childRouters[routeName];

        if (childRouter) {
          return childRouter.getComponentForState(state.routes[state.index]);
        }

        return (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
      },
      getComponentForRouteName: function getComponentForRouteName(routeName) {
        return (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
      },
      getPathAndParamsForState: function getPathAndParamsForState(state) {
        var route = state.routes[state.index];
        var routeName = order[state.index];
        var subPath = paths[routeName];
        var screen = (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
        var path = subPath;
        var params = route.params;

        if (screen && screen.router) {
          var stateRoute = route;
          var child = screen.router.getPathAndParamsForState(stateRoute);
          path = subPath ? subPath + "/" + child.path : child.path;
          params = child.params ? babelHelpers.extends({}, params, child.params) : params;
        }

        return {
          path: path,
          params: params
        };
      },
      getActionForPathAndParams: function getActionForPathAndParams(path, params) {
        return order.map(function (childId) {
          var parts = path.split('/');
          var pathToTest = paths[childId];

          if (parts[0] === pathToTest) {
            var childRouter = childRouters[childId];

            var action = _NavigationActions2.default.navigate({
              routeName: childId
            });

            if (childRouter && childRouter.getActionForPathAndParams) {
              action.action = childRouter.getActionForPathAndParams(parts.slice(1).join('/'), params);
            } else if (params) {
              action.params = params;
            }

            return action;
          }

          return null;
        }).find(function (action) {
          return !!action;
        }) || order.map(function (childId) {
          var childRouter = childRouters[childId];
          return childRouter && childRouter.getActionForPathAndParams(path, params);
        }).find(function (action) {
          return !!action;
        }) || null;
      },
      getScreenOptions: (0, _createConfigGetter2.default)(routeConfigs, config.navigationOptions),
      getScreenConfig: _getScreenConfigDeprecated2.default
    };
  };
},421,[381,415,414,379,417,418],"react-navigation/src/routers/SwitchRouter.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/SwitchView/SwitchView.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _SceneView = require(_dependencyMap[1], "../SceneView");

  var _SceneView2 = babelHelpers.interopRequireDefault(_SceneView);

  var _withCachedChildNavigation = require(_dependencyMap[2], "../../withCachedChildNavigation");

  var _withCachedChildNavigation2 = babelHelpers.interopRequireDefault(_withCachedChildNavigation);

  var SwitchContainer = function (_React$Component) {
    babelHelpers.inherits(SwitchContainer, _React$Component);

    function SwitchContainer() {
      babelHelpers.classCallCheck(this, SwitchContainer);
      return babelHelpers.possibleConstructorReturn(this, (SwitchContainer.__proto__ || Object.getPrototypeOf(SwitchContainer)).apply(this, arguments));
    }

    babelHelpers.createClass(SwitchContainer, [{
      key: "render",
      value: function render() {
        var screenProps = this.props.screenProps;
        var route = this.props.navigation.state.routes[this.props.navigation.state.index];
        var childNavigation = this.props.childNavigationProps[route.key];
        var ChildComponent = this.props.router.getComponentForRouteName(route.routeName);
        return _react2.default.createElement(_SceneView2.default, {
          component: ChildComponent,
          navigation: childNavigation,
          screenProps: screenProps,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 18
          }
        });
      }
    }]);
    return SwitchContainer;
  }(_react2.default.Component);

  exports.default = (0, _withCachedChildNavigation2.default)(SwitchContainer);
},422,[12,404,423],"react-navigation/src/views/SwitchView/SwitchView.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/withCachedChildNavigation.js";
  exports.default = withCachedChildNavigation;

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _addNavigationHelpers = require(_dependencyMap[1], "./addNavigationHelpers");

  var _addNavigationHelpers2 = babelHelpers.interopRequireDefault(_addNavigationHelpers);

  var _getChildEventSubscriber = require(_dependencyMap[2], "./getChildEventSubscriber");

  var _getChildEventSubscriber2 = babelHelpers.interopRequireDefault(_getChildEventSubscriber);

  function withCachedChildNavigation(Comp) {
    var _class, _temp2;

    var displayName = Comp.displayName || Comp.name;
    return _temp2 = _class = function (_React$PureComponent) {
      babelHelpers.inherits(_class, _React$PureComponent);

      function _class() {
        var _ref;

        var _temp, _this, _ret;

        babelHelpers.classCallCheck(this, _class);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = _class.__proto__ || Object.getPrototypeOf(_class)).call.apply(_ref, [this].concat(args))), _this), _this._childEventSubscribers = {}, _this._isRouteFocused = function (route) {
          return function () {
            var state = _this.props.navigation.state;
            var focusedRoute = state.routes[state.index];
            return route === focusedRoute;
          };
        }, _this._updateNavigationProps = function (navigation) {
          if (!_this._childNavigationProps) {
            _this._childNavigationProps = {};
          }

          navigation.state.routes.forEach(function (route) {
            var childNavigation = _this._childNavigationProps[route.key];

            if (childNavigation && childNavigation.state === route) {
              return;
            }

            if (!_this._childEventSubscribers[route.key]) {
              _this._childEventSubscribers[route.key] = (0, _getChildEventSubscriber2.default)(navigation.addListener, route.key);
            }

            _this._childNavigationProps[route.key] = (0, _addNavigationHelpers2.default)({
              dispatch: navigation.dispatch,
              state: route,
              isFocused: _this._isRouteFocused.bind(_this, route),
              addListener: _this._childEventSubscribers[route.key]
            });
          });
        }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
      }

      babelHelpers.createClass(_class, [{
        key: "componentWillMount",
        value: function componentWillMount() {
          this._updateNavigationProps(this.props.navigation);
        }
      }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(nextProps) {
          this._updateNavigationProps(nextProps.navigation);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          var _this2 = this;

          var activeKeys = this.props.navigation.state.routes.map(function (route) {
            return route.key;
          });
          Object.keys(this._childEventSubscribers).forEach(function (key) {
            if (!activeKeys.includes(key)) {
              delete _this2._childEventSubscribers[key];
            }
          });
        }
      }, {
        key: "render",
        value: function render() {
          return _react2.default.createElement(Comp, babelHelpers.extends({}, this.props, {
            childNavigationProps: this._childNavigationProps,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 69
            }
          }));
        }
      }]);
      return _class;
    }(_react2.default.PureComponent), _class.displayName = "withCachedChildNavigation(" + displayName + ")", _temp2;
  }
},423,[12,380,403],"react-navigation/src/withCachedChildNavigation.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/navigators/TabNavigator.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _createNavigator = require(_dependencyMap[2], "./createNavigator");

  var _createNavigator2 = babelHelpers.interopRequireDefault(_createNavigator);

  var _createNavigationContainer = require(_dependencyMap[3], "../createNavigationContainer");

  var _createNavigationContainer2 = babelHelpers.interopRequireDefault(_createNavigationContainer);

  var _TabRouter = require(_dependencyMap[4], "../routers/TabRouter");

  var _TabRouter2 = babelHelpers.interopRequireDefault(_TabRouter);

  var _TabView = require(_dependencyMap[5], "../views/TabView/TabView");

  var _TabView2 = babelHelpers.interopRequireDefault(_TabView);

  var _TabBarTop = require(_dependencyMap[6], "../views/TabView/TabBarTop");

  var _TabBarTop2 = babelHelpers.interopRequireDefault(_TabBarTop);

  var _TabBarBottom = require(_dependencyMap[7], "../views/TabView/TabBarBottom");

  var _TabBarBottom2 = babelHelpers.interopRequireDefault(_TabBarBottom);

  var TabNavigator = function TabNavigator(routeConfigs) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var mergedConfig = babelHelpers.extends({}, TabNavigator.Presets.Default, config);
    var tabBarComponent = mergedConfig.tabBarComponent,
        tabBarPosition = mergedConfig.tabBarPosition,
        tabBarOptions = mergedConfig.tabBarOptions,
        lazy = mergedConfig.lazy,
        removeClippedSubviews = mergedConfig.removeClippedSubviews,
        swipeEnabled = mergedConfig.swipeEnabled,
        animationEnabled = mergedConfig.animationEnabled,
        configureTransition = mergedConfig.configureTransition,
        initialLayout = mergedConfig.initialLayout,
        tabsConfig = babelHelpers.objectWithoutProperties(mergedConfig, ["tabBarComponent", "tabBarPosition", "tabBarOptions", "lazy", "removeClippedSubviews", "swipeEnabled", "animationEnabled", "configureTransition", "initialLayout"]);
    var router = (0, _TabRouter2.default)(routeConfigs, tabsConfig);
    var navigator = (0, _createNavigator2.default)(router, routeConfigs, config)(function (props) {
      return _react2.default.createElement(_TabView2.default, babelHelpers.extends({}, props, {
        lazy: lazy,
        removeClippedSubviews: removeClippedSubviews,
        tabBarComponent: tabBarComponent,
        tabBarPosition: tabBarPosition,
        tabBarOptions: tabBarOptions,
        swipeEnabled: swipeEnabled,
        animationEnabled: animationEnabled,
        configureTransition: configureTransition,
        initialLayout: initialLayout,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 34
        }
      }));
    });
    return (0, _createNavigationContainer2.default)(navigator);
  };

  var Presets = {
    iOSBottomTabs: {
      tabBarComponent: _TabBarBottom2.default,
      tabBarPosition: 'bottom',
      swipeEnabled: false,
      animationEnabled: false,
      initialLayout: undefined
    },
    AndroidTopTabs: {
      tabBarComponent: _TabBarTop2.default,
      tabBarPosition: 'top',
      swipeEnabled: true,
      animationEnabled: true,
      initialLayout: undefined
    }
  };
  TabNavigator.Presets = {
    iOSBottomTabs: Presets.iOSBottomTabs,
    AndroidTopTabs: Presets.AndroidTopTabs,
    Default: _reactNative.Platform.OS === 'ios' ? Presets.iOSBottomTabs : Presets.AndroidTopTabs
  };
  exports.default = TabNavigator;
},424,[12,66,383,377,425,426,438,440],"react-navigation/src/navigators/TabNavigator.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _invariant = require(_dependencyMap[0], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var _getScreenForRouteName = require(_dependencyMap[1], "./getScreenForRouteName");

  var _getScreenForRouteName2 = babelHelpers.interopRequireDefault(_getScreenForRouteName);

  var _createConfigGetter = require(_dependencyMap[2], "./createConfigGetter");

  var _createConfigGetter2 = babelHelpers.interopRequireDefault(_createConfigGetter);

  var _NavigationActions = require(_dependencyMap[3], "../NavigationActions");

  var _NavigationActions2 = babelHelpers.interopRequireDefault(_NavigationActions);

  var _validateRouteConfigMap = require(_dependencyMap[4], "./validateRouteConfigMap");

  var _validateRouteConfigMap2 = babelHelpers.interopRequireDefault(_validateRouteConfigMap);

  var _getScreenConfigDeprecated = require(_dependencyMap[5], "./getScreenConfigDeprecated");

  var _getScreenConfigDeprecated2 = babelHelpers.interopRequireDefault(_getScreenConfigDeprecated);

  function childrenUpdateWithoutSwitchingIndex(actionType) {
    return [_NavigationActions2.default.SET_PARAMS, _NavigationActions2.default.COMPLETE_TRANSITION].includes(actionType);
  }

  exports.default = function (routeConfigs) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _validateRouteConfigMap2.default)(routeConfigs);
    var order = config.order || Object.keys(routeConfigs);
    var paths = config.paths || {};
    var initialRouteParams = config.initialRouteParams;
    var initialRouteName = config.initialRouteName || order[0];
    var initialRouteIndex = order.indexOf(initialRouteName);
    var backBehavior = config.backBehavior || 'initialRoute';
    var shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';
    var tabRouters = {};
    order.forEach(function (routeName) {
      var routeConfig = routeConfigs[routeName];
      paths[routeName] = typeof routeConfig.path === 'string' ? routeConfig.path : routeName;
      tabRouters[routeName] = null;
      var screen = (0, _getScreenForRouteName2.default)(routeConfigs, routeName);

      if (screen.router) {
        tabRouters[routeName] = screen.router;
      }
    });

    if (initialRouteIndex === -1) {
      throw new Error("Invalid initialRouteName '" + initialRouteName + "' for TabRouter. " + ("Should be one of " + order.map(function (n) {
        return "\"" + n + "\"";
      }).join(', ')));
    }

    return {
      getStateForAction: function getStateForAction(action, inputState) {
        var state = inputState;

        if (!state) {
          var _routes = order.map(function (routeName) {
            var params = routeName === initialRouteName ? initialRouteParams : undefined;
            var tabRouter = tabRouters[routeName];

            if (tabRouter) {
              var childAction = _NavigationActions2.default.init();

              return babelHelpers.extends({}, tabRouter.getStateForAction(childAction), {
                key: routeName,
                routeName: routeName,
                params: params
              });
            }

            return {
              key: routeName,
              routeName: routeName,
              params: params
            };
          });

          state = {
            routes: _routes,
            index: initialRouteIndex,
            isTransitioning: false
          };
        }

        if (action.type === _NavigationActions2.default.INIT) {
          var params = action.params;

          if (params) {
            state.routes = state.routes.map(function (route) {
              return babelHelpers.extends({}, route, {
                params: babelHelpers.extends({}, route.params, params, route.routeName === initialRouteName ? initialRouteParams : null)
              });
            });
          }
        }

        var activeTabLastState = state.routes[state.index];
        var activeTabRouter = tabRouters[order[state.index]];

        if (activeTabRouter) {
          var activeTabState = activeTabRouter.getStateForAction(action, activeTabLastState);

          if (!activeTabState && inputState) {
            return null;
          }

          if (activeTabState && activeTabState !== activeTabLastState) {
            var _routes2 = [].concat(babelHelpers.toConsumableArray(state.routes));

            _routes2[state.index] = activeTabState;
            return babelHelpers.extends({}, state, {
              routes: _routes2
            });
          }
        }

        var activeTabIndex = state.index;
        var isBackEligible = action.key == null || action.key === activeTabLastState.key;

        if (action.type === _NavigationActions2.default.BACK) {
          if (isBackEligible && shouldBackNavigateToInitialRoute) {
            activeTabIndex = initialRouteIndex;
          } else {
            return state;
          }
        }

        var didNavigate = false;

        if (action.type === _NavigationActions2.default.NAVIGATE) {
          var navigateAction = action;
          didNavigate = !!order.find(function (tabId, i) {
            if (tabId === navigateAction.routeName) {
              activeTabIndex = i;
              return true;
            }

            return false;
          });

          if (didNavigate) {
            var childState = state.routes[activeTabIndex];
            var newChildState = void 0;
            var tabRouter = tabRouters[action.routeName];

            if (action.action) {
              newChildState = tabRouter ? tabRouter.getStateForAction(action.action, childState) : null;
            } else if (!tabRouter && action.params) {
              newChildState = babelHelpers.extends({}, childState, {
                params: babelHelpers.extends({}, childState.params || {}, action.params)
              });
            }

            if (newChildState && newChildState !== childState) {
              var _routes3 = [].concat(babelHelpers.toConsumableArray(state.routes));

              _routes3[activeTabIndex] = newChildState;
              return babelHelpers.extends({}, state, {
                routes: _routes3,
                index: activeTabIndex
              });
            }
          }
        }

        if (action.type === _NavigationActions2.default.SET_PARAMS) {
          var key = action.key;
          var lastRoute = state.routes.find(function (route) {
            return route.key === key;
          });

          if (lastRoute) {
            var _params = babelHelpers.extends({}, lastRoute.params, action.params);

            var _routes4 = [].concat(babelHelpers.toConsumableArray(state.routes));

            _routes4[state.routes.indexOf(lastRoute)] = babelHelpers.extends({}, lastRoute, {
              params: _params
            });
            return babelHelpers.extends({}, state, {
              routes: _routes4
            });
          }
        }

        if (activeTabIndex !== state.index) {
          return babelHelpers.extends({}, state, {
            index: activeTabIndex
          });
        } else if (didNavigate && !inputState) {
          return state;
        } else if (didNavigate) {
          return null;
        }

        var index = state.index;
        var routes = state.routes;
        order.find(function (tabId, i) {
          var tabRouter = tabRouters[tabId];

          if (i === index) {
            return false;
          }

          var tabState = routes[i];

          if (tabRouter) {
            tabState = tabRouter.getStateForAction(action, tabState);
          }

          if (!tabState) {
            index = i;
            return true;
          }

          if (tabState !== routes[i]) {
            routes = [].concat(babelHelpers.toConsumableArray(routes));
            routes[i] = tabState;
            index = i;
            return true;
          }

          return false;
        });

        if (childrenUpdateWithoutSwitchingIndex(action.type)) {
          index = state.index;
        }

        if (index !== state.index || routes !== state.routes) {
          return babelHelpers.extends({}, state, {
            index: index,
            routes: routes
          });
        }

        return state;
      },
      getComponentForState: function getComponentForState(state) {
        var routeName = state.routes[state.index].routeName;
        (0, _invariant2.default)(routeName, "There is no route defined for index " + state.index + ". Check that\n        that you passed in a navigation state with a valid tab/screen index.");
        var childRouter = tabRouters[routeName];

        if (childRouter) {
          return childRouter.getComponentForState(state.routes[state.index]);
        }

        return (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
      },
      getComponentForRouteName: function getComponentForRouteName(routeName) {
        return (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
      },
      getPathAndParamsForState: function getPathAndParamsForState(state) {
        var route = state.routes[state.index];
        var routeName = order[state.index];
        var subPath = paths[routeName];
        var screen = (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
        var path = subPath;
        var params = route.params;

        if (screen && screen.router) {
          var stateRoute = route;
          var child = screen.router.getPathAndParamsForState(stateRoute);
          path = subPath ? subPath + "/" + child.path : child.path;
          params = child.params ? babelHelpers.extends({}, params, child.params) : params;
        }

        return {
          path: path,
          params: params
        };
      },
      getActionForPathAndParams: function getActionForPathAndParams(path, params) {
        return order.map(function (tabId) {
          var parts = path.split('/');
          var pathToTest = paths[tabId];

          if (parts[0] === pathToTest) {
            var tabRouter = tabRouters[tabId];

            var action = _NavigationActions2.default.navigate({
              routeName: tabId
            });

            if (tabRouter && tabRouter.getActionForPathAndParams) {
              action.action = tabRouter.getActionForPathAndParams(parts.slice(1).join('/'), params);
            } else if (params) {
              action.params = params;
            }

            return action;
          }

          return null;
        }).find(function (action) {
          return !!action;
        }) || order.map(function (tabId) {
          var tabRouter = tabRouters[tabId];
          return tabRouter && tabRouter.getActionForPathAndParams(path, params);
        }).find(function (action) {
          return !!action;
        }) || null;
      },
      getScreenOptions: (0, _createConfigGetter2.default)(routeConfigs, config.navigationOptions),
      getScreenConfig: _getScreenConfigDeprecated2.default
    };
  };
},425,[381,415,414,379,417,418],"react-navigation/src/routers/TabRouter.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/TabView/TabView.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _reactNativeTabView = require(_dependencyMap[2], "react-native-tab-view");

  var _reactNativeSafeAreaView = require(_dependencyMap[3], "react-native-safe-area-view");

  var _reactNativeSafeAreaView2 = babelHelpers.interopRequireDefault(_reactNativeSafeAreaView);

  var _ResourceSavingSceneView = require(_dependencyMap[4], "../ResourceSavingSceneView");

  var _ResourceSavingSceneView2 = babelHelpers.interopRequireDefault(_ResourceSavingSceneView);

  var _withCachedChildNavigation = require(_dependencyMap[5], "../../withCachedChildNavigation");

  var _withCachedChildNavigation2 = babelHelpers.interopRequireDefault(_withCachedChildNavigation);

  var TabView = function (_React$PureComponent) {
    babelHelpers.inherits(TabView, _React$PureComponent);

    function TabView() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, TabView);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = TabView.__proto__ || Object.getPrototypeOf(TabView)).call.apply(_ref, [this].concat(args))), _this), _this._handlePageChanged = function (index) {
        var navigation = _this.props.navigation;
        navigation.navigate(navigation.state.routes[index].routeName);
      }, _this._renderScene = function (_ref2) {
        var route = _ref2.route;
        var screenProps = _this.props.screenProps;
        var childNavigation = _this.props.childNavigationProps[route.key];

        var TabComponent = _this.props.router.getComponentForRouteName(route.routeName);

        return _react2.default.createElement(_ResourceSavingSceneView2.default, {
          lazy: _this.props.lazy,
          removeClippedSubViews: _this.props.removeClippedSubviews,
          animationEnabled: _this.props.animationEnabled,
          swipeEnabled: _this.props.swipeEnabled,
          screenProps: screenProps,
          component: TabComponent,
          navigation: _this.props.navigation,
          childNavigation: childNavigation,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 32
          }
        });
      }, _this._getLabel = function (_ref3) {
        var route = _ref3.route,
            tintColor = _ref3.tintColor,
            focused = _ref3.focused;

        var options = _this.props.router.getScreenOptions(_this.props.childNavigationProps[route.key], _this.props.screenProps || {});

        if (options.tabBarLabel) {
          return typeof options.tabBarLabel === 'function' ? options.tabBarLabel({
            tintColor: tintColor,
            focused: focused
          }) : options.tabBarLabel;
        }

        if (typeof options.title === 'string') {
          return options.title;
        }

        return route.routeName;
      }, _this._getOnPress = function (previousScene, _ref4) {
        var route = _ref4.route;

        var options = _this.props.router.getScreenOptions(_this.props.childNavigationProps[route.key], _this.props.screenProps || {});

        return options.tabBarOnPress;
      }, _this._getTestIDProps = function (_ref5) {
        var route = _ref5.route,
            focused = _ref5.focused;

        var options = _this.props.router.getScreenOptions(_this.props.childNavigationProps[route.key], _this.props.screenProps || {});

        return typeof options.tabBarTestIDProps === 'function' ? options.tabBarTestIDProps({
          focused: focused
        }) : options.tabBarTestIDProps;
      }, _this._renderIcon = function (_ref6) {
        var focused = _ref6.focused,
            route = _ref6.route,
            tintColor = _ref6.tintColor;

        var options = _this.props.router.getScreenOptions(_this.props.childNavigationProps[route.key], _this.props.screenProps || {});

        if (options.tabBarIcon) {
          return typeof options.tabBarIcon === 'function' ? options.tabBarIcon({
            tintColor: tintColor,
            focused: focused
          }) : options.tabBarIcon;
        }

        return null;
      }, _this._renderTabBar = function (props) {
        var _this$props = _this.props,
            tabBarOptions = _this$props.tabBarOptions,
            TabBarComponent = _this$props.tabBarComponent,
            animationEnabled = _this$props.animationEnabled;

        if (typeof TabBarComponent === 'undefined') {
          return null;
        }

        return _react2.default.createElement(TabBarComponent, babelHelpers.extends({}, props, tabBarOptions, {
          tabBarPosition: _this.props.tabBarPosition,
          screenProps: _this.props.screenProps,
          navigation: _this.props.navigation,
          getLabel: _this._getLabel,
          getTestIDProps: _this._getTestIDProps,
          getOnPress: _this._getOnPress,
          renderIcon: _this._renderIcon,
          animationEnabled: animationEnabled,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 108
          }
        }));
      }, _this._renderPager = function (props) {
        return _react2.default.createElement(_reactNativeTabView.TabViewPagerPan, babelHelpers.extends({}, props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 123
          }
        }));
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(TabView, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            router = _props.router,
            tabBarComponent = _props.tabBarComponent,
            tabBarPosition = _props.tabBarPosition,
            animationEnabled = _props.animationEnabled,
            configureTransition = _props.configureTransition,
            initialLayout = _props.initialLayout,
            screenProps = _props.screenProps;
        var renderHeader = void 0;
        var renderFooter = void 0;
        var renderPager = void 0;
        var state = this.props.navigation.state;
        var options = router.getScreenOptions(this.props.childNavigationProps[state.routes[state.index].key], screenProps || {});
        var tabBarVisible = options.tabBarVisible == null ? true : options.tabBarVisible;
        var swipeEnabled = options.swipeEnabled == null ? this.props.swipeEnabled : options.swipeEnabled;

        if (typeof swipeEnabled === 'function') {
          swipeEnabled = swipeEnabled(state);
        }

        if (tabBarComponent !== undefined && tabBarVisible) {
          if (tabBarPosition === 'bottom') {
            renderFooter = this._renderTabBar;
          } else {
            renderHeader = this._renderTabBar;
          }
        }

        if (animationEnabled === false && swipeEnabled === false || typeof configureTransition === 'function') {
          renderPager = this._renderPager;
        }

        var props = {
          initialLayout: initialLayout,
          animationEnabled: animationEnabled,
          configureTransition: configureTransition,
          swipeEnabled: swipeEnabled,
          renderPager: renderPager,
          renderHeader: renderHeader,
          renderFooter: renderFooter,
          renderScene: this._renderScene,
          onIndexChange: this._handlePageChanged,
          navigationState: this.props.navigation.state,
          screenProps: this.props.screenProps,
          style: styles.container
        };
        return _react2.default.createElement(_reactNativeTabView.TabViewAnimated, babelHelpers.extends({}, props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 188
          }
        }));
      }
    }]);
    return TabView;
  }(_react2.default.PureComponent);

  TabView.defaultProps = {
    lazy: true,
    removedClippedSubviews: true,
    initialLayout: _reactNative.Platform.select({
      android: {
        width: 1,
        height: 0
      }
    })
  };
  exports.default = (0, _withCachedChildNavigation2.default)(TabView);

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1
    }
  });
},426,[12,66,427,392,437,423],"react-navigation/src/views/TabView/TabView.js");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = {
    get TabViewAnimated() {
      return require(_dependencyMap[0], './TabViewAnimated').default;
    },

    get TabViewPagerPan() {
      return require(_dependencyMap[1], './TabViewPagerPan').default;
    },

    get TabViewPagerScroll() {
      return require(_dependencyMap[2], './TabViewPagerScroll').default;
    },

    get TabViewPagerAndroid() {
      return require(_dependencyMap[3], './TabViewPagerAndroid').default;
    },

    get TabViewPagerExperimental() {
      return require(_dependencyMap[4], './TabViewPagerExperimental').default;
    },

    get TabBar() {
      return require(_dependencyMap[5], './TabBar').default;
    },

    get SceneMap() {
      return require(_dependencyMap[6], './SceneMap').default;
    }

  };
},427,[428,432,431,430,433,434,436],"react-native-tab-view/src/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-tab-view/src/TabViewAnimated.js";

  var _react = require(_dependencyMap[0], "react");

  var React = babelHelpers.interopRequireWildcard(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _TabViewPropTypes = require(_dependencyMap[3], "./TabViewPropTypes");

  var TabViewPager = void 0;

  switch (_reactNative.Platform.OS) {
    case 'android':
      TabViewPager = require(_dependencyMap[4], './TabViewPagerAndroid').default;
      break;

    case 'ios':
      TabViewPager = require(_dependencyMap[5], './TabViewPagerScroll').default;
      break;

    default:
      TabViewPager = require(_dependencyMap[6], './TabViewPagerPan').default;
      break;
  }

  var TabViewAnimated = function (_React$Component) {
    babelHelpers.inherits(TabViewAnimated, _React$Component);

    function TabViewAnimated(props) {
      babelHelpers.classCallCheck(this, TabViewAnimated);

      var _this = babelHelpers.possibleConstructorReturn(this, (TabViewAnimated.__proto__ || Object.getPrototypeOf(TabViewAnimated)).call(this, props));

      _initialiseProps.call(_this);

      var navigationState = _this.props.navigationState;
      var layout = babelHelpers.extends({}, _this.props.initialLayout, {
        measured: false
      });
      var panX = new _reactNative.Animated.Value(0);
      var offsetX = new _reactNative.Animated.Value(-navigationState.index * layout.width);
      var layoutXY = new _reactNative.Animated.ValueXY({
        x: layout.width || 0.001,
        y: layout.height || 0.001
      });

      var position = _reactNative.Animated.multiply(_reactNative.Animated.divide(_reactNative.Animated.add(panX, offsetX), layoutXY.x), -1);

      _this.state = {
        loaded: [navigationState.index],
        layout: layout,
        layoutXY: layoutXY,
        panX: panX,
        offsetX: offsetX,
        position: position
      };
      return _this;
    }

    babelHelpers.createClass(TabViewAnimated, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._mounted = true;
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._mounted = false;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            navigationState = _props.navigationState,
            onIndexChange = _props.onIndexChange,
            initialLayout = _props.initialLayout,
            renderScene = _props.renderScene,
            renderPager = _props.renderPager,
            renderHeader = _props.renderHeader,
            renderFooter = _props.renderFooter,
            rest = babelHelpers.objectWithoutProperties(_props, ["navigationState", "onIndexChange", "initialLayout", "renderScene", "renderPager", "renderHeader", "renderFooter"]);

        var props = this._buildSceneRendererProps();

        return React.createElement(
          _reactNative.View,
          {
            onLayout: this._handleLayout,
            loaded: this.state.loaded,
            style: [styles.container, this.props.style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 194
            }
          },
          renderHeader && renderHeader(props),
          renderPager(babelHelpers.extends({}, props, rest, {
            panX: this.state.panX,
            offsetX: this.state.offsetX,
            children: navigationState.routes.map(function (route, index) {
              var scene = _this2._renderScene(babelHelpers.extends({}, props, {
                route: route,
                index: index,
                focused: index === navigationState.index
              }));

              if (scene) {
                return React.cloneElement(scene, {
                  key: route.key
                });
              }

              return scene;
            })
          })),
          renderFooter && renderFooter(props)
        );
      }
    }]);
    return TabViewAnimated;
  }(React.Component);

  TabViewAnimated.propTypes = {
    navigationState: _TabViewPropTypes.NavigationStatePropType.isRequired,
    onIndexChange: _propTypes2.default.func.isRequired,
    initialLayout: _propTypes2.default.shape({
      height: _propTypes2.default.number.isRequired,
      width: _propTypes2.default.number.isRequired
    }),
    canJumpToTab: _propTypes2.default.func.isRequired,
    renderPager: _propTypes2.default.func.isRequired,
    renderScene: _propTypes2.default.func.isRequired,
    renderHeader: _propTypes2.default.func,
    renderFooter: _propTypes2.default.func
  };
  TabViewAnimated.defaultProps = {
    canJumpToTab: function canJumpToTab() {
      return true;
    },
    renderPager: function renderPager(props) {
      return React.createElement(TabViewPager, babelHelpers.extends({}, props, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 71
        }
      }));
    },
    initialLayout: {
      height: 0,
      width: 0
    },
    useNativeDriver: false
  };

  var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this._mounted = false;

    this._renderScene = function (props) {
      return _this3.props.renderScene(props);
    };

    this._handleLayout = function (e) {
      var _e$nativeEvent$layout = e.nativeEvent.layout,
          height = _e$nativeEvent$layout.height,
          width = _e$nativeEvent$layout.width;

      if (_this3.state.layout.width === width && _this3.state.layout.height === height) {
        return;
      }

      _this3.state.offsetX.setValue(-_this3.props.navigationState.index * width);

      _this3.state.layoutXY.setValue({
        x: width || 0.001,
        y: height || 0.001
      });

      _this3.setState({
        layout: {
          measured: true,
          height: height,
          width: width
        }
      });
    };

    this._buildSceneRendererProps = function () {
      return {
        panX: _this3.state.panX,
        offsetX: _this3.state.offsetX,
        position: _this3.state.position,
        layout: _this3.state.layout,
        navigationState: _this3.props.navigationState,
        jumpToIndex: _this3._jumpToIndex,
        useNativeDriver: _this3.props.useNativeDriver === true
      };
    };

    this._jumpToIndex = function (index) {
      if (!_this3._mounted) {
        return;
      }

      var _props2 = _this3.props,
          canJumpToTab = _props2.canJumpToTab,
          navigationState = _props2.navigationState;

      if (!canJumpToTab(navigationState.routes[index])) {
        return;
      }

      if (index !== navigationState.index) {
        _this3.props.onIndexChange(index);
      }
    };
  };

  exports.default = TabViewAnimated;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      overflow: 'hidden'
    }
  });
},428,[12,24,66,429,430,431,432],"react-native-tab-view/src/TabViewAnimated.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PagerRendererPropType = exports.SceneRendererPropType = exports.NavigationStatePropType = exports.NavigationRoutePropType = undefined;

  var _propTypes = require(_dependencyMap[0], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var NavigationRoutePropType = exports.NavigationRoutePropType = _propTypes2.default.shape({
    title: _propTypes2.default.string,
    key: _propTypes2.default.string.isRequired
  });

  var NavigationStatePropType = exports.NavigationStatePropType = _propTypes2.default.shape({
    routes: _propTypes2.default.arrayOf(NavigationRoutePropType).isRequired,
    index: _propTypes2.default.number.isRequired
  });

  var SceneRendererPropType = exports.SceneRendererPropType = {
    panX: _propTypes2.default.object.isRequired,
    offsetX: _propTypes2.default.object.isRequired,
    layout: _propTypes2.default.shape({
      measured: _propTypes2.default.bool.isRequired,
      height: _propTypes2.default.number.isRequired,
      width: _propTypes2.default.number.isRequired
    }).isRequired,
    navigationState: NavigationStatePropType.isRequired,
    position: _propTypes2.default.object.isRequired,
    jumpToIndex: _propTypes2.default.func.isRequired,
    useNativeDriver: _propTypes2.default.bool
  };
  var PagerRendererPropType = exports.PagerRendererPropType = {
    layout: _propTypes2.default.shape({
      measured: _propTypes2.default.bool.isRequired,
      height: _propTypes2.default.number.isRequired,
      width: _propTypes2.default.number.isRequired
    }).isRequired,
    navigationState: NavigationStatePropType.isRequired,
    panX: _propTypes2.default.instanceOf(_reactNative.Animated.Value).isRequired,
    offsetX: _propTypes2.default.instanceOf(_reactNative.Animated.Value).isRequired,
    canJumpToTab: _propTypes2.default.func.isRequired,
    jumpToIndex: _propTypes2.default.func.isRequired,
    animationEnabled: _propTypes2.default.bool,
    swipeEnabled: _propTypes2.default.bool,
    useNativeDriver: _propTypes2.default.bool,
    children: _propTypes2.default.node.isRequired
  };
},429,[24,66],"react-native-tab-view/src/TabViewPropTypes.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-tab-view/src/TabViewPagerAndroid.js";

  var _react = require(_dependencyMap[0], "react");

  var React = babelHelpers.interopRequireWildcard(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _TabViewPropTypes = require(_dependencyMap[2], "./TabViewPropTypes");

  var TabViewPagerAndroid = function (_React$Component) {
    babelHelpers.inherits(TabViewPagerAndroid, _React$Component);

    function TabViewPagerAndroid(props) {
      babelHelpers.classCallCheck(this, TabViewPagerAndroid);

      var _this = babelHelpers.possibleConstructorReturn(this, (TabViewPagerAndroid.__proto__ || Object.getPrototypeOf(TabViewPagerAndroid)).call(this, props));

      _this._isIdle = true;
      _this._currentIndex = 0;

      _this._getPageIndex = function (index) {
        return _reactNative.I18nManager.isRTL ? _this.props.navigationState.routes.length - (index + 1) : index;
      };

      _this._setPage = function (index) {
        var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var pager = _this._viewPager;

        if (pager) {
          var page = _this._getPageIndex(index);

          if (_this.props.animationEnabled === false || animated === false) {
            pager.setPageWithoutAnimation(page);
          } else {
            pager.setPage(page);
          }
        }
      };

      _this._handlePageChange = function (index) {
        if (_this._isIdle && _this._currentIndex !== index) {
          _this._setPage(index);

          _this._currentIndex = index;
        }
      };

      _this._handlePageScroll = function (e) {
        _this.props.offsetX.setValue(e.nativeEvent.position * _this.props.layout.width * (_reactNative.I18nManager.isRTL ? 1 : -1));

        _this.props.panX.setValue(e.nativeEvent.offset * _this.props.layout.width * (_reactNative.I18nManager.isRTL ? 1 : -1));
      };

      _this._handlePageScrollStateChanged = function (e) {
        _this._isIdle = e === 'idle';
        var nextIndex = _this._currentIndex;

        if (_this.props.canJumpToTab(_this.props.navigationState.routes[nextIndex])) {
          _this.props.jumpToIndex(nextIndex);
        } else {
          _this._setPage(_this.props.navigationState.index);

          _this._currentIndex = _this.props.navigationState.index;
        }
      };

      _this._handlePageSelected = function (e) {
        var index = _this._getPageIndex(e.nativeEvent.position);

        _this._currentIndex = index;
      };

      _this._setRef = function (el) {
        return _this._viewPager = el;
      };

      _this._currentIndex = _this.props.navigationState.index;
      return _this;
    }

    babelHelpers.createClass(TabViewPagerAndroid, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (this.props.layout !== prevProps.layout || this.props.navigationState.routes.length !== prevProps.navigationState.routes.length || this.props.navigationState.index !== prevProps.navigationState.index) {
          this._handlePageChange(this.props.navigationState.index);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            children = _props.children,
            navigationState = _props.navigationState,
            swipeEnabled = _props.swipeEnabled;
        var content = React.Children.map(children, function (child, i) {
          return React.createElement(
            _reactNative.View,
            {
              key: navigationState.routes[i].key,
              testID: navigationState.routes[i].testID,
              style: styles.page,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 111
              }
            },
            child
          );
        });

        if (_reactNative.I18nManager.isRTL) {
          content.reverse();
        }

        var initialPage = this._getPageIndex(navigationState.index);

        return React.createElement(
          _reactNative.ViewPagerAndroid,
          {
            key: navigationState.routes.length,
            keyboardDismissMode: "on-drag",
            initialPage: initialPage,
            scrollEnabled: swipeEnabled !== false,
            onPageScroll: this._handlePageScroll,
            onPageScrollStateChanged: this._handlePageScrollStateChanged,
            onPageSelected: this._handlePageSelected,
            style: styles.container,
            ref: this._setRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 127
            }
          },
          content
        );
      }
    }]);
    return TabViewPagerAndroid;
  }(React.Component);

  TabViewPagerAndroid.propTypes = _TabViewPropTypes.PagerRendererPropType;
  TabViewPagerAndroid.defaultProps = {
    canJumpToTab: function canJumpToTab() {
      return true;
    }
  };
  exports.default = TabViewPagerAndroid;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flexGrow: 1
    },
    page: {
      overflow: 'hidden'
    }
  });
},430,[12,66,429],"react-native-tab-view/src/TabViewPagerAndroid.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-tab-view/src/TabViewPagerScroll.js";

  var _react = require(_dependencyMap[0], "react");

  var React = babelHelpers.interopRequireWildcard(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _TabViewPropTypes = require(_dependencyMap[2], "./TabViewPropTypes");

  var TabViewPagerScroll = function (_React$Component) {
    babelHelpers.inherits(TabViewPagerScroll, _React$Component);

    function TabViewPagerScroll(props) {
      babelHelpers.classCallCheck(this, TabViewPagerScroll);

      var _this = babelHelpers.possibleConstructorReturn(this, (TabViewPagerScroll.__proto__ || Object.getPrototypeOf(TabViewPagerScroll)).call(this, props));

      _initialiseProps.call(_this);

      var _this$props = _this.props,
          navigationState = _this$props.navigationState,
          layout = _this$props.layout;
      _this.state = {
        initialOffset: {
          x: navigationState.index * layout.width,
          y: 0
        }
      };
      return _this;
    }

    babelHelpers.createClass(TabViewPagerScroll, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._setInitialPage();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (prevProps.layout.width !== this.props.layout.width || prevProps.navigationState !== this.props.navigationState) {
          this._scrollTo(this.props.navigationState.index * this.props.layout.width, prevProps.layout.width === this.props.layout.width);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            children = _props.children,
            layout = _props.layout,
            navigationState = _props.navigationState;
        return React.createElement(
          _reactNative.ScrollView,
          {
            horizontal: true,
            pagingEnabled: true,
            directionalLockEnabled: true,
            keyboardDismissMode: "on-drag",
            keyboardShouldPersistTaps: "always",
            overScrollMode: "never",
            scrollEnabled: this.props.swipeEnabled,
            automaticallyAdjustContentInsets: false,
            bounces: false,
            alwaysBounceHorizontal: false,
            scrollsToTop: false,
            showsHorizontalScrollIndicator: false,
            scrollEventThrottle: 1,
            onScroll: this._handleScroll,
            onMomentumScrollEnd: this._handleMomentumScrollEnd,
            contentOffset: this.state.initialOffset,
            style: styles.container,
            contentContainerStyle: layout.width ? null : styles.container,
            ref: function ref(el) {
              return _this2._scrollView = el;
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 128
            }
          },
          React.Children.map(children, function (child, i) {
            return React.createElement(
              _reactNative.View,
              {
                key: navigationState.routes[i].key,
                testID: navigationState.routes[i].testID,
                style: layout.width ? {
                  width: layout.width,
                  overflow: 'hidden'
                } : i === navigationState.index ? styles.page : null,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 150
                }
              },
              i === navigationState.index || layout.width ? child : null
            );
          })
        );
      }
    }]);
    return TabViewPagerScroll;
  }(React.Component);

  TabViewPagerScroll.propTypes = _TabViewPropTypes.PagerRendererPropType;
  TabViewPagerScroll.defaultProps = {
    canJumpToTab: function canJumpToTab() {
      return true;
    }
  };

  var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this._isIdle = true;
    this._isInitial = true;

    this._setInitialPage = function () {
      if (_this3.props.layout.width) {
        _this3._isInitial = true;

        _this3._scrollTo(_this3.props.navigationState.index * _this3.props.layout.width, false);
      }

      setTimeout(function () {
        _this3._isInitial = false;
      }, 50);
    };

    this._scrollTo = function (x, animated) {
      if (_this3._isIdle && _this3._scrollView) {
        _this3._scrollView.scrollTo({
          x: x,
          animated: animated && _this3.props.animationEnabled !== false
        });
      }
    };

    this._handleMomentumScrollEnd = function (e) {
      var nextIndex = Math.round(e.nativeEvent.contentOffset.x / _this3.props.layout.width);

      if (_this3.props.canJumpToTab(_this3.props.navigationState.routes[nextIndex])) {
        _this3.props.jumpToIndex(nextIndex);
      } else {
        global.requestAnimationFrame(function () {
          _this3._scrollTo(_this3.props.navigationState.index * _this3.props.layout.width);
        });
      }
    };

    this._handleScroll = function (e) {
      if (_this3._isInitial) {
        return;
      }

      var _props2 = _this3.props,
          navigationState = _props2.navigationState,
          layout = _props2.layout;
      var offset = navigationState.index * layout.width;

      _this3.props.offsetX.setValue(-offset);

      _this3.props.panX.setValue(offset - e.nativeEvent.contentOffset.x);

      global.cancelAnimationFrame(_this3._idleCallback);
      _this3._isIdle = false;
      _this3._idleCallback = global.requestAnimationFrame(function () {
        _this3._isIdle = true;
      });
    };
  };

  exports.default = TabViewPagerScroll;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1
    },
    page: {
      flex: 1,
      overflow: 'hidden'
    }
  });
},431,[12,66,429],"react-native-tab-view/src/TabViewPagerScroll.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-tab-view/src/TabViewPagerPan.js";

  var _react = require(_dependencyMap[0], "react");

  var React = babelHelpers.interopRequireWildcard(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _TabViewPropTypes = require(_dependencyMap[3], "./TabViewPropTypes");

  var DEAD_ZONE = 12;
  var DefaultTransitionSpec = {
    timing: _reactNative.Animated.spring,
    tension: 300,
    friction: 35
  };

  var TabViewPagerPan = function (_React$Component) {
    babelHelpers.inherits(TabViewPagerPan, _React$Component);

    function TabViewPagerPan() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, TabViewPagerPan);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = TabViewPagerPan.__proto__ || Object.getPrototypeOf(TabViewPagerPan)).call.apply(_ref, [this].concat(args))), _this), _this._isMovingHorizontally = function (evt, gestureState) {
        return Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2);
      }, _this._canMoveScreen = function (evt, gestureState) {
        if (_this.props.swipeEnabled === false) {
          return false;
        }

        var _this$props$navigatio = _this.props.navigationState,
            routes = _this$props$navigatio.routes,
            index = _this$props$navigatio.index;
        return _this._isMovingHorizontally(evt, gestureState) && (gestureState.dx >= DEAD_ZONE && index >= 0 || gestureState.dx <= -DEAD_ZONE && index <= routes.length - 1);
      }, _this._startGesture = function (evt, gestureState) {
        if (typeof _this.props.onSwipeStart === 'function') {
          _this.props.onSwipeStart(evt, gestureState);
        }

        _this.props.panX.stopAnimation();
      }, _this._respondToGesture = function (evt, gestureState) {
        var _this$props$navigatio2 = _this.props.navigationState,
            routes = _this$props$navigatio2.routes,
            index = _this$props$navigatio2.index;

        if (gestureState.dx > 0 && index <= 0 || gestureState.dx < 0 && index >= routes.length - 1) {
          return;
        }

        _this.props.panX.setValue(gestureState.dx);
      }, _this._finishGesture = function (evt, gestureState) {
        var _this$props = _this.props,
            navigationState = _this$props.navigationState,
            layout = _this$props.layout,
            _this$props$swipeDist = _this$props.swipeDistanceThreshold,
            swipeDistanceThreshold = _this$props$swipeDist === undefined ? layout.width / 1.75 : _this$props$swipeDist;
        var _this$props$swipeVelo = _this.props.swipeVelocityThreshold,
            swipeVelocityThreshold = _this$props$swipeVelo === undefined ? 0.15 : _this$props$swipeVelo;

        if (_reactNative.Platform.OS === 'android') {
          swipeVelocityThreshold /= 1000000;
        }

        var currentIndex = typeof _this._pendingIndex === 'number' ? _this._pendingIndex : navigationState.index;
        var nextIndex = currentIndex;

        if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy) && (Math.abs(gestureState.dx) > swipeDistanceThreshold || Math.abs(gestureState.vx) > swipeVelocityThreshold)) {
          nextIndex = Math.round(Math.min(Math.max(0, currentIndex - gestureState.dx / Math.abs(gestureState.dx)), navigationState.routes.length - 1));
        }

        if (!isFinite(nextIndex) || !_this.props.canJumpToTab(_this.props.navigationState.routes[nextIndex])) {
          nextIndex = currentIndex;
        }

        _this._transitionTo(nextIndex);
      }, _this._transitionTo = function (index) {
        var offset = -index * _this.props.layout.width;

        if (_this.props.animationEnabled === false) {
          _this.props.panX.setValue(0);

          _this.props.offsetX.setValue(offset);

          return;
        }

        var timing = DefaultTransitionSpec.timing,
            transitionConfig = babelHelpers.objectWithoutProperties(DefaultTransitionSpec, ["timing"]);

        _reactNative.Animated.parallel([timing(_this.props.panX, babelHelpers.extends({}, transitionConfig, {
          toValue: 0
        })), timing(_this.props.offsetX, babelHelpers.extends({}, transitionConfig, {
          toValue: offset
        }))]).start(function (_ref2) {
          var finished = _ref2.finished;

          if (finished) {
            _this.props.jumpToIndex(index);

            _this._pendingIndex = null;
          }
        });

        _this._pendingIndex = index;
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(TabViewPagerPan, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this._panResponder = _reactNative.PanResponder.create({
          onMoveShouldSetPanResponder: this._canMoveScreen,
          onMoveShouldSetPanResponderCapture: this._canMoveScreen,
          onPanResponderGrant: this._startGesture,
          onPanResponderMove: this._respondToGesture,
          onPanResponderTerminate: this._finishGesture,
          onPanResponderRelease: this._finishGesture,
          onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {
            return true;
          }
        });
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (prevProps.navigationState.index !== this.props.navigationState.index) {
          this._transitionTo(this.props.navigationState.index);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            panX = _props.panX,
            offsetX = _props.offsetX,
            navigationState = _props.navigationState,
            layout = _props.layout,
            children = _props.children;
        var width = layout.width;
        var routes = navigationState.routes;
        var maxTranslate = width * (routes.length - 1);

        var translateX = _reactNative.Animated.add(panX, offsetX).interpolate({
          inputRange: [-maxTranslate, 0],
          outputRange: [-maxTranslate, 0],
          extrapolate: 'clamp'
        });

        return React.createElement(
          _reactNative.Animated.View,
          babelHelpers.extends({
            style: [styles.sheet, width ? {
              width: routes.length * width,
              transform: [{
                translateX: translateX
              }]
            } : null]
          }, this._panResponder.panHandlers, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 238
            }
          }),
          React.Children.map(children, function (child, i) {
            return React.createElement(
              _reactNative.View,
              {
                key: navigationState.routes[i].key,
                testID: navigationState.routes[i].testID,
                style: width ? {
                  width: width
                } : i === navigationState.index ? _reactNative.StyleSheet.absoluteFill : null,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 251
                }
              },
              i === navigationState.index || width ? child : null
            );
          })
        );
      }
    }]);
    return TabViewPagerPan;
  }(React.Component);

  TabViewPagerPan.propTypes = babelHelpers.extends({}, _TabViewPropTypes.PagerRendererPropType, {
    configureTransition: _propTypes2.default.func.isRequired,
    swipeDistanceThreshold: _propTypes2.default.number,
    swipeVelocityThreshold: _propTypes2.default.number,
    onSwipeStart: _propTypes2.default.func,
    onSwipeEnd: _propTypes2.default.func
  });
  TabViewPagerPan.defaultProps = {
    canJumpToTab: function canJumpToTab() {
      return true;
    },
    configureTransition: function configureTransition() {
      return DefaultTransitionSpec;
    },
    initialLayout: {
      height: 0,
      width: 0
    }
  };
  exports.default = TabViewPagerPan;

  var styles = _reactNative.StyleSheet.create({
    sheet: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'stretch'
    }
  });
},432,[12,24,66,429],"react-native-tab-view/src/TabViewPagerPan.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-tab-view/src/TabViewPagerExperimental.js";

  var _react = require(_dependencyMap[0], "react");

  var React = babelHelpers.interopRequireWildcard(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _TabViewPropTypes = require(_dependencyMap[3], "./TabViewPropTypes");

  var DefaultTransitionSpec = {
    timing: _reactNative.Animated.spring,
    tension: 75,
    friction: 25
  };

  var TabViewPagerExperimental = function (_React$Component) {
    babelHelpers.inherits(TabViewPagerExperimental, _React$Component);

    function TabViewPagerExperimental() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, TabViewPagerExperimental);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = TabViewPagerExperimental.__proto__ || Object.getPrototypeOf(TabViewPagerExperimental)).call.apply(_ref, [this].concat(args))), _this), _this._handleHandlerStateChange = function (event) {
        var GestureHandler = _this.props.GestureHandler;

        if (event.nativeEvent.state === GestureHandler.State.END) {
          var _this$props = _this.props,
              navigationState = _this$props.navigationState,
              layout = _this$props.layout,
              _this$props$swipeDist = _this$props.swipeDistanceThreshold,
              _swipeDistanceThreshold = _this$props$swipeDist === undefined ? layout.width / 1.75 : _this$props$swipeDist,
              _this$props$swipeVelo = _this$props.swipeVelocityThreshold,
              _swipeVelocityThreshold = _this$props$swipeVelo === undefined ? 150 : _this$props$swipeVelo;

          var _event$nativeEvent = event.nativeEvent,
              translationX = _event$nativeEvent.translationX,
              translationY = _event$nativeEvent.translationY,
              velocityX = _event$nativeEvent.velocityX,
              velocityY = _event$nativeEvent.velocityY;
          var currentIndex = typeof _this._pendingIndex === 'number' ? _this._pendingIndex : navigationState.index;
          var nextIndex = currentIndex;

          if (Math.abs(translationX) > Math.abs(translationY) && Math.abs(velocityX) > Math.abs(velocityY) && (Math.abs(translationX) > _swipeDistanceThreshold || Math.abs(velocityX) > _swipeVelocityThreshold)) {
            nextIndex = Math.round(Math.min(Math.max(0, currentIndex - translationX / Math.abs(translationX)), navigationState.routes.length - 1));
          }

          if (!isFinite(nextIndex) || !_this.props.canJumpToTab(_this.props.navigationState.routes[nextIndex])) {
            nextIndex = currentIndex;
          }

          _this._transitionTo(nextIndex, velocityX);
        }
      }, _this._transitionTo = function (index, velocity) {
        var offset = -index * _this.props.layout.width;

        if (_this.props.animationEnabled === false) {
          _this.props.panX.setValue(0);

          _this.props.offsetX.setValue(offset);

          return;
        }

        var timing = DefaultTransitionSpec.timing,
            transitionConfig = babelHelpers.objectWithoutProperties(DefaultTransitionSpec, ["timing"]);
        var useNativeDriver = _this.props.useNativeDriver;

        _reactNative.Animated.parallel([timing(_this.props.panX, babelHelpers.extends({}, transitionConfig, {
          toValue: 0,
          velocity: velocity,
          useNativeDriver: useNativeDriver
        })), timing(_this.props.offsetX, babelHelpers.extends({}, transitionConfig, {
          toValue: offset,
          velocity: velocity,
          useNativeDriver: useNativeDriver
        }))]).start(function (_ref2) {
          var finished = _ref2.finished;

          if (finished) {
            _this.props.jumpToIndex(index);

            _this._pendingIndex = null;
          }
        });

        _this._pendingIndex = index;
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(TabViewPagerExperimental, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (prevProps.navigationState.index !== this.props.navigationState.index) {
          this._transitionTo(this.props.navigationState.index);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            GestureHandler = _props.GestureHandler,
            panX = _props.panX,
            offsetX = _props.offsetX,
            layout = _props.layout,
            navigationState = _props.navigationState,
            swipeEnabled = _props.swipeEnabled,
            children = _props.children;
        var width = layout.width;
        var routes = navigationState.routes;
        var maxTranslate = width * (routes.length - 1);

        var translateX = _reactNative.Animated.add(panX, offsetX).interpolate({
          inputRange: [-maxTranslate, 0],
          outputRange: [-maxTranslate, 0],
          extrapolate: 'clamp'
        });

        return React.createElement(
          GestureHandler.PanGestureHandler,
          {
            enabled: layout.width !== 0 && swipeEnabled !== false,
            minDeltaX: 10,
            onGestureEvent: _reactNative.Animated.event([{
              nativeEvent: {
                translationX: this.props.panX
              }
            }], {
              useNativeDriver: this.props.useNativeDriver
            }),
            onHandlerStateChange: this._handleHandlerStateChange,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 150
            }
          },
          React.createElement(
            _reactNative.Animated.View,
            {
              style: [styles.sheet, width ? {
                width: routes.length * width,
                transform: [{
                  translateX: translateX
                }]
              } : null],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 159
              }
            },
            React.Children.map(children, function (child, i) {
              return React.createElement(
                _reactNative.View,
                {
                  key: navigationState.routes[i].key,
                  testID: navigationState.routes[i].testID,
                  style: width ? {
                    width: width
                  } : i === navigationState.index ? _reactNative.StyleSheet.absoluteFill : null,
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 168
                  }
                },
                i === navigationState.index || width ? child : null
              );
            })
          )
        );
      }
    }]);
    return TabViewPagerExperimental;
  }(React.Component);

  TabViewPagerExperimental.propTypes = babelHelpers.extends({}, _TabViewPropTypes.PagerRendererPropType, {
    swipeDistanceThreshold: _propTypes2.default.number,
    swipeVelocityThreshold: _propTypes2.default.number,
    GestureHandler: _propTypes2.default.object
  });
  TabViewPagerExperimental.defaultProps = {
    GestureHandler: global.__expo && global.__expo.DangerZone ? global.__expo.DangerZone.GestureHandler : undefined,
    canJumpToTab: function canJumpToTab() {
      return true;
    }
  };
  exports.default = TabViewPagerExperimental;

  var styles = _reactNative.StyleSheet.create({
    sheet: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'stretch'
    }
  });
},433,[12,24,66,429],"react-native-tab-view/src/TabViewPagerExperimental.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-tab-view/src/TabBar.js";

  var _react = require(_dependencyMap[0], "react");

  var React = babelHelpers.interopRequireWildcard(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _TouchableItem = require(_dependencyMap[3], "./TouchableItem");

  var _TouchableItem2 = babelHelpers.interopRequireDefault(_TouchableItem);

  var _TabViewPropTypes = require(_dependencyMap[4], "./TabViewPropTypes");

  var TabBar = function (_React$Component) {
    babelHelpers.inherits(TabBar, _React$Component);

    function TabBar(props) {
      babelHelpers.classCallCheck(this, TabBar);

      var _this = babelHelpers.possibleConstructorReturn(this, (TabBar.__proto__ || Object.getPrototypeOf(TabBar)).call(this, props));

      _initialiseProps.call(_this);

      var initialVisibility = 1;

      if (_this.props.scrollEnabled) {
        var tabWidth = _this._getTabWidth(_this.props);

        if (!tabWidth) {
          initialVisibility = 0;
        }
      }

      var initialOffset = _this.props.scrollEnabled && _this.props.layout.width ? {
        x: _this._getScrollAmount(_this.props, _this.props.navigationState.index),
        y: 0
      } : undefined;
      _this.state = {
        visibility: new _reactNative.Animated.Value(initialVisibility),
        scrollAmount: new _reactNative.Animated.Value(0),
        initialOffset: initialOffset
      };
      return _this;
    }

    babelHelpers.createClass(TabBar, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._adjustScroll(this.props.navigationState.index);

        this.props.scrollEnabled && this._startTrackingPosition();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var prevTabWidth = this._getTabWidth(prevProps);

        var currentTabWidth = this._getTabWidth(this.props);

        if (prevTabWidth !== currentTabWidth && currentTabWidth) {
          this.state.visibility.setValue(1);
        }

        if ((prevProps.navigationState !== this.props.navigationState || prevProps.layout !== this.props.layout || prevTabWidth !== currentTabWidth) && this.props.navigationState.index !== this._pendingIndex) {
          this._resetScroll(this.props.navigationState.index, Boolean(prevProps.layout.width));

          this._pendingIndex = null;
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._stopTrackingPosition();
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            position = _props.position,
            navigationState = _props.navigationState,
            scrollEnabled = _props.scrollEnabled;
        var routes = navigationState.routes,
            index = navigationState.index;

        var tabWidth = this._getTabWidth(this.props);

        var tabBarWidth = tabWidth * routes.length;
        var inputRange = [-1].concat(babelHelpers.toConsumableArray(routes.map(function (x, i) {
          return i;
        })));

        var translateX = _reactNative.Animated.multiply(this.state.scrollAmount, -1);

        return React.createElement(
          _reactNative.Animated.View,
          {
            style: [styles.tabBar, this.props.style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 343
            }
          },
          React.createElement(
            _reactNative.Animated.View,
            {
              pointerEvents: "none",
              style: [styles.indicatorContainer, scrollEnabled ? {
                width: tabBarWidth,
                transform: [{
                  translateX: translateX
                }]
              } : null],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 344
              }
            },
            this._renderIndicator(babelHelpers.extends({}, this.props, {
              width: tabWidth
            }))
          ),
          React.createElement(
            _reactNative.View,
            {
              style: styles.scroll,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 358
              }
            },
            React.createElement(
              _reactNative.Animated.ScrollView,
              {
                horizontal: true,
                keyboardShouldPersistTaps: "handled",
                scrollEnabled: scrollEnabled,
                bounces: false,
                alwaysBounceHorizontal: false,
                scrollsToTop: false,
                showsHorizontalScrollIndicator: false,
                automaticallyAdjustContentInsets: false,
                overScrollMode: "never",
                contentContainerStyle: [styles.tabContent, scrollEnabled ? null : styles.container],
                scrollEventThrottle: 1,
                onScroll: _reactNative.Animated.event([{
                  nativeEvent: {
                    contentOffset: {
                      x: this.state.scrollAmount
                    }
                  }
                }], {
                  useNativeDriver: true,
                  listener: this._handleScroll
                }),
                onScrollBeginDrag: this._handleBeginDrag,
                onScrollEndDrag: this._handleEndDrag,
                onMomentumScrollBegin: this._handleMomentumScrollBegin,
                onMomentumScrollEnd: this._handleMomentumScrollEnd,
                contentOffset: this.state.initialOffset,
                ref: this._setRef,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 359
                }
              },
              routes.map(function (route, i) {
                var focused = index === i;
                var outputRange = inputRange.map(function (inputIndex) {
                  return inputIndex === i ? 1 : 0.7;
                });

                var opacity = _reactNative.Animated.multiply(_this2.state.visibility, position.interpolate({
                  inputRange: inputRange,
                  outputRange: outputRange
                }));

                var scene = {
                  route: route,
                  focused: focused,
                  index: i
                };

                var label = _this2._renderLabel(scene);

                var icon = _this2.props.renderIcon ? _this2.props.renderIcon(scene) : null;
                var badge = _this2.props.renderBadge ? _this2.props.renderBadge(scene) : null;
                var tabStyle = {};
                tabStyle.opacity = opacity;

                if (icon) {
                  if (label) {
                    tabStyle.paddingTop = 8;
                  } else {
                    tabStyle.padding = 12;
                  }
                }

                var passedTabStyle = _reactNative.StyleSheet.flatten(_this2.props.tabStyle);

                var isWidthSet = passedTabStyle && typeof passedTabStyle.width !== 'undefined' || scrollEnabled === true;
                var tabContainerStyle = {};

                if (isWidthSet) {
                  tabStyle.width = tabWidth;
                }

                if (passedTabStyle && typeof passedTabStyle.flex === 'number') {
                  tabContainerStyle.flex = passedTabStyle.flex;
                } else if (!isWidthSet) {
                  tabContainerStyle.flex = 1;
                }

                var accessibilityLabel = route.accessibilityLabel || route.title;
                return React.createElement(
                  _TouchableItem2.default,
                  {
                    borderless: true,
                    key: route.key,
                    testID: route.testID,
                    accessible: route.accessible,
                    accessibilityLabel: accessibilityLabel,
                    accessibilityTraits: "button",
                    pressColor: _this2.props.pressColor,
                    pressOpacity: _this2.props.pressOpacity,
                    delayPressIn: 0,
                    onPress: function onPress() {
                      return _this2._handleTabPress(scene);
                    },
                    style: tabContainerStyle,
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 449
                    }
                  },
                  React.createElement(
                    _reactNative.View,
                    {
                      pointerEvents: "none",
                      style: styles.container,
                      __source: {
                        fileName: _jsxFileName,
                        lineNumber: 462
                      }
                    },
                    React.createElement(
                      _reactNative.Animated.View,
                      {
                        style: [styles.tabItem, tabStyle, passedTabStyle, styles.container],
                        __source: {
                          fileName: _jsxFileName,
                          lineNumber: 463
                        }
                      },
                      icon,
                      label
                    ),
                    badge ? React.createElement(
                      _reactNative.Animated.View,
                      {
                        style: [styles.badge, {
                          opacity: _this2.state.visibility
                        }],
                        __source: {
                          fileName: _jsxFileName,
                          lineNumber: 475
                        }
                      },
                      badge
                    ) : null
                  )
                );
              })
            )
          )
        );
      }
    }]);
    return TabBar;
  }(React.Component);

  TabBar.propTypes = babelHelpers.extends({}, _TabViewPropTypes.SceneRendererPropType, {
    scrollEnabled: _propTypes2.default.bool,
    pressColor: _TouchableItem2.default.propTypes.pressColor,
    pressOpacity: _TouchableItem2.default.propTypes.pressOpacity,
    getLabelText: _propTypes2.default.func,
    renderIcon: _propTypes2.default.func,
    renderLabel: _propTypes2.default.func,
    renderIndicator: _propTypes2.default.func,
    onTabPress: _propTypes2.default.func,
    labelStyle: _propTypes2.default.any,
    style: _propTypes2.default.any
  });
  TabBar.defaultProps = {
    getLabelText: function getLabelText(_ref) {
      var route = _ref.route;
      return typeof route.title === 'string' ? route.title.toUpperCase() : route.title;
    }
  };

  var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this._isManualScroll = false;
    this._isMomentumScroll = false;
    this._scrollDelta = 0;

    this._startTrackingPosition = function () {
      _this3._offsetXListener = _this3.props.offsetX.addListener(function (_ref2) {
        var value = _ref2.value;
        _this3._lastOffsetX = value;

        _this3._handlePosition();
      });
      _this3._panXListener = _this3.props.panX.addListener(function (_ref3) {
        var value = _ref3.value;
        _this3._lastPanX = value;

        _this3._handlePosition();
      });
    };

    this._stopTrackingPosition = function () {
      _this3.props.offsetX.removeListener(_this3._offsetXListener);

      _this3.props.panX.removeListener(_this3._panXListener);
    };

    this._handlePosition = function () {
      var _props2 = _this3.props,
          navigationState = _props2.navigationState,
          layout = _props2.layout;
      var panX = typeof _this3._lastPanX === 'number' ? _this3._lastPanX : 0;
      var offsetX = typeof _this3._lastOffsetX === 'number' ? _this3._lastOffsetX : -navigationState.index * layout.width;
      var value = (panX + offsetX) / -(layout.width || 0.001);

      _this3._adjustScroll(value);
    };

    this._renderLabel = function (scene) {
      if (typeof _this3.props.renderLabel !== 'undefined') {
        return _this3.props.renderLabel(scene);
      }

      var label = _this3.props.getLabelText(scene);

      if (typeof label !== 'string') {
        return null;
      }

      return React.createElement(
        _reactNative.Animated.Text,
        {
          style: [styles.tabLabel, _this3.props.labelStyle],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 177
          }
        },
        label
      );
    };

    this._renderIndicator = function (props) {
      if (typeof _this3.props.renderIndicator !== 'undefined') {
        return _this3.props.renderIndicator(props);
      }

      var width = props.width,
          position = props.position,
          navigationState = props.navigationState;

      var translateX = _reactNative.Animated.multiply(_reactNative.Animated.multiply(position.interpolate({
        inputRange: [0, navigationState.routes.length - 1],
        outputRange: [0, navigationState.routes.length - 1],
        extrapolate: 'clamp'
      }), width), _reactNative.I18nManager.isRTL ? -1 : 1);

      return React.createElement(_reactNative.Animated.View, {
        style: [styles.indicator, {
          width: width,
          transform: [{
            translateX: translateX
          }]
        }, _this3.props.indicatorStyle],
        __source: {
          fileName: _jsxFileName,
          lineNumber: 200
        }
      });
    };

    this._getTabWidth = function (props) {
      var layout = props.layout,
          navigationState = props.navigationState,
          tabStyle = props.tabStyle;

      var flattened = _reactNative.StyleSheet.flatten(tabStyle);

      if (flattened) {
        switch (typeof flattened.width) {
          case 'number':
            return flattened.width;

          case 'string':
            if (flattened.width.endsWith('%')) {
              var _width = parseFloat(flattened.width);

              if (Number.isFinite(_width)) {
                return layout.width * (_width / 100);
              }
            }

        }
      }

      if (props.scrollEnabled) {
        return layout.width / 5 * 2;
      }

      return layout.width / navigationState.routes.length;
    };

    this._handleTabPress = function (scene) {
      _this3._pendingIndex = scene.index;

      _this3.props.jumpToIndex(scene.index);

      if (_this3.props.onTabPress) {
        _this3.props.onTabPress(scene);
      }
    };

    this._handleScroll = function (event) {
      if (_this3._isManualScroll) {
        _this3._scrollDelta = _this3._getScrollAmount(_this3.props, _this3.props.navigationState.index) - event.nativeEvent.contentOffset.x;
      }
    };

    this._normalizeScrollValue = function (props, value) {
      var layout = props.layout,
          navigationState = props.navigationState;

      var tabWidth = _this3._getTabWidth(props);

      var tabBarWidth = Math.max(tabWidth * navigationState.routes.length, layout.width);
      var maxDistance = tabBarWidth - layout.width;
      return Math.max(Math.min(value, maxDistance), 0);
    };

    this._getScrollAmount = function (props, i) {
      var layout = props.layout;

      var tabWidth = _this3._getTabWidth(props);

      var centerDistance = tabWidth * (i + 1 / 2);
      var scrollAmount = centerDistance - layout.width / 2;
      return _this3._normalizeScrollValue(props, scrollAmount);
    };

    this._adjustScroll = function (value) {
      if (_this3.props.scrollEnabled) {
        global.cancelAnimationFrame(_this3._scrollResetCallback);
        _this3._scrollView && _this3._scrollView.scrollTo({
          x: _this3._normalizeScrollValue(_this3.props, _this3._getScrollAmount(_this3.props, value) - _this3._scrollDelta),
          animated: false
        });
      }
    };

    this._resetScroll = function (value) {
      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (_this3.props.scrollEnabled) {
        global.cancelAnimationFrame(_this3._scrollResetCallback);
        _this3._scrollResetCallback = global.requestAnimationFrame(function () {
          _this3._scrollDelta = 0;
          _this3._scrollView && _this3._scrollView.scrollTo({
            x: _this3._getScrollAmount(_this3.props, value),
            animated: animated
          });
        });
      }
    };

    this._handleBeginDrag = function () {
      _this3._isManualScroll = true;
      _this3._isMomentumScroll = false;
    };

    this._handleEndDrag = function () {
      global.requestAnimationFrame(function () {
        if (_this3._isMomentumScroll) {
          return;
        }

        _this3._isManualScroll = false;
      });
    };

    this._handleMomentumScrollBegin = function () {
      _this3._isMomentumScroll = true;
    };

    this._handleMomentumScrollEnd = function () {
      _this3._isMomentumScroll = false;
      _this3._isManualScroll = false;
    };

    this._setRef = function (el) {
      return _this3._scrollView = el && el._component;
    };
  };

  exports.default = TabBar;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1
    },
    scroll: {
      overflow: _reactNative.Platform.OS === 'web' ? 'auto' : 'scroll'
    },
    tabBar: {
      backgroundColor: '#2196f3',
      elevation: 4,
      shadowColor: 'black',
      shadowOpacity: 0.1,
      shadowRadius: _reactNative.StyleSheet.hairlineWidth,
      shadowOffset: {
        height: _reactNative.StyleSheet.hairlineWidth
      },
      zIndex: _reactNative.Platform.OS === 'android' ? 0 : 1
    },
    tabContent: {
      flexDirection: 'row',
      flexWrap: 'nowrap'
    },
    tabLabel: {
      backgroundColor: 'transparent',
      color: 'white',
      margin: 8
    },
    tabItem: {
      flex: 1,
      padding: 8,
      alignItems: 'center',
      justifyContent: 'center'
    },
    badge: {
      position: 'absolute',
      top: 0,
      right: 0
    },
    indicatorContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    indicator: {
      backgroundColor: '#ffeb3b',
      position: 'absolute',
      left: 0,
      bottom: 0,
      right: 0,
      height: 2
    }
  });
},434,[12,24,66,435,429],"react-native-tab-view/src/TabBar.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-tab-view/src/TouchableItem.js";

  var _react = require(_dependencyMap[0], "react");

  var React = babelHelpers.interopRequireWildcard(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[2], "react-native");

  var LOLLIPOP = 21;

  var TouchableItem = function (_React$Component) {
    babelHelpers.inherits(TouchableItem, _React$Component);

    function TouchableItem() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, TouchableItem);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = TouchableItem.__proto__ || Object.getPrototypeOf(TouchableItem)).call.apply(_ref, [this].concat(args))), _this), _this._handlePress = function () {
        global.requestAnimationFrame(_this.props.onPress);
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(TouchableItem, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            style = _props.style,
            pressOpacity = _props.pressOpacity,
            pressColor = _props.pressColor,
            borderless = _props.borderless,
            rest = babelHelpers.objectWithoutProperties(_props, ["style", "pressOpacity", "pressColor", "borderless"]);

        if (_reactNative.Platform.OS === 'android' && _reactNative.Platform.Version >= LOLLIPOP) {
          return React.createElement(
            _reactNative.TouchableNativeFeedback,
            babelHelpers.extends({}, rest, {
              onPress: this._handlePress,
              background: _reactNative.TouchableNativeFeedback.Ripple(pressColor, borderless),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 48
              }
            }),
            React.createElement(
              _reactNative.View,
              {
                style: style,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 53
                }
              },
              React.Children.only(this.props.children)
            )
          );
        } else {
          return React.createElement(
            _reactNative.TouchableOpacity,
            babelHelpers.extends({}, rest, {
              onPress: this._handlePress,
              style: style,
              activeOpacity: pressOpacity,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 58
              }
            }),
            this.props.children
          );
        }
      }
    }]);
    return TouchableItem;
  }(React.Component);

  TouchableItem.propTypes = {
    onPress: _propTypes2.default.func.isRequired,
    delayPressIn: _propTypes2.default.number,
    borderless: _propTypes2.default.bool,
    pressColor: _propTypes2.default.string,
    pressOpacity: _propTypes2.default.number,
    children: _propTypes2.default.node.isRequired
  };
  TouchableItem.defaultProps = {
    pressColor: 'rgba(255, 255, 255, .4)'
  };
  exports.default = TouchableItem;
},435,[12,24,66],"react-native-tab-view/src/TouchableItem.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-tab-view/src/SceneMap.js";
  exports.default = SceneMap;

  var _react = require(_dependencyMap[0], "react");

  var React = babelHelpers.interopRequireWildcard(_react);

  function SceneMap(scenes) {
    var SceneComponent = function (_React$PureComponent) {
      babelHelpers.inherits(SceneComponent, _React$PureComponent);

      function SceneComponent() {
        babelHelpers.classCallCheck(this, SceneComponent);
        return babelHelpers.possibleConstructorReturn(this, (SceneComponent.__proto__ || Object.getPrototypeOf(SceneComponent)).apply(this, arguments));
      }

      babelHelpers.createClass(SceneComponent, [{
        key: "render",
        value: function render() {
          return React.createElement(scenes[this.props.route.key], this.props);
        }
      }]);
      return SceneComponent;
    }(React.PureComponent);

    return function (_ref) {
      var route = _ref.route;
      return React.createElement(SceneComponent, {
        key: route.key,
        route: route,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 12
        }
      });
    };
  }
},436,[12],"react-native-tab-view/src/SceneMap.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/ResourceSavingSceneView.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _propTypes = require(_dependencyMap[2], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _SceneView = require(_dependencyMap[3], "./SceneView");

  var _SceneView2 = babelHelpers.interopRequireDefault(_SceneView);

  var FAR_FAR_AWAY = 3000;

  var ResourceSavingSceneView = function (_React$PureComponent) {
    babelHelpers.inherits(ResourceSavingSceneView, _React$PureComponent);

    function ResourceSavingSceneView(props) {
      babelHelpers.classCallCheck(this, ResourceSavingSceneView);

      var _this = babelHelpers.possibleConstructorReturn(this, (ResourceSavingSceneView.__proto__ || Object.getPrototypeOf(ResourceSavingSceneView)).call(this));

      _initialiseProps.call(_this);

      var key = props.childNavigation.state.key;
      var focusedIndex = props.navigation.state.index;
      var focusedKey = props.navigation.state.routes[focusedIndex].key;
      var isFocused = key === focusedKey;
      _this.state = {
        awake: props.lazy ? isFocused : true,
        visible: isFocused
      };
      return _this;
    }

    babelHelpers.createClass(ResourceSavingSceneView, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this._actionListener = this.props.navigation.addListener('action', this._onAction);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._actionListener.remove();
      }
    }, {
      key: "render",
      value: function render() {
        var _state = this.state,
            awake = _state.awake,
            visible = _state.visible;
        var _props = this.props,
            childNavigation = _props.childNavigation,
            navigation = _props.navigation,
            removeClippedSubviews = _props.removeClippedSubviews,
            lazy = _props.lazy,
            rest = babelHelpers.objectWithoutProperties(_props, ["childNavigation", "navigation", "removeClippedSubviews", "lazy"]);
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.container,
            collapsable: false,
            removeClippedSubviews: _reactNative.Platform.OS === 'android' ? removeClippedSubviews : !visible && removeClippedSubviews,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 46
            }
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: this._mustAlwaysBeVisible() || visible ? styles.innerAttached : styles.innerDetached,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 55
              }
            },
            awake ? _react2.default.createElement(_SceneView2.default, babelHelpers.extends({}, rest, {
              navigation: childNavigation,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 62
              }
            })) : null
          )
        );
      }
    }]);
    return ResourceSavingSceneView;
  }(_react2.default.PureComponent);

  var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this._mustAlwaysBeVisible = function () {
      return _this2.props.animationEnabled || _this2.props.swipeEnabled;
    };

    this._onAction = function (payload) {
      if (payload.action.type == 'Navigation/COMPLETE_TRANSITION' || !payload.state) {
        return;
      }

      var _payload$state = payload.state,
          routes = _payload$state.routes,
          index = _payload$state.index;
      var key = _this2.props.childNavigation.state.key;

      if (routes[index].key === key) {
        if (!_this2.state.visible) {
          var nextState = {
            visible: true
          };

          if (!_this2.state.awake) {
            nextState.awake = true;
          }

          _this2.setState(nextState);
        }
      } else {
        if (_this2.state.visible) {
          _this2.setState({
            visible: false
          });
        }
      }
    };
  };

  exports.default = ResourceSavingSceneView;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      overflow: 'hidden'
    },
    innerAttached: {
      flex: 1
    },
    innerDetached: {
      flex: 1,
      top: FAR_FAR_AWAY
    }
  });
},437,[12,66,24,404],"react-navigation/src/views/ResourceSavingSceneView.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/TabView/TabBarTop.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _reactNativeTabView = require(_dependencyMap[2], "react-native-tab-view");

  var _TabBarIcon = require(_dependencyMap[3], "./TabBarIcon");

  var _TabBarIcon2 = babelHelpers.interopRequireDefault(_TabBarIcon);

  var TabBarTop = function (_React$PureComponent) {
    babelHelpers.inherits(TabBarTop, _React$PureComponent);

    function TabBarTop() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, TabBarTop);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = TabBarTop.__proto__ || Object.getPrototypeOf(TabBarTop)).call.apply(_ref, [this].concat(args))), _this), _this._renderLabel = function (scene) {
        var _this$props = _this.props,
            position = _this$props.position,
            tabBarPosition = _this$props.tabBarPosition,
            navigation = _this$props.navigation,
            activeTintColor = _this$props.activeTintColor,
            inactiveTintColor = _this$props.inactiveTintColor,
            showLabel = _this$props.showLabel,
            upperCaseLabel = _this$props.upperCaseLabel,
            labelStyle = _this$props.labelStyle,
            allowFontScaling = _this$props.allowFontScaling;

        if (showLabel === false) {
          return null;
        }

        var index = scene.index;
        var routes = navigation.state.routes;
        var inputRange = [-1].concat(babelHelpers.toConsumableArray(routes.map(function (x, i) {
          return i;
        })));
        var outputRange = inputRange.map(function (inputIndex) {
          return inputIndex === index ? activeTintColor : inactiveTintColor;
        });
        var color = position.interpolate({
          inputRange: inputRange,
          outputRange: outputRange
        });
        var tintColor = scene.focused ? activeTintColor : inactiveTintColor;

        var label = _this.props.getLabel(babelHelpers.extends({}, scene, {
          tintColor: tintColor
        }));

        if (typeof label === 'string') {
          return _react2.default.createElement(
            _reactNative.Animated.Text,
            {
              style: [styles.label, {
                color: color
              }, labelStyle],
              allowFontScaling: allowFontScaling,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 47
              }
            },
            upperCaseLabel ? label.toUpperCase() : label
          );
        }

        if (typeof label === 'function') {
          return label(babelHelpers.extends({}, scene, {
            tintColor: tintColor
          }));
        }

        return label;
      }, _this._renderIcon = function (scene) {
        var _this$props2 = _this.props,
            position = _this$props2.position,
            navigation = _this$props2.navigation,
            activeTintColor = _this$props2.activeTintColor,
            inactiveTintColor = _this$props2.inactiveTintColor,
            renderIcon = _this$props2.renderIcon,
            showIcon = _this$props2.showIcon,
            iconStyle = _this$props2.iconStyle;

        if (showIcon === false) {
          return null;
        }

        return _react2.default.createElement(_TabBarIcon2.default, {
          position: position,
          navigation: navigation,
          activeTintColor: activeTintColor,
          inactiveTintColor: inactiveTintColor,
          renderIcon: renderIcon,
          scene: scene,
          style: [styles.icon, iconStyle],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 76
          }
        });
      }, _this._handleOnPress = function (scene) {
        var _this$props3 = _this.props,
            getOnPress = _this$props3.getOnPress,
            jumpToIndex = _this$props3.jumpToIndex,
            navigation = _this$props3.navigation;
        var previousScene = navigation.state.routes[navigation.state.index];
        var onPress = getOnPress(previousScene, scene);

        if (onPress) {
          onPress({
            previousScene: previousScene,
            scene: scene,
            jumpToIndex: jumpToIndex,
            defaultHandler: jumpToIndex
          });
        } else {
          jumpToIndex(scene.index);
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(TabBarTop, [{
      key: "render",
      value: function render() {
        var props = this.props;
        return _react2.default.createElement(_reactNativeTabView.TabBar, babelHelpers.extends({}, props, {
          onTabPress: this._handleOnPress,
          jumpToIndex: function jumpToIndex() {},
          renderIcon: this._renderIcon,
          renderLabel: this._renderLabel,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 113
          }
        }));
      }
    }]);
    return TabBarTop;
  }(_react2.default.PureComponent);

  TabBarTop.defaultProps = {
    activeTintColor: '#fff',
    inactiveTintColor: '#fff',
    showIcon: false,
    showLabel: true,
    upperCaseLabel: true,
    allowFontScaling: true
  };
  exports.default = TabBarTop;

  var styles = _reactNative.StyleSheet.create({
    icon: {
      height: 24,
      width: 24
    },
    label: {
      textAlign: 'center',
      fontSize: 13,
      margin: 8,
      backgroundColor: 'transparent'
    }
  });
},438,[12,66,427,439],"react-navigation/src/views/TabView/TabBarTop.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/TabView/TabBarIcon.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var TabBarIcon = function (_React$PureComponent) {
    babelHelpers.inherits(TabBarIcon, _React$PureComponent);

    function TabBarIcon() {
      babelHelpers.classCallCheck(this, TabBarIcon);
      return babelHelpers.possibleConstructorReturn(this, (TabBarIcon.__proto__ || Object.getPrototypeOf(TabBarIcon)).apply(this, arguments));
    }

    babelHelpers.createClass(TabBarIcon, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            position = _props.position,
            scene = _props.scene,
            navigation = _props.navigation,
            activeTintColor = _props.activeTintColor,
            inactiveTintColor = _props.inactiveTintColor,
            style = _props.style;
        var route = scene.route,
            index = scene.index;
        var routes = navigation.state.routes;
        var inputRange = [-1].concat(babelHelpers.toConsumableArray(routes.map(function (x, i) {
          return i;
        })));
        var activeOpacity = position.interpolate({
          inputRange: inputRange,
          outputRange: inputRange.map(function (i) {
            return i === index ? 1 : 0;
          })
        });
        var inactiveOpacity = position.interpolate({
          inputRange: inputRange,
          outputRange: inputRange.map(function (i) {
            return i === index ? 0 : 1;
          })
        });
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: style,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 29
            }
          },
          _react2.default.createElement(
            _reactNative.Animated.View,
            {
              style: [styles.icon, {
                opacity: activeOpacity
              }],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 30
              }
            },
            this.props.renderIcon({
              route: route,
              index: index,
              focused: true,
              tintColor: activeTintColor
            })
          ),
          _react2.default.createElement(
            _reactNative.Animated.View,
            {
              style: [styles.icon, {
                opacity: inactiveOpacity
              }],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 38
              }
            },
            this.props.renderIcon({
              route: route,
              index: index,
              focused: false,
              tintColor: inactiveTintColor
            })
          )
        );
      }
    }]);
    return TabBarIcon;
  }(_react2.default.PureComponent);

  exports.default = TabBarIcon;

  var styles = _reactNative.StyleSheet.create({
    icon: {
      alignItems: 'center',
      alignSelf: 'center',
      height: '100%',
      justifyContent: 'center',
      position: 'absolute',
      width: '100%'
    }
  });
},439,[12,66],"react-navigation/src/views/TabView/TabBarIcon.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/TabView/TabBarBottom.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _reactNativeSafeAreaView = require(_dependencyMap[2], "react-native-safe-area-view");

  var _reactNativeSafeAreaView2 = babelHelpers.interopRequireDefault(_reactNativeSafeAreaView);

  var _TabBarIcon = require(_dependencyMap[3], "./TabBarIcon");

  var _TabBarIcon2 = babelHelpers.interopRequireDefault(_TabBarIcon);

  var _NavigationActions = require(_dependencyMap[4], "../../NavigationActions");

  var _NavigationActions2 = babelHelpers.interopRequireDefault(_NavigationActions);

  var _withOrientation = require(_dependencyMap[5], "../withOrientation");

  var _withOrientation2 = babelHelpers.interopRequireDefault(_withOrientation);

  var majorVersion = parseInt(_reactNative.Platform.Version, 10);
  var isIos = _reactNative.Platform.OS === 'ios';
  var isIOS11 = majorVersion >= 11 && isIos;
  var defaultMaxTabBarItemWidth = 125;

  var TabBarBottom = function (_React$PureComponent) {
    babelHelpers.inherits(TabBarBottom, _React$PureComponent);

    function TabBarBottom() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, TabBarBottom);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = TabBarBottom.__proto__ || Object.getPrototypeOf(TabBarBottom)).call.apply(_ref, [this].concat(args))), _this), _this._renderLabel = function (scene) {
        var _this$props = _this.props,
            position = _this$props.position,
            navigation = _this$props.navigation,
            activeTintColor = _this$props.activeTintColor,
            inactiveTintColor = _this$props.inactiveTintColor,
            labelStyle = _this$props.labelStyle,
            showLabel = _this$props.showLabel,
            showIcon = _this$props.showIcon,
            isLandscape = _this$props.isLandscape,
            allowFontScaling = _this$props.allowFontScaling;

        if (showLabel === false) {
          return null;
        }

        var index = scene.index;
        var routes = navigation.state.routes;
        var inputRange = [-1].concat(babelHelpers.toConsumableArray(routes.map(function (x, i) {
          return i;
        })));
        var outputRange = inputRange.map(function (inputIndex) {
          return inputIndex === index ? activeTintColor : inactiveTintColor;
        });
        var color = position.interpolate({
          inputRange: inputRange,
          outputRange: outputRange
        });
        var tintColor = scene.focused ? activeTintColor : inactiveTintColor;

        var label = _this.props.getLabel(babelHelpers.extends({}, scene, {
          tintColor: tintColor
        }));

        if (typeof label === 'string') {
          return _react2.default.createElement(
            _reactNative.Animated.Text,
            {
              numberOfLines: 1,
              style: [styles.label, {
                color: color
              }, showIcon && _this._shouldUseHorizontalTabs() ? styles.labelBeside : styles.labelBeneath, labelStyle],
              allowFontScaling: allowFontScaling,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 66
              }
            },
            label
          );
        }

        if (typeof label === 'function') {
          return label(babelHelpers.extends({}, scene, {
            tintColor: tintColor
          }));
        }

        return label;
      }, _this._renderIcon = function (scene) {
        var _this$props2 = _this.props,
            position = _this$props2.position,
            navigation = _this$props2.navigation,
            activeTintColor = _this$props2.activeTintColor,
            inactiveTintColor = _this$props2.inactiveTintColor,
            renderIcon = _this$props2.renderIcon,
            showIcon = _this$props2.showIcon,
            showLabel = _this$props2.showLabel;

        if (showIcon === false) {
          return null;
        }

        return _react2.default.createElement(_TabBarIcon2.default, {
          position: position,
          navigation: navigation,
          activeTintColor: activeTintColor,
          inactiveTintColor: inactiveTintColor,
          renderIcon: renderIcon,
          scene: scene,
          style: showLabel && _this._shouldUseHorizontalTabs() ? {} : styles.icon,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 104
          }
        });
      }, _this._renderTestIDProps = function (scene) {
        var testIDProps = _this.props.getTestIDProps && _this.props.getTestIDProps(scene);

        return testIDProps;
      }, _this._handleTabPress = function (index) {
        var _this$props3 = _this.props,
            jumpToIndex = _this$props3.jumpToIndex,
            navigation = _this$props3.navigation;
        var currentIndex = navigation.state.index;

        if (currentIndex === index) {
          var childRoute = navigation.state.routes[index];

          if (childRoute.hasOwnProperty('index') && childRoute.index > 0) {
            navigation.dispatch(_NavigationActions2.default.popToTop({
              key: childRoute.key
            }));
          } else {}
        } else {
          jumpToIndex(index);
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(TabBarBottom, [{
      key: "_tabItemMaxWidth",
      value: function _tabItemMaxWidth() {
        var _props = this.props,
            tabStyle = _props.tabStyle,
            layout = _props.layout;
        var maxTabBarItemWidth = void 0;

        var flattenedTabStyle = _reactNative.StyleSheet.flatten(tabStyle);

        if (flattenedTabStyle) {
          if (typeof flattenedTabStyle.width === 'number') {
            maxTabBarItemWidth = flattenedTabStyle.width;
          } else if (typeof flattenedTabStyle.width === 'string' && flattenedTabStyle.endsWith('%')) {
            var width = parseFloat(flattenedTabStyle.width);

            if (Number.isFinite(width)) {
              maxTabBarItemWidth = layout.width * (width / 100);
            }
          } else if (typeof flattenedTabStyle.maxWidth === 'number') {
            maxTabBarItemWidth = flattenedTabStyle.maxWidth;
          } else if (typeof flattenedTabStyle.maxWidth === 'string' && flattenedTabStyle.endsWith('%')) {
            var _width = parseFloat(flattenedTabStyle.maxWidth);

            if (Number.isFinite(_width)) {
              maxTabBarItemWidth = layout.width * (_width / 100);
            }
          }
        }

        if (!maxTabBarItemWidth) {
          maxTabBarItemWidth = defaultMaxTabBarItemWidth;
        }

        return maxTabBarItemWidth;
      }
    }, {
      key: "_shouldUseHorizontalTabs",
      value: function _shouldUseHorizontalTabs() {
        var routes = this.props.navigation.state.routes;
        var _props2 = this.props,
            isLandscape = _props2.isLandscape,
            layout = _props2.layout,
            adaptive = _props2.adaptive,
            tabStyle = _props2.tabStyle;

        if (!adaptive) {
          return false;
        }

        var tabBarWidth = layout.width;

        if (tabBarWidth === 0) {
          return _reactNative.Platform.isPad;
        }

        if (!_reactNative.Platform.isPad) {
          return isLandscape;
        } else {
          var maxTabBarItemWidth = this._tabItemMaxWidth();

          return routes.length * maxTabBarItemWidth <= tabBarWidth;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props3 = this.props,
            position = _props3.position,
            navigation = _props3.navigation,
            jumpToIndex = _props3.jumpToIndex,
            getOnPress = _props3.getOnPress,
            getTestIDProps = _props3.getTestIDProps,
            activeBackgroundColor = _props3.activeBackgroundColor,
            inactiveBackgroundColor = _props3.inactiveBackgroundColor,
            style = _props3.style,
            animateStyle = _props3.animateStyle,
            tabStyle = _props3.tabStyle,
            isLandscape = _props3.isLandscape;
        var routes = navigation.state.routes;
        var previousScene = routes[navigation.state.index];
        var inputRange = [-1].concat(babelHelpers.toConsumableArray(routes.map(function (x, i) {
          return i;
        })));
        var tabBarStyle = [styles.tabBar, this._shouldUseHorizontalTabs() && !_reactNative.Platform.isPad ? styles.tabBarCompact : styles.tabBarRegular, style];
        return _react2.default.createElement(
          _reactNative.Animated.View,
          {
            style: animateStyle,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 226
            }
          },
          _react2.default.createElement(
            _reactNativeSafeAreaView2.default,
            {
              style: tabBarStyle,
              forceInset: {
                bottom: 'always',
                top: 'never'
              },
              __source: {
                fileName: _jsxFileName,
                lineNumber: 227
              }
            },
            routes.map(function (route, index) {
              var focused = index === navigation.state.index;
              var scene = {
                route: route,
                index: index,
                focused: focused
              };

              var _onPress = getOnPress(previousScene, scene);

              var outputRange = inputRange.map(function (inputIndex) {
                return inputIndex === index ? activeBackgroundColor : inactiveBackgroundColor;
              });
              var backgroundColor = position.interpolate({
                inputRange: inputRange,
                outputRange: outputRange
              });
              var justifyContent = _this2.props.showIcon ? 'flex-end' : 'center';
              var extraProps = _this2._renderTestIDProps(scene) || {};
              var testID = extraProps.testID,
                  accessibilityLabel = extraProps.accessibilityLabel;
              return _react2.default.createElement(
                _reactNative.TouchableWithoutFeedback,
                {
                  key: route.key,
                  testID: testID,
                  accessibilityLabel: accessibilityLabel,
                  onPress: function onPress() {
                    return _onPress ? _onPress({
                      previousScene: previousScene,
                      scene: scene,
                      jumpToIndex: jumpToIndex,
                      defaultHandler: _this2._handleTabPress
                    }) : _this2._handleTabPress(index);
                  },
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 251
                  }
                },
                _react2.default.createElement(
                  _reactNative.Animated.View,
                  {
                    style: [styles.tab, {
                      backgroundColor: backgroundColor
                    }],
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 266
                    }
                  },
                  _react2.default.createElement(
                    _reactNative.View,
                    {
                      style: [styles.tab, _this2._shouldUseHorizontalTabs() ? styles.tabLandscape : styles.tabPortrait, tabStyle],
                      __source: {
                        fileName: _jsxFileName,
                        lineNumber: 267
                      }
                    },
                    _this2._renderIcon(scene),
                    _this2._renderLabel(scene)
                  )
                )
              );
            })
          )
        );
      }
    }]);
    return TabBarBottom;
  }(_react2.default.PureComponent);

  TabBarBottom.defaultProps = {
    activeTintColor: '#3478f6',
    activeBackgroundColor: 'transparent',
    inactiveTintColor: '#929292',
    inactiveBackgroundColor: 'transparent',
    showLabel: true,
    showIcon: true,
    allowFontScaling: true,
    adaptive: isIOS11
  };

  var styles = _reactNative.StyleSheet.create({
    tabBar: {
      backgroundColor: '#F7F7F7',
      borderTopWidth: _reactNative.StyleSheet.hairlineWidth,
      borderTopColor: 'rgba(0, 0, 0, .3)',
      flexDirection: 'row'
    },
    tabBarCompact: {
      height: 29
    },
    tabBarRegular: {
      height: 49
    },
    tab: {
      flex: 1,
      alignItems: isIos ? 'center' : 'stretch'
    },
    tabPortrait: {
      justifyContent: 'flex-end',
      flexDirection: 'column'
    },
    tabLandscape: {
      justifyContent: 'center',
      flexDirection: 'row'
    },
    icon: {
      flexGrow: 1
    },
    label: {
      textAlign: 'center',
      backgroundColor: 'transparent'
    },
    labelBeneath: {
      fontSize: 10,
      marginBottom: 1.5
    },
    labelBeside: {
      fontSize: 13,
      marginLeft: 20
    }
  });

  exports.default = (0, _withOrientation2.default)(TabBarBottom);
},440,[12,66,392,439,379,401],"react-navigation/src/views/TabView/TabBarBottom.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/navigators/DrawerNavigator.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _reactNativeSafeAreaView = require(_dependencyMap[2], "react-native-safe-area-view");

  var _reactNativeSafeAreaView2 = babelHelpers.interopRequireDefault(_reactNativeSafeAreaView);

  var _createNavigator = require(_dependencyMap[3], "./createNavigator");

  var _createNavigator2 = babelHelpers.interopRequireDefault(_createNavigator);

  var _createNavigationContainer = require(_dependencyMap[4], "../createNavigationContainer");

  var _createNavigationContainer2 = babelHelpers.interopRequireDefault(_createNavigationContainer);

  var _TabRouter2 = require(_dependencyMap[5], "../routers/TabRouter");

  var _TabRouter3 = babelHelpers.interopRequireDefault(_TabRouter2);

  var _DrawerScreen = require(_dependencyMap[6], "../views/Drawer/DrawerScreen");

  var _DrawerScreen2 = babelHelpers.interopRequireDefault(_DrawerScreen);

  var _DrawerView = require(_dependencyMap[7], "../views/Drawer/DrawerView");

  var _DrawerView2 = babelHelpers.interopRequireDefault(_DrawerView);

  var _DrawerNavigatorItems = require(_dependencyMap[8], "../views/Drawer/DrawerNavigatorItems");

  var _DrawerNavigatorItems2 = babelHelpers.interopRequireDefault(_DrawerNavigatorItems);

  var defaultContentComponent = function defaultContentComponent(props) {
    return _react2.default.createElement(
      _reactNative.ScrollView,
      {
        alwaysBounceVertical: false,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 17
        }
      },
      _react2.default.createElement(
        _reactNativeSafeAreaView2.default,
        {
          forceInset: {
            top: 'always',
            horizontal: 'never'
          },
          __source: {
            fileName: _jsxFileName,
            lineNumber: 18
          }
        },
        _react2.default.createElement(_DrawerNavigatorItems2.default, babelHelpers.extends({}, props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 19
          }
        }))
      )
    );
  };

  var DefaultDrawerConfig = {
    drawerWidth: function drawerWidth() {
      var _Dimensions$get = _reactNative.Dimensions.get('window'),
          height = _Dimensions$get.height,
          width = _Dimensions$get.width;

      var smallerAxisSize = Math.min(height, width);
      var isLandscape = width > height;
      var isTablet = smallerAxisSize >= 600;
      var appBarHeight = _reactNative.Platform.OS === 'ios' ? isLandscape ? 32 : 44 : 56;
      var maxWidth = isTablet ? 320 : 280;
      return Math.min(smallerAxisSize - appBarHeight, maxWidth);
    },
    contentComponent: defaultContentComponent,
    drawerOpenRoute: 'DrawerOpen',
    drawerCloseRoute: 'DrawerClose',
    drawerToggleRoute: 'DrawerToggle',
    drawerPosition: 'left',
    drawerBackgroundColor: 'white',
    useNativeAnimations: true
  };

  var DrawerNavigator = function DrawerNavigator(routeConfigs) {
    var _TabRouter;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var mergedConfig = babelHelpers.extends({}, DefaultDrawerConfig, config);
    var containerConfig = mergedConfig.containerConfig,
        drawerWidth = mergedConfig.drawerWidth,
        drawerLockMode = mergedConfig.drawerLockMode,
        contentComponent = mergedConfig.contentComponent,
        contentOptions = mergedConfig.contentOptions,
        drawerPosition = mergedConfig.drawerPosition,
        useNativeAnimations = mergedConfig.useNativeAnimations,
        drawerBackgroundColor = mergedConfig.drawerBackgroundColor,
        drawerOpenRoute = mergedConfig.drawerOpenRoute,
        drawerCloseRoute = mergedConfig.drawerCloseRoute,
        drawerToggleRoute = mergedConfig.drawerToggleRoute,
        tabsConfig = babelHelpers.objectWithoutProperties(mergedConfig, ["containerConfig", "drawerWidth", "drawerLockMode", "contentComponent", "contentOptions", "drawerPosition", "useNativeAnimations", "drawerBackgroundColor", "drawerOpenRoute", "drawerCloseRoute", "drawerToggleRoute"]);
    var contentRouter = (0, _TabRouter3.default)(routeConfigs, tabsConfig);
    var drawerRouter = (0, _TabRouter3.default)((_TabRouter = {}, babelHelpers.defineProperty(_TabRouter, drawerCloseRoute, {
      screen: (0, _createNavigator2.default)(contentRouter, routeConfigs, config)(function (props) {
        return _react2.default.createElement(_DrawerScreen2.default, babelHelpers.extends({}, props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 71
          }
        }));
      })
    }), babelHelpers.defineProperty(_TabRouter, drawerOpenRoute, {
      screen: function screen() {
        return null;
      }
    }), babelHelpers.defineProperty(_TabRouter, drawerToggleRoute, {
      screen: function screen() {
        return null;
      }
    }), _TabRouter), {
      initialRouteName: drawerCloseRoute
    });
    var navigator = (0, _createNavigator2.default)(drawerRouter, routeConfigs, config)(function (props) {
      return _react2.default.createElement(_DrawerView2.default, babelHelpers.extends({}, props, {
        drawerBackgroundColor: drawerBackgroundColor,
        drawerLockMode: drawerLockMode,
        useNativeAnimations: useNativeAnimations,
        drawerWidth: drawerWidth,
        contentComponent: contentComponent,
        contentOptions: contentOptions,
        drawerPosition: drawerPosition,
        drawerOpenRoute: drawerOpenRoute,
        drawerCloseRoute: drawerCloseRoute,
        drawerToggleRoute: drawerToggleRoute,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 88
        }
      }));
    });
    return (0, _createNavigationContainer2.default)(navigator);
  };

  exports.default = DrawerNavigator;
},441,[12,66,392,383,377,425,442,443,446],"react-navigation/src/navigators/DrawerNavigator.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/Drawer/DrawerScreen.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _SceneView = require(_dependencyMap[1], "../SceneView");

  var _SceneView2 = babelHelpers.interopRequireDefault(_SceneView);

  var _withCachedChildNavigation = require(_dependencyMap[2], "../../withCachedChildNavigation");

  var _withCachedChildNavigation2 = babelHelpers.interopRequireDefault(_withCachedChildNavigation);

  var DrawerScreen = function (_React$PureComponent) {
    babelHelpers.inherits(DrawerScreen, _React$PureComponent);

    function DrawerScreen() {
      babelHelpers.classCallCheck(this, DrawerScreen);
      return babelHelpers.possibleConstructorReturn(this, (DrawerScreen.__proto__ || Object.getPrototypeOf(DrawerScreen)).apply(this, arguments));
    }

    babelHelpers.createClass(DrawerScreen, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            router = _props.router,
            navigation = _props.navigation,
            childNavigationProps = _props.childNavigationProps,
            screenProps = _props.screenProps;
        var _navigation$state = navigation.state,
            routes = _navigation$state.routes,
            index = _navigation$state.index;
        var childNavigation = childNavigationProps[routes[index].key];
        var Content = router.getComponentForRouteName(routes[index].routeName);
        return _react2.default.createElement(_SceneView2.default, {
          screenProps: screenProps,
          component: Content,
          navigation: childNavigation,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 21
          }
        });
      }
    }]);
    return DrawerScreen;
  }(_react2.default.PureComponent);

  exports.default = (0, _withCachedChildNavigation2.default)(DrawerScreen);
},442,[12,404,423],"react-navigation/src/views/Drawer/DrawerScreen.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/Drawer/DrawerView.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _reactNativeDrawerLayoutPolyfill = require(_dependencyMap[2], "react-native-drawer-layout-polyfill");

  var _reactNativeDrawerLayoutPolyfill2 = babelHelpers.interopRequireDefault(_reactNativeDrawerLayoutPolyfill);

  var _addNavigationHelpers = require(_dependencyMap[3], "../../addNavigationHelpers");

  var _addNavigationHelpers2 = babelHelpers.interopRequireDefault(_addNavigationHelpers);

  var _DrawerSidebar = require(_dependencyMap[4], "./DrawerSidebar");

  var _DrawerSidebar2 = babelHelpers.interopRequireDefault(_DrawerSidebar);

  var _getChildEventSubscriber = require(_dependencyMap[5], "../../getChildEventSubscriber");

  var _getChildEventSubscriber2 = babelHelpers.interopRequireDefault(_getChildEventSubscriber);

  var DrawerView = function (_React$PureComponent) {
    babelHelpers.inherits(DrawerView, _React$PureComponent);

    function DrawerView() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, DrawerView);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = DrawerView.__proto__ || Object.getPrototypeOf(DrawerView)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        drawerWidth: typeof _this.props.drawerWidth === 'function' ? _this.props.drawerWidth() : _this.props.drawerWidth
      }, _this._childEventSubscribers = {}, _this._handleDrawerOpen = function () {
        var _this$props = _this.props,
            navigation = _this$props.navigation,
            drawerOpenRoute = _this$props.drawerOpenRoute;
        var _navigation$state = navigation.state,
            routes = _navigation$state.routes,
            index = _navigation$state.index;

        if (routes[index].routeName !== drawerOpenRoute) {
          _this.props.navigation.navigate(drawerOpenRoute);
        }
      }, _this._handleDrawerClose = function () {
        var _this$props2 = _this.props,
            navigation = _this$props2.navigation,
            drawerCloseRoute = _this$props2.drawerCloseRoute;
        var _navigation$state2 = navigation.state,
            routes = _navigation$state2.routes,
            index = _navigation$state2.index;

        if (routes[index].routeName !== drawerCloseRoute) {
          _this.props.navigation.navigate(drawerCloseRoute);
        }
      }, _this._isRouteFocused = function (route) {
        return function () {
          var state = _this.props.navigation.state;
          var focusedRoute = state.routes[state.index];
          return route === focusedRoute;
        };
      }, _this._updateScreenNavigation = function (navigation) {
        var drawerCloseRoute = _this.props.drawerCloseRoute;
        var navigationState = navigation.state.routes.find(function (route) {
          return route.routeName === drawerCloseRoute;
        });

        if (_this._screenNavigationProp && _this._screenNavigationProp.state === navigationState) {
          return;
        }

        if (!_this._childEventSubscribers[navigationState.key]) {
          _this._childEventSubscribers[navigationState.key] = (0, _getChildEventSubscriber2.default)(navigation.addListener, navigationState.key);
        }

        _this._screenNavigationProp = (0, _addNavigationHelpers2.default)({
          dispatch: navigation.dispatch,
          state: navigationState,
          isFocused: _this._isRouteFocused.bind(_this, navigationState),
          addListener: _this._childEventSubscribers[navigationState.key]
        });
      }, _this._updateWidth = function () {
        var drawerWidth = typeof _this.props.drawerWidth === 'function' ? _this.props.drawerWidth() : _this.props.drawerWidth;

        if (_this.state.drawerWidth !== drawerWidth) {
          _this.setState({
            drawerWidth: drawerWidth
          });
        }
      }, _this._getNavigationState = function (navigation) {
        var drawerCloseRoute = _this.props.drawerCloseRoute;
        var navigationState = navigation.state.routes.find(function (route) {
          return route.routeName === drawerCloseRoute;
        });
        return navigationState;
      }, _this._renderNavigationView = function () {
        return _react2.default.createElement(_DrawerSidebar2.default, {
          screenProps: _this.props.screenProps,
          navigation: _this._screenNavigationProp,
          router: _this.props.router,
          contentComponent: _this.props.contentComponent,
          contentOptions: _this.props.contentOptions,
          drawerPosition: _this.props.drawerPosition,
          style: _this.props.style,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 136
          }
        });
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(DrawerView, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this._updateScreenNavigation(this.props.navigation);

        _reactNative.Dimensions.addEventListener('change', this._updateWidth);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _reactNative.Dimensions.removeEventListener('change', this._updateWidth);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var _this2 = this;

        var activeKeys = this.props.navigation.state.routes.map(function (route) {
          return route.key;
        });
        Object.keys(this._childEventSubscribers).forEach(function (key) {
          if (!activeKeys.includes(key)) {
            delete _this2._childEventSubscribers[key];
          }
        });
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (this.props.navigation.state.index !== nextProps.navigation.state.index) {
          var _props = this.props,
              drawerOpenRoute = _props.drawerOpenRoute,
              drawerCloseRoute = _props.drawerCloseRoute,
              drawerToggleRoute = _props.drawerToggleRoute;
          var _nextProps$navigation = nextProps.navigation.state,
              routes = _nextProps$navigation.routes,
              index = _nextProps$navigation.index;

          if (routes[index].routeName === drawerOpenRoute) {
            this._drawer.openDrawer();
          } else if (routes[index].routeName === drawerToggleRoute) {
            if (this.props.navigation.state.index === 0) {
              this.props.navigation.navigate(drawerOpenRoute);
            } else {
              this.props.navigation.navigate(drawerCloseRoute);
            }
          } else {
            this._drawer.closeDrawer();
          }
        }

        this._updateScreenNavigation(nextProps.navigation);
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var DrawerScreen = this.props.router.getComponentForRouteName(this.props.drawerCloseRoute);
        var config = this.props.router.getScreenOptions(this._screenNavigationProp, this.props.screenProps);
        return _react2.default.createElement(
          _reactNativeDrawerLayoutPolyfill2.default,
          {
            ref: function ref(c) {
              _this3._drawer = c;
            },
            drawerLockMode: this.props.screenProps && this.props.screenProps.drawerLockMode || config && config.drawerLockMode,
            drawerBackgroundColor: this.props.drawerBackgroundColor,
            drawerWidth: this.state.drawerWidth,
            onDrawerOpen: this._handleDrawerOpen,
            onDrawerClose: this._handleDrawerClose,
            useNativeAnimations: this.props.useNativeAnimations,
            renderNavigationView: this._renderNavigationView,
            drawerPosition: this.props.drawerPosition === 'right' ? _reactNativeDrawerLayoutPolyfill2.default.positions.Right : _reactNativeDrawerLayoutPolyfill2.default.positions.Left,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 158
            }
          },
          _react2.default.createElement(DrawerScreen, {
            screenProps: this.props.screenProps,
            navigation: this._screenNavigationProp,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 178
            }
          })
        );
      }
    }]);
    return DrawerView;
  }(_react2.default.PureComponent);

  exports.default = DrawerView;
},443,[12,66,444,380,445,403],"react-navigation/src/views/Drawer/DrawerView.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], 'react-native');

  exports.default = _reactNative.DrawerLayoutAndroid;
},444,[66],"react-native-drawer-layout-polyfill/dist/index.android.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/Drawer/DrawerSidebar.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _reactNativeSafeAreaView = require(_dependencyMap[2], "react-native-safe-area-view");

  var _reactNativeSafeAreaView2 = babelHelpers.interopRequireDefault(_reactNativeSafeAreaView);

  var _withCachedChildNavigation = require(_dependencyMap[3], "../../withCachedChildNavigation");

  var _withCachedChildNavigation2 = babelHelpers.interopRequireDefault(_withCachedChildNavigation);

  var _NavigationActions = require(_dependencyMap[4], "../../NavigationActions");

  var _NavigationActions2 = babelHelpers.interopRequireDefault(_NavigationActions);

  var _invariant = require(_dependencyMap[5], "../../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var DrawerSidebar = function (_React$PureComponent) {
    babelHelpers.inherits(DrawerSidebar, _React$PureComponent);

    function DrawerSidebar() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, DrawerSidebar);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = DrawerSidebar.__proto__ || Object.getPrototypeOf(DrawerSidebar)).call.apply(_ref, [this].concat(args))), _this), _this._getScreenOptions = function (routeKey) {
        var DrawerScreen = _this.props.router.getComponentForRouteName('DrawerClose');

        (0, _invariant2.default)(DrawerScreen.router, 'NavigationComponent with routeName DrawerClose should be a Navigator');
        var childNavigation = _this.props.childNavigationProps[routeKey];
        return DrawerScreen.router.getScreenOptions(childNavigation.state.index !== undefined ? babelHelpers.extends({}, childNavigation, {
          state: babelHelpers.extends({}, childNavigation.state, {
            index: 0
          })
        }) : childNavigation, _this.props.screenProps);
      }, _this._getLabel = function (_ref2) {
        var focused = _ref2.focused,
            tintColor = _ref2.tintColor,
            route = _ref2.route;

        var _this$_getScreenOptio = _this._getScreenOptions(route.key),
            drawerLabel = _this$_getScreenOptio.drawerLabel,
            title = _this$_getScreenOptio.title;

        if (drawerLabel) {
          return typeof drawerLabel === 'function' ? drawerLabel({
            tintColor: tintColor,
            focused: focused
          }) : drawerLabel;
        }

        if (typeof title === 'string') {
          return title;
        }

        return route.routeName;
      }, _this._renderIcon = function (_ref3) {
        var focused = _ref3.focused,
            tintColor = _ref3.tintColor,
            route = _ref3.route;

        var _this$_getScreenOptio2 = _this._getScreenOptions(route.key),
            drawerIcon = _this$_getScreenOptio2.drawerIcon;

        if (drawerIcon) {
          return typeof drawerIcon === 'function' ? drawerIcon({
            tintColor: tintColor,
            focused: focused
          }) : drawerIcon;
        }

        return null;
      }, _this._onItemPress = function (_ref4) {
        var route = _ref4.route,
            focused = _ref4.focused;

        _this.props.navigation.navigate('DrawerClose');

        if (!focused) {
          var subAction = void 0;

          if (route.index !== undefined && route.index !== 0) {
            subAction = _NavigationActions2.default.reset({
              index: 0,
              actions: [_NavigationActions2.default.navigate({
                routeName: route.routes[0].routeName
              })]
            });
          }

          _this.props.navigation.navigate(route.routeName, undefined, subAction);
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(DrawerSidebar, [{
      key: "render",
      value: function render() {
        var ContentComponent = this.props.contentComponent;

        if (!ContentComponent) {
          return null;
        }

        var state = this.props.navigation.state;
        (0, _invariant2.default)(typeof state.index === 'number', 'should be set');
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: [styles.container, this.props.style],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 85
            }
          },
          _react2.default.createElement(ContentComponent, babelHelpers.extends({}, this.props.contentOptions, {
            navigation: this.props.navigation,
            items: state.routes,
            activeItemKey: state.routes[state.index] ? state.routes[state.index].key : null,
            screenProps: this.props.screenProps,
            getLabel: this._getLabel,
            renderIcon: this._renderIcon,
            onItemPress: this._onItemPress,
            router: this.props.router,
            drawerPosition: this.props.drawerPosition,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 86
            }
          }))
        );
      }
    }]);
    return DrawerSidebar;
  }(_react2.default.PureComponent);

  exports.default = (0, _withCachedChildNavigation2.default)(DrawerSidebar);

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1
    }
  });
},445,[12,66,392,423,379,381],"react-navigation/src/views/Drawer/DrawerSidebar.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/Drawer/DrawerNavigatorItems.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _reactNativeSafeAreaView = require(_dependencyMap[2], "react-native-safe-area-view");

  var _reactNativeSafeAreaView2 = babelHelpers.interopRequireDefault(_reactNativeSafeAreaView);

  var _TouchableItem = require(_dependencyMap[3], "../TouchableItem");

  var _TouchableItem2 = babelHelpers.interopRequireDefault(_TouchableItem);

  var DrawerNavigatorItems = function DrawerNavigatorItems(_ref) {
    var _ref$navigation = _ref.navigation,
        state = _ref$navigation.state,
        navigate = _ref$navigation.navigate,
        items = _ref.items,
        activeItemKey = _ref.activeItemKey,
        activeTintColor = _ref.activeTintColor,
        activeBackgroundColor = _ref.activeBackgroundColor,
        inactiveTintColor = _ref.inactiveTintColor,
        inactiveBackgroundColor = _ref.inactiveBackgroundColor,
        getLabel = _ref.getLabel,
        renderIcon = _ref.renderIcon,
        onItemPress = _ref.onItemPress,
        itemsContainerStyle = _ref.itemsContainerStyle,
        itemStyle = _ref.itemStyle,
        labelStyle = _ref.labelStyle,
        activeLabelStyle = _ref.activeLabelStyle,
        inactiveLabelStyle = _ref.inactiveLabelStyle,
        iconContainerStyle = _ref.iconContainerStyle,
        drawerPosition = _ref.drawerPosition;
    return _react2.default.createElement(
      _reactNative.View,
      {
        style: [styles.container, itemsContainerStyle],
        __source: {
          fileName: _jsxFileName,
          lineNumber: 29
        }
      },
      items.map(function (route, index) {
        var _ref2;

        var focused = activeItemKey === route.key;
        var color = focused ? activeTintColor : inactiveTintColor;
        var backgroundColor = focused ? activeBackgroundColor : inactiveBackgroundColor;
        var scene = {
          route: route,
          index: index,
          focused: focused,
          tintColor: color
        };
        var icon = renderIcon(scene);
        var label = getLabel(scene);
        var extraLabelStyle = focused ? activeLabelStyle : inactiveLabelStyle;
        return _react2.default.createElement(
          _TouchableItem2.default,
          {
            key: route.key,
            onPress: function onPress() {
              onItemPress({
                route: route,
                focused: focused
              });
            },
            delayPressIn: 0,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 41
            }
          },
          _react2.default.createElement(
            _reactNativeSafeAreaView2.default,
            {
              style: {
                backgroundColor: backgroundColor
              },
              forceInset: (_ref2 = {}, babelHelpers.defineProperty(_ref2, drawerPosition, 'always'), babelHelpers.defineProperty(_ref2, drawerPosition === 'left' ? 'right' : 'left', 'never'), babelHelpers.defineProperty(_ref2, "vertical", 'never'), _ref2),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 48
              }
            },
            _react2.default.createElement(
              _reactNative.View,
              {
                style: [styles.item, itemStyle],
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 56
                }
              },
              icon ? _react2.default.createElement(
                _reactNative.View,
                {
                  style: [styles.icon, focused ? null : styles.inactiveIcon, iconContainerStyle],
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 58
                  }
                },
                icon
              ) : null,
              typeof label === 'string' ? _react2.default.createElement(
                _reactNative.Text,
                {
                  style: [styles.label, {
                    color: color
                  }, labelStyle, extraLabelStyle],
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 69
                  }
                },
                label
              ) : label
            )
          )
        );
      })
    );
  };

  DrawerNavigatorItems.defaultProps = {
    activeTintColor: '#2196f3',
    activeBackgroundColor: 'rgba(0, 0, 0, .04)',
    inactiveTintColor: 'rgba(0, 0, 0, .87)',
    inactiveBackgroundColor: 'transparent'
  };

  var styles = _reactNative.StyleSheet.create({
    container: {
      paddingVertical: 4
    },
    item: {
      flexDirection: 'row',
      alignItems: 'center'
    },
    icon: {
      marginHorizontal: 16,
      width: 24,
      alignItems: 'center'
    },
    inactiveIcon: {
      opacity: 0.62
    },
    label: {
      margin: 16,
      fontWeight: 'bold'
    }
  });

  exports.default = DrawerNavigatorItems;
},446,[12,66,392,396],"react-navigation/src/views/Drawer/DrawerNavigatorItems.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/withNavigation.js";
  exports.default = withNavigation;

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _hoistNonReactStatics = require(_dependencyMap[2], "hoist-non-react-statics");

  var _hoistNonReactStatics2 = babelHelpers.interopRequireDefault(_hoistNonReactStatics);

  function withNavigation(Component) {
    var ComponentWithNavigation = function (_React$Component) {
      babelHelpers.inherits(ComponentWithNavigation, _React$Component);

      function ComponentWithNavigation() {
        babelHelpers.classCallCheck(this, ComponentWithNavigation);
        return babelHelpers.possibleConstructorReturn(this, (ComponentWithNavigation.__proto__ || Object.getPrototypeOf(ComponentWithNavigation)).apply(this, arguments));
      }

      babelHelpers.createClass(ComponentWithNavigation, [{
        key: "render",
        value: function render() {
          var navigation = this.context.navigation;
          return _react2.default.createElement(Component, babelHelpers.extends({}, this.props, {
            navigation: navigation,
            ref: this.props.onRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 17
            }
          }));
        }
      }]);
      return ComponentWithNavigation;
    }(_react2.default.Component);

    ComponentWithNavigation.displayName = "withNavigation(" + (Component.displayName || Component.name) + ")";
    ComponentWithNavigation.contextTypes = {
      navigation: _propTypes2.default.object.isRequired
    };
    return (0, _hoistNonReactStatics2.default)(ComponentWithNavigation, Component);
  }
},447,[12,24,30],"react-navigation/src/views/withNavigation.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-navigation/src/views/withNavigationFocus.js";
  exports.default = withNavigationFocus;

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _hoistNonReactStatics = require(_dependencyMap[2], "hoist-non-react-statics");

  var _hoistNonReactStatics2 = babelHelpers.interopRequireDefault(_hoistNonReactStatics);

  var _invariant = require(_dependencyMap[3], "../utils/invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  function withNavigationFocus(Component) {
    var ComponentWithNavigationFocus = function (_React$Component) {
      babelHelpers.inherits(ComponentWithNavigationFocus, _React$Component);

      function ComponentWithNavigationFocus(props, context) {
        babelHelpers.classCallCheck(this, ComponentWithNavigationFocus);

        var _this = babelHelpers.possibleConstructorReturn(this, (ComponentWithNavigationFocus.__proto__ || Object.getPrototypeOf(ComponentWithNavigationFocus)).call(this));

        _initialiseProps.call(_this);

        _this.state = {
          isFocused: _this.getNavigation(props, context).isFocused()
        };
        return _this;
      }

      babelHelpers.createClass(ComponentWithNavigationFocus, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this2 = this;

          var navigation = this.getNavigation();
          this.subscriptions = [navigation.addListener('didFocus', function () {
            return _this2.setState({
              isFocused: true
            });
          }), navigation.addListener('willBlur', function () {
            return _this2.setState({
              isFocused: false
            });
          })];
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.subscriptions.forEach(function (sub) {
            return sub.remove();
          });
        }
      }, {
        key: "render",
        value: function render() {
          return _react2.default.createElement(Component, babelHelpers.extends({}, this.props, {
            isFocused: this.state.isFocused,
            ref: this.props.onRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 50
            }
          }));
        }
      }]);
      return ComponentWithNavigationFocus;
    }(_react2.default.Component);

    ComponentWithNavigationFocus.displayName = "withNavigationFocus(" + (Component.displayName || Component.name) + ")";
    ComponentWithNavigationFocus.contextTypes = {
      navigation: _propTypes2.default.object.isRequired
    };

    var _initialiseProps = function _initialiseProps() {
      var _this3 = this;

      this.getNavigation = function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this3.props;
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this3.context;
        var navigation = props.navigation || context.navigation;
        (0, _invariant2.default)(!!navigation, 'withNavigationFocus can only be used on a view hierarchy of a navigator. The wrapped component is unable to get access to navigation from props or context.');
        return navigation;
      };
    };

    return (0, _hoistNonReactStatics2.default)(ComponentWithNavigationFocus, Component);
  }
},448,[12,24,30,381],"react-navigation/src/views/withNavigationFocus.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactRedux = require(_dependencyMap[0], "react-redux");

  var _view = require(_dependencyMap[1], "./view");

  var _view2 = babelHelpers.interopRequireDefault(_view);

  var select = function select(state) {
    return {};
  };

  var perform = function perform(dispatch) {
    return {};
  };

  exports.default = (0, _reactRedux.connect)(select, perform)(_view2.default);
},449,[22,450],"LBRYApp/src/component/fileItemMedia/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/component/fileItemMedia/view.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _fileItemMedia = require(_dependencyMap[2], "../../styles/fileItemMedia");

  var _fileItemMedia2 = babelHelpers.interopRequireDefault(_fileItemMedia);

  var FileItemMedia = function (_React$PureComponent) {
    babelHelpers.inherits(FileItemMedia, _React$PureComponent);

    function FileItemMedia() {
      babelHelpers.classCallCheck(this, FileItemMedia);
      return babelHelpers.possibleConstructorReturn(this, (FileItemMedia.__proto__ || Object.getPrototypeOf(FileItemMedia)).apply(this, arguments));
    }

    babelHelpers.createClass(FileItemMedia, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.setState({
          autoThumbStyle: FileItemMedia.AUTO_THUMB_STYLES[Math.floor(Math.random() * FileItemMedia.AUTO_THUMB_STYLES.length)]
        });
      }
    }, {
      key: "render",
      value: function render() {
        var style = this.props.style;
        var _props = this.props,
            title = _props.title,
            thumbnail = _props.thumbnail,
            resizeMode = _props.resizeMode;
        var atStyle = this.state.autoThumbStyle;

        if (thumbnail && typeof thumbnail === 'string') {
          if (style == null) {
            style = _fileItemMedia2.default.thumbnail;
          }

          return _react2.default.createElement(_reactNative.Image, {
            source: {
              uri: thumbnail
            },
            resizeMode: resizeMode ? resizeMode : "cover",
            style: style,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 40
            }
          });
        }

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: [_fileItemMedia2.default.autothumb, atStyle],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 45
            }
          },
          _react2.default.createElement(
            _reactNative.Text,
            {
              style: _fileItemMedia2.default.autothumbText,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 46
              }
            },
            title && title.replace(/\s+/g, '').substring(0, Math.min(title.replace(' ', '').length, 5)).toUpperCase()
          )
        );
      }
    }]);
    return FileItemMedia;
  }(_react2.default.PureComponent);

  FileItemMedia.AUTO_THUMB_STYLES = [_fileItemMedia2.default.autothumbPurple, _fileItemMedia2.default.autothumbRed, _fileItemMedia2.default.autothumbPink, _fileItemMedia2.default.autothumbIndigo, _fileItemMedia2.default.autothumbBlue, _fileItemMedia2.default.autothumbLightBlue, _fileItemMedia2.default.autothumbCyan, _fileItemMedia2.default.autothumbTeal, _fileItemMedia2.default.autothumbGreen, _fileItemMedia2.default.autothumbYellow, _fileItemMedia2.default.autothumbOrange];
  exports.default = FileItemMedia;
},450,[12,66,451],"LBRYApp/src/component/fileItemMedia/view.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var screenDimension = _reactNative.Dimensions.get('window');

  var width = screenDimension.width - 48;

  var fileItemMediaStyle = _reactNative.StyleSheet.create({
    autothumb: {
      flex: 1,
      width: '100%',
      height: 200,
      justifyContent: 'center'
    },
    autothumbText: {
      fontFamily: 'Metropolis-SemiBold',
      textAlign: 'center',
      color: '#ffffff',
      fontSize: 40
    },
    autothumbPurple: {
      backgroundColor: '#9c27b0'
    },
    autothumbRed: {
      backgroundColor: '#e53935'
    },
    autothumbPink: {
      backgroundColor: '#e91e63'
    },
    autothumbIndigo: {
      backgroundColor: '#3f51b5'
    },
    autothumbBlue: {
      backgroundColor: '#2196f3'
    },
    autothumbLightBlue: {
      backgroundColor: '#039be5'
    },
    autothumbCyan: {
      backgroundColor: '#00acc1'
    },
    autothumbTeal: {
      backgroundColor: '#009688'
    },
    autothumbGreen: {
      backgroundColor: '#43a047'
    },
    autothumbYellow: {
      backgroundColor: '#ffeb3b'
    },
    autothumbOrange: {
      backgroundColor: '#ffa726'
    },
    thumbnail: {
      flex: 1,
      width: '100%',
      height: 200,
      shadowColor: 'transparent'
    }
  });

  exports.default = fileItemMediaStyle;
},451,[66],"LBRYApp/src/styles/fileItemMedia.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactRedux = require(_dependencyMap[0], "react-redux");

  var _lbryRedux = require(_dependencyMap[1], "lbry-redux");

  var _view = require(_dependencyMap[2], "./view");

  var _view2 = babelHelpers.interopRequireDefault(_view);

  var select = function select(state, props) {
    return {
      costInfo: (0, _lbryRedux.makeSelectCostInfoForUri)(props.uri)(state),
      fetching: (0, _lbryRedux.makeSelectFetchingCostInfoForUri)(props.uri)(state),
      claim: (0, _lbryRedux.makeSelectClaimForUri)(props.uri)(state)
    };
  };

  var perform = function perform(dispatch) {
    return {
      fetchCostInfo: function fetchCostInfo(uri) {
        return dispatch((0, _lbryRedux.doFetchCostInfoForUri)(uri));
      }
    };
  };

  exports.default = (0, _reactRedux.connect)(select, perform)(_view2.default);
},452,[22,62,453],"LBRYApp/src/component/filePrice/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/component/filePrice/view.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _lbryRedux = require(_dependencyMap[3], "lbry-redux");

  var CreditAmount = function (_React$PureComponent) {
    babelHelpers.inherits(CreditAmount, _React$PureComponent);

    function CreditAmount() {
      babelHelpers.classCallCheck(this, CreditAmount);
      return babelHelpers.possibleConstructorReturn(this, (CreditAmount.__proto__ || Object.getPrototypeOf(CreditAmount)).apply(this, arguments));
    }

    babelHelpers.createClass(CreditAmount, [{
      key: "render",
      value: function render() {
        var minimumRenderableAmount = Math.pow(10, -1 * this.props.precision);
        var _props = this.props,
            amount = _props.amount,
            precision = _props.precision,
            showFullPrice = _props.showFullPrice,
            style = _props.style;
        var formattedAmount = void 0;
        var fullPrice = (0, _lbryRedux.formatFullPrice)(amount, 2);

        if (showFullPrice) {
          formattedAmount = fullPrice;
        } else {
          formattedAmount = amount > 0 && amount < minimumRenderableAmount ? "<" + minimumRenderableAmount : (0, _lbryRedux.formatCredits)(amount, precision);
        }

        var amountText = void 0;

        if (this.props.showFree && parseFloat(this.props.amount) === 0) {
          amountText = 'FREE';
        } else {
          if (this.props.label) {
            var label = typeof this.props.label === 'string' ? this.props.label : parseFloat(amount) == 1 ? 'credit' : 'credits';
            amountText = formattedAmount + " " + label;
          } else {
            amountText = formattedAmount;
          }

          if (this.props.showPlus && amount > 0) {
            amountText = "+" + amountText;
          }
        }

        return _react2.default.createElement(
          _reactNative.Text,
          {
            style: style,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 71
            }
          },
          amountText
        );
      }
    }]);
    return CreditAmount;
  }(_react2.default.PureComponent);

  CreditAmount.propTypes = {
    amount: _propTypes2.default.number.isRequired,
    precision: _propTypes2.default.number,
    isEstimate: _propTypes2.default.bool,
    label: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.bool]),
    showFree: _propTypes2.default.bool,
    showFullPrice: _propTypes2.default.bool,
    showPlus: _propTypes2.default.bool,
    look: _propTypes2.default.oneOf(['indicator', 'plain', 'fee'])
  };
  CreditAmount.defaultProps = {
    precision: 2,
    label: true,
    showFree: false,
    look: 'indicator',
    showFullPrice: false,
    showPlus: false
  };

  var FilePrice = function (_React$PureComponent2) {
    babelHelpers.inherits(FilePrice, _React$PureComponent2);

    function FilePrice() {
      babelHelpers.classCallCheck(this, FilePrice);
      return babelHelpers.possibleConstructorReturn(this, (FilePrice.__proto__ || Object.getPrototypeOf(FilePrice)).apply(this, arguments));
    }

    babelHelpers.createClass(FilePrice, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.fetchCost(this.props);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        this.fetchCost(nextProps);
      }
    }, {
      key: "fetchCost",
      value: function fetchCost(props) {
        var costInfo = props.costInfo,
            fetchCostInfo = props.fetchCostInfo,
            uri = props.uri,
            fetching = props.fetching,
            claim = props.claim;

        if (costInfo === undefined && !fetching && claim) {
          fetchCostInfo(uri);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _props2 = this.props,
            costInfo = _props2.costInfo,
            _props2$look = _props2.look,
            look = _props2$look === undefined ? 'indicator' : _props2$look,
            _props2$showFullPrice = _props2.showFullPrice,
            showFullPrice = _props2$showFullPrice === undefined ? false : _props2$showFullPrice,
            style = _props2.style,
            textStyle = _props2.textStyle;
        var isEstimate = costInfo ? !costInfo.includesData : null;

        if (!costInfo) {
          return _react2.default.createElement(
            _reactNative.View,
            {
              style: style,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 100
              }
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: textStyle,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 101
                }
              },
              "???"
            )
          );
        }

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: style,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 107
            }
          },
          _react2.default.createElement(
            CreditAmount,
            {
              style: textStyle,
              label: false,
              amount: costInfo.cost,
              isEstimate: isEstimate,
              showFree: true,
              showFullPrice: showFullPrice,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 108
              }
            },
            "???"
          )
        );
      }
    }]);
    return FilePrice;
  }(_react2.default.PureComponent);

  exports.default = FilePrice;
},453,[12,24,66,62],"LBRYApp/src/component/filePrice/view.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var discoverStyle = _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center'
    },
    scrollContainer: {
      flex: 1
    },
    title: {
      fontFamily: 'Metropolis-Regular',
      fontSize: 20,
      textAlign: 'center',
      margin: 10
    },
    categoryName: {
      fontFamily: 'Metropolis-Regular',
      fontSize: 20,
      marginLeft: 24,
      marginTop: 16,
      marginBottom: 16,
      color: '#40b89a'
    },
    fileItem: {
      marginLeft: 24,
      marginRight: 24,
      marginBottom: 48
    },
    fileItemName: {
      fontFamily: 'Metropolis-Bold',
      marginTop: 8,
      fontSize: 16
    },
    channelName: {
      fontFamily: 'Metropolis-SemiBold',
      fontSize: 14,
      marginTop: 4,
      color: '#c0c0c0'
    },
    filePriceContainer: {
      backgroundColor: '#61fcd8',
      justifyContent: 'center',
      position: 'absolute',
      right: 16,
      top: 16,
      width: 56,
      height: 24,
      borderRadius: 4
    },
    filePriceText: {
      fontFamily: 'Metropolis-Bold',
      fontSize: 12,
      textAlign: 'center',
      color: '#0c604b'
    },
    drawerHamburger: {
      marginLeft: 8
    }
  });

  exports.default = discoverStyle;
},454,[66],"LBRYApp/src/styles/discover.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = undefined;

  var _createIconSet = require(_dependencyMap[0], "./lib/create-icon-set");

  var _createIconSet2 = babelHelpers.interopRequireDefault(_createIconSet);

  var _Feather = require(_dependencyMap[1], "./glyphmaps/Feather.json");

  var _Feather2 = babelHelpers.interopRequireDefault(_Feather);

  var iconSet = (0, _createIconSet2.default)(_Feather2.default, 'Feather', 'Feather.ttf');
  exports.default = iconSet;
  var Button = exports.Button = iconSet.Button;
  var TabBarItem = exports.TabBarItem = iconSet.TabBarItem;
  var TabBarItemIOS = exports.TabBarItemIOS = iconSet.TabBarItemIOS;
  var ToolbarAndroid = exports.ToolbarAndroid = iconSet.ToolbarAndroid;
  var getImageSource = exports.getImageSource = iconSet.getImageSource;
},455,[456,608],"react-native-vector-icons/Feather.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-vector-icons/lib/create-icon-set.js";
  exports.default = createIconSet;

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[2], "./react-native");

  var _iconButton = require(_dependencyMap[3], "./icon-button");

  var _iconButton2 = babelHelpers.interopRequireDefault(_iconButton);

  var _tabBarItemIos = require(_dependencyMap[4], "./tab-bar-item-ios");

  var _tabBarItemIos2 = babelHelpers.interopRequireDefault(_tabBarItemIos);

  var _toolbarAndroid = require(_dependencyMap[5], "./toolbar-android");

  var _toolbarAndroid2 = babelHelpers.interopRequireDefault(_toolbarAndroid);

  var NativeIconAPI = _reactNative.NativeModules.RNVectorIconsManager || _reactNative.NativeModules.RNVectorIconsModule;
  var DEFAULT_ICON_SIZE = 12;
  var DEFAULT_ICON_COLOR = 'black';

  function createIconSet(glyphMap, fontFamily, fontFile) {
    var fontReference = fontFamily;

    if (_reactNative.Platform.OS === 'android' && fontFile) {
      fontReference = fontFile.replace(/\.(otf|ttf)$/, '');
    }

    if (_reactNative.Platform.OS === 'windows' && fontFile) {
      fontReference = "Assets/" + fontFile + "#" + fontFamily;
    }

    var IconNamePropType = _propTypes2.default.oneOf(Object.keys(glyphMap));

    var Icon = function (_PureComponent) {
      babelHelpers.inherits(Icon, _PureComponent);

      function Icon() {
        var _ref;

        var _temp, _this, _ret;

        babelHelpers.classCallCheck(this, Icon);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = Icon.__proto__ || Object.getPrototypeOf(Icon)).call.apply(_ref, [this].concat(args))), _this), _this.root = null, _this.handleRef = function (ref) {
          _this.root = ref;
        }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
      }

      babelHelpers.createClass(Icon, [{
        key: "setNativeProps",
        value: function setNativeProps(nativeProps) {
          if (this.root) {
            this.root.setNativeProps(nativeProps);
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _props = this.props,
              name = _props.name,
              size = _props.size,
              color = _props.color,
              style = _props.style,
              props = babelHelpers.objectWithoutProperties(_props, ["name", "size", "color", "style"]);
          var glyph = name ? glyphMap[name] || '?' : '';

          if (typeof glyph === 'number') {
            glyph = String.fromCharCode(glyph);
          }

          var styleDefaults = {
            fontSize: size,
            color: color
          };
          var styleOverrides = {
            fontFamily: fontReference,
            fontWeight: 'normal',
            fontStyle: 'normal'
          };
          props.style = [styleDefaults, style, styleOverrides];
          props.ref = this.handleRef;
          return _react2.default.createElement(
            _reactNative.Text,
            babelHelpers.extends({}, props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 82
              }
            }),
            glyph,
            this.props.children
          );
        }
      }]);
      return Icon;
    }(_react.PureComponent);

    Icon.propTypes = {
      name: IconNamePropType,
      size: _propTypes2.default.number,
      color: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
      children: _propTypes2.default.node,
      style: _propTypes2.default.any
    };
    Icon.defaultProps = {
      size: DEFAULT_ICON_SIZE,
      allowFontScaling: false
    };
    var imageSourceCache = {};

    function ensureNativeModuleAvailable() {
      if (!NativeIconAPI) {
        if (_reactNative.Platform.OS === 'android') {
          throw new Error('RNVectorIconsModule not available, did you properly integrate the module? Try running `react-native link react-native-vector-icons` and recompiling.');
        }

        throw new Error('RNVectorIconsManager not available, did you add the library to your project and link with libRNVectorIcons.a? Try running `react-native link react-native-vector-icons` and recompiling.');
      }
    }

    function getImageSource(name) {
      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ICON_SIZE;
      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ICON_COLOR;
      ensureNativeModuleAvailable();
      var glyph = glyphMap[name] || '?';

      if (typeof glyph === 'number') {
        glyph = String.fromCharCode(glyph);
      }

      var processedColor = (0, _reactNative.processColor)(color);
      var cacheKey = glyph + ":" + size + ":" + processedColor;

      var scale = _reactNative.PixelRatio.get();

      return new Promise(function (resolve, reject) {
        var cached = imageSourceCache[cacheKey];

        if (typeof cached !== 'undefined') {
          if (!cached || cached instanceof Error) {
            reject(cached);
          } else {
            resolve({
              uri: cached,
              scale: scale
            });
          }
        } else {
          NativeIconAPI.getImageForFont(fontReference, glyph, size, processedColor, function (err, image) {
            var error = typeof err === 'string' ? new Error(err) : err;
            imageSourceCache[cacheKey] = image || error || false;

            if (!error && image) {
              resolve({
                uri: image,
                scale: scale
              });
            } else {
              reject(error);
            }
          });
        }
      });
    }

    function loadFont() {
      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : fontFile;

      if (_reactNative.Platform.OS === 'ios') {
        ensureNativeModuleAvailable();

        if (!file) {
          return Promise.reject(new Error('Unable to load font, because no file was specified. '));
        }

        return NativeIconAPI.loadFontWithFileName.apply(NativeIconAPI, babelHelpers.toConsumableArray(file.split('.')));
      }

      return Promise.resolve();
    }

    Icon.Button = (0, _iconButton2.default)(Icon);
    Icon.TabBarItem = (0, _tabBarItemIos2.default)(IconNamePropType, getImageSource);
    Icon.TabBarItemIOS = Icon.TabBarItem;
    Icon.ToolbarAndroid = (0, _toolbarAndroid2.default)(IconNamePropType, getImageSource);
    Icon.getImageSource = getImageSource;
    Icon.loadFont = loadFont;
    return Icon;
  }
},456,[12,24,457,458,593,607],"react-native-vector-icons/lib/create-icon-set.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  Object.keys(_reactNative).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _reactNative[key];
      }
    });
  });
},457,[66],"react-native-vector-icons/lib/react-native.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-vector-icons/lib/icon-button.js";
  exports.default = createIconButtonComponent;

  var _isString = require(_dependencyMap[0], "lodash/isString");

  var _isString2 = babelHelpers.interopRequireDefault(_isString);

  var _omit = require(_dependencyMap[1], "lodash/omit");

  var _omit2 = babelHelpers.interopRequireDefault(_omit);

  var _pick = require(_dependencyMap[2], "lodash/pick");

  var _pick2 = babelHelpers.interopRequireDefault(_pick);

  var _react = require(_dependencyMap[3], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = require(_dependencyMap[4], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[5], "./react-native");

  var styles = _reactNative.StyleSheet.create({
    container: {
      flexDirection: 'row',
      justifyContent: 'flex-start',
      alignItems: 'center',
      padding: 8
    },
    touchable: {
      overflow: 'hidden'
    },
    icon: {
      marginRight: 10
    },
    text: {
      fontWeight: '600',
      backgroundColor: 'transparent'
    }
  });

  var IOS7_BLUE = '#007AFF';

  function createIconButtonComponent(Icon) {
    var _class, _temp;

    return _temp = _class = function (_PureComponent) {
      babelHelpers.inherits(IconButton, _PureComponent);

      function IconButton() {
        babelHelpers.classCallCheck(this, IconButton);
        return babelHelpers.possibleConstructorReturn(this, (IconButton.__proto__ || Object.getPrototypeOf(IconButton)).apply(this, arguments));
      }

      babelHelpers.createClass(IconButton, [{
        key: "render",
        value: function render() {
          var _props = this.props,
              style = _props.style,
              iconStyle = _props.iconStyle,
              children = _props.children,
              restProps = babelHelpers.objectWithoutProperties(_props, ["style", "iconStyle", "children"]);
          var iconProps = (0, _pick2.default)(restProps, Object.keys(_reactNative.Text.propTypes), 'style', 'name', 'size', 'color');
          var touchableProps = (0, _pick2.default)(restProps, Object.keys(_reactNative.TouchableHighlight.propTypes));
          var props = (0, _omit2.default)(restProps, Object.keys(iconProps), Object.keys(touchableProps), 'iconStyle', 'borderRadius', 'backgroundColor');
          iconProps.style = iconStyle ? [styles.icon, iconStyle] : styles.icon;
          var colorStyle = (0, _pick2.default)(this.props, 'color');
          var blockStyle = (0, _pick2.default)(this.props, 'backgroundColor', 'borderRadius');
          return _react2.default.createElement(
            _reactNative.TouchableHighlight,
            babelHelpers.extends({
              style: [styles.touchable, blockStyle]
            }, touchableProps, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 80
              }
            }),
            _react2.default.createElement(
              _reactNative.View,
              babelHelpers.extends({
                style: [styles.container, blockStyle, style]
              }, props, {
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 84
                }
              }),
              _react2.default.createElement(Icon, babelHelpers.extends({}, iconProps, {
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 85
                }
              })),
              (0, _isString2.default)(children) ? _react2.default.createElement(
                _reactNative.Text,
                {
                  style: [styles.text, colorStyle],
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 87
                  }
                },
                children
              ) : children
            )
          );
        }
      }]);
      return IconButton;
    }(_react.PureComponent), _class.propTypes = {
      backgroundColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
      borderRadius: _propTypes2.default.number,
      color: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
      size: _propTypes2.default.number,
      iconStyle: _propTypes2.default.any,
      style: _propTypes2.default.any,
      children: _propTypes2.default.node
    }, _class.defaultProps = {
      backgroundColor: IOS7_BLUE,
      borderRadius: 5,
      color: 'white',
      size: 20
    }, _temp;
  }
},458,[459,461,586,12,24,457],"react-native-vector-icons/lib/icon-button.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var baseGetTag = require(_dependencyMap[0], './_baseGetTag'),
        isArray = require(_dependencyMap[1], './isArray'),
        isObjectLike = require(_dependencyMap[2], './isObjectLike');

    var stringTag = '[object String]';

    function isString(value) {
        return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }

    module.exports = isString;
},459,[39,460,47],"lodash/isString.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isArray = Array.isArray;
  module.exports = isArray;
},460,[],"lodash/isArray.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var arrayMap = require(_dependencyMap[0], './_arrayMap'),
      baseClone = require(_dependencyMap[1], './_baseClone'),
      baseUnset = require(_dependencyMap[2], './_baseUnset'),
      castPath = require(_dependencyMap[3], './_castPath'),
      copyObject = require(_dependencyMap[4], './_copyObject'),
      customOmitClone = require(_dependencyMap[5], './_customOmitClone'),
      flatRest = require(_dependencyMap[6], './_flatRest'),
      getAllKeysIn = require(_dependencyMap[7], './_getAllKeysIn');

  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;
  var omit = flatRest(function (object, paths) {
    var result = {};

    if (object == null) {
      return result;
    }

    var isDeep = false;
    paths = arrayMap(paths, function (path) {
      path = castPath(path, object);
      isDeep || (isDeep = path.length > 1);
      return path;
    });
    copyObject(object, getAllKeysIn(object), result);

    if (isDeep) {
      result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }

    var length = paths.length;

    while (length--) {
      baseUnset(result, paths[length]);
    }

    return result;
  });
  module.exports = omit;
},461,[462,463,560,561,507,574,575,540],"lodash/omit.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  module.exports = arrayMap;
},462,[],"lodash/_arrayMap.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var Stack = require(_dependencyMap[0], './_Stack'),
      arrayEach = require(_dependencyMap[1], './_arrayEach'),
      assignValue = require(_dependencyMap[2], './_assignValue'),
      baseAssign = require(_dependencyMap[3], './_baseAssign'),
      baseAssignIn = require(_dependencyMap[4], './_baseAssignIn'),
      cloneBuffer = require(_dependencyMap[5], './_cloneBuffer'),
      copyArray = require(_dependencyMap[6], './_copyArray'),
      copySymbols = require(_dependencyMap[7], './_copySymbols'),
      copySymbolsIn = require(_dependencyMap[8], './_copySymbolsIn'),
      getAllKeys = require(_dependencyMap[9], './_getAllKeys'),
      getAllKeysIn = require(_dependencyMap[10], './_getAllKeysIn'),
      getTag = require(_dependencyMap[11], './_getTag'),
      initCloneArray = require(_dependencyMap[12], './_initCloneArray'),
      initCloneByTag = require(_dependencyMap[13], './_initCloneByTag'),
      initCloneObject = require(_dependencyMap[14], './_initCloneObject'),
      isArray = require(_dependencyMap[15], './isArray'),
      isBuffer = require(_dependencyMap[16], './isBuffer'),
      isMap = require(_dependencyMap[17], './isMap'),
      isObject = require(_dependencyMap[18], './isObject'),
      isSet = require(_dependencyMap[19], './isSet'),
      keys = require(_dependencyMap[20], './keys');

  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;

  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }

    if (result !== undefined) {
      return result;
    }

    if (!isObject(value)) {
      return value;
    }

    var isArr = isArray(value);

    if (isArr) {
      result = initCloneArray(value);

      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }

      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);

        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }

        result = initCloneByTag(value, tag, isDeep);
      }
    }

    stack || (stack = new Stack());
    var stacked = stack.get(value);

    if (stacked) {
      return stacked;
    }

    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
      return result;
    }

    if (isMap(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }

      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  module.exports = baseClone;
},463,[464,502,503,506,525,529,530,531,535,538,540,541,546,547,554,460,513,556,482,558,508],"lodash/_baseClone.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var ListCache = require(_dependencyMap[0], './_ListCache'),
      stackClear = require(_dependencyMap[1], './_stackClear'),
      stackDelete = require(_dependencyMap[2], './_stackDelete'),
      stackGet = require(_dependencyMap[3], './_stackGet'),
      stackHas = require(_dependencyMap[4], './_stackHas'),
      stackSet = require(_dependencyMap[5], './_stackSet');

  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  module.exports = Stack;
},464,[465,473,474,475,476,477],"lodash/_Stack.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var listCacheClear = require(_dependencyMap[0], './_listCacheClear'),
        listCacheDelete = require(_dependencyMap[1], './_listCacheDelete'),
        listCacheGet = require(_dependencyMap[2], './_listCacheGet'),
        listCacheHas = require(_dependencyMap[3], './_listCacheHas'),
        listCacheSet = require(_dependencyMap[4], './_listCacheSet');

    function ListCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;
        this.clear();

        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }

    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
},465,[466,467,470,471,472],"lodash/_ListCache.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  module.exports = listCacheClear;
},466,[],"lodash/_listCacheClear.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var assocIndexOf = require(_dependencyMap[0], './_assocIndexOf');

  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;

  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  module.exports = listCacheDelete;
},467,[468],"lodash/_listCacheDelete.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var eq = require(_dependencyMap[0], './eq');

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  module.exports = assocIndexOf;
},468,[469],"lodash/_assocIndexOf.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  module.exports = eq;
},469,[],"lodash/eq.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var assocIndexOf = require(_dependencyMap[0], './_assocIndexOf');

  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  module.exports = listCacheGet;
},470,[468],"lodash/_listCacheGet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var assocIndexOf = require(_dependencyMap[0], './_assocIndexOf');

  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  module.exports = listCacheHas;
},471,[468],"lodash/_listCacheHas.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var assocIndexOf = require(_dependencyMap[0], './_assocIndexOf');

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  module.exports = listCacheSet;
},472,[468],"lodash/_listCacheSet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var ListCache = require(_dependencyMap[0], './_ListCache');

  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }

  module.exports = stackClear;
},473,[465],"lodash/_stackClear.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  module.exports = stackDelete;
},474,[],"lodash/_stackDelete.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function stackGet(key) {
    return this.__data__.get(key);
  }

  module.exports = stackGet;
},475,[],"lodash/_stackGet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function stackHas(key) {
    return this.__data__.has(key);
  }

  module.exports = stackHas;
},476,[],"lodash/_stackHas.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var ListCache = require(_dependencyMap[0], './_ListCache'),
      Map = require(_dependencyMap[1], './_Map'),
      MapCache = require(_dependencyMap[2], './_MapCache');

  var LARGE_ARRAY_SIZE = 200;

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof ListCache) {
      var pairs = data.__data__;

      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  module.exports = stackSet;
},477,[465,478,487],"lodash/_stackSet.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var getNative = require(_dependencyMap[0], './_getNative'),
        root = require(_dependencyMap[1], './_root');

    var Map = getNative(root, 'Map');
    module.exports = Map;
},478,[479,41],"lodash/_Map.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseIsNative = require(_dependencyMap[0], './_baseIsNative'),
      getValue = require(_dependencyMap[1], './_getValue');

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  module.exports = getNative;
},479,[480,486],"lodash/_getNative.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isFunction = require(_dependencyMap[0], './isFunction'),
      isMasked = require(_dependencyMap[1], './_isMasked'),
      isObject = require(_dependencyMap[2], './isObject'),
      toSource = require(_dependencyMap[3], './_toSource');

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype,
      objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  module.exports = baseIsNative;
},480,[481,483,482,485],"lodash/_baseIsNative.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var baseGetTag = require(_dependencyMap[0], './_baseGetTag'),
        isObject = require(_dependencyMap[1], './isObject');

    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    function isFunction(value) {
        if (!isObject(value)) {
            return false;
        }

        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    module.exports = isFunction;
},481,[39,482],"lodash/isFunction.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  module.exports = isObject;
},482,[],"lodash/isObject.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var coreJsData = require(_dependencyMap[0], './_coreJsData');

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  module.exports = isMasked;
},483,[484],"lodash/_isMasked.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var root = require(_dependencyMap[0], './_root');

  var coreJsData = root['__core-js_shared__'];
  module.exports = coreJsData;
},484,[41],"lodash/_coreJsData.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  module.exports = toSource;
},485,[],"lodash/_toSource.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  module.exports = getValue;
},486,[],"lodash/_getValue.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var mapCacheClear = require(_dependencyMap[0], './_mapCacheClear'),
        mapCacheDelete = require(_dependencyMap[1], './_mapCacheDelete'),
        mapCacheGet = require(_dependencyMap[2], './_mapCacheGet'),
        mapCacheHas = require(_dependencyMap[3], './_mapCacheHas'),
        mapCacheSet = require(_dependencyMap[4], './_mapCacheSet');

    function MapCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;
        this.clear();

        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }

    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
},487,[488,496,499,500,501],"lodash/_MapCache.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var Hash = require(_dependencyMap[0], './_Hash'),
      ListCache = require(_dependencyMap[1], './_ListCache'),
      Map = require(_dependencyMap[2], './_Map');

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }

  module.exports = mapCacheClear;
},488,[489,465,478],"lodash/_mapCacheClear.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var hashClear = require(_dependencyMap[0], './_hashClear'),
        hashDelete = require(_dependencyMap[1], './_hashDelete'),
        hashGet = require(_dependencyMap[2], './_hashGet'),
        hashHas = require(_dependencyMap[3], './_hashHas'),
        hashSet = require(_dependencyMap[4], './_hashSet');

    function Hash(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;
        this.clear();

        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }

    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
},489,[490,492,493,494,495],"lodash/_Hash.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var nativeCreate = require(_dependencyMap[0], './_nativeCreate');

  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  module.exports = hashClear;
},490,[491],"lodash/_hashClear.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getNative = require(_dependencyMap[0], './_getNative');

  var nativeCreate = getNative(Object, 'create');
  module.exports = nativeCreate;
},491,[479],"lodash/_nativeCreate.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  module.exports = hashDelete;
},492,[],"lodash/_hashDelete.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var nativeCreate = require(_dependencyMap[0], './_nativeCreate');

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  module.exports = hashGet;
},493,[491],"lodash/_hashGet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var nativeCreate = require(_dependencyMap[0], './_nativeCreate');

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  module.exports = hashHas;
},494,[491],"lodash/_hashHas.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var nativeCreate = require(_dependencyMap[0], './_nativeCreate');

  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  module.exports = hashSet;
},495,[491],"lodash/_hashSet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getMapData = require(_dependencyMap[0], './_getMapData');

  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  module.exports = mapCacheDelete;
},496,[497],"lodash/_mapCacheDelete.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isKeyable = require(_dependencyMap[0], './_isKeyable');

  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  module.exports = getMapData;
},497,[498],"lodash/_getMapData.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  module.exports = isKeyable;
},498,[],"lodash/_isKeyable.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getMapData = require(_dependencyMap[0], './_getMapData');

  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  module.exports = mapCacheGet;
},499,[497],"lodash/_mapCacheGet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getMapData = require(_dependencyMap[0], './_getMapData');

  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  module.exports = mapCacheHas;
},500,[497],"lodash/_mapCacheHas.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getMapData = require(_dependencyMap[0], './_getMapData');

  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  module.exports = mapCacheSet;
},501,[497],"lodash/_mapCacheSet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  module.exports = arrayEach;
},502,[],"lodash/_arrayEach.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseAssignValue = require(_dependencyMap[0], './_baseAssignValue'),
      eq = require(_dependencyMap[1], './eq');

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }

  module.exports = assignValue;
},503,[504,469],"lodash/_assignValue.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var defineProperty = require(_dependencyMap[0], './_defineProperty');

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  module.exports = baseAssignValue;
},504,[505],"lodash/_baseAssignValue.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getNative = require(_dependencyMap[0], './_getNative');

  var defineProperty = function () {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  module.exports = defineProperty;
},505,[479],"lodash/_defineProperty.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var copyObject = require(_dependencyMap[0], './_copyObject'),
      keys = require(_dependencyMap[1], './keys');

  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  module.exports = baseAssign;
},506,[507,508],"lodash/_baseAssign.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var assignValue = require(_dependencyMap[0], './_assignValue'),
      baseAssignValue = require(_dependencyMap[1], './_baseAssignValue');

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }

    return object;
  }

  module.exports = copyObject;
},507,[503,504],"lodash/_copyObject.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var arrayLikeKeys = require(_dependencyMap[0], './_arrayLikeKeys'),
      baseKeys = require(_dependencyMap[1], './_baseKeys'),
      isArrayLike = require(_dependencyMap[2], './isArrayLike');

  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  module.exports = keys;
},508,[509,521,524],"lodash/keys.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseTimes = require(_dependencyMap[0], './_baseTimes'),
      isArguments = require(_dependencyMap[1], './isArguments'),
      isArray = require(_dependencyMap[2], './isArray'),
      isBuffer = require(_dependencyMap[3], './isBuffer'),
      isIndex = require(_dependencyMap[4], './_isIndex'),
      isTypedArray = require(_dependencyMap[5], './isTypedArray');

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = arrayLikeKeys;
},509,[510,511,460,513,515,516],"lodash/_arrayLikeKeys.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  module.exports = baseTimes;
},510,[],"lodash/_baseTimes.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var baseIsArguments = require(_dependencyMap[0], './_baseIsArguments'),
        isObjectLike = require(_dependencyMap[1], './isObjectLike');

    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function () {
        return arguments;
    }()) ? baseIsArguments : function (value) {
        return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };
    module.exports = isArguments;
},511,[512,47],"lodash/isArguments.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseGetTag = require(_dependencyMap[0], './_baseGetTag'),
      isObjectLike = require(_dependencyMap[1], './isObjectLike');

  var argsTag = '[object Arguments]';

  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  module.exports = baseIsArguments;
},512,[39,47],"lodash/_baseIsArguments.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var root = require(_dependencyMap[0], './_root'),
      stubFalse = require(_dependencyMap[1], './stubFalse');

  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root.Buffer : undefined;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
},513,[41,514],"lodash/isBuffer.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function stubFalse() {
    return false;
  }

  module.exports = stubFalse;
},514,[],"lodash/stubFalse.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  module.exports = isIndex;
},515,[],"lodash/_isIndex.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseIsTypedArray = require(_dependencyMap[0], './_baseIsTypedArray'),
      baseUnary = require(_dependencyMap[1], './_baseUnary'),
      nodeUtil = require(_dependencyMap[2], './_nodeUtil');

  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module.exports = isTypedArray;
},516,[517,519,520],"lodash/isTypedArray.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var baseGetTag = require(_dependencyMap[0], './_baseGetTag'),
        isLength = require(_dependencyMap[1], './isLength'),
        isObjectLike = require(_dependencyMap[2], './isObjectLike');

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

    function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    module.exports = baseIsTypedArray;
},517,[39,518,47],"lodash/_baseIsTypedArray.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  module.exports = isLength;
},518,[],"lodash/isLength.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  module.exports = baseUnary;
},519,[],"lodash/_baseUnary.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var freeGlobal = require(_dependencyMap[0], './_freeGlobal');

  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;

  var nodeUtil = function () {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  module.exports = nodeUtil;
},520,[42],"lodash/_nodeUtil.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isPrototype = require(_dependencyMap[0], './_isPrototype'),
      nativeKeys = require(_dependencyMap[1], './_nativeKeys');

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = baseKeys;
},521,[522,523],"lodash/_baseKeys.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }

  module.exports = isPrototype;
},522,[],"lodash/_isPrototype.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var overArg = require(_dependencyMap[0], './_overArg');

  var nativeKeys = overArg(Object.keys, Object);
  module.exports = nativeKeys;
},523,[46],"lodash/_nativeKeys.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isFunction = require(_dependencyMap[0], './isFunction'),
      isLength = require(_dependencyMap[1], './isLength');

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  module.exports = isArrayLike;
},524,[481,518],"lodash/isArrayLike.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var copyObject = require(_dependencyMap[0], './_copyObject'),
      keysIn = require(_dependencyMap[1], './keysIn');

  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }

  module.exports = baseAssignIn;
},525,[507,526],"lodash/_baseAssignIn.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var arrayLikeKeys = require(_dependencyMap[0], './_arrayLikeKeys'),
      baseKeysIn = require(_dependencyMap[1], './_baseKeysIn'),
      isArrayLike = require(_dependencyMap[2], './isArrayLike');

  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  module.exports = keysIn;
},526,[509,527,524],"lodash/keysIn.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isObject = require(_dependencyMap[0], './isObject'),
      isPrototype = require(_dependencyMap[1], './_isPrototype'),
      nativeKeysIn = require(_dependencyMap[2], './_nativeKeysIn');

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = baseKeysIn;
},527,[482,522,528],"lodash/_baseKeysIn.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = nativeKeysIn;
},528,[],"lodash/_nativeKeysIn.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var root = require(_dependencyMap[0], './_root');

  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  module.exports = cloneBuffer;
},529,[41],"lodash/_cloneBuffer.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  module.exports = copyArray;
},530,[],"lodash/_copyArray.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var copyObject = require(_dependencyMap[0], './_copyObject'),
      getSymbols = require(_dependencyMap[1], './_getSymbols');

  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  module.exports = copySymbols;
},531,[507,532],"lodash/_copySymbols.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var arrayFilter = require(_dependencyMap[0], './_arrayFilter'),
      stubArray = require(_dependencyMap[1], './stubArray');

  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  module.exports = getSymbols;
},532,[533,534],"lodash/_getSymbols.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  module.exports = arrayFilter;
},533,[],"lodash/_arrayFilter.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function stubArray() {
    return [];
  }

  module.exports = stubArray;
},534,[],"lodash/stubArray.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var copyObject = require(_dependencyMap[0], './_copyObject'),
      getSymbolsIn = require(_dependencyMap[1], './_getSymbolsIn');

  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  module.exports = copySymbolsIn;
},535,[507,536],"lodash/_copySymbolsIn.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var arrayPush = require(_dependencyMap[0], './_arrayPush'),
      getPrototype = require(_dependencyMap[1], './_getPrototype'),
      getSymbols = require(_dependencyMap[2], './_getSymbols'),
      stubArray = require(_dependencyMap[3], './stubArray');

  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];

    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }

    return result;
  };
  module.exports = getSymbolsIn;
},536,[537,45,532,534],"lodash/_getSymbolsIn.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  module.exports = arrayPush;
},537,[],"lodash/_arrayPush.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseGetAllKeys = require(_dependencyMap[0], './_baseGetAllKeys'),
      getSymbols = require(_dependencyMap[1], './_getSymbols'),
      keys = require(_dependencyMap[2], './keys');

  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  module.exports = getAllKeys;
},538,[539,532,508],"lodash/_getAllKeys.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var arrayPush = require(_dependencyMap[0], './_arrayPush'),
      isArray = require(_dependencyMap[1], './isArray');

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  module.exports = baseGetAllKeys;
},539,[537,460],"lodash/_baseGetAllKeys.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseGetAllKeys = require(_dependencyMap[0], './_baseGetAllKeys'),
      getSymbolsIn = require(_dependencyMap[1], './_getSymbolsIn'),
      keysIn = require(_dependencyMap[2], './keysIn');

  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  module.exports = getAllKeysIn;
},540,[539,536,526],"lodash/_getAllKeysIn.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var DataView = require(_dependencyMap[0], './_DataView'),
        Map = require(_dependencyMap[1], './_Map'),
        Promise = require(_dependencyMap[2], './_Promise'),
        Set = require(_dependencyMap[3], './_Set'),
        WeakMap = require(_dependencyMap[4], './_WeakMap'),
        baseGetTag = require(_dependencyMap[5], './_baseGetTag'),
        toSource = require(_dependencyMap[6], './_toSource');

    var mapTag = '[object Map]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        setTag = '[object Set]',
        weakMapTag = '[object WeakMap]';
    var dataViewTag = '[object DataView]';
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);
    var getTag = baseGetTag;

    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function getTag(value) {
            var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined,
                ctorString = Ctor ? toSource(Ctor) : '';

            if (ctorString) {
                switch (ctorString) {
                    case dataViewCtorString:
                        return dataViewTag;

                    case mapCtorString:
                        return mapTag;

                    case promiseCtorString:
                        return promiseTag;

                    case setCtorString:
                        return setTag;

                    case weakMapCtorString:
                        return weakMapTag;
                }
            }

            return result;
        };
    }

    module.exports = getTag;
},541,[542,478,543,544,545,39,485],"lodash/_getTag.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var getNative = require(_dependencyMap[0], './_getNative'),
        root = require(_dependencyMap[1], './_root');

    var DataView = getNative(root, 'DataView');
    module.exports = DataView;
},542,[479,41],"lodash/_DataView.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var getNative = require(_dependencyMap[0], './_getNative'),
        root = require(_dependencyMap[1], './_root');

    var Promise = getNative(root, 'Promise');
    module.exports = Promise;
},543,[479,41],"lodash/_Promise.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var getNative = require(_dependencyMap[0], './_getNative'),
        root = require(_dependencyMap[1], './_root');

    var Set = getNative(root, 'Set');
    module.exports = Set;
},544,[479,41],"lodash/_Set.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var getNative = require(_dependencyMap[0], './_getNative'),
        root = require(_dependencyMap[1], './_root');

    var WeakMap = getNative(root, 'WeakMap');
    module.exports = WeakMap;
},545,[479,41],"lodash/_WeakMap.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }

    return result;
  }

  module.exports = initCloneArray;
},546,[],"lodash/_initCloneArray.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var cloneArrayBuffer = require(_dependencyMap[0], './_cloneArrayBuffer'),
      cloneDataView = require(_dependencyMap[1], './_cloneDataView'),
      cloneRegExp = require(_dependencyMap[2], './_cloneRegExp'),
      cloneSymbol = require(_dependencyMap[3], './_cloneSymbol'),
      cloneTypedArray = require(_dependencyMap[4], './_cloneTypedArray');

  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;

    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return new Ctor();

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return new Ctor();

      case symbolTag:
        return cloneSymbol(object);
    }
  }

  module.exports = initCloneByTag;
},547,[548,550,551,552,553],"lodash/_initCloneByTag.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var Uint8Array = require(_dependencyMap[0], './_Uint8Array');

  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  module.exports = cloneArrayBuffer;
},548,[549],"lodash/_cloneArrayBuffer.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var root = require(_dependencyMap[0], './_root');

  var Uint8Array = root.Uint8Array;
  module.exports = Uint8Array;
},549,[41],"lodash/_Uint8Array.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var cloneArrayBuffer = require(_dependencyMap[0], './_cloneArrayBuffer');

  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  module.exports = cloneDataView;
},550,[548],"lodash/_cloneDataView.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var reFlags = /\w*$/;

  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  module.exports = cloneRegExp;
},551,[],"lodash/_cloneRegExp.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var Symbol = require(_dependencyMap[0], './_Symbol');

  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  module.exports = cloneSymbol;
},552,[40],"lodash/_cloneSymbol.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var cloneArrayBuffer = require(_dependencyMap[0], './_cloneArrayBuffer');

  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  module.exports = cloneTypedArray;
},553,[548],"lodash/_cloneTypedArray.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var baseCreate = require(_dependencyMap[0], './_baseCreate'),
        getPrototype = require(_dependencyMap[1], './_getPrototype'),
        isPrototype = require(_dependencyMap[2], './_isPrototype');

    function initCloneObject(object) {
        return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }

    module.exports = initCloneObject;
},554,[555,45,522],"lodash/_initCloneObject.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isObject = require(_dependencyMap[0], './isObject');

  var objectCreate = Object.create;

  var baseCreate = function () {
    function object() {}

    return function (proto) {
      if (!isObject(proto)) {
        return {};
      }

      if (objectCreate) {
        return objectCreate(proto);
      }

      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();

  module.exports = baseCreate;
},555,[482],"lodash/_baseCreate.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseIsMap = require(_dependencyMap[0], './_baseIsMap'),
      baseUnary = require(_dependencyMap[1], './_baseUnary'),
      nodeUtil = require(_dependencyMap[2], './_nodeUtil');

  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  module.exports = isMap;
},556,[557,519,520],"lodash/isMap.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getTag = require(_dependencyMap[0], './_getTag'),
      isObjectLike = require(_dependencyMap[1], './isObjectLike');

  var mapTag = '[object Map]';

  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }

  module.exports = baseIsMap;
},557,[541,47],"lodash/_baseIsMap.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseIsSet = require(_dependencyMap[0], './_baseIsSet'),
      baseUnary = require(_dependencyMap[1], './_baseUnary'),
      nodeUtil = require(_dependencyMap[2], './_nodeUtil');

  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  module.exports = isSet;
},558,[559,519,520],"lodash/isSet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getTag = require(_dependencyMap[0], './_getTag'),
      isObjectLike = require(_dependencyMap[1], './isObjectLike');

  var setTag = '[object Set]';

  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }

  module.exports = baseIsSet;
},559,[541,47],"lodash/_baseIsSet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var castPath = require(_dependencyMap[0], './_castPath'),
      last = require(_dependencyMap[1], './last'),
      parent = require(_dependencyMap[2], './_parent'),
      toKey = require(_dependencyMap[3], './_toKey');

  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last(path))];
  }

  module.exports = baseUnset;
},560,[561,569,570,572],"lodash/_baseUnset.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isArray = require(_dependencyMap[0], './isArray'),
      isKey = require(_dependencyMap[1], './_isKey'),
      stringToPath = require(_dependencyMap[2], './_stringToPath'),
      toString = require(_dependencyMap[3], './toString');

  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }

    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  module.exports = castPath;
},561,[460,562,564,567],"lodash/_castPath.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isArray = require(_dependencyMap[0], './isArray'),
      isSymbol = require(_dependencyMap[1], './isSymbol');

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }

    var type = typeof value;

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  module.exports = isKey;
},562,[460,563],"lodash/_isKey.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var baseGetTag = require(_dependencyMap[0], './_baseGetTag'),
        isObjectLike = require(_dependencyMap[1], './isObjectLike');

    var symbolTag = '[object Symbol]';

    function isSymbol(value) {
        return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }

    module.exports = isSymbol;
},563,[39,47],"lodash/isSymbol.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var memoizeCapped = require(_dependencyMap[0], './_memoizeCapped');

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });
  module.exports = stringToPath;
},564,[565],"lodash/_stringToPath.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var memoize = require(_dependencyMap[0], './memoize');

  var MAX_MEMOIZE_SIZE = 500;

  function memoizeCapped(func) {
    var result = memoize(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  module.exports = memoizeCapped;
},565,[566],"lodash/_memoizeCapped.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var MapCache = require(_dependencyMap[0], './_MapCache');

  var FUNC_ERROR_TEXT = 'Expected a function';

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  memoize.Cache = MapCache;
  module.exports = memoize;
},566,[487],"lodash/memoize.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseToString = require(_dependencyMap[0], './_baseToString');

  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  module.exports = toString;
},567,[568],"lodash/toString.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var Symbol = require(_dependencyMap[0], './_Symbol'),
      arrayMap = require(_dependencyMap[1], './_arrayMap'),
      isArray = require(_dependencyMap[2], './isArray'),
      isSymbol = require(_dependencyMap[3], './isSymbol');

  var INFINITY = 1 / 0;
  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isArray(value)) {
      return arrayMap(value, baseToString) + '';
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  module.exports = baseToString;
},568,[40,462,460,563],"lodash/_baseToString.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }

  module.exports = last;
},569,[],"lodash/last.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseGet = require(_dependencyMap[0], './_baseGet'),
      baseSlice = require(_dependencyMap[1], './_baseSlice');

  function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }

  module.exports = parent;
},570,[571,573],"lodash/_parent.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var castPath = require(_dependencyMap[0], './_castPath'),
      toKey = require(_dependencyMap[1], './_toKey');

  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  module.exports = baseGet;
},571,[561,572],"lodash/_baseGet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isSymbol = require(_dependencyMap[0], './isSymbol');

  var INFINITY = 1 / 0;

  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  module.exports = toKey;
},572,[563],"lodash/_toKey.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  module.exports = baseSlice;
},573,[],"lodash/_baseSlice.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var isPlainObject = require(_dependencyMap[0], './isPlainObject');

  function customOmitClone(value) {
    return isPlainObject(value) ? undefined : value;
  }

  module.exports = customOmitClone;
},574,[38],"lodash/_customOmitClone.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var flatten = require(_dependencyMap[0], './flatten'),
      overRest = require(_dependencyMap[1], './_overRest'),
      setToString = require(_dependencyMap[2], './_setToString');

  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
  }

  module.exports = flatRest;
},575,[576,579,581],"lodash/_flatRest.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseFlatten = require(_dependencyMap[0], './_baseFlatten');

  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }

  module.exports = flatten;
},576,[577],"lodash/flatten.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var arrayPush = require(_dependencyMap[0], './_arrayPush'),
      isFlattenable = require(_dependencyMap[1], './_isFlattenable');

  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }

  module.exports = baseFlatten;
},577,[537,578],"lodash/_baseFlatten.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var Symbol = require(_dependencyMap[0], './_Symbol'),
        isArguments = require(_dependencyMap[1], './isArguments'),
        isArray = require(_dependencyMap[2], './isArray');

    var spreadableSymbol = Symbol ? typeof Symbol === "function" ? Symbol.isConcatSpreadable : "@@isConcatSpreadable" : undefined;

    function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    module.exports = isFlattenable;
},578,[40,511,460],"lodash/_isFlattenable.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var apply = require(_dependencyMap[0], './_apply');

  var nativeMax = Math.max;

  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  module.exports = overRest;
},579,[580],"lodash/_overRest.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }

  module.exports = apply;
},580,[],"lodash/_apply.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseSetToString = require(_dependencyMap[0], './_baseSetToString'),
      shortOut = require(_dependencyMap[1], './_shortOut');

  var setToString = shortOut(baseSetToString);
  module.exports = setToString;
},581,[582,585],"lodash/_setToString.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var constant = require(_dependencyMap[0], './constant'),
      defineProperty = require(_dependencyMap[1], './_defineProperty'),
      identity = require(_dependencyMap[2], './identity');

  var baseSetToString = !defineProperty ? identity : function (func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };
  module.exports = baseSetToString;
},582,[583,505,584],"lodash/_baseSetToString.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function constant(value) {
    return function () {
      return value;
    };
  }

  module.exports = constant;
},583,[],"lodash/constant.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function identity(value) {
    return value;
  }

  module.exports = identity;
},584,[],"lodash/identity.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  var nativeNow = Date.now;

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }

  module.exports = shortOut;
},585,[],"lodash/_shortOut.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var basePick = require(_dependencyMap[0], './_basePick'),
      flatRest = require(_dependencyMap[1], './_flatRest');

  var pick = flatRest(function (object, paths) {
    return object == null ? {} : basePick(object, paths);
  });
  module.exports = pick;
},586,[587,575],"lodash/pick.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var basePickBy = require(_dependencyMap[0], './_basePickBy'),
      hasIn = require(_dependencyMap[1], './hasIn');

  function basePick(object, paths) {
    return basePickBy(object, paths, function (value, path) {
      return hasIn(object, path);
    });
  }

  module.exports = basePick;
},587,[588,590],"lodash/_basePick.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var baseGet = require(_dependencyMap[0], './_baseGet'),
        baseSet = require(_dependencyMap[1], './_baseSet'),
        castPath = require(_dependencyMap[2], './_castPath');

    function basePickBy(object, paths, predicate) {
        var index = -1,
            length = paths.length,
            result = {};

        while (++index < length) {
            var path = paths[index],
                value = baseGet(object, path);

            if (predicate(value, path)) {
                baseSet(result, castPath(path, object), value);
            }
        }

        return result;
    }

    module.exports = basePickBy;
},588,[571,589,561],"lodash/_basePickBy.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var assignValue = require(_dependencyMap[0], './_assignValue'),
      castPath = require(_dependencyMap[1], './_castPath'),
      isIndex = require(_dependencyMap[2], './_isIndex'),
      isObject = require(_dependencyMap[3], './isObject'),
      toKey = require(_dependencyMap[4], './_toKey');

  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }

    path = castPath(path, object);
    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;

        if (newValue === undefined) {
          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
      }

      assignValue(nested, key, newValue);
      nested = nested[key];
    }

    return object;
  }

  module.exports = baseSet;
},589,[503,561,515,482,572],"lodash/_baseSet.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseHasIn = require(_dependencyMap[0], './_baseHasIn'),
      hasPath = require(_dependencyMap[1], './_hasPath');

  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  module.exports = hasIn;
},590,[591,592],"lodash/hasIn.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  module.exports = baseHasIn;
},591,[],"lodash/_baseHasIn.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var castPath = require(_dependencyMap[0], './_castPath'),
      isArguments = require(_dependencyMap[1], './isArguments'),
      isArray = require(_dependencyMap[2], './isArray'),
      isIndex = require(_dependencyMap[3], './_isIndex'),
      isLength = require(_dependencyMap[4], './isLength'),
      toKey = require(_dependencyMap[5], './_toKey');

  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }

  module.exports = hasPath;
},592,[561,511,460,515,518,572],"lodash/_hasPath.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-vector-icons/lib/tab-bar-item-ios.js";
  exports.default = createTabBarItemIOSComponent;

  var _isEqual = require(_dependencyMap[0], "lodash/isEqual");

  var _isEqual2 = babelHelpers.interopRequireDefault(_isEqual);

  var _pick = require(_dependencyMap[1], "lodash/pick");

  var _pick2 = babelHelpers.interopRequireDefault(_pick);

  var _react = require(_dependencyMap[2], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = require(_dependencyMap[3], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[4], "./react-native");

  function createTabBarItemIOSComponent(IconNamePropType, getImageSource) {
    var _class, _temp;

    return _temp = _class = function (_PureComponent) {
      babelHelpers.inherits(TabBarItemIOS, _PureComponent);

      function TabBarItemIOS() {
        babelHelpers.classCallCheck(this, TabBarItemIOS);
        return babelHelpers.possibleConstructorReturn(this, (TabBarItemIOS.__proto__ || Object.getPrototypeOf(TabBarItemIOS)).apply(this, arguments));
      }

      babelHelpers.createClass(TabBarItemIOS, [{
        key: "componentWillMount",
        value: function componentWillMount() {
          this.updateIconSources(this.props);
        }
      }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(nextProps) {
          var keys = Object.keys(TabBarItemIOS.propTypes);

          if (!(0, _isEqual2.default)((0, _pick2.default)(nextProps, keys), (0, _pick2.default)(this.props, keys))) {
            this.updateIconSources(nextProps);
          }
        }
      }, {
        key: "updateIconSources",
        value: function updateIconSources(props) {
          var _this2 = this;

          if (props.iconName) {
            getImageSource(props.iconName, props.iconSize, props.iconColor).then(function (icon) {
              return _this2.setState({
                icon: icon
              });
            });
          }

          if (props.selectedIconName || props.selectedIconColor) {
            var selectedIconName = props.selectedIconName || props.iconName;
            var selectedIconColor = props.selectedIconColor || props.iconColor;
            getImageSource(selectedIconName, props.iconSize, selectedIconColor).then(function (selectedIcon) {
              return _this2.setState({
                selectedIcon: selectedIcon
              });
            });
          }
        }
      }, {
        key: "render",
        value: function render() {
          return _react2.default.createElement(_reactNative.TabBarIOS.Item, babelHelpers.extends({}, this.props, this.state, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 59
            }
          }));
        }
      }]);
      return TabBarItemIOS;
    }(_react.PureComponent), _class.propTypes = {
      iconName: IconNamePropType.isRequired,
      selectedIconName: IconNamePropType,
      iconSize: _propTypes2.default.number,
      iconColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
      selectedIconColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])
    }, _class.defaultProps = {
      iconSize: 30
    }, _temp;
  }
},593,[594,586,12,24,457],"react-native-vector-icons/lib/tab-bar-item-ios.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseIsEqual = require(_dependencyMap[0], './_baseIsEqual');

  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }

  module.exports = isEqual;
},594,[595],"lodash/isEqual.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var baseIsEqualDeep = require(_dependencyMap[0], './_baseIsEqualDeep'),
      isObjectLike = require(_dependencyMap[1], './isObjectLike');

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }

    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  module.exports = baseIsEqual;
},595,[596,47],"lodash/_baseIsEqual.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var Stack = require(_dependencyMap[0], './_Stack'),
      equalArrays = require(_dependencyMap[1], './_equalArrays'),
      equalByTag = require(_dependencyMap[2], './_equalByTag'),
      equalObjects = require(_dependencyMap[3], './_equalObjects'),
      getTag = require(_dependencyMap[4], './_getTag'),
      isArray = require(_dependencyMap[5], './isArray'),
      isBuffer = require(_dependencyMap[6], './isBuffer'),
      isTypedArray = require(_dependencyMap[7], './isTypedArray');

  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag(object),
        othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  module.exports = baseIsEqualDeep;
},596,[464,597,603,606,541,460,513,516],"lodash/_baseIsEqualDeep.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var SetCache = require(_dependencyMap[0], './_SetCache'),
      arraySome = require(_dependencyMap[1], './_arraySome'),
      cacheHas = require(_dependencyMap[2], './_cacheHas');

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }

    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      }

      if (seen) {
        if (!arraySome(other, function (othValue, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  module.exports = equalArrays;
},597,[598,601,602],"lodash/_equalArrays.js");
__d(function (global, require, module, exports, _dependencyMap) {
    var MapCache = require(_dependencyMap[0], './_MapCache'),
        setCacheAdd = require(_dependencyMap[1], './_setCacheAdd'),
        setCacheHas = require(_dependencyMap[2], './_setCacheHas');

    function SetCache(values) {
        var index = -1,
            length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();

        while (++index < length) {
            this.add(values[index]);
        }
    }

    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
},598,[487,599,600],"lodash/_SetCache.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);

    return this;
  }

  module.exports = setCacheAdd;
},599,[],"lodash/_setCacheAdd.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  module.exports = setCacheHas;
},600,[],"lodash/_setCacheHas.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  module.exports = arraySome;
},601,[],"lodash/_arraySome.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  module.exports = cacheHas;
},602,[],"lodash/_cacheHas.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var Symbol = require(_dependencyMap[0], './_Symbol'),
      Uint8Array = require(_dependencyMap[1], './_Uint8Array'),
      eq = require(_dependencyMap[2], './eq'),
      equalArrays = require(_dependencyMap[3], './_equalArrays'),
      mapToArray = require(_dependencyMap[4], './_mapToArray'),
      setToArray = require(_dependencyMap[5], './_setToArray');

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]';
  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        return object == other + '';

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }

        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  module.exports = equalByTag;
},603,[40,549,469,597,604,605],"lodash/_equalByTag.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  module.exports = mapToArray;
},604,[],"lodash/_mapToArray.js");
__d(function (global, require, module, exports, _dependencyMap) {
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  module.exports = setToArray;
},605,[],"lodash/_setToArray.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var getAllKeys = require(_dependencyMap[0], './_getAllKeys');

  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }

    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }

      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  module.exports = equalObjects;
},606,[538],"lodash/_equalObjects.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-vector-icons/lib/toolbar-android.js";
  exports.default = createToolbarAndroidComponent;

  var _isEqual = require(_dependencyMap[0], "lodash/isEqual");

  var _isEqual2 = babelHelpers.interopRequireDefault(_isEqual);

  var _pick = require(_dependencyMap[1], "lodash/pick");

  var _pick2 = babelHelpers.interopRequireDefault(_pick);

  var _react = require(_dependencyMap[2], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = require(_dependencyMap[3], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[4], "./react-native");

  function createToolbarAndroidComponent(IconNamePropType, getImageSource) {
    var _class, _temp;

    return _temp = _class = function (_PureComponent) {
      babelHelpers.inherits(IconToolbarAndroid, _PureComponent);

      function IconToolbarAndroid() {
        babelHelpers.classCallCheck(this, IconToolbarAndroid);
        return babelHelpers.possibleConstructorReturn(this, (IconToolbarAndroid.__proto__ || Object.getPrototypeOf(IconToolbarAndroid)).apply(this, arguments));
      }

      babelHelpers.createClass(IconToolbarAndroid, [{
        key: "componentWillMount",
        value: function componentWillMount() {
          this.updateIconSources(this.props);
        }
      }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(nextProps) {
          var _this2 = this;

          var keys = Object.keys(IconToolbarAndroid.propTypes);

          if (!(0, _isEqual2.default)((0, _pick2.default)(nextProps, keys), (0, _pick2.default)(this.props, keys))) {
            var stateToEvict = {};

            if (!nextProps.logoName) {
              stateToEvict.logo = undefined;
            }

            if (!nextProps.navIconName) {
              stateToEvict.navIcon = undefined;
            }

            if (!nextProps.overflowIconName) {
              stateToEvict.overflowIcon = undefined;
            }

            if (this.state && Object.keys(stateToEvict).length) {
              this.setState(stateToEvict, function () {
                return _this2.updateIconSources(nextProps);
              });
            } else {
              this.updateIconSources(nextProps);
            }
          }
        }
      }, {
        key: "updateIconSources",
        value: function updateIconSources(props) {
          var _this3 = this;

          var size = props.iconSize;
          var color = props.iconColor || props.titleColor;

          if (props.logoName) {
            getImageSource(props.logoName, size, color).then(function (logo) {
              return _this3.setState({
                logo: logo
              });
            });
          }

          if (props.navIconName) {
            getImageSource(props.navIconName, size, color).then(function (navIcon) {
              return _this3.setState({
                navIcon: navIcon
              });
            });
          }

          if (props.overflowIconName) {
            getImageSource(props.overflowIconName, size, color).then(function (overflowIcon) {
              return _this3.setState({
                overflowIcon: overflowIcon
              });
            });
          }

          Promise.all((props.actions || []).map(function (action) {
            if (action.iconName) {
              return getImageSource(action.iconName, action.iconSize || size, action.iconColor || color).then(function (icon) {
                return babelHelpers.extends({}, action, {
                  icon: icon
                });
              });
            }

            return Promise.resolve(action);
          })).then(function (actions) {
            return _this3.setState({
              actions: actions
            });
          });
        }
      }, {
        key: "render",
        value: function render() {
          return _react2.default.createElement(_reactNative.ToolbarAndroid, babelHelpers.extends({}, this.props, this.state, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 94
            }
          }));
        }
      }]);
      return IconToolbarAndroid;
    }(_react.PureComponent), _class.propTypes = {
      logoName: IconNamePropType,
      navIconName: IconNamePropType,
      overflowIconName: IconNamePropType,
      actions: _propTypes2.default.arrayOf(_propTypes2.default.shape({
        title: _propTypes2.default.string.isRequired,
        iconName: IconNamePropType,
        iconSize: _propTypes2.default.number,
        iconColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
        show: _propTypes2.default.oneOf(['always', 'ifRoom', 'never']),
        showWithText: _propTypes2.default.bool
      })),
      iconSize: _propTypes2.default.number,
      iconColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])
    }, _class.defaultProps = {
      iconSize: 24
    }, _temp;
  }
},607,[594,586,12,24,457],"react-native-vector-icons/lib/toolbar-android.js");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = {
    "activity": 59648,
    "airplay": 59649,
    "alert-circle": 59650,
    "alert-octagon": 59651,
    "alert-triangle": 59652,
    "align-center": 59653,
    "align-justify": 59654,
    "align-left": 59655,
    "align-right": 59656,
    "anchor": 59657,
    "aperture": 59658,
    "arrow-down": 59659,
    "arrow-down-left": 59660,
    "arrow-down-right": 59661,
    "arrow-left": 59662,
    "arrow-right": 59663,
    "arrow-up": 59664,
    "arrow-up-left": 59665,
    "arrow-up-right": 59666,
    "at-sign": 59667,
    "award": 59668,
    "bar-chart": 59669,
    "bar-chart-2": 59670,
    "battery": 59671,
    "battery-charging": 59672,
    "bell": 59673,
    "bell-off": 59674,
    "bluetooth": 59675,
    "bold": 59676,
    "book": 59677,
    "bookmark": 59678,
    "box": 59679,
    "briefcase": 59680,
    "calendar": 59681,
    "camera": 59682,
    "camera-off": 59683,
    "cast": 59684,
    "check": 59685,
    "check-circle": 59686,
    "check-square": 59687,
    "chevron-down": 59688,
    "chevron-left": 59689,
    "chevron-right": 59690,
    "chevron-up": 59691,
    "chevrons-down": 59692,
    "chevrons-left": 59693,
    "chevrons-right": 59694,
    "chevrons-up": 59695,
    "chrome": 59696,
    "circle": 59697,
    "clipboard": 59698,
    "clock": 59699,
    "cloud": 59700,
    "cloud-drizzle": 59701,
    "cloud-lightning": 59702,
    "cloud-off": 59703,
    "cloud-rain": 59704,
    "cloud-snow": 59705,
    "codepen": 59706,
    "command": 59707,
    "compass": 59708,
    "copy": 59709,
    "corner-down-left": 59710,
    "corner-down-right": 59711,
    "corner-left-down": 59712,
    "corner-left-up": 59713,
    "corner-right-down": 59714,
    "corner-right-up": 59715,
    "corner-up-left": 59716,
    "corner-up-right": 59717,
    "cpu": 59718,
    "credit-card": 59719,
    "crop": 59720,
    "crosshair": 59721,
    "delete": 59722,
    "disc": 59723,
    "download": 59724,
    "download-cloud": 59725,
    "droplet": 59726,
    "edit": 59727,
    "edit-2": 59728,
    "edit-3": 59729,
    "external-link": 59730,
    "eye": 59731,
    "eye-off": 59732,
    "facebook": 59733,
    "fast-forward": 59734,
    "feather": 59735,
    "file": 59736,
    "file-minus": 59737,
    "file-plus": 59738,
    "file-text": 59739,
    "film": 59740,
    "filter": 59741,
    "flag": 59742,
    "folder": 59743,
    "github": 59744,
    "gitlab": 59745,
    "globe": 59746,
    "grid": 59747,
    "hash": 59748,
    "headphones": 59749,
    "heart": 59750,
    "help-circle": 59751,
    "home": 59752,
    "image": 59753,
    "inbox": 59754,
    "info": 59755,
    "instagram": 59756,
    "italic": 59757,
    "layers": 59758,
    "layout": 59759,
    "life-buoy": 59760,
    "link": 59761,
    "link-2": 59762,
    "list": 59763,
    "loader": 59764,
    "lock": 59765,
    "log-in": 59766,
    "log-out": 59767,
    "mail": 59768,
    "map": 59769,
    "map-pin": 59770,
    "maximize": 59771,
    "maximize-2": 59772,
    "menu": 59773,
    "message-circle": 59774,
    "message-square": 59775,
    "mic": 59776,
    "mic-off": 59777,
    "minimize": 59778,
    "minimize-2": 59779,
    "minus": 59780,
    "minus-circle": 59781,
    "minus-square": 59782,
    "monitor": 59783,
    "moon": 59784,
    "more-horizontal": 59785,
    "more-vertical": 59786,
    "move": 59787,
    "music": 59788,
    "navigation": 59789,
    "navigation-2": 59790,
    "octagon": 59791,
    "package": 59792,
    "paperclip": 59793,
    "pause": 59794,
    "pause-circle": 59795,
    "percent": 59796,
    "phone": 59797,
    "phone-call": 59798,
    "phone-forwarded": 59799,
    "phone-incoming": 59800,
    "phone-missed": 59801,
    "phone-off": 59802,
    "phone-outgoing": 59803,
    "pie-chart": 59804,
    "play": 59805,
    "play-circle": 59806,
    "plus": 59807,
    "plus-circle": 59808,
    "plus-square": 59809,
    "pocket": 59810,
    "power": 59811,
    "printer": 59812,
    "radio": 59813,
    "refresh-ccw": 59814,
    "refresh-cw": 59815,
    "repeat": 59816,
    "rewind": 59817,
    "rotate-ccw": 59818,
    "rotate-cw": 59819,
    "save": 59820,
    "scissors": 59821,
    "search": 59822,
    "server": 59823,
    "settings": 59824,
    "share": 59825,
    "share-2": 59826,
    "shield": 59827,
    "shopping-cart": 59828,
    "shuffle": 59829,
    "sidebar": 59830,
    "skip-back": 59831,
    "skip-forward": 59832,
    "slack": 59833,
    "slash": 59834,
    "sliders": 59835,
    "smartphone": 59836,
    "speaker": 59837,
    "square": 59838,
    "star": 59839,
    "stop-circle": 59840,
    "sun": 59841,
    "sunrise": 59842,
    "sunset": 59843,
    "tablet": 59844,
    "tag": 59845,
    "target": 59846,
    "thermometer": 59847,
    "thumbs-down": 59848,
    "thumbs-up": 59849,
    "toggle-left": 59850,
    "toggle-right": 59851,
    "trash": 59852,
    "trash-2": 59853,
    "trending-down": 59854,
    "trending-up": 59855,
    "triangle": 59856,
    "tv": 59857,
    "twitter": 59858,
    "type": 59859,
    "umbrella": 59860,
    "underline": 59861,
    "unlock": 59862,
    "upload": 59863,
    "upload-cloud": 59864,
    "user": 59865,
    "user-check": 59866,
    "user-minus": 59867,
    "user-plus": 59868,
    "user-x": 59869,
    "users": 59870,
    "video": 59871,
    "video-off": 59872,
    "voicemail": 59873,
    "volume": 59874,
    "volume-1": 59875,
    "volume-2": 59876,
    "volume-x": 59877,
    "watch": 59878,
    "wifi": 59879,
    "wifi-off": 59880,
    "wind": 59881,
    "x": 59882,
    "x-circle": 59883,
    "x-square": 59884,
    "zap": 59885,
    "zoom-in": 59886,
    "zoom-out": 59887
  };
},608,[],"react-native-vector-icons/glyphmaps/Feather.json");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AppNavigator = undefined;
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/component/AppNavigator.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _discover = require(_dependencyMap[1], "../page/discover");

  var _discover2 = babelHelpers.interopRequireDefault(_discover);

  var _file = require(_dependencyMap[2], "../page/file");

  var _file2 = babelHelpers.interopRequireDefault(_file);

  var _splash = require(_dependencyMap[3], "../page/splash");

  var _splash2 = babelHelpers.interopRequireDefault(_splash);

  var _reactNavigation = require(_dependencyMap[4], "react-navigation");

  var _reactRedux = require(_dependencyMap[5], "react-redux");

  var _redux = require(_dependencyMap[6], "../utils/redux");

  var _reactNative = require(_dependencyMap[7], "react-native");

  var _Feather = require(_dependencyMap[8], "react-native-vector-icons/Feather");

  var _Feather2 = babelHelpers.interopRequireDefault(_Feather);

  var _discover3 = require(_dependencyMap[9], "../styles/discover");

  var _discover4 = babelHelpers.interopRequireDefault(_discover3);

  var discoverStack = (0, _reactNavigation.StackNavigator)({
    Discover: {
      screen: _discover2.default,
      navigationOptions: function navigationOptions(_ref) {
        var navigation = _ref.navigation;
        return {
          title: 'Discover',
          headerLeft: _react2.default.createElement(_Feather2.default, {
            name: "menu",
            size: 24,
            style: _discover4.default.drawerHamburger,
            onPress: function onPress() {
              return navigation.navigate('DrawerOpen');
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 17
            }
          })
        };
      }
    },
    File: {
      screen: _file2.default,
      navigationOptions: {
        header: null,
        drawerLockMode: 'locked-closed'
      }
    }
  }, {
    headerMode: 'screen'
  });
  var drawer = (0, _reactNavigation.DrawerNavigator)({
    Discover: {
      screen: discoverStack
    }
  }, {
    drawerWidth: 300,
    headerMode: 'none'
  });
  var AppNavigator = exports.AppNavigator = new _reactNavigation.StackNavigator({
    Splash: {
      screen: _splash2.default
    },
    Main: {
      screen: drawer
    }
  }, {
    headerMode: 'none'
  });

  var AppWithNavigationState = function (_React$Component) {
    babelHelpers.inherits(AppWithNavigationState, _React$Component);

    function AppWithNavigationState() {
      babelHelpers.classCallCheck(this, AppWithNavigationState);
      return babelHelpers.possibleConstructorReturn(this, (AppWithNavigationState.__proto__ || Object.getPrototypeOf(AppWithNavigationState)).apply(this, arguments));
    }

    babelHelpers.createClass(AppWithNavigationState, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        _reactNative.BackHandler.addEventListener('hardwareBackPress', function () {
          var _props = this.props,
              dispatch = _props.dispatch,
              navigation = _props.navigation,
              nav = _props.nav;

          if (nav.routes.length === 2 && nav.routes[1].routeName === 'Main') {
            if (nav.routes[1].routes[0].routes[0].index > 0) {
              dispatch({
                type: 'Navigation/BACK'
              });
              return true;
            }
          }

          return false;
        }.bind(this));
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _reactNative.BackHandler.removeEventListener('hardwareBackPress');
      }
    }, {
      key: "render",
      value: function render() {
        var _props2 = this.props,
            dispatch = _props2.dispatch,
            nav = _props2.nav;
        return _react2.default.createElement(AppNavigator, {
          navigation: (0, _reactNavigation.addNavigationHelpers)({
            dispatch: dispatch,
            state: nav,
            addListener: _redux.addListener
          }),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 70
          }
        });
      }
    }]);
    return AppWithNavigationState;
  }(_react2.default.Component);

  var mapStateToProps = function mapStateToProps(state) {
    return {
      nav: state.nav
    };
  };

  exports.default = (0, _reactRedux.connect)(mapStateToProps)(AppWithNavigationState);
},609,[12,61,610,625,376,22,628,66,455,454],"LBRYApp/src/component/AppNavigator.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactRedux = require(_dependencyMap[0], "react-redux");

  var _lbryRedux = require(_dependencyMap[1], "lbry-redux");

  var _view = require(_dependencyMap[2], "./view");

  var _view2 = babelHelpers.interopRequireDefault(_view);

  var select = function select(state, props) {
    var selectProps = {
      uri: props.navigation.state.params.uri
    };
    return {
      claim: (0, _lbryRedux.makeSelectClaimForUri)(selectProps.uri)(state),
      contentType: (0, _lbryRedux.makeSelectContentTypeForUri)(selectProps.uri)(state),
      costInfo: (0, _lbryRedux.makeSelectCostInfoForUri)(selectProps.uri)(state),
      metadata: (0, _lbryRedux.makeSelectMetadataForUri)(selectProps.uri)(state),
      fileInfo: (0, _lbryRedux.makeSelectFileInfoForUri)(selectProps.uri)(state),
      rewardedContentClaimIds: (0, _lbryRedux.selectRewardContentClaimIds)(state, selectProps)
    };
  };

  var perform = function perform(dispatch) {
    return {
      fetchFileInfo: function fetchFileInfo(uri) {
        return dispatch((0, _lbryRedux.doFetchFileInfo)(uri));
      },
      fetchCostInfo: function fetchCostInfo(uri) {
        return dispatch((0, _lbryRedux.doFetchCostInfoForUri)(uri));
      }
    };
  };

  exports.default = (0, _reactRedux.connect)(select, perform)(_view2.default);
},610,[22,62,611],"LBRYApp/src/page/file/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/page/file/view.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _lbryRedux = require(_dependencyMap[1], "lbry-redux");

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _fileItemMedia = require(_dependencyMap[3], "../../component/fileItemMedia");

  var _fileItemMedia2 = babelHelpers.interopRequireDefault(_fileItemMedia);

  var _fileDownloadButton = require(_dependencyMap[4], "../../component/fileDownloadButton");

  var _fileDownloadButton2 = babelHelpers.interopRequireDefault(_fileDownloadButton);

  var _mediaPlayer = require(_dependencyMap[5], "../../component/mediaPlayer");

  var _mediaPlayer2 = babelHelpers.interopRequireDefault(_mediaPlayer);

  var _reactNativeVideo = require(_dependencyMap[6], "react-native-video");

  var _reactNativeVideo2 = babelHelpers.interopRequireDefault(_reactNativeVideo);

  var _filePage = require(_dependencyMap[7], "../../styles/filePage");

  var _filePage2 = babelHelpers.interopRequireDefault(_filePage);

  var FilePage = function (_React$PureComponent) {
    babelHelpers.inherits(FilePage, _React$PureComponent);

    function FilePage() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, FilePage);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = FilePage.__proto__ || Object.getPrototypeOf(FilePage)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        mediaLoaded: false,
        fullscreenMode: false
      }, _this.handleFullscreenToggle = function (mode) {
        _this.setState({
          fullscreenMode: mode
        });

        _reactNative.StatusBar.setHidden(mode);

        if (_reactNative.NativeModules.ScreenOrientation) {
          if (mode) {
            _reactNative.NativeModules.ScreenOrientation.lockOrientationLandscape();
          } else {
            _reactNative.NativeModules.ScreenOrientation.unlockOrientation();
          }
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(FilePage, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        _reactNative.StatusBar.setHidden(false);

        this.fetchFileInfo(this.props);
        this.fetchCostInfo(this.props);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        this.fetchFileInfo(nextProps);
      }
    }, {
      key: "fetchFileInfo",
      value: function fetchFileInfo(props) {
        if (props.fileInfo === undefined) {
          props.fetchFileInfo(props.navigation.state.params.uri);
        }
      }
    }, {
      key: "fetchCostInfo",
      value: function fetchCostInfo(props) {
        if (props.costInfo === undefined) {
          props.fetchCostInfo(props.navigation.state.params.uri);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _reactNative.StatusBar.setHidden(false);

        if (_reactNative.NativeModules.ScreenOrientation) {
          _reactNative.NativeModules.ScreenOrientation.unlockOrientation();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            claim = _props.claim,
            fileInfo = _props.fileInfo,
            metadata = _props.metadata,
            contentType = _props.contentType,
            tab = _props.tab,
            rewardedContentClaimIds = _props.rewardedContentClaimIds,
            navigation = _props.navigation;

        if (!claim || !metadata) {
          return _react2.default.createElement(
            _reactNative.View,
            {
              style: _filePage2.default.container,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 75
              }
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: _filePage2.default.emptyClaimText,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 76
                }
              },
              "Empty claim or metadata info."
            )
          );
        }

        var completed = fileInfo && fileInfo.completed;
        var title = metadata.title;
        var isRewardContent = rewardedContentClaimIds.includes(claim.claim_id);
        var description = metadata.description ? metadata.description : null;

        var mediaType = _lbryRedux.Lbry.getMediaType(contentType);

        var isPlayable = mediaType === 'video' || mediaType === 'audio';
        var height = claim.height,
            channelName = claim.channel_name,
            value = claim.value;
        var channelClaimId = value && value.publisherSignature && value.publisherSignature.certificateId;
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: _filePage2.default.pageContainer,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 92
            }
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: this.state.fullscreenMode ? _filePage2.default.fullscreenMedia : _filePage2.default.mediaContainer,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 93
              }
            },
            (!fileInfo || isPlayable && !this.state.mediaLoaded) && _react2.default.createElement(_fileItemMedia2.default, {
              style: _filePage2.default.thumbnail,
              title: title,
              thumbnail: metadata.thumbnail,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 95
              }
            }),
            !completed && _react2.default.createElement(_fileDownloadButton2.default, {
              uri: navigation.state.params.uri,
              style: _filePage2.default.downloadButton,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 96
              }
            }),
            fileInfo && isPlayable && _react2.default.createElement(_mediaPlayer2.default, {
              fileInfo: fileInfo,
              style: _filePage2.default.player,
              onFullscreenToggled: this.handleFullscreenToggle,
              onMediaLoaded: function onMediaLoaded() {
                _this2.setState({
                  mediaLoaded: true
                });
              },
              __source: {
                fileName: _jsxFileName,
                lineNumber: 97
              }
            })
          ),
          _react2.default.createElement(
            _reactNative.ScrollView,
            {
              style: _filePage2.default.scrollContainer,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 102
              }
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: _filePage2.default.title,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 103
                }
              },
              title
            ),
            channelName && _react2.default.createElement(
              _reactNative.Text,
              {
                style: _filePage2.default.channelName,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 104
                }
              },
              channelName
            ),
            description && _react2.default.createElement(
              _reactNative.Text,
              {
                style: _filePage2.default.description,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 105
                }
              },
              description
            )
          )
        );
      }
    }]);
    return FilePage;
  }(_react2.default.PureComponent);

  FilePage.navigationOptions = {
    title: ''
  };
  exports.default = FilePage;
},611,[12,62,66,449,612,616,618,624],"LBRYApp/src/page/file/view.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactRedux = require(_dependencyMap[0], "react-redux");

  var _lbryRedux = require(_dependencyMap[1], "lbry-redux");

  var _file = require(_dependencyMap[2], "../../redux/actions/file");

  var _view = require(_dependencyMap[3], "./view");

  var _view2 = babelHelpers.interopRequireDefault(_view);

  var select = function select(state, props) {
    return {
      fileInfo: (0, _lbryRedux.makeSelectFileInfoForUri)(props.uri)(state),
      downloading: (0, _lbryRedux.makeSelectDownloadingForUri)(props.uri)(state),
      costInfo: (0, _lbryRedux.makeSelectCostInfoForUri)(props.uri)(state),
      loading: (0, _lbryRedux.makeSelectLoadingForUri)(props.uri)(state)
    };
  };

  var perform = function perform(dispatch) {
    return {
      purchaseUri: function purchaseUri(uri) {
        return dispatch((0, _file.doPurchaseUri)(uri));
      },
      restartDownload: function restartDownload(uri, outpoint) {
        return dispatch((0, _file.doStartDownload)(uri, outpoint));
      }
    };
  };

  exports.default = (0, _reactRedux.connect)(select, perform)(_view2.default);
},612,[22,62,613,614],"LBRYApp/src/component/fileDownloadButton/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.doUpdateLoadStatus = doUpdateLoadStatus;
  exports.doStartDownload = doStartDownload;
  exports.doDownloadFile = doDownloadFile;
  exports.doSetPlayingUri = doSetPlayingUri;
  exports.doLoadVideo = doLoadVideo;
  exports.doPurchaseUri = doPurchaseUri;

  var _lbryRedux = require(_dependencyMap[0], "lbry-redux");

  var _reactNative = require(_dependencyMap[1], "react-native");

  var DOWNLOAD_POLL_INTERVAL = 250;

  function doUpdateLoadStatus(uri, outpoint) {
    return function (dispatch, getState) {
      _lbryRedux.Lbry.file_list({
        outpoint: outpoint,
        full_status: true
      }).then(function (_ref) {
        var _ref2 = babelHelpers.slicedToArray(_ref, 1),
            fileInfo = _ref2[0];

        if (!fileInfo || fileInfo.written_bytes === 0) {
          setTimeout(function () {
            dispatch(doUpdateLoadStatus(uri, outpoint));
          }, DOWNLOAD_POLL_INTERVAL);
        } else if (fileInfo.completed) {
          var totalBytes = fileInfo.total_bytes,
              writtenBytes = fileInfo.written_bytes;
          dispatch({
            type: _lbryRedux.ACTIONS.DOWNLOADING_COMPLETED,
            data: {
              uri: uri,
              outpoint: outpoint,
              fileInfo: fileInfo
            }
          });

          _reactNative.NativeModules.LbryDownloadManager.updateDownload(uri, fileInfo.file_name, 100, writtenBytes, totalBytes);
        } else {
          var _totalBytes = fileInfo.total_bytes,
              _writtenBytes = fileInfo.written_bytes;
          var progress = _writtenBytes / _totalBytes * 100;
          dispatch({
            type: _lbryRedux.ACTIONS.DOWNLOADING_PROGRESSED,
            data: {
              uri: uri,
              outpoint: outpoint,
              fileInfo: fileInfo,
              progress: progress
            }
          });

          _reactNative.NativeModules.LbryDownloadManager.updateDownload(uri, fileInfo.file_name, progress, _writtenBytes, _totalBytes);

          setTimeout(function () {
            dispatch(doUpdateLoadStatus(uri, outpoint));
          }, DOWNLOAD_POLL_INTERVAL);
        }
      });
    };
  }

  function doStartDownload(uri, outpoint) {
    return function (dispatch, getState) {
      var state = getState();

      if (!outpoint) {
        throw new Error('outpoint is required to begin a download');
      }

      var _state$fileInfo$downl = state.fileInfo.downloadingByOutpoint,
          downloadingByOutpoint = _state$fileInfo$downl === undefined ? {} : _state$fileInfo$downl;
      if (downloadingByOutpoint[outpoint]) return;

      _lbryRedux.Lbry.file_list({
        outpoint: outpoint,
        full_status: true
      }).then(function (_ref3) {
        var _ref4 = babelHelpers.slicedToArray(_ref3, 1),
            fileInfo = _ref4[0];

        dispatch({
          type: _lbryRedux.ACTIONS.DOWNLOADING_STARTED,
          data: {
            uri: uri,
            outpoint: outpoint,
            fileInfo: fileInfo
          }
        });

        _reactNative.NativeModules.LbryDownloadManager.startDownload(uri, fileInfo.file_name);

        dispatch(doUpdateLoadStatus(uri, outpoint));
      });
    };
  }

  function doDownloadFile(uri, streamInfo) {
    return function (dispatch) {
      dispatch(doStartDownload(uri, streamInfo.outpoint));
    };
  }

  function doSetPlayingUri(uri) {
    return function (dispatch) {
      dispatch({
        type: _lbryRedux.ACTIONS.SET_PLAYING_URI,
        data: {
          uri: uri
        }
      });
    };
  }

  function doLoadVideo(uri) {
    return function (dispatch) {
      dispatch({
        type: _lbryRedux.ACTIONS.LOADING_VIDEO_STARTED,
        data: {
          uri: uri
        }
      });

      _lbryRedux.Lbry.get({
        uri: uri
      }).then(function (streamInfo) {
        var timeout = streamInfo === null || typeof streamInfo !== 'object' || streamInfo.error === 'Timeout';

        if (timeout) {
          dispatch(doSetPlayingUri(null));
          dispatch({
            type: _lbryRedux.ACTIONS.LOADING_VIDEO_FAILED,
            data: {
              uri: uri
            }
          });
          console.log("File timeout for uri " + uri);
        } else {
          dispatch(doDownloadFile(uri, streamInfo));
        }
      }).catch(function () {
        dispatch(doSetPlayingUri(null));
        dispatch({
          type: _lbryRedux.ACTIONS.LOADING_VIDEO_FAILED,
          data: {
            uri: uri
          }
        });
        console.log("Failed to download " + uri);
      });
    };
  }

  function doPurchaseUri(uri, specificCostInfo) {
    return function (dispatch, getState) {
      var state = getState();
      var balance = 0;
      var fileInfo = (0, _lbryRedux.makeSelectFileInfoForUri)(uri)(state);
      var downloadingByOutpoint = (0, _lbryRedux.selectDownloadingByOutpoint)(state);
      var alreadyDownloading = fileInfo && !!downloadingByOutpoint[fileInfo.outpoint];

      function attemptPlay(cost) {
        var instantPurchaseMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (cost > 0 && (!instantPurchaseMax || cost > instantPurchaseMax)) {
          console.log('Affirm purchase...');
        } else {
          dispatch(doLoadVideo(uri));
        }
      }

      if (fileInfo && fileInfo.completed) {
        if (!fileInfo.written_bytes) dispatch(doLoadVideo(uri));
        Promise.resolve();
        return;
      }

      if (alreadyDownloading) {
        Promise.resolve();
        return;
      }

      var costInfo = (0, _lbryRedux.makeSelectCostInfoForUri)(uri)(state) || specificCostInfo;
      var cost = costInfo.cost;

      if (cost > balance) {
        dispatch(doSetPlayingUri(null));
        Promise.resolve();
        return;
      }

      if (cost === 0) {
          attemptPlay(cost);
        }
    };
  }
},613,[62,66],"LBRYApp/src/redux/actions/file.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/component/fileDownloadButton/view.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = require(_dependencyMap[1], "react-native");

  var _fileDownloadButton = require(_dependencyMap[2], "../../styles/fileDownloadButton");

  var _fileDownloadButton2 = babelHelpers.interopRequireDefault(_fileDownloadButton);

  var FileDownloadButton = function (_React$PureComponent) {
    babelHelpers.inherits(FileDownloadButton, _React$PureComponent);

    function FileDownloadButton() {
      babelHelpers.classCallCheck(this, FileDownloadButton);
      return babelHelpers.possibleConstructorReturn(this, (FileDownloadButton.__proto__ || Object.getPrototypeOf(FileDownloadButton)).apply(this, arguments));
    }

    babelHelpers.createClass(FileDownloadButton, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        this.restartDownload(nextProps);
      }
    }, {
      key: "restartDownload",
      value: function restartDownload(props) {
        var downloading = props.downloading,
            fileInfo = props.fileInfo,
            uri = props.uri,
            restartDownload = props.restartDownload;

        if (!downloading && fileInfo && !fileInfo.completed && fileInfo.written_bytes !== false && fileInfo.written_bytes < fileInfo.total_bytes) {
          restartDownload(uri, fileInfo.outpoint);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            fileInfo = _props.fileInfo,
            downloading = _props.downloading,
            uri = _props.uri,
            purchaseUri = _props.purchaseUri,
            costInfo = _props.costInfo,
            loading = _props.loading,
            doPause = _props.doPause,
            style = _props.style;

        var openFile = function openFile() {};

        if (loading || downloading) {
          var progress = fileInfo && fileInfo.written_bytes ? fileInfo.written_bytes / fileInfo.total_bytes * 100 : 0,
              label = fileInfo ? progress.toFixed(0) + '% complete' : 'Connecting...';
          return _react2.default.createElement(
            _reactNative.View,
            {
              style: [style, _fileDownloadButton2.default.container],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 48
              }
            },
            _react2.default.createElement(_reactNative.View, {
              style: {
                width: progress + "%",
                backgroundColor: '#ff0000',
                position: 'absolute',
                left: 0,
                top: 0
              },
              __source: {
                fileName: _jsxFileName,
                lineNumber: 49
              }
            }),
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: _fileDownloadButton2.default.text,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 50
                }
              },
              label
            )
          );
        } else if (fileInfo === null && !downloading) {
          if (!costInfo) {
            return _react2.default.createElement(
              _reactNative.View,
              {
                style: [style, _fileDownloadButton2.default.container],
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 56
                }
              },
              _react2.default.createElement(
                _reactNative.Text,
                {
                  __source: {
                    fileName: _jsxFileName,
                    lineNumber: 57
                  }
                },
                "Fetching cost info..."
              )
            );
          }

          return _react2.default.createElement(
            _reactNative.TouchableOpacity,
            {
              style: [style, _fileDownloadButton2.default.container],
              onPress: function onPress() {
                purchaseUri(uri);
              },
              __source: {
                fileName: _jsxFileName,
                lineNumber: 62
              }
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: _fileDownloadButton2.default.text,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 65
                }
              },
              "Download"
            )
          );
        } else if (fileInfo && fileInfo.download_path) {
          return _react2.default.createElement(
            _reactNative.TouchableOpacity,
            {
              style: [style, _fileDownloadButton2.default.container],
              onPress: function onPress() {
                return openFile();
              },
              __source: {
                fileName: _jsxFileName,
                lineNumber: 70
              }
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: _fileDownloadButton2.default.text,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 71
                }
              },
              "Open"
            )
          );
        }

        return null;
      }
    }]);
    return FileDownloadButton;
  }(_react2.default.PureComponent);

  exports.default = FileDownloadButton;
},614,[12,66,615],"LBRYApp/src/component/fileDownloadButton/view.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var fileDownloadButtonStyle = _reactNative.StyleSheet.create({
    container: {
      width: 120,
      height: 36,
      borderRadius: 18,
      justifyContent: 'center',
      backgroundColor: '#40c0a9'
    },
    text: {
      fontFamily: 'Metropolis-Medium',
      color: '#ffffff',
      fontSize: 14,
      textAlign: 'center'
    }
  });

  exports.default = fileDownloadButtonStyle;
},615,[66],"LBRYApp/src/styles/fileDownloadButton.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactRedux = require(_dependencyMap[0], "react-redux");

  var _view = require(_dependencyMap[1], "./view");

  var _view2 = babelHelpers.interopRequireDefault(_view);

  var select = function select(state) {
    return {};
  };

  var perform = function perform(dispatch) {
    return {};
  };

  exports.default = (0, _reactRedux.connect)(select, perform)(_view2.default);
},616,[22,617],"LBRYApp/src/component/mediaPlayer/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/component/mediaPlayer/view.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _lbryRedux = require(_dependencyMap[1], "lbry-redux");

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _reactNativeVideo = require(_dependencyMap[3], "react-native-video");

  var _reactNativeVideo2 = babelHelpers.interopRequireDefault(_reactNativeVideo);

  var _FontAwesome = require(_dependencyMap[4], "react-native-vector-icons/FontAwesome");

  var _FontAwesome2 = babelHelpers.interopRequireDefault(_FontAwesome);

  var _fileItemMedia = require(_dependencyMap[5], "../fileItemMedia");

  var _fileItemMedia2 = babelHelpers.interopRequireDefault(_fileItemMedia);

  var _mediaPlayer = require(_dependencyMap[6], "../../styles/mediaPlayer");

  var _mediaPlayer2 = babelHelpers.interopRequireDefault(_mediaPlayer);

  var MediaPlayer = function (_React$PureComponent) {
    babelHelpers.inherits(MediaPlayer, _React$PureComponent);

    function MediaPlayer() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, MediaPlayer);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = MediaPlayer.__proto__ || Object.getPrototypeOf(MediaPlayer)).call.apply(_ref, [this].concat(args))), _this), _this.seekResponder = null, _this.seekerWidth = 0, _this.video = null, _this.state = {
        rate: 1,
        volume: 1,
        muted: false,
        resizeMode: 'stretch',
        duration: 0.0,
        currentTime: 0.0,
        paused: false,
        fullscreenMode: false,
        areControlsVisible: true,
        controlsTimeout: -1,
        seekerOffset: 0,
        seekerPosition: 0,
        firstPlay: true
      }, _this.onLoad = function (data) {
        _this.setState({
          duration: data.duration
        });

        if (_this.props.onMediaLoaded) {
          _this.props.onMediaLoaded();
        }
      }, _this.onProgress = function (data) {
        _this.setState({
          currentTime: data.currentTime
        });

        if (!_this.state.seeking) {
          _this.setSeekerPosition(_this.calculateSeekerPosition());
        }

        if (_this.state.firstPlay) {
          _this.setState({
            firstPlay: false
          });

          _this.hidePlayerControls();
        }
      }, _this.clearControlsTimeout = function () {
        if (_this.state.controlsTimeout > -1) {
          clearTimeout(_this.state.controlsTimeout);
        }
      }, _this.showPlayerControls = function () {
        _this.clearControlsTimeout();

        if (!_this.state.areControlsVisible) {
          _this.setState({
            areControlsVisible: true
          });
        }

        _this.hidePlayerControls();
      }, _this.togglePlay = function () {
        _this.showPlayerControls();

        _this.setState({
          paused: !_this.state.paused
        });
      }, _this.toggleFullscreenMode = function () {
        _this.showPlayerControls();

        var onFullscreenToggled = _this.props.onFullscreenToggled;

        _this.setState({
          fullscreenMode: !_this.state.fullscreenMode
        }, function () {
          _this.setState({
            resizeMode: _this.state.fullscreenMode ? 'contain' : 'stretch'
          });

          if (onFullscreenToggled) {
            onFullscreenToggled(_this.state.fullscreenMode);
          }
        });
      }, _this.onEnd = function () {
        _this.setState({
          paused: true
        });

        _this.video.seek(0);
      }, _this.seekTo = function () {
        var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (time > _this.state.duration) {
          return;
        }

        _this.video.seek(time);

        _this.setState({
          currentTime: time
        });
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(MediaPlayer, [{
      key: "formatTime",
      value: function formatTime(time) {
        var str = '';
        var minutes = 0,
            hours = 0,
            seconds = parseInt(time, 10);

        if (seconds > 60) {
          minutes = parseInt(seconds / 60, 10);
          seconds = seconds % 60;

          if (minutes > 60) {
            hours = parseInt(minutes / 60, 10);
            minutes = minutes % 60;
          }

          str = (hours > 0 ? this.pad(hours) + ':' : '') + this.pad(minutes) + ':' + this.pad(seconds);
        } else {
          str = '00:' + this.pad(seconds);
        }

        return str;
      }
    }, {
      key: "pad",
      value: function pad(value) {
        if (value < 10) {
          return '0' + String(value);
        }

        return value;
      }
    }, {
      key: "hidePlayerControls",
      value: function hidePlayerControls() {
        var player = this;
        var timeout = setTimeout(function () {
          player.setState({
            areControlsVisible: false
          });
        }, MediaPlayer.ControlsTimeout);
        player.setState({
          controlsTimeout: timeout
        });
      }
    }, {
      key: "setSeekerPosition",
      value: function setSeekerPosition() {
        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        position = this.checkSeekerPosition(position);
        this.setState({
          seekerPosition: position
        });

        if (!this.state.seeking) {
          this.setState({
            seekerOffset: position
          });
        }
      }
    }, {
      key: "checkSeekerPosition",
      value: function checkSeekerPosition() {
        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (val < 0) {
          val = 0;
        } else if (val >= this.seekerWidth) {
          return this.seekerWidth;
        }

        return val;
      }
    }, {
      key: "initSeeker",
      value: function initSeeker() {
        var _this2 = this;

        this.seekResponder = _reactNative.PanResponder.create({
          onStartShouldSetPanResponder: function onStartShouldSetPanResponder(evt, gestureState) {
            return true;
          },
          onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(evt, gestureState) {
            return true;
          },
          onPanResponderGrant: function onPanResponderGrant(evt, gestureState) {
            _this2.clearControlsTimeout();

            _this2.setState({
              seeking: true
            });
          },
          onPanResponderMove: function onPanResponderMove(evt, gestureState) {
            var position = _this2.state.seekerOffset + gestureState.dx;

            _this2.setSeekerPosition(position);
          },
          onPanResponderRelease: function onPanResponderRelease(evt, gestureState) {
            var time = _this2.getCurrentTimeForSeekerPosition();

            if (time >= _this2.state.duration) {
              _this2.setState({
                paused: true
              });

              _this2.onEnd();
            } else {
              _this2.seekTo(time);

              _this2.setState({
                seeking: false
              });
            }

            _this2.hidePlayerControls();
          }
        });
      }
    }, {
      key: "getCurrentTimeForSeekerPosition",
      value: function getCurrentTimeForSeekerPosition() {
        return this.state.duration * (this.state.seekerPosition / this.seekerWidth);
      }
    }, {
      key: "calculateSeekerPosition",
      value: function calculateSeekerPosition() {
        return this.seekerWidth * this.getCurrentTimePercentage();
      }
    }, {
      key: "getCurrentTimePercentage",
      value: function getCurrentTimePercentage() {
        if (this.state.currentTime > 0) {
          return parseFloat(this.state.currentTime) / parseFloat(this.state.duration);
        }

        return 0;
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {
        this.initSeeker();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.setState({
          paused: true,
          fullscreenMode: false
        });
        var onFullscreenToggled = this.props.onFullscreenToggled;

        if (onFullscreenToggled) {
          onFullscreenToggled(false);
        }
      }
    }, {
      key: "renderPlayerControls",
      value: function renderPlayerControls() {
        if (this.state.areControlsVisible) {
          return _react2.default.createElement(
            _reactNative.View,
            {
              style: _mediaPlayer2.default.playerControlsContainer,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 212
              }
            },
            _react2.default.createElement(
              _reactNative.TouchableOpacity,
              {
                style: _mediaPlayer2.default.playPauseButton,
                onPress: this.togglePlay,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 213
                }
              },
              this.state.paused && _react2.default.createElement(_FontAwesome2.default, {
                name: "play",
                size: 32,
                color: "#ffffff",
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 215
                }
              }),
              !this.state.paused && _react2.default.createElement(_FontAwesome2.default, {
                name: "pause",
                size: 32,
                color: "#ffffff",
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 216
                }
              })
            ),
            _react2.default.createElement(
              _reactNative.TouchableOpacity,
              {
                style: _mediaPlayer2.default.toggleFullscreenButton,
                onPress: this.toggleFullscreenMode,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 219
                }
              },
              this.state.fullscreenMode && _react2.default.createElement(_FontAwesome2.default, {
                name: "compress",
                size: 16,
                color: "#ffffff",
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 220
                }
              }),
              !this.state.fullscreenMode && _react2.default.createElement(_FontAwesome2.default, {
                name: "expand",
                size: 16,
                color: "#ffffff",
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 221
                }
              })
            ),
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: _mediaPlayer2.default.elapsedDuration,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 224
                }
              },
              this.formatTime(this.state.currentTime)
            ),
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: _mediaPlayer2.default.totalDuration,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 225
                }
              },
              this.formatTime(this.state.duration)
            )
          );
        }

        return null;
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var _props = this.props,
            fileInfo = _props.fileInfo,
            title = _props.title,
            thumbnail = _props.thumbnail,
            style = _props.style,
            fullScreenStyle = _props.fullScreenStyle;
        var flexCompleted = this.getCurrentTimePercentage() * 100;
        var flexRemaining = (1 - this.getCurrentTimePercentage()) * 100;
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: [style, _mediaPlayer2.default.container],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 239
            }
          },
          _react2.default.createElement(_reactNativeVideo2.default, {
            source: {
              uri: 'file:///' + fileInfo.download_path
            },
            ref: function ref(_ref2) {
              _this3.video = _ref2;
            },
            resizeMode: this.state.resizeMode,
            playInBackground: true,
            style: _mediaPlayer2.default.player,
            rate: this.state.rate,
            volume: this.state.volume,
            paused: this.state.paused,
            onLoad: this.onLoad,
            onProgress: this.onProgress,
            onEnd: this.onEnd,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 240
            }
          }),
          _react2.default.createElement(
            _reactNative.TouchableOpacity,
            {
              style: _mediaPlayer2.default.playerControls,
              onPress: this.showPlayerControls,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 253
              }
            },
            this.renderPlayerControls()
          ),
          _react2.default.createElement(
            _reactNative.View,
            {
              style: _mediaPlayer2.default.trackingControls,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 257
              }
            },
            _react2.default.createElement(
              _reactNative.View,
              {
                style: _mediaPlayer2.default.progress,
                onLayout: function onLayout(evt) {
                  return _this3.seekerWidth = evt.nativeEvent.layout.width;
                },
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 258
                }
              },
              _react2.default.createElement(_reactNative.View, {
                style: [_mediaPlayer2.default.innerProgressCompleted, {
                  flex: flexCompleted
                }],
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 259
                }
              }),
              _react2.default.createElement(_reactNative.View, {
                style: [_mediaPlayer2.default.innerProgressRemaining, {
                  flex: flexRemaining
                }],
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 260
                }
              })
            )
          ),
          this.state.areControlsVisible && _react2.default.createElement(
            _reactNative.View,
            babelHelpers.extends({
              style: [_mediaPlayer2.default.seekerHandle, {
                left: this.state.seekerPosition
              }]
            }, this.seekResponder.panHandlers, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 265
              }
            }),
            _react2.default.createElement(_reactNative.View, {
              style: this.state.seeking ? _mediaPlayer2.default.bigSeekerCircle : _mediaPlayer2.default.seekerCircle,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 266
              }
            })
          )
        );
      }
    }]);
    return MediaPlayer;
  }(_react2.default.PureComponent);

  MediaPlayer.ControlsTimeout = 3000;
  exports.default = MediaPlayer;
},617,[12,62,66,618,621,449,623],"LBRYApp/src/component/mediaPlayer/view.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/node_modules/react-native-video/Video.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = require(_dependencyMap[1], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _resolveAssetSource = require(_dependencyMap[3], "react-native/Libraries/Image/resolveAssetSource");

  var _resolveAssetSource2 = babelHelpers.interopRequireDefault(_resolveAssetSource);

  var _VideoResizeMode = require(_dependencyMap[4], "./VideoResizeMode.js");

  var _VideoResizeMode2 = babelHelpers.interopRequireDefault(_VideoResizeMode);

  var styles = _reactNative.StyleSheet.create({
    base: {
      overflow: 'hidden'
    }
  });

  var Video = function (_Component) {
    babelHelpers.inherits(Video, _Component);

    function Video(props) {
      babelHelpers.classCallCheck(this, Video);

      var _this = babelHelpers.possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).call(this, props));

      _this.seek = function (time) {
        _this.setNativeProps({
          seek: time
        });
      };

      _this.presentFullscreenPlayer = function () {
        _this.setNativeProps({
          fullscreen: true
        });
      };

      _this.dismissFullscreenPlayer = function () {
        _this.setNativeProps({
          fullscreen: false
        });
      };

      _this._assignRoot = function (component) {
        _this._root = component;
      };

      _this._onLoadStart = function (event) {
        if (_this.props.onLoadStart) {
          _this.props.onLoadStart(event.nativeEvent);
        }
      };

      _this._onLoad = function (event) {
        if (_this.props.onLoad) {
          _this.props.onLoad(event.nativeEvent);
        }
      };

      _this._onError = function (event) {
        if (_this.props.onError) {
          _this.props.onError(event.nativeEvent);
        }
      };

      _this._onProgress = function (event) {
        if (_this.props.onProgress) {
          _this.props.onProgress(event.nativeEvent);
        }
      };

      _this._onSeek = function (event) {
        if (_this.state.showPoster) {
          _this.setState({
            showPoster: false
          });
        }

        if (_this.props.onSeek) {
          _this.props.onSeek(event.nativeEvent);
        }
      };

      _this._onEnd = function (event) {
        if (_this.props.onEnd) {
          _this.props.onEnd(event.nativeEvent);
        }
      };

      _this._onTimedMetadata = function (event) {
        if (_this.props.onTimedMetadata) {
          _this.props.onTimedMetadata(event.nativeEvent);
        }
      };

      _this._onFullscreenPlayerWillPresent = function (event) {
        if (_this.props.onFullscreenPlayerWillPresent) {
          _this.props.onFullscreenPlayerWillPresent(event.nativeEvent);
        }
      };

      _this._onFullscreenPlayerDidPresent = function (event) {
        if (_this.props.onFullscreenPlayerDidPresent) {
          _this.props.onFullscreenPlayerDidPresent(event.nativeEvent);
        }
      };

      _this._onFullscreenPlayerWillDismiss = function (event) {
        if (_this.props.onFullscreenPlayerWillDismiss) {
          _this.props.onFullscreenPlayerWillDismiss(event.nativeEvent);
        }
      };

      _this._onFullscreenPlayerDidDismiss = function (event) {
        if (_this.props.onFullscreenPlayerDidDismiss) {
          _this.props.onFullscreenPlayerDidDismiss(event.nativeEvent);
        }
      };

      _this._onReadyForDisplay = function (event) {
        if (_this.props.onReadyForDisplay) {
          _this.props.onReadyForDisplay(event.nativeEvent);
        }
      };

      _this._onPlaybackStalled = function (event) {
        if (_this.props.onPlaybackStalled) {
          _this.props.onPlaybackStalled(event.nativeEvent);
        }
      };

      _this._onPlaybackResume = function (event) {
        if (_this.props.onPlaybackResume) {
          _this.props.onPlaybackResume(event.nativeEvent);
        }
      };

      _this._onPlaybackRateChange = function (event) {
        if (_this.state.showPoster && event.nativeEvent.playbackRate !== 0) {
          _this.setState({
            showPoster: false
          });
        }

        if (_this.props.onPlaybackRateChange) {
          _this.props.onPlaybackRateChange(event.nativeEvent);
        }
      };

      _this._onAudioBecomingNoisy = function () {
        if (_this.props.onAudioBecomingNoisy) {
          _this.props.onAudioBecomingNoisy();
        }
      };

      _this._onAudioFocusChanged = function (event) {
        if (_this.props.onAudioFocusChanged) {
          _this.props.onAudioFocusChanged(event.nativeEvent);
        }
      };

      _this._onBuffer = function (event) {
        if (_this.props.onBuffer) {
          _this.props.onBuffer(event.nativeEvent);
        }
      };

      _this.state = {
        showPoster: true
      };
      return _this;
    }

    babelHelpers.createClass(Video, [{
      key: "setNativeProps",
      value: function setNativeProps(nativeProps) {
        this._root.setNativeProps(nativeProps);
      }
    }, {
      key: "render",
      value: function render() {
        var resizeMode = this.props.resizeMode;
        var source = (0, _resolveAssetSource2.default)(this.props.source) || {};
        var uri = source.uri || '';

        if (uri && uri.match(/^\//)) {
          uri = "file://" + uri;
        }

        var isNetwork = !!(uri && uri.match(/^https?:/));
        var isAsset = !!(uri && uri.match(/^(assets-library|file|content|ms-appx|ms-appdata):/));
        var nativeResizeMode = void 0;

        if (resizeMode === _VideoResizeMode2.default.stretch) {
          nativeResizeMode = _reactNative.NativeModules.UIManager.RCTVideo.Constants.ScaleToFill;
        } else if (resizeMode === _VideoResizeMode2.default.contain) {
          nativeResizeMode = _reactNative.NativeModules.UIManager.RCTVideo.Constants.ScaleAspectFit;
        } else if (resizeMode === _VideoResizeMode2.default.cover) {
          nativeResizeMode = _reactNative.NativeModules.UIManager.RCTVideo.Constants.ScaleAspectFill;
        } else {
          nativeResizeMode = _reactNative.NativeModules.UIManager.RCTVideo.Constants.ScaleNone;
        }

        var nativeProps = babelHelpers.extends({}, this.props);
        babelHelpers.extends(nativeProps, {
          style: [styles.base, nativeProps.style],
          resizeMode: nativeResizeMode,
          src: {
            uri: uri,
            isNetwork: isNetwork,
            isAsset: isAsset,
            type: source.type || '',
            mainVer: source.mainVer || 0,
            patchVer: source.patchVer || 0
          },
          onVideoLoadStart: this._onLoadStart,
          onVideoLoad: this._onLoad,
          onVideoError: this._onError,
          onVideoProgress: this._onProgress,
          onVideoSeek: this._onSeek,
          onVideoEnd: this._onEnd,
          onVideoBuffer: this._onBuffer,
          onTimedMetadata: this._onTimedMetadata,
          onVideoFullscreenPlayerWillPresent: this._onFullscreenPlayerWillPresent,
          onVideoFullscreenPlayerDidPresent: this._onFullscreenPlayerDidPresent,
          onVideoFullscreenPlayerWillDismiss: this._onFullscreenPlayerWillDismiss,
          onVideoFullscreenPlayerDidDismiss: this._onFullscreenPlayerDidDismiss,
          onReadyForDisplay: this._onReadyForDisplay,
          onPlaybackStalled: this._onPlaybackStalled,
          onPlaybackResume: this._onPlaybackResume,
          onPlaybackRateChange: this._onPlaybackRateChange,
          onAudioFocusChanged: this._onAudioFocusChanged,
          onAudioBecomingNoisy: this._onAudioBecomingNoisy
        });

        if (this.props.poster && this.state.showPoster) {
          var posterStyle = {
            position: 'absolute',
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            resizeMode: 'contain'
          };
          return _react2.default.createElement(
            _reactNative.View,
            {
              style: nativeProps.style,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 225
              }
            },
            _react2.default.createElement(RCTVideo, babelHelpers.extends({
              ref: this._assignRoot
            }, nativeProps, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 226
              }
            })),
            _react2.default.createElement(_reactNative.Image, {
              style: posterStyle,
              source: {
                uri: this.props.poster
              },
              __source: {
                fileName: _jsxFileName,
                lineNumber: 230
              }
            })
          );
        }

        return _react2.default.createElement(RCTVideo, babelHelpers.extends({
          ref: this._assignRoot
        }, nativeProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 239
          }
        }));
      }
    }]);
    return Video;
  }(_react.Component);

  exports.default = Video;
  Video.propTypes = babelHelpers.extends({
    src: _propTypes2.default.object,
    seek: _propTypes2.default.number,
    fullscreen: _propTypes2.default.bool,
    onVideoLoadStart: _propTypes2.default.func,
    onVideoLoad: _propTypes2.default.func,
    onVideoBuffer: _propTypes2.default.func,
    onVideoError: _propTypes2.default.func,
    onVideoProgress: _propTypes2.default.func,
    onVideoSeek: _propTypes2.default.func,
    onVideoEnd: _propTypes2.default.func,
    onTimedMetadata: _propTypes2.default.func,
    onVideoFullscreenPlayerWillPresent: _propTypes2.default.func,
    onVideoFullscreenPlayerDidPresent: _propTypes2.default.func,
    onVideoFullscreenPlayerWillDismiss: _propTypes2.default.func,
    onVideoFullscreenPlayerDidDismiss: _propTypes2.default.func,
    source: _propTypes2.default.oneOfType([_propTypes2.default.shape({
      uri: _propTypes2.default.string
    }), _propTypes2.default.number]),
    resizeMode: _propTypes2.default.string,
    poster: _propTypes2.default.string,
    repeat: _propTypes2.default.bool,
    paused: _propTypes2.default.bool,
    muted: _propTypes2.default.bool,
    volume: _propTypes2.default.number,
    rate: _propTypes2.default.number,
    playInBackground: _propTypes2.default.bool,
    playWhenInactive: _propTypes2.default.bool,
    ignoreSilentSwitch: _propTypes2.default.oneOf(['ignore', 'obey']),
    disableFocus: _propTypes2.default.bool,
    controls: _propTypes2.default.bool,
    currentTime: _propTypes2.default.number,
    progressUpdateInterval: _propTypes2.default.number,
    onLoadStart: _propTypes2.default.func,
    onLoad: _propTypes2.default.func,
    onBuffer: _propTypes2.default.func,
    onError: _propTypes2.default.func,
    onProgress: _propTypes2.default.func,
    onSeek: _propTypes2.default.func,
    onEnd: _propTypes2.default.func,
    onFullscreenPlayerWillPresent: _propTypes2.default.func,
    onFullscreenPlayerDidPresent: _propTypes2.default.func,
    onFullscreenPlayerWillDismiss: _propTypes2.default.func,
    onFullscreenPlayerDidDismiss: _propTypes2.default.func,
    onReadyForDisplay: _propTypes2.default.func,
    onPlaybackStalled: _propTypes2.default.func,
    onPlaybackResume: _propTypes2.default.func,
    onPlaybackRateChange: _propTypes2.default.func,
    onAudioFocusChanged: _propTypes2.default.func,
    onAudioBecomingNoisy: _propTypes2.default.func,
    scaleX: _propTypes2.default.number,
    scaleY: _propTypes2.default.number,
    translateX: _propTypes2.default.number,
    translateY: _propTypes2.default.number,
    rotation: _propTypes2.default.number
  }, _reactNative.View.propTypes);
  var RCTVideo = (0, _reactNative.requireNativeComponent)('RCTVideo', Video, {
    nativeOnly: {
      src: true,
      seek: true,
      fullscreen: true
    }
  });
},618,[12,24,66,201,619],"react-native-video/Video.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _keymirror = require(_dependencyMap[0], "keymirror");

  var _keymirror2 = babelHelpers.interopRequireDefault(_keymirror);

  exports.default = (0, _keymirror2.default)({
    contain: null,
    cover: null,
    stretch: null
  });
},619,[620],"react-native-video/VideoResizeMode.js");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  var keyMirror = function keyMirror(obj) {
    var ret = {};
    var key;

    if (!(obj instanceof Object && !Array.isArray(obj))) {
      throw new Error('keyMirror(...): Argument must be an object.');
    }

    for (key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }

      ret[key] = key;
    }

    return ret;
  };

  module.exports = keyMirror;
},620,[],"keymirror/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = undefined;

  var _createIconSet = require(_dependencyMap[0], "./lib/create-icon-set");

  var _createIconSet2 = babelHelpers.interopRequireDefault(_createIconSet);

  var _FontAwesome = require(_dependencyMap[1], "./glyphmaps/FontAwesome.json");

  var _FontAwesome2 = babelHelpers.interopRequireDefault(_FontAwesome);

  var iconSet = (0, _createIconSet2.default)(_FontAwesome2.default, 'FontAwesome', 'FontAwesome.ttf');
  exports.default = iconSet;
  var Button = exports.Button = iconSet.Button;
  var TabBarItem = exports.TabBarItem = iconSet.TabBarItem;
  var TabBarItemIOS = exports.TabBarItemIOS = iconSet.TabBarItemIOS;
  var ToolbarAndroid = exports.ToolbarAndroid = iconSet.ToolbarAndroid;
  var getImageSource = exports.getImageSource = iconSet.getImageSource;
},621,[456,622],"react-native-vector-icons/FontAwesome.js");
__d(function (global, require, module, exports, _dependencyMap) {
  module.exports = {
    "glass": 61440,
    "music": 61441,
    "search": 61442,
    "envelope-o": 61443,
    "heart": 61444,
    "star": 61445,
    "star-o": 61446,
    "user": 61447,
    "film": 61448,
    "th-large": 61449,
    "th": 61450,
    "th-list": 61451,
    "check": 61452,
    "remove": 61453,
    "close": 61453,
    "times": 61453,
    "search-plus": 61454,
    "search-minus": 61456,
    "power-off": 61457,
    "signal": 61458,
    "gear": 61459,
    "cog": 61459,
    "trash-o": 61460,
    "home": 61461,
    "file-o": 61462,
    "clock-o": 61463,
    "road": 61464,
    "download": 61465,
    "arrow-circle-o-down": 61466,
    "arrow-circle-o-up": 61467,
    "inbox": 61468,
    "play-circle-o": 61469,
    "rotate-right": 61470,
    "repeat": 61470,
    "refresh": 61473,
    "list-alt": 61474,
    "lock": 61475,
    "flag": 61476,
    "headphones": 61477,
    "volume-off": 61478,
    "volume-down": 61479,
    "volume-up": 61480,
    "qrcode": 61481,
    "barcode": 61482,
    "tag": 61483,
    "tags": 61484,
    "book": 61485,
    "bookmark": 61486,
    "print": 61487,
    "camera": 61488,
    "font": 61489,
    "bold": 61490,
    "italic": 61491,
    "text-height": 61492,
    "text-width": 61493,
    "align-left": 61494,
    "align-center": 61495,
    "align-right": 61496,
    "align-justify": 61497,
    "list": 61498,
    "dedent": 61499,
    "outdent": 61499,
    "indent": 61500,
    "video-camera": 61501,
    "photo": 61502,
    "image": 61502,
    "picture-o": 61502,
    "pencil": 61504,
    "map-marker": 61505,
    "adjust": 61506,
    "tint": 61507,
    "edit": 61508,
    "pencil-square-o": 61508,
    "share-square-o": 61509,
    "check-square-o": 61510,
    "arrows": 61511,
    "step-backward": 61512,
    "fast-backward": 61513,
    "backward": 61514,
    "play": 61515,
    "pause": 61516,
    "stop": 61517,
    "forward": 61518,
    "fast-forward": 61520,
    "step-forward": 61521,
    "eject": 61522,
    "chevron-left": 61523,
    "chevron-right": 61524,
    "plus-circle": 61525,
    "minus-circle": 61526,
    "times-circle": 61527,
    "check-circle": 61528,
    "question-circle": 61529,
    "info-circle": 61530,
    "crosshairs": 61531,
    "times-circle-o": 61532,
    "check-circle-o": 61533,
    "ban": 61534,
    "arrow-left": 61536,
    "arrow-right": 61537,
    "arrow-up": 61538,
    "arrow-down": 61539,
    "mail-forward": 61540,
    "share": 61540,
    "expand": 61541,
    "compress": 61542,
    "plus": 61543,
    "minus": 61544,
    "asterisk": 61545,
    "exclamation-circle": 61546,
    "gift": 61547,
    "leaf": 61548,
    "fire": 61549,
    "eye": 61550,
    "eye-slash": 61552,
    "warning": 61553,
    "exclamation-triangle": 61553,
    "plane": 61554,
    "calendar": 61555,
    "random": 61556,
    "comment": 61557,
    "magnet": 61558,
    "chevron-up": 61559,
    "chevron-down": 61560,
    "retweet": 61561,
    "shopping-cart": 61562,
    "folder": 61563,
    "folder-open": 61564,
    "arrows-v": 61565,
    "arrows-h": 61566,
    "bar-chart-o": 61568,
    "bar-chart": 61568,
    "twitter-square": 61569,
    "facebook-square": 61570,
    "camera-retro": 61571,
    "key": 61572,
    "gears": 61573,
    "cogs": 61573,
    "comments": 61574,
    "thumbs-o-up": 61575,
    "thumbs-o-down": 61576,
    "star-half": 61577,
    "heart-o": 61578,
    "sign-out": 61579,
    "linkedin-square": 61580,
    "thumb-tack": 61581,
    "external-link": 61582,
    "sign-in": 61584,
    "trophy": 61585,
    "github-square": 61586,
    "upload": 61587,
    "lemon-o": 61588,
    "phone": 61589,
    "square-o": 61590,
    "bookmark-o": 61591,
    "phone-square": 61592,
    "twitter": 61593,
    "facebook-f": 61594,
    "facebook": 61594,
    "github": 61595,
    "unlock": 61596,
    "credit-card": 61597,
    "feed": 61598,
    "rss": 61598,
    "hdd-o": 61600,
    "bullhorn": 61601,
    "bell": 61683,
    "certificate": 61603,
    "hand-o-right": 61604,
    "hand-o-left": 61605,
    "hand-o-up": 61606,
    "hand-o-down": 61607,
    "arrow-circle-left": 61608,
    "arrow-circle-right": 61609,
    "arrow-circle-up": 61610,
    "arrow-circle-down": 61611,
    "globe": 61612,
    "wrench": 61613,
    "tasks": 61614,
    "filter": 61616,
    "briefcase": 61617,
    "arrows-alt": 61618,
    "group": 61632,
    "users": 61632,
    "chain": 61633,
    "link": 61633,
    "cloud": 61634,
    "flask": 61635,
    "cut": 61636,
    "scissors": 61636,
    "copy": 61637,
    "files-o": 61637,
    "paperclip": 61638,
    "save": 61639,
    "floppy-o": 61639,
    "square": 61640,
    "navicon": 61641,
    "reorder": 61641,
    "bars": 61641,
    "list-ul": 61642,
    "list-ol": 61643,
    "strikethrough": 61644,
    "underline": 61645,
    "table": 61646,
    "magic": 61648,
    "truck": 61649,
    "pinterest": 61650,
    "pinterest-square": 61651,
    "google-plus-square": 61652,
    "google-plus": 61653,
    "money": 61654,
    "caret-down": 61655,
    "caret-up": 61656,
    "caret-left": 61657,
    "caret-right": 61658,
    "columns": 61659,
    "unsorted": 61660,
    "sort": 61660,
    "sort-down": 61661,
    "sort-desc": 61661,
    "sort-up": 61662,
    "sort-asc": 61662,
    "envelope": 61664,
    "linkedin": 61665,
    "rotate-left": 61666,
    "undo": 61666,
    "legal": 61667,
    "gavel": 61667,
    "dashboard": 61668,
    "tachometer": 61668,
    "comment-o": 61669,
    "comments-o": 61670,
    "flash": 61671,
    "bolt": 61671,
    "sitemap": 61672,
    "umbrella": 61673,
    "paste": 61674,
    "clipboard": 61674,
    "lightbulb-o": 61675,
    "exchange": 61676,
    "cloud-download": 61677,
    "cloud-upload": 61678,
    "user-md": 61680,
    "stethoscope": 61681,
    "suitcase": 61682,
    "bell-o": 61602,
    "coffee": 61684,
    "cutlery": 61685,
    "file-text-o": 61686,
    "building-o": 61687,
    "hospital-o": 61688,
    "ambulance": 61689,
    "medkit": 61690,
    "fighter-jet": 61691,
    "beer": 61692,
    "h-square": 61693,
    "plus-square": 61694,
    "angle-double-left": 61696,
    "angle-double-right": 61697,
    "angle-double-up": 61698,
    "angle-double-down": 61699,
    "angle-left": 61700,
    "angle-right": 61701,
    "angle-up": 61702,
    "angle-down": 61703,
    "desktop": 61704,
    "laptop": 61705,
    "tablet": 61706,
    "mobile-phone": 61707,
    "mobile": 61707,
    "circle-o": 61708,
    "quote-left": 61709,
    "quote-right": 61710,
    "spinner": 61712,
    "circle": 61713,
    "mail-reply": 61714,
    "reply": 61714,
    "github-alt": 61715,
    "folder-o": 61716,
    "folder-open-o": 61717,
    "smile-o": 61720,
    "frown-o": 61721,
    "meh-o": 61722,
    "gamepad": 61723,
    "keyboard-o": 61724,
    "flag-o": 61725,
    "flag-checkered": 61726,
    "terminal": 61728,
    "code": 61729,
    "mail-reply-all": 61730,
    "reply-all": 61730,
    "star-half-empty": 61731,
    "star-half-full": 61731,
    "star-half-o": 61731,
    "location-arrow": 61732,
    "crop": 61733,
    "code-fork": 61734,
    "unlink": 61735,
    "chain-broken": 61735,
    "question": 61736,
    "info": 61737,
    "exclamation": 61738,
    "superscript": 61739,
    "subscript": 61740,
    "eraser": 61741,
    "puzzle-piece": 61742,
    "microphone": 61744,
    "microphone-slash": 61745,
    "shield": 61746,
    "calendar-o": 61747,
    "fire-extinguisher": 61748,
    "rocket": 61749,
    "maxcdn": 61750,
    "chevron-circle-left": 61751,
    "chevron-circle-right": 61752,
    "chevron-circle-up": 61753,
    "chevron-circle-down": 61754,
    "html5": 61755,
    "css3": 61756,
    "anchor": 61757,
    "unlock-alt": 61758,
    "bullseye": 61760,
    "ellipsis-h": 61761,
    "ellipsis-v": 61762,
    "rss-square": 61763,
    "play-circle": 61764,
    "ticket": 61765,
    "minus-square": 61766,
    "minus-square-o": 61767,
    "level-up": 61768,
    "level-down": 61769,
    "check-square": 61770,
    "pencil-square": 61771,
    "external-link-square": 61772,
    "share-square": 61773,
    "compass": 61774,
    "toggle-down": 61776,
    "caret-square-o-down": 61776,
    "toggle-up": 61777,
    "caret-square-o-up": 61777,
    "toggle-right": 61778,
    "caret-square-o-right": 61778,
    "euro": 61779,
    "eur": 61779,
    "gbp": 61780,
    "dollar": 61781,
    "usd": 61781,
    "rupee": 61782,
    "inr": 61782,
    "cny": 61783,
    "rmb": 61783,
    "yen": 61783,
    "jpy": 61783,
    "ruble": 61784,
    "rouble": 61784,
    "rub": 61784,
    "won": 61785,
    "krw": 61785,
    "bitcoin": 61786,
    "btc": 61786,
    "file": 61787,
    "file-text": 61788,
    "sort-alpha-asc": 61789,
    "sort-alpha-desc": 61790,
    "sort-amount-asc": 61792,
    "sort-amount-desc": 61793,
    "sort-numeric-asc": 61794,
    "sort-numeric-desc": 61795,
    "thumbs-up": 61796,
    "thumbs-down": 61797,
    "youtube-square": 61798,
    "youtube": 61799,
    "xing": 61800,
    "xing-square": 61801,
    "youtube-play": 61802,
    "dropbox": 61803,
    "stack-overflow": 61804,
    "instagram": 61805,
    "flickr": 61806,
    "adn": 61808,
    "bitbucket": 61809,
    "bitbucket-square": 61810,
    "tumblr": 61811,
    "tumblr-square": 61812,
    "long-arrow-down": 61813,
    "long-arrow-up": 61814,
    "long-arrow-left": 61815,
    "long-arrow-right": 61816,
    "apple": 61817,
    "windows": 61818,
    "android": 61819,
    "linux": 61820,
    "dribbble": 61821,
    "skype": 61822,
    "foursquare": 61824,
    "trello": 61825,
    "female": 61826,
    "male": 61827,
    "gittip": 61828,
    "gratipay": 61828,
    "sun-o": 61829,
    "moon-o": 61830,
    "archive": 61831,
    "bug": 61832,
    "vk": 61833,
    "weibo": 61834,
    "renren": 61835,
    "pagelines": 61836,
    "stack-exchange": 61837,
    "arrow-circle-o-right": 61838,
    "arrow-circle-o-left": 61840,
    "toggle-left": 61841,
    "caret-square-o-left": 61841,
    "dot-circle-o": 61842,
    "wheelchair": 61843,
    "vimeo-square": 61844,
    "turkish-lira": 61845,
    "try": 61845,
    "plus-square-o": 61846,
    "space-shuttle": 61847,
    "slack": 61848,
    "envelope-square": 61849,
    "wordpress": 61850,
    "openid": 61851,
    "institution": 61852,
    "bank": 61852,
    "university": 61852,
    "mortar-board": 61853,
    "graduation-cap": 61853,
    "yahoo": 61854,
    "google": 61856,
    "reddit": 61857,
    "reddit-square": 61858,
    "stumbleupon-circle": 61859,
    "stumbleupon": 61860,
    "delicious": 61861,
    "digg": 61862,
    "pied-piper-pp": 61863,
    "pied-piper-alt": 61864,
    "drupal": 61865,
    "joomla": 61866,
    "language": 61867,
    "fax": 61868,
    "building": 61869,
    "child": 61870,
    "paw": 61872,
    "spoon": 61873,
    "cube": 61874,
    "cubes": 61875,
    "behance": 61876,
    "behance-square": 61877,
    "steam": 61878,
    "steam-square": 61879,
    "recycle": 61880,
    "automobile": 61881,
    "car": 61881,
    "cab": 61882,
    "taxi": 61882,
    "tree": 61883,
    "spotify": 61884,
    "deviantart": 61885,
    "soundcloud": 61886,
    "database": 61888,
    "file-pdf-o": 61889,
    "file-word-o": 61890,
    "file-excel-o": 61891,
    "file-powerpoint-o": 61892,
    "file-photo-o": 61893,
    "file-picture-o": 61893,
    "file-image-o": 61893,
    "file-zip-o": 61894,
    "file-archive-o": 61894,
    "file-sound-o": 61895,
    "file-audio-o": 61895,
    "file-movie-o": 61896,
    "file-video-o": 61896,
    "file-code-o": 61897,
    "vine": 61898,
    "codepen": 61899,
    "jsfiddle": 61900,
    "life-bouy": 61901,
    "life-buoy": 61901,
    "life-saver": 61901,
    "support": 61901,
    "life-ring": 61901,
    "circle-o-notch": 61902,
    "ra": 61904,
    "resistance": 61904,
    "rebel": 61904,
    "ge": 61905,
    "empire": 61905,
    "git-square": 61906,
    "git": 61907,
    "y-combinator-square": 61908,
    "yc-square": 61908,
    "hacker-news": 61908,
    "tencent-weibo": 61909,
    "qq": 61910,
    "wechat": 61911,
    "weixin": 61911,
    "send": 61912,
    "paper-plane": 61912,
    "send-o": 61913,
    "paper-plane-o": 61913,
    "history": 61914,
    "circle-thin": 61915,
    "header": 61916,
    "paragraph": 61917,
    "sliders": 61918,
    "share-alt": 61920,
    "share-alt-square": 61921,
    "bomb": 61922,
    "soccer-ball-o": 61923,
    "futbol-o": 61923,
    "tty": 61924,
    "binoculars": 61925,
    "plug": 61926,
    "slideshare": 61927,
    "twitch": 61928,
    "yelp": 61929,
    "newspaper-o": 61930,
    "wifi": 61931,
    "calculator": 61932,
    "paypal": 61933,
    "google-wallet": 61934,
    "cc-visa": 61936,
    "cc-mastercard": 61937,
    "cc-discover": 61938,
    "cc-amex": 61939,
    "cc-paypal": 61940,
    "cc-stripe": 61941,
    "bell-slash": 61942,
    "bell-slash-o": 61943,
    "trash": 61944,
    "copyright": 61945,
    "at": 61946,
    "eyedropper": 61947,
    "paint-brush": 61948,
    "birthday-cake": 61949,
    "area-chart": 61950,
    "pie-chart": 61952,
    "line-chart": 61953,
    "lastfm": 61954,
    "lastfm-square": 61955,
    "toggle-off": 61956,
    "toggle-on": 61957,
    "bicycle": 61958,
    "bus": 61959,
    "ioxhost": 61960,
    "angellist": 61961,
    "cc": 61962,
    "shekel": 61963,
    "sheqel": 61963,
    "ils": 61963,
    "meanpath": 61964,
    "buysellads": 61965,
    "connectdevelop": 61966,
    "dashcube": 61968,
    "forumbee": 61969,
    "leanpub": 61970,
    "sellsy": 61971,
    "shirtsinbulk": 61972,
    "simplybuilt": 61973,
    "skyatlas": 61974,
    "cart-plus": 61975,
    "cart-arrow-down": 61976,
    "diamond": 61977,
    "ship": 61978,
    "user-secret": 61979,
    "motorcycle": 61980,
    "street-view": 61981,
    "heartbeat": 61982,
    "venus": 61985,
    "mars": 61986,
    "mercury": 61987,
    "intersex": 61988,
    "transgender": 61988,
    "transgender-alt": 61989,
    "venus-double": 61990,
    "mars-double": 61991,
    "venus-mars": 61992,
    "mars-stroke": 61993,
    "mars-stroke-v": 61994,
    "mars-stroke-h": 61995,
    "neuter": 61996,
    "genderless": 61997,
    "facebook-official": 62000,
    "pinterest-p": 62001,
    "whatsapp": 62002,
    "server": 62003,
    "user-plus": 62004,
    "user-times": 62005,
    "hotel": 62006,
    "bed": 62006,
    "viacoin": 62007,
    "train": 62008,
    "subway": 62009,
    "medium": 62010,
    "yc": 62011,
    "y-combinator": 62011,
    "optin-monster": 62012,
    "opencart": 62013,
    "expeditedssl": 62014,
    "battery-4": 62016,
    "battery": 62016,
    "battery-full": 62016,
    "battery-3": 62017,
    "battery-three-quarters": 62017,
    "battery-2": 62018,
    "battery-half": 62018,
    "battery-1": 62019,
    "battery-quarter": 62019,
    "battery-0": 62020,
    "battery-empty": 62020,
    "mouse-pointer": 62021,
    "i-cursor": 62022,
    "object-group": 62023,
    "object-ungroup": 62024,
    "sticky-note": 62025,
    "sticky-note-o": 62026,
    "cc-jcb": 62027,
    "cc-diners-club": 62028,
    "clone": 62029,
    "balance-scale": 62030,
    "hourglass-o": 62032,
    "hourglass-1": 62033,
    "hourglass-start": 62033,
    "hourglass-2": 62034,
    "hourglass-half": 62034,
    "hourglass-3": 62035,
    "hourglass-end": 62035,
    "hourglass": 62036,
    "hand-grab-o": 62037,
    "hand-rock-o": 62037,
    "hand-stop-o": 62038,
    "hand-paper-o": 62038,
    "hand-scissors-o": 62039,
    "hand-lizard-o": 62040,
    "hand-spock-o": 62041,
    "hand-pointer-o": 62042,
    "hand-peace-o": 62043,
    "trademark": 62044,
    "registered": 62045,
    "creative-commons": 62046,
    "gg": 62048,
    "gg-circle": 62049,
    "tripadvisor": 62050,
    "odnoklassniki": 62051,
    "odnoklassniki-square": 62052,
    "get-pocket": 62053,
    "wikipedia-w": 62054,
    "safari": 62055,
    "chrome": 62056,
    "firefox": 62057,
    "opera": 62058,
    "internet-explorer": 62059,
    "tv": 62060,
    "television": 62060,
    "contao": 62061,
    "500px": 62062,
    "amazon": 62064,
    "calendar-plus-o": 62065,
    "calendar-minus-o": 62066,
    "calendar-times-o": 62067,
    "calendar-check-o": 62068,
    "industry": 62069,
    "map-pin": 62070,
    "map-signs": 62071,
    "map-o": 62072,
    "map": 62073,
    "commenting": 62074,
    "commenting-o": 62075,
    "houzz": 62076,
    "vimeo": 62077,
    "black-tie": 62078,
    "fonticons": 62080,
    "reddit-alien": 62081,
    "edge": 62082,
    "credit-card-alt": 62083,
    "codiepie": 62084,
    "modx": 62085,
    "fort-awesome": 62086,
    "usb": 62087,
    "product-hunt": 62088,
    "mixcloud": 62089,
    "scribd": 62090,
    "pause-circle": 62091,
    "pause-circle-o": 62092,
    "stop-circle": 62093,
    "stop-circle-o": 62094,
    "shopping-bag": 62096,
    "shopping-basket": 62097,
    "hashtag": 62098,
    "bluetooth": 62099,
    "bluetooth-b": 62100,
    "percent": 62101,
    "gitlab": 62102,
    "wpbeginner": 62103,
    "wpforms": 62104,
    "envira": 62105,
    "universal-access": 62106,
    "wheelchair-alt": 62107,
    "question-circle-o": 62108,
    "blind": 62109,
    "audio-description": 62110,
    "volume-control-phone": 62112,
    "braille": 62113,
    "assistive-listening-systems": 62114,
    "asl-interpreting": 62115,
    "american-sign-language-interpreting": 62115,
    "deafness": 62116,
    "hard-of-hearing": 62116,
    "deaf": 62116,
    "glide": 62117,
    "glide-g": 62118,
    "signing": 62119,
    "sign-language": 62119,
    "low-vision": 62120,
    "viadeo": 62121,
    "viadeo-square": 62122,
    "snapchat": 62123,
    "snapchat-ghost": 62124,
    "snapchat-square": 62125,
    "pied-piper": 62126,
    "first-order": 62128,
    "yoast": 62129,
    "themeisle": 62130,
    "google-plus-circle": 62131,
    "google-plus-official": 62131,
    "fa": 62132,
    "font-awesome": 62132,
    "handshake-o": 62133,
    "envelope-open": 62134,
    "envelope-open-o": 62135,
    "linode": 62136,
    "address-book": 62137,
    "address-book-o": 62138,
    "vcard": 62139,
    "address-card": 62139,
    "vcard-o": 62140,
    "address-card-o": 62140,
    "user-circle": 62141,
    "user-circle-o": 62142,
    "user-o": 62144,
    "id-badge": 62145,
    "drivers-license": 62146,
    "id-card": 62146,
    "drivers-license-o": 62147,
    "id-card-o": 62147,
    "quora": 62148,
    "free-code-camp": 62149,
    "telegram": 62150,
    "thermometer-4": 62151,
    "thermometer": 62151,
    "thermometer-full": 62151,
    "thermometer-3": 62152,
    "thermometer-three-quarters": 62152,
    "thermometer-2": 62153,
    "thermometer-half": 62153,
    "thermometer-1": 62154,
    "thermometer-quarter": 62154,
    "thermometer-0": 62155,
    "thermometer-empty": 62155,
    "shower": 62156,
    "bathtub": 62157,
    "s15": 62157,
    "bath": 62157,
    "podcast": 62158,
    "window-maximize": 62160,
    "window-minimize": 62161,
    "window-restore": 62162,
    "times-rectangle": 62163,
    "window-close": 62163,
    "times-rectangle-o": 62164,
    "window-close-o": 62164,
    "bandcamp": 62165,
    "grav": 62166,
    "etsy": 62167,
    "imdb": 62168,
    "ravelry": 62169,
    "eercast": 62170,
    "microchip": 62171,
    "snowflake-o": 62172,
    "superpowers": 62173,
    "wpexplorer": 62174,
    "meetup": 62176
  };
},622,[],"react-native-vector-icons/glyphmaps/FontAwesome.json");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var screenDimension = _reactNative.Dimensions.get('window');

  var screenWidth = screenDimension.width;

  var mediaPlayerStyle = _reactNative.StyleSheet.create({
    player: {
      flex: 1
    },
    container: {},
    progress: {
      flex: 1,
      flexDirection: 'row',
      overflow: 'hidden'
    },
    innerProgressCompleted: {
      height: 4,
      backgroundColor: '#40c0a9'
    },
    innerProgressRemaining: {
      height: 4,
      backgroundColor: '#2c2c2c'
    },
    trackingControls: {
      height: 3,
      width: '100%',
      position: 'absolute',
      bottom: 0,
      left: 0
    },
    playerControls: {
      position: 'absolute',
      left: 0,
      top: 0,
      width: '100%',
      height: '100%'
    },
    playerControlsContainer: {
      backgroundColor: 'transparent',
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center'
    },
    playPauseButton: {
      position: 'absolute',
      width: 64,
      height: 64,
      alignItems: 'center',
      justifyContent: 'center'
    },
    toggleFullscreenButton: {
      position: 'absolute',
      width: 36,
      height: 36,
      alignItems: 'center',
      justifyContent: 'center',
      right: 0,
      bottom: 14
    },
    elapsedDuration: {
      fontFamily: 'Metropolis-Regular',
      position: 'absolute',
      left: 8,
      bottom: 24,
      fontSize: 12,
      color: '#ffffff'
    },
    totalDuration: {
      fontFamily: 'Metropolis-Regular',
      position: 'absolute',
      right: 40,
      bottom: 24,
      fontSize: 12,
      color: '#ffffff'
    },
    seekerCircle: {
      borderRadius: 12,
      position: 'relative',
      top: 8,
      left: 8,
      height: 12,
      width: 12,
      backgroundColor: '#40c0a9'
    },
    seekerHandle: {
      position: 'absolute',
      height: 28,
      width: 28,
      bottom: -12,
      marginLeft: -8
    },
    bigSeekerCircle: {
      borderRadius: 24,
      position: 'relative',
      top: 2,
      left: 8,
      height: 24,
      width: 24,
      backgroundColor: '#40c0a9'
    }
  });

  exports.default = mediaPlayerStyle;
},623,[66],"LBRYApp/src/styles/mediaPlayer.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var screenDimension = _reactNative.Dimensions.get('window');

  var screenWidth = screenDimension.width;

  var filePageStyle = _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center'
    },
    pageContainer: {
      flex: 1
    },
    mediaContainer: {
      alignItems: 'center',
      width: screenWidth,
      height: 220
    },
    emptyClaimText: {
      fontFamily: 'Metropolis-Regular',
      textAlign: 'center',
      fontSize: 20,
      marginLeft: 16,
      marginRight: 16
    },
    scrollContainer: {
      flex: 1
    },
    title: {
      fontFamily: 'Metropolis-Bold',
      fontSize: 24,
      marginTop: 12,
      marginLeft: 20,
      marginRight: 20,
      marginBottom: 12
    },
    channelName: {
      fontFamily: 'Metropolis-SemiBold',
      fontSize: 20,
      marginLeft: 20,
      marginRight: 20,
      marginBottom: 20,
      color: '#9b9b9b'
    },
    description: {
      fontFamily: 'Metropolis-Regular',
      fontSize: 16,
      marginLeft: 20,
      marginRight: 20,
      marginBottom: 20,
      color: '#999999'
    },
    thumbnail: {
      width: screenWidth,
      height: 200
    },
    downloadButton: {
      position: 'absolute',
      top: '50%'
    },
    player: {
      flex: 1,
      width: '100%',
      height: '100%',
      marginBottom: 14
    },
    fullscreenMedia: {
      position: 'absolute',
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      flex: 1,
      backgroundColor: '#000000',
      zIndex: 100
    }
  });

  exports.default = filePageStyle;
},624,[66],"LBRYApp/src/styles/filePage.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactRedux = require(_dependencyMap[0], "react-redux");

  var _view = require(_dependencyMap[1], "./view");

  var _view2 = babelHelpers.interopRequireDefault(_view);

  var select = function select(state) {
    return {};
  };

  var perform = function perform(dispatch) {
    return {};
  };

  exports.default = (0, _reactRedux.connect)(select, perform)(_view2.default);
},625,[22,626],"LBRYApp/src/page/splash/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _jsxFileName = "/home/akinwale/Dev/Python/lbry-android/app/src/page/splash/view.js";

  var _react = require(_dependencyMap[0], "react");

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _lbryRedux = require(_dependencyMap[1], "lbry-redux");

  var _reactNative = require(_dependencyMap[2], "react-native");

  var _propTypes = require(_dependencyMap[3], "prop-types");

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _splash = require(_dependencyMap[4], "../../styles/splash");

  var _splash2 = babelHelpers.interopRequireDefault(_splash);

  var SplashScreen = function (_React$PureComponent) {
    babelHelpers.inherits(SplashScreen, _React$PureComponent);

    function SplashScreen() {
      babelHelpers.classCallCheck(this, SplashScreen);
      return babelHelpers.possibleConstructorReturn(this, (SplashScreen.__proto__ || Object.getPrototypeOf(SplashScreen)).apply(this, arguments));
    }

    babelHelpers.createClass(SplashScreen, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.setState({
          details: 'Starting daemon',
          message: 'Connecting',
          isRunning: false,
          isLagging: false
        });
      }
    }, {
      key: "updateStatus",
      value: function updateStatus() {
        var _this2 = this;

        _lbryRedux.Lbry.status().then(function (status) {
          _this2._updateStatusCallback(status);
        });
      }
    }, {
      key: "_updateStatusCallback",
      value: function _updateStatusCallback(status) {
        var _this3 = this;

        var startupStatus = status.startup_status;

        if (startupStatus.code == 'started') {
          this.setState({
            message: 'Testing Network',
            details: 'Waiting for name resolution',
            isLagging: false,
            isRunning: true
          });

          _lbryRedux.Lbry.resolve({
            uri: 'lbry://one'
          }).then(function () {
            var navigation = _this3.props.navigation;
            navigation.navigate('Main');
          });

          return;
        }

        if (status.blockchain_status && status.blockchain_status.blocks_behind > 0) {
          var behind = status.blockchain_status.blocks_behind;
          var behindText = behind + ' block' + (behind == 1 ? '' : 's') + ' behind';
          this.setState({
            message: 'Blockchain Sync',
            details: behindText,
            isLagging: startupStatus.is_lagging
          });
        } else {
          this.setState({
            message: 'Network Loading',
            details: startupStatus.message + (startupStatus.is_lagging ? '' : '...'),
            isLagging: startupStatus.is_lagging
          });
        }

        setTimeout(function () {
          _this3.updateStatus();
        }, 500);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this4 = this;

        _lbryRedux.Lbry.connect().then(function () {
          _this4.updateStatus();
        }).catch(function (e) {
          _this4.setState({
            isLagging: true,
            message: 'Connection Failure',
            details: 'We could not establish a connection to the daemon. Your data connection may be preventing LBRY from connecting. Contact hello@lbry.io if you think this is a software bug.'
          });
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _state = this.state,
            message = _state.message,
            details = _state.details,
            isLagging = _state.isLagging,
            isRunning = _state.isRunning;
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: _splash2.default.container,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 88
            }
          },
          _react2.default.createElement(
            _reactNative.Text,
            {
              style: _splash2.default.title,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 89
              }
            },
            "Lbry."
          ),
          _react2.default.createElement(
            _reactNative.Text,
            {
              style: _splash2.default.message,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 90
              }
            },
            message
          ),
          _react2.default.createElement(
            _reactNative.Text,
            {
              style: _splash2.default.details,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 91
              }
            },
            details
          )
        );
      }
    }]);
    return SplashScreen;
  }(_react2.default.PureComponent);

  SplashScreen.navigationOptions = {
    title: 'Splash'
  };
  exports.default = SplashScreen;
},626,[12,62,66,24,627],"LBRYApp/src/page/splash/view.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = require(_dependencyMap[0], "react-native");

  var splashStyle = _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      backgroundColor: '#40b89a'
    },
    title: {
      fontFamily: 'Metropolis-Bold',
      fontSize: 64,
      textAlign: 'center',
      marginBottom: 48,
      color: '#ffffff'
    },
    details: {
      fontFamily: 'Metropolis-Regular',
      fontSize: 14,
      marginLeft: 16,
      marginRight: 16,
      color: '#ffffff',
      textAlign: 'center'
    },
    message: {
      fontFamily: 'Metropolis-Bold',
      fontSize: 18,
      color: '#ffffff',
      marginLeft: 16,
      marginRight: 16,
      marginBottom: 4,
      textAlign: 'center'
    }
  });

  exports.default = splashStyle;
},627,[66],"LBRYApp/src/styles/splash.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addListener = exports.reactNavigationMiddleware = undefined;

  var _reactNavigationReduxHelpers = require(_dependencyMap[0], "react-navigation-redux-helpers");

  var reactNavigationMiddleware = (0, _reactNavigationReduxHelpers.createReactNavigationReduxMiddleware)("root", function (state) {
    return state.nav;
  });
  var addListener = (0, _reactNavigationReduxHelpers.createReduxBoundAddListener)("root");
  exports.reactNavigationMiddleware = reactNavigationMiddleware;
  exports.addListener = addListener;
},628,[629],"LBRYApp/src/utils/redux.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createNavigationReducer = undefined;

  var _types = require(_dependencyMap[0], "./types");

  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _types[key];
      }
    });
  });

  var _middleware = require(_dependencyMap[1], "./middleware");

  Object.keys(_middleware).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _middleware[key];
      }
    });
  });

  var _reducer = require(_dependencyMap[2], "./reducer");

  exports.createNavigationReducer = _reducer.createNavigationReducer;
},629,[630,631,632],"react-navigation-redux-helpers/src/index.js");
__d(function (global, require, module, exports, _dependencyMap) {},630,[],"react-navigation-redux-helpers/src/types.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.initializeListeners = exports.createReduxBoundAddListener = exports.createReactNavigationReduxMiddleware = undefined;

  var _invariant = require(_dependencyMap[0], "invariant");

  var _invariant2 = babelHelpers.interopRequireDefault(_invariant);

  var _reducer = require(_dependencyMap[1], "./reducer");

  var reduxSubscribers = new Map();

  function createReactNavigationReduxMiddleware(key, navStateSelector) {
    reduxSubscribers.set(key, new Set());
    return function (store) {
      return function (next) {
        return function (action) {
          var oldState = store.getState();
          var result = next(action);
          var newState = store.getState();
          var subscribers = reduxSubscribers.get(key);
          (0, _invariant2.default)(subscribers, "subscribers set should exist for " + key);
          triggerAllSubscribers(subscribers, {
            type: 'action',
            action: action,
            state: navStateSelector(newState),
            lastState: navStateSelector(oldState)
          });
          return result;
        };
      };
    };
  }

  function triggerAllSubscribers(subscribers, payload) {
    subscribers.forEach(function (subscriber) {
      return subscriber(payload);
    });
  }

  function createReduxBoundAddListener(key) {
    (0, _invariant2.default)(reduxSubscribers.has(key), "Cannot listen for a key that isn't associated with a Redux store. " + "First call `createReactNavigationReduxMiddleware` so that we know " + "when to trigger your listener.");
    return function (eventName, handler) {
      if (eventName !== 'action') {
        return {
          remove: function remove() {}
        };
      }

      var subscribers = reduxSubscribers.get(key);
      (0, _invariant2.default)(subscribers, "subscribers set should exist for " + key);
      subscribers.add(handler);
      return {
        remove: function remove() {
          subscribers.delete(handler);
        }
      };
    };
  }

  function initializeListeners(key, state) {
    var subscribers = reduxSubscribers.get(key);
    (0, _invariant2.default)(subscribers, "Cannot initialize listeners for a key that isn't associated with a " + "Redux store. First call `createReactNavigationReduxMiddleware` so " + "that we know when to trigger your listener.");
    triggerAllSubscribers(subscribers, {
      type: 'action',
      action: _reducer.initAction,
      state: state,
      lastState: null
    });
  }

  exports.createReactNavigationReduxMiddleware = createReactNavigationReduxMiddleware;
  exports.createReduxBoundAddListener = createReduxBoundAddListener;
  exports.initializeListeners = initializeListeners;
},631,[31,632],"react-navigation-redux-helpers/src/middleware.js");
__d(function (global, require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.initAction = exports.createNavigationReducer = undefined;

  var _reactNavigation = require(_dependencyMap[0], "react-navigation");

  var initAction = _reactNavigation.NavigationActions.init();

  function createNavigationReducer(navigator) {
    var initialState = navigator.router.getStateForAction(initAction, null);
    return function () {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
      var action = arguments[1];
      return navigator.router.getStateForAction(action, state);
    };
  }

  ;
  exports.createNavigationReducer = createNavigationReducer;
  exports.initAction = initAction;
},632,[376],"react-navigation-redux-helpers/src/reducer.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.storages = exports.purgeStoredState = exports.persistStore = exports.getStoredState = exports.createTransform = exports.createPersistor = exports.autoRehydrate = undefined;

  var _autoRehydrate = require(_dependencyMap[0], './autoRehydrate');

  var _autoRehydrate2 = _interopRequireDefault(_autoRehydrate);

  var _createPersistor = require(_dependencyMap[1], './createPersistor');

  var _createPersistor2 = _interopRequireDefault(_createPersistor);

  var _createTransform = require(_dependencyMap[2], './createTransform');

  var _createTransform2 = _interopRequireDefault(_createTransform);

  var _getStoredState = require(_dependencyMap[3], './getStoredState');

  var _getStoredState2 = _interopRequireDefault(_getStoredState);

  var _persistStore = require(_dependencyMap[4], './persistStore');

  var _persistStore2 = _interopRequireDefault(_persistStore);

  var _purgeStoredState = require(_dependencyMap[5], './purgeStoredState');

  var _purgeStoredState2 = _interopRequireDefault(_purgeStoredState);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var deprecated = function deprecated(cb, cb2, cb3) {
    console.error('redux-persist: this method of importing storages has been removed. instead use `import { asyncLocalStorage } from "redux-persist/storages"`');
    if (typeof cb === 'function') cb();
    if (typeof cb2 === 'function') cb2();
    if (typeof cb3 === 'function') cb3();
  };

  var deprecatedStorage = {
    getAllKeys: deprecated,
    getItem: deprecated,
    setItem: deprecated,
    removeItem: deprecated
  };
  var storages = {
    asyncLocalStorage: deprecatedStorage,
    asyncSessionStorage: deprecatedStorage
  };
  exports.autoRehydrate = _autoRehydrate2.default;
  exports.createPersistor = _createPersistor2.default;
  exports.createTransform = _createTransform2.default;
  exports.getStoredState = _getStoredState2.default;
  exports.persistStore = _persistStore2.default;
  exports.purgeStoredState = _purgeStoredState2.default;
  exports.storages = storages;
},633,[634,637,642,643,644,640],"redux-persist/lib/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  var _typeof = typeof Symbol === "function" && typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  exports.default = autoRehydrate;

  var _constants = require(_dependencyMap[0], './constants');

  var _isStatePlainEnough = require(_dependencyMap[1], './utils/isStatePlainEnough');

  var _isStatePlainEnough2 = _interopRequireDefault(_isStatePlainEnough);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function autoRehydrate() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var stateReconciler = config.stateReconciler || defaultStateReconciler;
    return function (next) {
      return function (reducer, initialState, enhancer) {
        var store = next(liftReducer(reducer), initialState, enhancer);
        return _extends({}, store, {
          replaceReducer: function replaceReducer(reducer) {
            return store.replaceReducer(liftReducer(reducer));
          }
        });
      };
    };

    function liftReducer(reducer) {
      var rehydrated = false;
      var preRehydrateActions = [];
      return function (state, action) {
        if (action.type !== _constants.REHYDRATE) {
          if (config.log && !rehydrated) preRehydrateActions.push(action);
          return reducer(state, action);
        } else {
          if (config.log && !rehydrated) logPreRehydrate(preRehydrateActions);
          rehydrated = true;
          var inboundState = action.payload;
          var reducedState = reducer(state, action);
          return stateReconciler(state, inboundState, reducedState, config.log);
        }
      };
    }
  }

  function logPreRehydrate(preRehydrateActions) {
    var concernedActions = preRehydrateActions.slice(1);

    if (concernedActions.length > 0) {
      console.log('\n      redux-persist/autoRehydrate: %d actions were fired before rehydration completed. This can be a symptom of a race\n      condition where the rehydrate action may overwrite the previously affected state. Consider running these actions\n      after rehydration:\n    ', concernedActions.length, concernedActions);
    }
  }

  function defaultStateReconciler(state, inboundState, reducedState, log) {
    var newState = _extends({}, reducedState);

    Object.keys(inboundState).forEach(function (key) {
      if (!state.hasOwnProperty(key)) return;

      if (_typeof(state[key]) === 'object' && !inboundState[key]) {
        if (log) console.log('redux-persist/autoRehydrate: sub state for key `%s` is falsy but initial state is an object, skipping autoRehydrate.', key);
        return;
      }

      if (state[key] !== reducedState[key]) {
        if (log) console.log('redux-persist/autoRehydrate: sub state for key `%s` modified, skipping autoRehydrate.', key);
        newState[key] = reducedState[key];
        return;
      }

      if ((0, _isStatePlainEnough2.default)(inboundState[key]) && (0, _isStatePlainEnough2.default)(state[key])) newState[key] = _extends({}, state[key], inboundState[key]);else newState[key] = inboundState[key];
      if (log) console.log('redux-persist/autoRehydrate: key `%s`, rehydrated to ', key, newState[key]);
    });
    return newState;
  }
},634,[635,636],"redux-persist/lib/autoRehydrate.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  var KEY_PREFIX = exports.KEY_PREFIX = 'reduxPersist:';
  var REHYDRATE = exports.REHYDRATE = 'persist/REHYDRATE';
},635,[],"redux-persist/lib/constants.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  var _typeof = typeof Symbol === "function" && typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
  };

  exports.default = isStatePlainEnough;

  var _isPlainObject = require(_dependencyMap[0], 'lodash/isPlainObject');

  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function isStatePlainEnough(a) {
    if (!a) return false;
    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== 'object') return false;
    if (typeof a.asMutable === 'function') return false;
    if (!(0, _isPlainObject2.default)(a)) return false;
    return true;
  }
},636,[38],"redux-persist/lib/utils/isStatePlainEnough.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.default = createPersistor;

  var _constants = require(_dependencyMap[0], './constants');

  var _asyncLocalStorage = require(_dependencyMap[1], './defaults/asyncLocalStorage');

  var _asyncLocalStorage2 = _interopRequireDefault(_asyncLocalStorage);

  var _purgeStoredState = require(_dependencyMap[2], './purgeStoredState');

  var _purgeStoredState2 = _interopRequireDefault(_purgeStoredState);

  var _jsonStringifySafe = require(_dependencyMap[3], 'json-stringify-safe');

  var _jsonStringifySafe2 = _interopRequireDefault(_jsonStringifySafe);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function createPersistor(store, config) {
    var serializer = config.serialize === false ? function (data) {
      return data;
    } : defaultSerializer;
    var deserializer = config.serialize === false ? function (data) {
      return data;
    } : defaultDeserializer;
    var blacklist = config.blacklist || [];
    var whitelist = config.whitelist || false;
    var transforms = config.transforms || [];
    var debounce = config.debounce || false;
    var keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : _constants.KEY_PREFIX;
    var stateInit = config._stateInit || {};
    var stateIterator = config._stateIterator || defaultStateIterator;
    var stateGetter = config._stateGetter || defaultStateGetter;
    var stateSetter = config._stateSetter || defaultStateSetter;
    var storage = config.storage || (0, _asyncLocalStorage2.default)('local');

    if (storage.keys && !storage.getAllKeys) {
      storage.getAllKeys = storage.keys;
    }

    var lastState = stateInit;
    var paused = false;
    var storesToProcess = [];
    var timeIterator = null;
    store.subscribe(function () {
      if (paused) return;
      var state = store.getState();
      stateIterator(state, function (subState, key) {
        if (!passWhitelistBlacklist(key)) return;
        if (stateGetter(lastState, key) === stateGetter(state, key)) return;
        if (storesToProcess.indexOf(key) !== -1) return;
        storesToProcess.push(key);
      });
      var len = storesToProcess.length;

      if (timeIterator === null) {
        timeIterator = setInterval(function () {
          if (paused && len === storesToProcess.length || storesToProcess.length === 0) {
            clearInterval(timeIterator);
            timeIterator = null;
            return;
          }

          var key = storesToProcess.shift();
          var storageKey = createStorageKey(key);
          var endState = transforms.reduce(function (subState, transformer) {
            return transformer.in(subState, key);
          }, stateGetter(store.getState(), key));
          if (typeof endState !== 'undefined') storage.setItem(storageKey, serializer(endState), warnIfSetError(key));
        }, debounce);
      }

      lastState = state;
    });

    function passWhitelistBlacklist(key) {
      if (whitelist && whitelist.indexOf(key) === -1) return false;
      if (blacklist.indexOf(key) !== -1) return false;
      return true;
    }

    function adhocRehydrate(incoming) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var state = {};

      if (options.serial) {
        stateIterator(incoming, function (subState, key) {
          try {
            var data = deserializer(subState);
            var value = transforms.reduceRight(function (interState, transformer) {
              return transformer.out(interState, key);
            }, data);
            state = stateSetter(state, key, value);
          } catch (err) {
            if (process.env.NODE_ENV !== 'production') console.warn('Error rehydrating data for key "' + key + '"', subState, err);
          }
        });
      } else state = incoming;

      store.dispatch(rehydrateAction(state));
      return state;
    }

    function createStorageKey(key) {
      return '' + keyPrefix + key;
    }

    return {
      rehydrate: adhocRehydrate,
      pause: function pause() {
        paused = true;
      },
      resume: function resume() {
        paused = false;
      },
      purge: function purge(keys) {
        return (0, _purgeStoredState2.default)({
          storage: storage,
          keyPrefix: keyPrefix
        }, keys);
      }
    };
  }

  function warnIfSetError(key) {
    return function setError(err) {
      if (err && process.env.NODE_ENV !== 'production') {
        console.warn('Error storing data for key:', key, err);
      }
    };
  }

  function defaultSerializer(data) {
    return (0, _jsonStringifySafe2.default)(data, null, null, function (k, v) {
      if (process.env.NODE_ENV !== 'production') return null;
      throw new Error('\n      redux-persist: cannot process cyclical state.\n      Consider changing your state structure to have no cycles.\n      Alternatively blacklist the corresponding reducer key.\n      Cycle encounted at key "' + k + '" with value "' + v + '".\n    ');
    });
  }

  function defaultDeserializer(serial) {
    return JSON.parse(serial);
  }

  function rehydrateAction(data) {
    return {
      type: _constants.REHYDRATE,
      payload: data
    };
  }

  function defaultStateIterator(collection, callback) {
    return Object.keys(collection).forEach(function (key) {
      return callback(collection[key], key);
    });
  }

  function defaultStateGetter(state, key) {
    return state[key];
  }

  function defaultStateSetter(state, key, value) {
    state[key] = value;
    return state;
  }
},637,[635,638,640,641],"redux-persist/lib/createPersistor.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  var _typeof = typeof Symbol === "function" && typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
  };

  exports.default = function (type, config) {
    var storage = getStorage(type);
    return {
      getAllKeys: function getAllKeys(cb) {
        return new Promise(function (resolve, reject) {
          try {
            var keys = [];

            for (var i = 0; i < storage.length; i++) {
              keys.push(storage.key(i));
            }

            (0, _setImmediate2.default)(function () {
              cb && cb(null, keys);
              resolve(keys);
            });
          } catch (e) {
            cb && cb(e);
            reject(e);
          }
        });
      },
      getItem: function getItem(key, cb) {
        return new Promise(function (resolve, reject) {
          try {
            var s = storage.getItem(key);
            (0, _setImmediate2.default)(function () {
              cb && cb(null, s);
              resolve(s);
            });
          } catch (e) {
            cb && cb(e);
            reject(e);
          }
        });
      },
      setItem: function setItem(key, string, cb) {
        return new Promise(function (resolve, reject) {
          try {
            storage.setItem(key, string);
            (0, _setImmediate2.default)(function () {
              cb && cb(null);
              resolve();
            });
          } catch (e) {
            cb && cb(e);
            reject(e);
          }
        });
      },
      removeItem: function removeItem(key, cb) {
        return new Promise(function (resolve, reject) {
          try {
            storage.removeItem(key);
            (0, _setImmediate2.default)(function () {
              cb && cb(null);
              resolve();
            });
          } catch (e) {
            cb && cb(e);
            reject(e);
          }
        });
      }
    };
  };

  var _setImmediate = require(_dependencyMap[0], '../utils/setImmediate');

  var _setImmediate2 = _interopRequireDefault(_setImmediate);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var noStorage = function noStorage() {
    return null;
  };

  if (process.env.NODE_ENV !== 'production') {
    noStorage = function noStorage() {
      console.error('redux-persist asyncLocalStorage requires a global localStorage object. Either use a different storage backend or if this is a universal redux application you probably should conditionally persist like so: https://gist.github.com/rt2zz/ac9eb396793f95ff3c3b');
      return null;
    };
  }

  function _hasStorage(storageType) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(storageType in window)) {
      return false;
    }

    try {
      var storage = window[storageType];
      var testKey = 'redux-persist ' + storageType + ' test';
      storage.setItem(testKey, 'test');
      storage.getItem(testKey);
      storage.removeItem(testKey);
    } catch (e) {
      if (process.env.NODE_ENV !== 'production') console.warn('redux-persist ' + storageType + ' test failed, persistence will be disabled.');
      return false;
    }

    return true;
  }

  function hasLocalStorage() {
    return _hasStorage('localStorage');
  }

  function hasSessionStorage() {
    return _hasStorage('sessionStorage');
  }

  function getStorage(type) {
    if (type === 'local') {
      return hasLocalStorage() ? window.localStorage : {
        getItem: noStorage,
        setItem: noStorage,
        removeItem: noStorage,
        getAllKeys: noStorage
      };
    }

    if (type === 'session') {
      return hasSessionStorage() ? window.sessionStorage : {
        getItem: noStorage,
        setItem: noStorage,
        removeItem: noStorage,
        getAllKeys: noStorage
      };
    }
  }
},638,[639],"redux-persist/lib/defaults/asyncLocalStorage.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  var hasNativeSupport = typeof global !== 'undefined' && typeof global.setImmediate !== 'undefined';
  var setImmediate = hasNativeSupport ? function (fn, ms) {
    return global.setImmediate(fn, ms);
  } : function (fn, ms) {
    return setTimeout(fn, ms);
  };
  exports.default = setImmediate;
},639,[],"redux-persist/lib/utils/setImmediate.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports.default = purgeStoredState;

  var _constants = require(_dependencyMap[0], './constants');

  function purgeStoredState(config, keys) {
    var storage = config.storage;
    var keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : _constants.KEY_PREFIX;
    if (Array.isArray(config)) throw new Error('redux-persist: purgeStoredState requires config as a first argument (found array). An array of keys is the optional second argument.');
    if (!storage) throw new Error('redux-persist: config.storage required in purgeStoredState');

    if (typeof keys === 'undefined') {
      return new Promise(function (resolve, reject) {
        storage.getAllKeys(function (err, allKeys) {
          if (err) {
            if (process.env.NODE_ENV !== 'production') console.warn('redux-persist: error during purgeStoredState in storage.getAllKeys');
            reject(err);
          } else {
            resolve(purgeStoredState(config, allKeys.filter(function (key) {
              return key.indexOf(keyPrefix) === 0;
            }).map(function (key) {
              return key.slice(keyPrefix.length);
            })));
          }
        });
      });
    } else {
      return Promise.all(keys.map(function (key) {
        return storage.removeItem('' + keyPrefix + key, warnIfRemoveError(key));
      }));
    }
  }

  function warnIfRemoveError(key) {
    return function removeError(err) {
      if (err && process.env.NODE_ENV !== 'production') {
        console.warn('Error storing data for key:', key, err);
      }
    };
  }
},640,[635],"redux-persist/lib/purgeStoredState.js");
__d(function (global, require, module, exports, _dependencyMap) {
  exports = module.exports = stringify;
  exports.getSerialize = serializer;

  function stringify(obj, replacer, spaces, cycleReplacer) {
    return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
  }

  function serializer(replacer, cycleReplacer) {
    var stack = [],
        keys = [];
    if (cycleReplacer == null) cycleReplacer = function cycleReplacer(key, value) {
      if (stack[0] === value) return "[Circular ~]";
      return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
    };
    return function (key, value) {
      if (stack.length > 0) {
        var thisPos = stack.indexOf(this);
        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
        if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
      } else stack.push(value);

      return replacer == null ? value : replacer.call(this, key, value);
    };
  }
},641,[],"json-stringify-safe/stringify.js");
__d(function (global, require, module, exports, _dependencyMap) {
  "use strict";

  exports.__esModule = true;

  function createTransform(inbound, outbound) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var whitelist = config.whitelist || null;
    var blacklist = config.blacklist || null;

    function whitelistBlacklistCheck(key) {
      if (whitelist && whitelist.indexOf(key) === -1) return true;
      if (blacklist && blacklist.indexOf(key) !== -1) return true;
      return false;
    }

    return {
      in: function _in(state, key) {
        return !whitelistBlacklistCheck(key) && inbound ? inbound(state, key) : state;
      },
      out: function out(state, key) {
        return !whitelistBlacklistCheck(key) && outbound ? outbound(state, key) : state;
      }
    };
  }

  exports.default = createTransform;
},642,[],"redux-persist/lib/createTransform.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  exports.default = getStoredState;

  var _constants = require(_dependencyMap[0], './constants');

  var _asyncLocalStorage = require(_dependencyMap[1], './defaults/asyncLocalStorage');

  var _asyncLocalStorage2 = _interopRequireDefault(_asyncLocalStorage);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function getStoredState(config, onComplete) {
    var storage = config.storage || (0, _asyncLocalStorage2.default)('local');
    var deserializer = config.serialize === false ? function (data) {
      return data;
    } : defaultDeserializer;
    var blacklist = config.blacklist || [];
    var whitelist = config.whitelist || false;
    var transforms = config.transforms || [];
    var keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : _constants.KEY_PREFIX;
    if (storage.keys && !storage.getAllKeys) storage = _extends({}, storage, {
      getAllKeys: storage.keys
    });
    var restoredState = {};
    var completionCount = 0;
    storage.getAllKeys(function (err, allKeys) {
      if (err) {
        if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error in storage.getAllKeys');
        complete(err);
      }

      var persistKeys = allKeys.filter(function (key) {
        return key.indexOf(keyPrefix) === 0;
      }).map(function (key) {
        return key.slice(keyPrefix.length);
      });
      var keysToRestore = persistKeys.filter(passWhitelistBlacklist);
      var restoreCount = keysToRestore.length;
      if (restoreCount === 0) complete(null, restoredState);
      keysToRestore.forEach(function (key) {
        storage.getItem(createStorageKey(key), function (err, serialized) {
          if (err && process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err);else restoredState[key] = rehydrate(key, serialized);
          completionCount += 1;
          if (completionCount === restoreCount) complete(null, restoredState);
        });
      });
    });

    function rehydrate(key, serialized) {
      var state = null;

      try {
        var data = deserializer(serialized);
        state = transforms.reduceRight(function (subState, transformer) {
          return transformer.out(subState, key);
        }, data);
      } catch (err) {
        if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err);
      }

      return state;
    }

    function complete(err, restoredState) {
      onComplete(err, restoredState);
    }

    function passWhitelistBlacklist(key) {
      if (whitelist && whitelist.indexOf(key) === -1) return false;
      if (blacklist.indexOf(key) !== -1) return false;
      return true;
    }

    function createStorageKey(key) {
      return '' + keyPrefix + key;
    }

    if (typeof onComplete !== 'function' && !!Promise) {
      return new Promise(function (resolve, reject) {
        onComplete = function onComplete(err, restoredState) {
          if (err) reject(err);else resolve(restoredState);
        };
      });
    }
  }

  function defaultDeserializer(serial) {
    return JSON.parse(serial);
  }
},643,[635,638],"redux-persist/lib/getStoredState.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  exports.default = persistStore;

  var _constants = require(_dependencyMap[0], './constants');

  var _getStoredState = require(_dependencyMap[1], './getStoredState');

  var _getStoredState2 = _interopRequireDefault(_getStoredState);

  var _createPersistor = require(_dependencyMap[2], './createPersistor');

  var _createPersistor2 = _interopRequireDefault(_createPersistor);

  var _setImmediate = require(_dependencyMap[3], './utils/setImmediate');

  var _setImmediate2 = _interopRequireDefault(_setImmediate);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function persistStore(store) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var onComplete = arguments[2];
    var shouldRestore = !config.skipRestore;
    if (process.env.NODE_ENV !== 'production' && config.skipRestore) console.warn('redux-persist: config.skipRestore has been deprecated. If you want to skip restoration use `createPersistor` instead');
    var purgeKeys = null;
    var persistor = (0, _createPersistor2.default)(store, config);
    persistor.pause();

    if (shouldRestore) {
      (0, _setImmediate2.default)(function () {
        (0, _getStoredState2.default)(config, function (err, restoredState) {
          if (err) {
            complete(err);
            return;
          }

          if (purgeKeys) {
            if (purgeKeys === '*') restoredState = {};else purgeKeys.forEach(function (key) {
              return delete restoredState[key];
            });
          }

          try {
            store.dispatch(rehydrateAction(restoredState, err));
          } finally {
            complete(err, restoredState);
          }
        });
      });
    } else (0, _setImmediate2.default)(complete);

    function complete(err, restoredState) {
      persistor.resume();
      onComplete && onComplete(err, restoredState);
    }

    return _extends({}, persistor, {
      purge: function purge(keys) {
        purgeKeys = keys || '*';
        return persistor.purge(keys);
      }
    });
  }

  function rehydrateAction(payload) {
    var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return {
      type: _constants.REHYDRATE,
      payload: payload,
      error: error
    };
  }
},644,[635,643,637,639],"redux-persist/lib/persistStore.js");
__d(function (global, require, module, exports, _dependencyMap) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = createTransformCompress;

    var _reduxPersist = require(_dependencyMap[0], "redux-persist");

    var _lzString = require(_dependencyMap[1], "lz-string");

    var _lzString2 = _interopRequireDefault(_lzString);

    var _jsonStringifySafe = require(_dependencyMap[2], "json-stringify-safe");

    var _jsonStringifySafe2 = _interopRequireDefault(_jsonStringifySafe);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var NODE_ENV = typeof process !== "undefined" ? process.env.NODE_ENV : "production";

    function createTransformCompress(config) {
        return (0, _reduxPersist.createTransform)(function (state) {
            return _lzString2.default.compressToUTF16((0, _jsonStringifySafe2.default)(state));
        }, function (state) {
            if (typeof state !== "string") {
                if (NODE_ENV !== "production") {
                    console.error("redux-persist-transform-compress: expected outbound state to be a string");
                }

                return state;
            }

            try {
                return JSON.parse(_lzString2.default.decompressFromUTF16(state));
            } catch (err) {
                if (NODE_ENV !== "production") {
                    console.error("redux-persist-transform-compress: error while decompressing state", err);
                }

                return null;
            }
        }, config);
    }
},645,[633,646,641],"redux-persist-transform-compress/lib/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var LZString = function () {
    var f = String.fromCharCode;
    var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
    var baseReverseDic = {};

    function getBaseValue(alphabet, character) {
      if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};

        for (var i = 0; i < alphabet.length; i++) {
          baseReverseDic[alphabet][alphabet.charAt(i)] = i;
        }
      }

      return baseReverseDic[alphabet][character];
    }

    var LZString = {
      compressToBase64: function compressToBase64(input) {
        if (input == null) return "";

        var res = LZString._compress(input, 6, function (a) {
          return keyStrBase64.charAt(a);
        });

        switch (res.length % 4) {
          default:
          case 0:
            return res;

          case 1:
            return res + "===";

          case 2:
            return res + "==";

          case 3:
            return res + "=";
        }
      },
      decompressFromBase64: function decompressFromBase64(input) {
        if (input == null) return "";
        if (input == "") return null;
        return LZString._decompress(input.length, 32, function (index) {
          return getBaseValue(keyStrBase64, input.charAt(index));
        });
      },
      compressToUTF16: function compressToUTF16(input) {
        if (input == null) return "";
        return LZString._compress(input, 15, function (a) {
          return f(a + 32);
        }) + " ";
      },
      decompressFromUTF16: function decompressFromUTF16(compressed) {
        if (compressed == null) return "";
        if (compressed == "") return null;
        return LZString._decompress(compressed.length, 16384, function (index) {
          return compressed.charCodeAt(index) - 32;
        });
      },
      compressToUint8Array: function compressToUint8Array(uncompressed) {
        var compressed = LZString.compress(uncompressed);
        var buf = new Uint8Array(compressed.length * 2);

        for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
          var current_value = compressed.charCodeAt(i);
          buf[i * 2] = current_value >>> 8;
          buf[i * 2 + 1] = current_value % 256;
        }

        return buf;
      },
      decompressFromUint8Array: function decompressFromUint8Array(compressed) {
        if (compressed === null || compressed === undefined) {
          return LZString.decompress(compressed);
        } else {
          var buf = new Array(compressed.length / 2);

          for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
            buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
          }

          var result = [];
          buf.forEach(function (c) {
            result.push(f(c));
          });
          return LZString.decompress(result.join(''));
        }
      },
      compressToEncodedURIComponent: function compressToEncodedURIComponent(input) {
        if (input == null) return "";
        return LZString._compress(input, 6, function (a) {
          return keyStrUriSafe.charAt(a);
        });
      },
      decompressFromEncodedURIComponent: function decompressFromEncodedURIComponent(input) {
        if (input == null) return "";
        if (input == "") return null;
        input = input.replace(/ /g, "+");
        return LZString._decompress(input.length, 32, function (index) {
          return getBaseValue(keyStrUriSafe, input.charAt(index));
        });
      },
      compress: function compress(uncompressed) {
        return LZString._compress(uncompressed, 16, function (a) {
          return f(a);
        });
      },
      _compress: function _compress(uncompressed, bitsPerChar, getCharFromInt) {
        if (uncompressed == null) return "";
        var i,
            value,
            context_dictionary = {},
            context_dictionaryToCreate = {},
            context_c = "",
            context_wc = "",
            context_w = "",
            context_enlargeIn = 2,
            context_dictSize = 3,
            context_numBits = 2,
            context_data = [],
            context_data_val = 0,
            context_data_position = 0,
            ii;

        for (ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);

          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }

          context_wc = context_w + context_c;

          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;

                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }

                value = context_w.charCodeAt(0);

                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;

                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }

                  value = value >> 1;
                }
              } else {
                value = 1;

                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;

                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }

                  value = 0;
                }

                value = context_w.charCodeAt(0);

                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;

                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }

                  value = value >> 1;
                }
              }

              context_enlargeIn--;

              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }

              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];

              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;

                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }

                value = value >> 1;
              }
            }

            context_enlargeIn--;

            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }

            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }

        if (context_w !== "") {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1;

                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }

              value = context_w.charCodeAt(0);

              for (i = 0; i < 8; i++) {
                context_data_val = context_data_val << 1 | value & 1;

                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }

                value = value >> 1;
              }
            } else {
              value = 1;

              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value;

                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }

                value = 0;
              }

              value = context_w.charCodeAt(0);

              for (i = 0; i < 16; i++) {
                context_data_val = context_data_val << 1 | value & 1;

                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }

                value = value >> 1;
              }
            }

            context_enlargeIn--;

            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }

            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];

            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value & 1;

              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }

              value = value >> 1;
            }
          }

          context_enlargeIn--;

          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }

        value = 2;

        for (i = 0; i < context_numBits; i++) {
          context_data_val = context_data_val << 1 | value & 1;

          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }

          value = value >> 1;
        }

        while (true) {
          context_data_val = context_data_val << 1;

          if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else context_data_position++;
        }

        return context_data.join('');
      },
      decompress: function decompress(compressed) {
        if (compressed == null) return "";
        if (compressed == "") return null;
        return LZString._decompress(compressed.length, 32768, function (index) {
          return compressed.charCodeAt(index);
        });
      },
      _decompress: function _decompress(length, resetValue, getNextValue) {
        var dictionary = [],
            next,
            enlargeIn = 4,
            dictSize = 4,
            numBits = 3,
            entry = "",
            result = [],
            i,
            w,
            bits,
            resb,
            maxpower,
            power,
            c,
            data = {
          val: getNextValue(0),
          position: resetValue,
          index: 1
        };

        for (i = 0; i < 3; i += 1) {
          dictionary[i] = i;
        }

        bits = 0;
        maxpower = Math.pow(2, 2);
        power = 1;

        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;

          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }

          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }

        switch (next = bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;

            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;

              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }

              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }

            c = f(bits);
            break;

          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;

            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;

              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }

              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }

            c = f(bits);
            break;

          case 2:
            return "";
        }

        dictionary[3] = c;
        w = c;
        result.push(c);

        while (true) {
          if (data.index > length) {
            return "";
          }

          bits = 0;
          maxpower = Math.pow(2, numBits);
          power = 1;

          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;

            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }

            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }

          switch (c = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;

              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;

                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }

                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }

              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;

            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;

              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;

                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }

                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }

              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;

            case 2:
              return result.join('');
          }

          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }

          if (dictionary[c]) {
            entry = dictionary[c];
          } else {
            if (c === dictSize) {
              entry = w + w.charAt(0);
            } else {
              return null;
            }
          }

          result.push(entry);
          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;
          w = entry;

          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
        }
      }
    };
    return LZString;
  }();

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return LZString;
    });
  } else if (typeof module !== 'undefined' && module != null) {
    module.exports = LZString;
  }
},646,[],"lz-string/libs/lz-string.js");
__d(function (global, require, module, exports, _dependencyMap) {
	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") === "symbol" ? function (obj) {
		return typeof obj;
	} : function (obj) {
		return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
	};

	exports.default = createFilter;
	exports.createWhitelistFilter = createWhitelistFilter;
	exports.createBlacklistFilter = createBlacklistFilter;
	exports.persistFilter = persistFilter;

	var _reduxPersist = require(_dependencyMap[0], 'redux-persist');

	var _lodash = require(_dependencyMap[1], 'lodash.get');

	var _lodash2 = _interopRequireDefault(_lodash);

	var _lodash3 = require(_dependencyMap[2], 'lodash.set');

	var _lodash4 = _interopRequireDefault(_lodash3);

	var _lodash5 = require(_dependencyMap[3], 'lodash.unset');

	var _lodash6 = _interopRequireDefault(_lodash5);

	var _lodash7 = require(_dependencyMap[4], 'lodash.pickby');

	var _lodash8 = _interopRequireDefault(_lodash7);

	var _lodash9 = require(_dependencyMap[5], 'lodash.isempty');

	var _lodash10 = _interopRequireDefault(_lodash9);

	var _lodash11 = require(_dependencyMap[6], 'lodash.forin');

	var _lodash12 = _interopRequireDefault(_lodash11);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : {
			default: obj
		};
	}

	function createFilter(reducerName, inboundPaths, outboundPaths) {
		var transformType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'whitelist';
		return (0, _reduxPersist.createTransform)(function (inboundState, key) {
			return inboundPaths ? persistFilter(inboundState, inboundPaths, transformType) : inboundState;
		}, function (outboundState, key) {
			return outboundPaths ? persistFilter(outboundState, outboundPaths, transformType) : outboundState;
		}, {
			'whitelist': [reducerName]
		});
	}

	;

	function createWhitelistFilter(reducerName, inboundPaths, outboundPaths) {
		return createFilter(reducerName, inboundPaths, outboundPaths, 'whitelist');
	}

	function createBlacklistFilter(reducerName, inboundPaths, outboundPaths) {
		return createFilter(reducerName, inboundPaths, outboundPaths, 'blacklist');
	}

	function filterObject(_ref, state) {
		var path = _ref.path,
		    _ref$filterFunction = _ref.filterFunction,
		    filterFunction = _ref$filterFunction === undefined ? function () {
			return true;
		} : _ref$filterFunction;
		var value = (0, _lodash2.default)(state, path);
		return (0, _lodash8.default)(value, filterFunction);
	}

	function persistFilter(state) {
		var paths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
		var transformType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'whitelist';
		var subset = {};

		if (typeof paths === 'string') {
			paths = [paths];
		}

		if (transformType === 'whitelist') {
			paths.forEach(function (path) {
				if ((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && !(path instanceof Array)) {
					var value = filterObject(path, state);

					if (!(0, _lodash10.default)(value)) {
						(0, _lodash4.default)(subset, path.path, value);
					}
				} else {
					var _value = (0, _lodash2.default)(state, path);

					if (typeof _value !== 'undefined') {
						(0, _lodash4.default)(subset, path, _value);
					}
				}
			});
		} else if (transformType === 'blacklist') {
			subset = babelHelpers.extends({}, state);
			paths.forEach(function (path) {
				if ((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && !(path instanceof Array)) {
					var value = filterObject(path, state);

					if (!(0, _lodash10.default)(value)) {
						(0, _lodash12.default)(value, function (value, key) {
							(0, _lodash6.default)(subset, path.path + '.' + key);
						});
					}
				} else {
					var _value2 = (0, _lodash2.default)(state, path);

					if (typeof _value2 !== 'undefined') {
						(0, _lodash6.default)(subset, path);
					}
				}
			});
		} else {
			subset = state;
		}

		return subset;
	}
},647,[633,648,649,650,651,652,653],"redux-persist-transform-filter/dist/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var FUNC_ERROR_TEXT = 'Expected a function';
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var INFINITY = 1 / 0;
  var funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      symbolTag = '[object Symbol]';
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      reLeadingDot = /^\./,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  function isHostObject(value) {
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }

  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;
  var coreJsData = root['__core-js_shared__'];

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  var Symbol = root.Symbol,
      splice = arrayProto.splice;
  var Map = getNative(root, 'Map'),
      nativeCreate = getNative(Object, 'create');
  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }

  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }

  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function listCacheClear() {
    this.__data__ = [];
  }

  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    return true;
  }

  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }

  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }

  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }

  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }

  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }

    var type = typeof value;

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];

    if (reLeadingDot.test(string)) {
      result.push('');
    }

    string.replace(rePropName, function (match, number, quote, string) {
      result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };

    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  memoize.Cache = MapCache;

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var isArray = Array.isArray;

  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }

  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  module.exports = get;
},648,[],"lodash.get/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var FUNC_ERROR_TEXT = 'Expected a function';
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991;
  var funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      symbolTag = '[object Symbol]';
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      reLeadingDot = /^\./,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  function isHostObject(value) {
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }

  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;
  var coreJsData = root['__core-js_shared__'];

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  var Symbol = root.Symbol,
      splice = arrayProto.splice;
  var Map = getNative(root, 'Map'),
      nativeCreate = getNative(Object, 'create');
  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }

  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }

  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function listCacheClear() {
    this.__data__ = [];
  }

  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    return true;
  }

  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }

  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }

  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }

  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      object[key] = value;
    }
  }

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }

    path = isKey(path, object) ? [path] : castPath(path);
    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;

        if (newValue === undefined) {
          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
      }

      assignValue(nested, key, newValue);
      nested = nested[key];
    }

    return object;
  }

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }

  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }

    var type = typeof value;

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];

    if (reLeadingDot.test(string)) {
      result.push('');
    }

    string.replace(rePropName, function (match, number, quote, string) {
      result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };

    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  memoize.Cache = MapCache;

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var isArray = Array.isArray;

  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }

  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
  }

  module.exports = set;
},649,[],"lodash.set/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var FUNC_ERROR_TEXT = 'Expected a function';
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var INFINITY = 1 / 0;
  var funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      symbolTag = '[object Symbol]';
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      reLeadingDot = /^\./,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  function isHostObject(value) {
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }

  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;
  var coreJsData = root['__core-js_shared__'];

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  var Symbol = root.Symbol,
      splice = arrayProto.splice;
  var Map = getNative(root, 'Map'),
      nativeCreate = getNative(Object, 'create');
  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }

  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }

  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function listCacheClear() {
    this.__data__ = [];
  }

  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    return true;
  }

  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }

  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }

  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }

  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  function baseUnset(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    object = parent(object, path);
    var key = toKey(last(path));
    return !(object != null && hasOwnProperty.call(object, key)) || delete object[key];
  }

  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }

  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }

    var type = typeof value;

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  function parent(object, path) {
    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
  }

  var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];

    if (reLeadingDot.test(string)) {
      result.push('');
    }

    string.replace(rePropName, function (match, number, quote, string) {
      result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  function last(array) {
    var length = array ? array.length : 0;
    return length ? array[length - 1] : undefined;
  }

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };

    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  memoize.Cache = MapCache;

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var isArray = Array.isArray;

  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }

  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  function unset(object, path) {
    return object == null ? true : baseUnset(object, path);
  }

  module.exports = unset;
},650,[],"lodash.unset/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var LARGE_ARRAY_SIZE = 200;
  var FUNC_ERROR_TEXT = 'Expected a function';
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var UNORDERED_COMPARE_FLAG = 1,
      PARTIAL_COMPARE_FLAG = 2;
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      reLeadingDot = /^\./,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;

  var nodeUtil = function () {
    try {
      return freeProcess && freeProcess.binding('util');
    } catch (e) {}
  }();

  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  function arraySome(array, predicate) {
    var index = -1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  function isHostObject(value) {
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }

  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;
  var coreJsData = root['__core-js_shared__'];

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  var Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);
  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }

  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }

  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function listCacheClear() {
    this.__data__ = [];
  }

  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    return true;
  }

  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }

  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }

  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }

  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  function SetCache(values) {
    var index = -1,
        length = values ? values.length : 0;
    this.__data__ = new MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  }

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);

    return this;
  }

  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }

  function stackClear() {
    this.__data__ = new ListCache();
  }

  function stackDelete(key) {
    return this.__data__['delete'](key);
  }

  function stackGet(key) {
    return this.__data__.get(key);
  }

  function stackHas(key) {
    return this.__data__.has(key);
  }

  function stackSet(key, value) {
    var cache = this.__data__;

    if (cache instanceof ListCache) {
      var pairs = cache.__data__;

      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }

      cache = this.__data__ = new MapCache(pairs);
    }

    cache.set(key, value);
    return this;
  }

  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length,
        skipIndexes = !!length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  function baseGetTag(value) {
    return objectToString.call(value);
  }

  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }

    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
  }

  function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = arrayTag,
        othTag = arrayTag;

    if (!objIsArr) {
      objTag = getTag(object);
      objTag = objTag == argsTag ? objectTag : objTag;
    }

    if (!othIsArr) {
      othTag = getTag(other);
      othTag = othTag == argsTag ? objectTag : othTag;
    }

    var objIsObj = objTag == objectTag && !isHostObject(object),
        othIsObj = othTag == objectTag && !isHostObject(other),
        isSameTag = objTag == othTag;

    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
    }

    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new Stack());
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
  }

  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }

    object = Object(object);

    while (index--) {
      var data = matchData[index];

      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }

    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();

        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }

        if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
          return false;
        }
      }
    }

    return true;
  }

  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
  }

  function baseIteratee(value) {
    if (typeof value == 'function') {
      return value;
    }

    if (value == null) {
      return identity;
    }

    if (typeof value == 'object') {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }

    return property(value);
  }

  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  function baseMatches(source) {
    var matchData = getMatchData(source);

    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }

    return function (object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }

    return function (object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
  }

  function basePickBy(object, props, predicate) {
    var index = -1,
        length = props.length,
        result = {};

    while (++index < length) {
      var key = props[index],
          value = object[key];

      if (predicate(value, key)) {
        result[key] = value;
      }
    }

    return result;
  }

  function basePropertyDeep(path) {
    return function (object) {
      return baseGet(object, path);
    };
  }

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }

  function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }

    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      }

      if (seen) {
        if (!arraySome(other, function (othValue, othIndex) {
          if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            return seen.add(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        return object == other + '';

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }

        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
        objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }

    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }

      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }

    return result;
  }

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];

    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }

    return result;
  };
  var getTag = baseGetTag;

  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = objectToString.call(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : undefined;

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;

          case mapCtorString:
            return mapTag;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag;

          case weakMapCtorString:
            return weakMapTag;
        }
      }

      return result;
    };
  }

  function hasPath(object, path, hasFunc) {
    path = isKey(path, object) ? [path] : castPath(path);
    var result,
        index = -1,
        length = path.length;

    while (++index < length) {
      var key = toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result) {
      return result;
    }

    var length = object ? object.length : 0;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }

  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }

    var type = typeof value;

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }

  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }

  function matchesStrictComparable(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }

      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }

  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];

    if (reLeadingDot.test(string)) {
      result.push('');
    }

    string.replace(rePropName, function (match, number, quote, string) {
      result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };

    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  memoize.Cache = MapCache;

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
  }

  var isArray = Array.isArray;

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }

  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  function pickBy(object, predicate) {
    return object == null ? {} : basePickBy(object, getAllKeysIn(object), baseIteratee(predicate));
  }

  function identity(value) {
    return value;
  }

  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  function stubArray() {
    return [];
  }

  module.exports = pickBy;
},651,[],"lodash.pickby/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = '[object Arguments]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      setTag = '[object Set]',
      weakMapTag = '[object WeakMap]';
  var dataViewTag = '[object DataView]';
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  function isHostObject(value) {
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }

  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var funcProto = Function.prototype,
      objectProto = Object.prototype;
  var coreJsData = root['__core-js_shared__'];

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  var Buffer = moduleExports ? root.Buffer : undefined,
      propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap');
  var nonEnumShadows = !propertyIsEnumerable.call({
    'valueOf': 1
  }, 'valueOf');
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  function baseGetTag(value) {
    return objectToString.call(value);
  }

  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  var getTag = baseGetTag;

  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = objectToString.call(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : undefined;

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;

          case mapCtorString:
            return mapTag;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag;

          case weakMapCtorString:
            return weakMapTag;
        }
      }

      return result;
    };
  }

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
  }

  var isArray = Array.isArray;

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  var isBuffer = nativeIsBuffer || stubFalse;

  function isEmpty(value) {
    if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isArguments(value))) {
      return !value.length;
    }

    var tag = getTag(value);

    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }

    if (nonEnumShadows || isPrototype(value)) {
      return !nativeKeys(value).length;
    }

    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  }

  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  function stubFalse() {
    return false;
  }

  module.exports = isEmpty;
},652,[],"lodash.isempty/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = '[object Arguments]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]';
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;

  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length,
        skipIndexes = !!length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  var baseFor = createBaseFor();

  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }

  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }

  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
  }

  var isArray = Array.isArray;

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  function forIn(object, iteratee) {
    return object == null ? object : baseFor(object, typeof iteratee == 'function' ? iteratee : identity, keysIn);
  }

  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  function identity(value) {
    return value;
  }

  module.exports = forIn;
},653,[],"lodash.forin/index.js");
__d(function (global, require, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;

  function createThunkMiddleware(extraArgument) {
    return function (_ref) {
      var dispatch = _ref.dispatch,
          getState = _ref.getState;
      return function (next) {
        return function (action) {
          if (typeof action === 'function') {
            return action(dispatch, getState, extraArgument);
          }

          return next(action);
        };
      };
    };
  }

  var thunk = createThunkMiddleware();
  thunk.withExtraArgument = createThunkMiddleware;
  exports['default'] = thunk;
},654,[],"redux-thunk/lib/index.js");
require(76);
require(11);